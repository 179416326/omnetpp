%description:
Tests for SimTime.
XXX split to several tests? to be revised

%global:
// make protected SimTime::resetScale() accessible via subclassing
class SimTimeExt : SimTime {
  public: static void reset() {resetScale();}
};

%activity:
   // check scaling
   for (int i=-18; i<=0; i++)
   {
       SimTimeExt::reset();
       SimTime::setScaleExp(i);

       char *u="";
       if (SimTime::scaleExp()==SimTime::SCALEEXP_S)  u =  "s";
       if (SimTime::scaleExp()==SimTime::SCALEEXP_MS) u = "ms";
       if (SimTime::scaleExp()==SimTime::SCALEEXP_US) u = "us";
       if (SimTime::scaleExp()==SimTime::SCALEEXP_NS) u = "ns";
       if (SimTime::scaleExp()==SimTime::SCALEEXP_PS) u = "ps";
       if (SimTime::scaleExp()==SimTime::SCALEEXP_FS) u = "fs";

       ev.printf("%d: scale=%I64d %s\n", i, SimTime::scale(), u);
   }

   SimTimeExt::reset();
   SimTime::setScaleExp(SimTime::SCALEEXP_NS);
   ev.printf("using nanosecond precision: scale=%I64d\n", SimTime::scale());

   SimTime t, t2, tmp;

   // see if representation of powers of 10 is accurate
#define P(x) if (x <= SimTime::maxTime().dbl()) {t=(x); ev << #x << " -> " << t << "\n";}
   P(1e-15); P(1e-14); P(1e-13); P(1e-12); P(1e-11); P(1e-10); P(1e-9);
   P(1e-8); P(1e-7); P(1e-6); P(1e-5); P(1e-4); P(1e-3); P(1e-2); P(1e0);
   P(1e1); P(1e2); P(1e3); P(1e4); P(1e5); P(1e6); P(1e7); P(1e8); P(1e9);
   P(1e10); P(1e11); P(1e12); P(1e13); P(1e14); P(1e15); P(1e16); P(1e17);
   P(1e18); P(1e19); P(1e20);
#undef P

   // basic arithmetic
#define P(x) {ev << #x << " -> " << (x) << "\n";}
   t=1;
   t2=1.0/3.0;
   P(t);
   P(t2);

   P(t+0.1);
   P(t-0.1);
   P(0.1+t);
   P(0.1-t);

   P(t+t2);
   P(t-t2);

   P(t*3);
   P(t/3);
   P(3*t);
#undef P

   // assignments
#define P(x) {t=1; t2=1.0/3.0; tmp=(x); ev << #x << " -> " << tmp << ", t=" << t << "\n";}
   P(t=5);
   P(t=t2);

   P(t+=0.1);
   P(t+=-1);
   P(t+=-1.3);

   P(t-=0.1);
   P(t-=1);
   P(t-=1.3);

   P(t+=t2);
   P(t-=t2);

   P(t*=3);
   P(t/=3);
#undef P

   // comparison
#define P(x) {ev << #x << " -> " << (x) << "\n";}
   t=1;
   t2=1.0/3.0;
   P(t==1);
   P(t!=1);
   P(t==2);
   P(t!=2);
   P(t==t2);
   P(t!=t2);

   P(t<1);
   P(t<=1);
   P(t>1);
   P(t>=1);

   P(t<t);
   P(t<=t);
   P(t>t);
   P(t>=t);

   P(t<t2);
   P(t<=t2);
   P(t>t2);
   P(t>=t2);

   ev << ".\n";
%contains: stdout
-18: scale=1000000000000000000
-17: scale=100000000000000000
-16: scale=10000000000000000
-15: scale=1000000000000000 fs
-14: scale=100000000000000
-13: scale=10000000000000
-12: scale=1000000000000 ps
-11: scale=100000000000
-10: scale=10000000000
-9: scale=1000000000 ns
-8: scale=100000000
-7: scale=10000000
-6: scale=1000000 us
-5: scale=100000
-4: scale=10000
-3: scale=1000 ms
-2: scale=100
-1: scale=10
0: scale=1 s
using nanosecond precision: scale=1000000000
1e-15 -> 0
1e-14 -> 0
1e-13 -> 0
1e-12 -> 0
1e-11 -> 0
1e-10 -> 0
1e-9 -> 0.000000001
1e-8 -> 0.00000001
1e-7 -> 0.0000001
1e-6 -> 0.000001
1e-5 -> 0.00001
1e-4 -> 0.0001
1e-3 -> 0.001
1e-2 -> 0.01
1e0 -> 1
1e1 -> 10
1e2 -> 100
1e3 -> 1000
1e4 -> 10000
1e5 -> 100000
1e6 -> 1000000
1e7 -> 10000000
1e8 -> 100000000
1e9 -> 1000000000
t -> 1
t2 -> 0.333333333
t+0.1 -> 1.1
t-0.1 -> 0.9
0.1+t -> 1.1
0.1-t -> -0.9
t+t2 -> 1.333333333
t-t2 -> 0.666666667
t*3 -> 3
t/3 -> 0.333333333
3*t -> 3
t=5 -> 5, t=5
t=t2 -> 0.333333333, t=0.333333333
t+=0.1 -> 1.1, t=1.1
t+=-1 -> 0, t=0
t+=-1.3 -> -0.3, t=-0.3
t-=0.1 -> 0.9, t=0.9
t-=1.3 -> -0.3, t=-0.3
t+=t2 -> 1.333333333, t=1.333333333
t-=t2 -> 0.666666667, t=0.666666667
t*=3 -> 3, t=3
t/=3 -> 0.333333333, t=0.333333333
t-=1 -> 0, t=0
t==1 -> 1
t!=1 -> 0
t==2 -> 0
t!=2 -> 1
t==t2 -> 0
t!=t2 -> 1
t<1 -> 0
t<=1 -> 1
t>1 -> 0
t>=1 -> 1
t<t -> 0
t<=t -> 1
t>t -> 0
t>=t -> 1
t<t2 -> 0
t<=t2 -> 0
t>t2 -> 1
t>=t2 -> 1
.

