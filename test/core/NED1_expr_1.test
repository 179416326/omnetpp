%description:
Test operators in NED, with volatile parameters.

%file: test.ned

simple Simple
{
    parameters:
        volatile double p00;
        volatile double p01;
        volatile double p02;
        volatile double p03;
        volatile double p06;
        volatile double p07;
        volatile double p08;
        volatile double p09;
        volatile double p10;
        volatile double p11;
        volatile double p12;
        volatile double p13;
        volatile double p14;
        volatile double p15;
        volatile double p16;
        volatile double p17;
        volatile double p18;
        volatile double p19;
        volatile double p20;
        volatile double p21;
        volatile double p22;
        volatile double p23;
        volatile double p24;
        volatile double p25;
        volatile double p26;
        volatile double p27;
        volatile double p28;
        volatile double p29;
        volatile double p30;
        volatile double p31;
        volatile double p32;
        volatile double p33;
        volatile double p34;
        volatile double p35;
        volatile double p36;
        volatile double p37;
        volatile double p38;
        volatile double p39;
        volatile double p40;
        volatile double p41;
        volatile double p42;
        volatile double p43;
        volatile double p44;
        volatile double p45;
        volatile double p46;
        volatile double p47;
}

network Test extends Simple
{
    parameters:
        p00 = -3;      // unary minus or negative constant
        p01 = -(4+1);  // unary minus

        p02 = bool2int(!true);  // negation
        p03 = bool2int(!false); // negation

        p06 = ~3;      // bitwise complement (yields positive number)
        p07 = 12^3;  // power of
        p08 = 12*3;  // multiply
        p09 = 12/3;  // divide
        p10 = 12%5;  // modulus
        p11 = 12+3;  // add
        p12 = 12-3;  // subtract

        p13 = 10<<2; // bitwise shifting
        p14 = 10>>2; // bitwise shifting

        p15 = 10&3;  // bitwise and
        p16 = 10|3;  // bitwise or
        p17 = 10#3;  // bitwise xor

        p18 = bool2int(8==3); // equal
        p19 = bool2int(8==8); // equal

        p20 = bool2int(8!=3); // not equal
        p21 = bool2int(8!=8); // not equal

        p22 = bool2int(8>3);  // greater
        p23 = bool2int(3>8);  // greater
        p24 = bool2int(8>8);  // greater

        p25 = bool2int(8>=3); // greater or equal
        p26 = bool2int(3>=8); // greater or equal
        p27 = bool2int(8>=8); // greater or equal

        p28 = bool2int(8<3);  // less
        p29 = bool2int(3<8);  // less
        p30 = bool2int(8<8);  // less

        p31 = bool2int(8<=3); // less or equal
        p32 = bool2int(3<=8); // less or equal
        p33 = bool2int(8<=8); // less or equal

        p34 = bool2int(true && true);   // logical and
        p35 = bool2int(true && false);  // logical and
        p36 = bool2int(false && true);  // logical and
        p37 = bool2int(false && false); // logical and

        p38 = bool2int(true || true);   // logical or
        p39 = bool2int(true || false);  // logical or
        p40 = bool2int(false || true);  // logical or
        p41 = bool2int(false || false); // logical or

        p42 = bool2int(true ## true);   // logical xor
        p43 = bool2int(true ## false);  // logical xor
        p44 = bool2int(false ## true);  // logical xor
        p45 = bool2int(false ## false); // logical xor

        p46 = (true ? 5 : 2);  // the C/C++ ``inline if''
        p47 = (false ? 5 : 2); // the C/C++ ``inline if''

}

%file: test.cc

#include <omnetpp.h>

namespace {} {

typedef cDynamicExpression::StkValue Value;

Value bool2int(cComponent *context, Value args[], int numargs) {
    return args[0].bl ? 1L : 0L;
}
Define_NED_Function(bool2int, "B", "L");


class Simple : public cSimpleModule
{
  public:
    Simple() : cSimpleModule(16384) { }
    virtual void activity();
};

Define_Module(Simple);

void Simple::activity()
{
    for (int i=0; i<params(); i++)
        ev << par(i).name() << "=" << par(i).doubleValue() << endl;
    ev << ".\n";
}

}; //namespace

%contains-regex: stdout
p00=-3
p01=-5
p02=0
p03=1
p06=[0-9eE+.]+
p07=1728
p08=36
p09=4
p10=2
p11=15
p12=9
p13=40
p14=2
p15=2
p16=11
p17=9
p18=0
p19=1
p20=1
p21=0
p22=1
p23=0
p24=0
p25=1
p26=0
p27=1
p28=0
p29=1
p30=0
p31=0
p32=1
p33=1
p34=1
p35=0
p36=0
p37=0
p38=1
p39=1
p40=1
p41=0
p42=0
p43=1
p44=1
p45=0
p46=5
p47=2
.
