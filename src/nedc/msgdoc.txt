EXPERIMENTAL MESSAGE SUBCLASSING SUPPORT
========================================

Motivation
==========
Formerly, cPars were the only way to add data to message objects. cPars are
fairly complex objects themselves so they add both execution and memory
overhead, and they were also error-prone because cPar objects have to be
added dynamically and individually to each message object.

The solution is to define new C++ message classes with the necessary parameters
as instance variables instead of using cPar objects. The simulation library
is based on C++, and it is very easy to subclass cMessage:

        class RadioMsg : public cMessage {
                public:
                        int freq;
                        double power;
                ...
        }

Now it is possible to write code like this:

        RadioMsg *m = new RadioMsg;
        m->freq = 1;
        m->power = 10.0;
        ...

In one test (slotted Aloha simulation with 10 nodes), the simulation was
8 times faster when using this technique. Of course, if your simulation
doesn't create and destroy many messages (compared to other activities),
you may not benefit this much.

However, since instance variables in the message objects are invisible
to Tkenv, extra code is necessary if one wants to inspect message contents.

To relieve the simulation programmer from having to write this extra code,
message descriptions are moved into NED, and nedc will do the task of
generating the necessary C++ code with subclasses of cMessage and cPacket.
nedc can add the necessary data members and their get/set methods. nedc
also generates the necessary reflection code which makes it possible
to inspect message contents in Tkenv.

The original idea is described in:
  http://www.hit.bme.hu/phd/vargaa/omnetpp/subclass.htm

See also the NED II draft at:
  http://www.hit.bme.hu/phd/vargaa/omnetpp/neddraft.htm


Experimental message subclassing
================================
This is an experimental implementation of the message subclassing feature
described above. "Experimental" means that:
 1. The NED message description syntax and features may change in the future,
    based on feedback from the community;
 2. The nedc extension that translates message descriptions into C++ is
    implemented as a perl script (prototype implementation).


Files
=====
msgc.pl         -- "message subclassing compiler"
msgtest.ned     -- example NED source
nedcwrapper.sh  -- 'glue' script to integrate message subclassing
                   into the current OMNeT++ releases
msgdoc.txt      -- this file


How to try
==========
You place your message subclassing stuff into a file with .ned extension.
This file is going to be processed with msgc.pl, the experimental
"message subclassing compiler". Since msgc.pl doesn't understand
"conventional" NED elements (i.e. modules, networks, channels), don't put
any of them into a message subclassing .ned file! (Similarly, because
old nedc doesn't understand message subclassing syntax, don't put any such
elements into normal .ned files.)  The first line of your message subclassing
ned files should be:
  //--subclassing--
You'll immediately see why.

To enable this feature, you have to re-run configure with the
   --enable-nedc-subcl
command-line argument. This will replace the NEDC=nedc line in the makefiles
and in opp_makemake with:
  NEDC=$(HOME)/omnetpp/src/nedc/nedcwrapper.sh

nedcwrapper.sh is a small script that peeks into the ned file looking
for the '//--subclassing--' line, an depending on its presence, it invokes
either msgc.pl or nedc to process it. nedcwrapper.sh as well as the msgc.pl
script are a temporary solution until the new extended nedc becomes
available.

The task of the "message subclassing compiler" is to generate C++ classes
you can use from your models as well as "reflection" classes that allow
Tkenv to inspect these data stuctures. From a file called foo.ned,
the compiler will generate the foo_n.h and foo_n.cc files. You'll need to
#include foo_n.h into your C++ sources to be able to use the generated
classes. The foo_n.cc file contains implementation of the generated classes
as well as "reflection" code that (at some point in the future) will allow
you to inspect these data stuctures from the Tkenv GUI. The foo_n.cc file
should be compiled and linked into you simulation (the generated makefile
will take care of this).


Features in nutshell
====================
You're strongly advised to experiment with the source and always check out
the generated code!!!

For lack of time, syntax is not described here -- you should study the
msgtest.ned file instead!  What you find here however is very brief
explanations of certain keywords or features you find in msgtest.ned.

1. cppinclude directive:
Adds a C++ #include to the generated header file.
Example:
  cppinclude "myclasses.h"


2. enums:
An enum{..} generates a normal C++ enum, plus creates an object which stores
textual representations of the constants. The object makes it possible to
display symbolic names in Tkenv.


3. class, message declarations:
Different flavours of the same thing -- generated data classes with associated
descriptor objects which make them inspectable in Tkenv.
- class: class (default base class: none [NOT cObject!!!])
- message: class (default base class: cMessage)
- struct: public data members instead of set/get methods
Slightly different code is generated for classes that are rooted in cObject
than for those that are not. (For the latter, no className() or dup() method
is generated, and the constructor doesn't have the 'name' argument.)


4. struct declarations:
Generated structs have public data members instead of set/get methods.
They have no virtual functions (no vtable!). Inheritance is supported, but
"generation gap" or virtual fields are not (they build upon virtual functions).


5. fields, properties sections within the class/message/struct declarations:
fields section: data members to be generated.
properties section: contains meta info that affects how generated code will
look like.


6. 'customize' property (true/false):
When set, the 'generation gap' pattern is used which allows the programmer
to customize the generated class by redefining virtual member functions.


7. announcing your C++ types to the compiler
Announcement of all types unknown to msgc is mandatory. Use the struct, cobject,
noncobject keywords.
Examples:
  struct IPAddress;
  cobject PayloadPacket;
Types announced this way are assumed to have NO associated descriptor objects.


8. 'virtual' fields:
No data member is generated, and generated getter/setter methods are pure
virtual. Purpose is to allow the programmer to store the value of this field
in whatever way he/she wants. Assumes that the class has the 'customize'
property set.
Example:
   virtual int a;


9. enum declarations for fields:
It is possible to tell nedc if an integral field will take values from an enum.
Example:
   int p enum(ProtocolTypes);


