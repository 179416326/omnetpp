#!/bin/sh
# makemake (formerly jar_mkmk)
#
#  Creates a makefile for a given OMNeT++ model.
#  Assumes that .ned, .cc and .h files are in one directory.
#  The name of the program defaults to the name of the directory ('myproject').
#
#  Original script written by Jan Heijmans et al.
#
#  --VA
#

#
# Variables to be customized by the configure script
#   Any changes made here will be lost when configure is run!
#

OMNETPP_ROOT="/home/andras/omnetpp"
OMNETPP_SRC_DIR="/home/andras/omnetpp/src"

CC="gcc -g -I. -c -x c++"
NEDC="nedc"
LD="gcc"
AR="ar rs"
MAKE_SO="gcc -shared -o"

OMNETPP_INCL_PATH="-I$OMNETPP_SRC_DIR/sim"
OMNETPP_LIB_PATH="-L$OMNETPP_ROOT/lib"

OMNETPP_INCLUDES="$OMNETPP_SRC_DIR/sim/*.h"

TV_LIBS="-ltv"
X_LIBS="-lX11"
TK_LIBS="-ltk -ltcl -ldl"
PVM_LIBS="-lgpvm3 -lpvm3"
SYS_LIBS="-ldl -lm -lstdc++"

TV_LIB_PATH=""
X_LIB_PATH="-L/usr/X11R6/lib"
TK_LIB_PATH="-L/usr/lib -L/usr/lib"
PVM_LIB_PATH="-L/home/andras/pvm3/src/LINUX"

#
# process command line args
#
args="$*"

userif=TKENV
outfile=`pwd | sed "s/\/$//;s/.*\///"`
type="exe"
includes=""
libs=""
dirs=""
xobjs=""
fragments=""

while [ ! $# = 0 ] ; do
    case "$1" in

        -h | --help)
        cat <<EOT
makemake: write OMNeT++ makefile based on source files in current directory

makemake [-h] [-f] [-o make-target] [-t exe|so|o] [-u user-interface] [-p] 
         [-Idir] [-llibrary] [-i makefile-fragment-file] 
         [directories, library and object files]...
    -h, --help            This help text
    -f, --force           Force overwriting existing makefile
    -o, --outputfile      Name of simulation executable/library
    -n, --nolink          Produce object files but no not create executable or
                          library. Useful for models with parts in several dirs.
    -s, --make-so         Make shared library. Useful if you want to load the
                          model dynamically (Cmdenv/Tkenv -l so-file switch).
    -u, --userinterface   Use Cmdenv, Tkenv or Tvenv. Defaults to Tkenv
    -p, --pvm             Link executable with parallel execution support
    -Idir                 Additional NED and C++ include directory
    -llibrary             Additional library to link against
    -i, --includefragment Append file to near end of makefile. The file makefrag
                          is appended implicitly if no -i options are given.
    directory             Recursive make in that dir. Makemake will need 
                          to call make there to see what object files to
                          include in the makefile.
    library or object     Link with that file.

With -n and -s options, -u, -p and -l have no effect.
If you have a source tree instead of a single directory, run makemake -n
in the subdirs and then makemake dir1 dir2 etc. in your top-level directory. 
The -i option is useful if a source file (.ned or .cc) is to be generated 
from other files.
EOT
        exit
        ;;

        -f | --force)
        force=y
        ;;

        -o | --outputfile)
        shift
        outfile=$1
        ;;

        -n | --nolink)
        type="o"
        ;;

        -s | --make-so)
        type="so"
        ;;

        -u | --userinterface)
        shift
        userif=`echo $1 | tr a-z A-Z`
        case "$userif" in 
            CMDENV | TKENV | TVENV)
            ;;
            *)
            echo "makemake: -u: valid user interface names are Cmdenv, Tkenv or Tvenv" 1>&2
            exit
            ;;
        esac  
        ;;

        -p | --pvm)
        pvm=y
        ;;

        -i | --includefragment)
        shift
        fragments="$fragments $1"
        ;;

        -I*)
        includes="$includes $1"
        ;;

        -l*)
        libs="$libs $1"
        ;;

        *)
        if [ -d $1 ]; then
            dirs="$dirs $1"
        else
            if [ ! -f $1 ]; then
                echo "makemake: $1 is neither an existing file/dir nor a valid option" 1>&2
                exit
            fi
            xobjs="$xobjs $1"
        fi
        ;;

    esac
    shift
done

if [ -f makefile ]; then
    if [ ! -s makefile ]; then
        echo "makemake: synopsis changed (no longer needs '>makefile', type makemake -h)" 1>&2
        rm makefile
        exit
    fi
    if [ ! "$force" = "y" ]; then
        echo "makemake: use -f to force overwrite existing makefile" 1>&2
        exit
    fi
fi

sobjs=""
for i in $dirs; do
    echo "*** Running make in $i to see object file names"
    (cd $i; make)
    o=`echo $i/*.o`
    if [ "$o" = "$i/*.o" ]; then
         echo "makemake: warning: no object files in $i" 1>&2
    else
         sobjs="$sobjs $o"
    fi
done

objs=`echo *.ned *.cc | sed 's/\*[^ ]*//g; s/[^ ]*_n\.cc//g; s/.ned/_n.o/g; s/.cc/.o/g'`

#
# now the makefile creation
#

(

cat <<EOT
#
#  makefile for $outfile
#
#  ** This file was automatically generated by the command: 
#  makemake $args
#
EOT

suffix=''
if [ "$type" = "so" ]; then 
    suffix='.so'
fi
if [ "$type" = "o" ]; then 
    suffix=''
fi

case "$userif" in
    CMDENV)
    c_cmd=''; c_tk='# '; c_tv='# '; ;;
    TKENV)
    c_cmd='# '; c_tk=''; c_tv='# '; ;;
    TVENV)
    c_cmd='# '; c_tk='# '; c_tv='' ;;
esac
c_std=''; c_pvm='# ' 
if [ "$pvm" = "y" ]; then 
    c_std='# '; c_pvm='' 
fi

nil=""  # ${nil} is a hack to protect those lines against configure

cat <<EOT

# Name of target to be created (-o option)
TARGET = $outfile$suffix

# User interface (uncomment one) (-u option)
${c_cmd}USERIF_LIBS = \$(CMDENV_LIBS)
${c_tk}USERIF_LIBS = \$(TKENV_LIBS)
${c_tv}USERIF_LIBS = \$(TVENV_LIBS)

# Uncomment the second line for parallel execution (PVM3) support (-p option):
${c_std}KERNEL_LIBS = \$(STD_KERNEL_LIBS)
${c_pvm}KERNEL_LIBS = \$(PVM_KERNEL_LIBS)

# .ned or .h include paths with -I
INCLUDE_PATH = $includes

# misc additional object and library files to link
EXRA_OBJS = $xobjs

# object files in subdirectories
SUBDIR_OBJS = $sobjs

# Additional libraries (-l option)
LIBS = $libs

#------------------------------------------------------------------------------

# NOTE: The following variables (paths etc.) are set by the configure script.
#       Any changes you make here will be lost with the next configure.

${nil}OMNETPP_ROOT = $OMNETPP_ROOT
${nil}OMNETPP_SRC_DIR = $OMNETPP_SRC_DIR

${nil}CC = $CC
${nil}NEDC = $NEDC
${nil}LD = $LD
${nil}AR = $AR
${nil}MAKE_SO = $MAKE_SO

${nil}OMNETPP_INCL_PATH=$OMNETPP_INCL_PATH
${nil}OMNETPP_LIB_PATH=$OMNETPP_LIB_PATH

${nil}TV_LIBS=$TV_LIBS
${nil}X_LIBS=$X_LIBS
${nil}TK_LIBS=$TK_LIBS
${nil}PVM_LIBS=$PVM_LIBS
${nil}SYS_LIBS=$SYS_LIBS

${nil}TV_LIB_PATH=$TV_LIB_PATH
${nil}TK_LIB_PATH=$TK_LIB_PATH
${nil}X_LIB_PATH=$X_LIB_PATH
${nil}PVM_LIB_PATH=$PVM_LIB_PATH

# User interface libs
${nil}CMDENV_LIBS = -lenvir -lcmdenv
${nil}TVENV_LIBS = -lenvir -ltvenv \$(TV_LIB_PATH) \$(TV_LIBS)
${nil}TKENV_LIBS = -lenvir -ltkenv \$(TK_LIB_PATH) \$(TK_LIBS) \$(X_LIB_PATH) \$(X_LIBS)

# Simulation kernel
${nil}STD_KERNEL_LIBS = -lsim_std
${nil}PVM_KERNEL_LIBS = -lsim_pvm \$(PVM_LIB_PATH) \$(PVM_LIBS)

# Simulation kernel and user interface libraries
${nil}OMNETPP_LIBS = \$(OMNETPP_LIB_PATH) \$(KERNEL_LIBS) \$(USERIF_LIBS) \$(SYS_LIBS)

${nil}OMNETPP_INCLUDES = $OMNETPP_INCLUDES

#------------------------------------------------------------------------------

EOT

if [ "$dirs" != "" ]; then
    subdirsphony=subdirs-phony
else
    subdirsphony=""
fi

echo '# Object files from this directory to link'
echo "OBJS = $objs"
echo

case "$type" in
exe)
    echo '$(TARGET): $(OBJS) $(EXRA_OBJS) ' $subdirsphony ' makefile'
    echo '	$(LD) $(OBJS) $(EXRA_OBJS) $(SUBDIR_OBJS) $(LIBS) $(OMNETPP_LIBS) -o $(TARGET)'
    ;;
so)
    echo '$(TARGET): $(OBJS) $(EXRA_OBJS) ' $subdirsphony ' makefile'
    echo '	$(MAKE_SO) $(TARGET) $(OBJS) $(EXRA_OBJS) $(SUBDIR_OBJS)'
    ;;
o)
    echo '$(TARGET): $(OBJS) makefile'
    echo '	'
    ;;
esac
echo

if [ "$type" != "o" ]; then
    if [ "$dirs" != "" ]; then
        echo 'subdirs-phony:'
        for i in $dirs 
        do
           echo "	(cd $i; make)"
        done
        echo
    fi
fi

for i in *.ned
do
        if [ "$i" = "*.ned" ]; then break; fi;

	obj=`echo $i | sed 's/.ned/_n.o/g'`
	c=`echo $i | sed 's/.ned/_n.cc/g'`
	h=`echo $i | sed 's/.ned/.h/g'`

	echo -n $obj': '
	if test -s $h
	then
		echo -n $h' '
	fi
	echo $c '$(OMNETPP_INCLUDES)'
	echo '	$(CC) $(INCLUDE_PATH) $(OMNETPP_INCL_PATH) '$c
	echo

	echo $c':' $i
	echo '	$(NEDC) $(INCLUDE_PATH)' $i
	echo
done

headers=`echo *.h | sed 's/\*\.h//'`
for i in `echo *.cc | sed 's/[^ ]*_n\.cc//g'`
do
        if [ "$i" = "*.cc" ]; then break; fi;

	obj=`echo $i | sed 's/.cc/.o/g'`
	h=`echo $i | sed 's/.cc/.h/g'`
	echo $obj':' $i $headers '$(OMNETPP_INCLUDES)'
	echo '	$(CC) $(INCLUDE_PATH) $(OMNETPP_INCL_PATH) '$i
	echo
done

if [ ! "$fragments" = "" ]; then
    cat $fragments
else
    if [ -f makefrag ]; then
        cat makefrag
    fi
fi

echo 'clean:'
echo '	rm -f *.o *_n.cc $(TARGET)'

) > makefile

