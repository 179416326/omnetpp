#!/usr/bin/perl
#
# Creates a makefile for a given OMNeT++/OMNEST model.
# Assumes that .ned, .msg, .cc and .h files are in one directory.
# The name of the program defaults to the name of the directory ('myproject').
#
# Author: Andras Varga
#

use Cwd;
use Config;

$ARG0 = $0;
$progname = $ARG0;

#$arch = $Config{'archname'};
#$isCygwin = ($arch =~ /cygwin/i);
$isWindows = ($ENV{OS} =~ /windows/i) ? 1 : 0;

sub makemake();

makemake();
exit 0;

#TODO:
# support building static library
# support output dir
# project directory should be autodetected if not given!
# use linkall.cmd on Windows!
# -X incorrectly implemented (matches substring: -X befools also ignores "foo" subdir)
#
#TODO: to implement:
# outputDir  (derive $O from projectdir + "obj/" + configname + project-relative path?)
# invoke opp_makedepend in the end?
#
#TODO: port to Java:
# --deep opcio
# --mode (-M) opcio
# -D opcio
# "rem" => ""
#

sub makemake()
{
    if ($isWindows && $ENV{OS} ne "Windows_NT") {
        error("this program can only be used on Windows NT/2000/XP, but your OS environment variable says '$ENV{OS}'\n");
    }

    #
    # process command line args
    #
    @args = @ARGV;
    $isNMake = 0;
    $projectDir = "";
    $type = "EXE";
    $target = "";
    $outputDir = ".";
    $force = 0;
    $linkWithObjects = 0;
    $tstamp = 1;
    $recursive = 0;
    $mode = "";
    $userInterface = "ALL";
    $ccExt = "";
    $configFile = "";
    $exportDefOpt = "";
    $compileForDll = 0;
    $ignoreNedFiles = 1;
    @fragmentFiles = ();
    @subdirs = ();
    @exceptSubdirs = ();
    @includeDirs = ();
    @libDirs = ();
    @libs = ();
    @importLibs = ();
    @defines = ();
    @extraArgs = ();

    # process arg vector
    while (@ARGV)
    {
        $arg = shift @ARGV;
        if ($arg eq "-h" || $arg eq "--help") {
            usage();
            exit(1);
        }
        elsif ($arg eq "-f" || $arg eq "--force") {
            $force = 1;
        }
        elsif ($arg eq "--nmake") {
            $isNMake = 1;
        }
        elsif ($arg eq "-e" || $arg eq "--ext") {
            $ccExt = shift @ARGV;
        }
        elsif ($arg eq "-o" || $arg eq "--outputfile") {
            $target = shift @ARGV;
        }
        elsif ($arg eq "--outputdir") {
            $outputDir = shift @ARGV;
        }
        elsif ($arg eq "-N" || $arg eq "--ignore-ned") {
            error("obsolete option $arg, please remove (dynamic NED loading is now the default)");
        }
        elsif ($arg eq "-r" || $arg eq "--recurse") {
            $recursive = 1;
        }
        elsif ($arg eq "-X" || $arg eq "--except") {
            push(@exceptSubdirs, shift @ARGV);
        }
        elsif ($arg =~ /^-X/) {
            my $dir = substr($arg, 2);
            push(@exceptSubdirs, $dir);
        }
        elsif ($arg eq "-D" || $arg eq "--define") {
            push(@defines, shift @ARGV);
        }
        elsif ($arg =~ /^-D/) {
            my $define = substr($arg, 2);
            push(@defines, $define);
        }
        elsif ($arg eq "-P" || $arg eq "--projectdir") {
            $projectDir = shift @ARGV;
        }
        elsif ($arg eq "-M" || $arg eq "--mode") {
            $mode = shift @ARGV;
        }
        elsif ($arg eq "-c" || $arg eq "--configfile") {
            $configFile = shift @ARGV;
        }
        elsif ($arg eq "-n" || $arg eq "--nolink") {
            $type = "NOLINK";
        }
        elsif ($arg eq "-d" || $arg eq "--subdir") {
            push(@subdirs, shift @ARGV);
        }
        elsif ($arg =~ /^-d/) {
            my $subdir = substr($arg, 2);
            push(@subdirs, $subdir);
        }
        elsif ($arg eq "-s" || $arg eq "--make-so") {
            $compileForDll = 1;
            $type = "SO";
        }
        elsif ($arg eq "-t" || $arg eq "--importlib") {
            push(@importLibs, shift @ARGV);
        }
        elsif ($arg eq "-S" || $arg eq "--fordll") {
            $compileForDll = 1;
        }
        elsif ($arg eq "-w" || $arg eq "--withobjects") {
            $linkWithObjects = 1;
        }
        elsif ($arg eq "-x" || $arg eq "--notstamp") {
            $tstamp = 1;
        }
        elsif ($arg eq "-u" || $arg eq "--userinterface") {
            my $userInterface = shift @ARGV;
            $userInterface = uc($userInterface);
            if ($userInterface ne "ALL" && $userInterface ne "CMDENV" && $userInterface ne "TKENV") {
                error("$progname: -u: specify All, Cmdenv or Tkenv");
            }
        }
        elsif ($arg eq "-i" || $arg eq "--includefragment") {
            push(@fragmentFiles, shift @ARGV);
        }
        elsif ($arg eq "-I") {
            push(@includeDirs, shift @ARGV);
        }
        elsif ($arg =~ /^-I/) {
            my $dir = substr($arg, 2);
            push(@includeDirs, $dir);
        }
        elsif ($arg eq "-L") {
            push(@libDirs, shift @ARGV);
        }
        elsif ($arg =~ /^-L/) {
            my $dir = substr($arg, 2);
            push(@libDirs, $dir);
        }
        elsif ($arg =~ /^-l/) {
            my $lib = substr($arg, 2);
            push(@libs, $lib);
        }
        elsif ($arg eq "-p") {
            $exportDefOpt = shift @ARGV;
        }
        elsif ($arg =~ /^-p/) {
            $exportDefOpt = substr($arg, 2);
        }
        else {
            # FIXME add support for "--" after which everything is extraArg
            if ($arg ne "--") {
                if ($arg =~ /^-/) {
                    error("unrecognized option: $arg");
                }
                push(@extraArgs, $arg);
            }
        }
    }


    #
    # Prepare the variables for the template
    #

    $makefile = $isNMake ? "Makefile.vc" : "Makefile";
    if (-f $makefile && $force ne 1) {
        error("use -f to force overwriting existing $makefile");
    }

    $folder = cwd;
    $folderName = $folder;
    $folderName  =~ s/[\/\\]$//;  # remove trailing slash/backslash
    $folderName  =~ s/.*[\/\\]//; # keep only part after last slash/backslash

    print "Creating $makefile in $folder...\n";

    $target = $target eq "" ? $folderName : $target;

    @externaldirobjs = ();
    @externaldirtstamps = ();
    @objs = ();
    @generatedHeaders = ();
    @linkDirs = ();
    @externalObjects = ();
    @tstampDirs = ();
    @msgfiles = ();
    @msgccfiles = ();
    @msghfiles = ();

    $target = abs2rel($target,$projectDir);

    @tmp = @includeDirs;
    foreach $i (@tmp) {
        push(@includeDirs, abs2rel($i,$projectDir));
    }
    @tmp = @libDirs;
    foreach $i (@tmp) {
        push(@libDirs, abs2rel($i,$projectDir));
    }

    $makecommand = $isNMake ? "nmake /nologo /f Makefile.vc" : "make";

    # find configuser.vc / Makefile.inc
    $configFile = `opp_configfilepath`;
    if ($? != 0) {
        error("opp_configfilepath returned nonzero exit code -- make sure it exists and is in the PATH");
    }
    $configFile =~ s/\n//gs;
    $configFile =~ s/\s*(.*)\s*/$1/gs;
    if ($configFile eq "" || ! -f $configFile) {
        error("opp_configfilepath returned \"$configFile\"");  #FIXME better error message
    }

    # try to find project root directory (go up until we find a ".project" file)
    if ($projectDir eq "") {
        my $dir = cwd;
        $dir =~ s|\\|/|g;
        for (;;) {
            if (-f "$dir/.project") {
                $projectDir = $dir;
                last;
            }
            if ($dir =~ m|/|) {
                $dir =~ s|/.*$||;
            }
            else {
                last;
            }
        }
    }

    # collect source files
    $deep = 0;  # "--deep" is not implemented yet
    if (!$deep) {
        @ccfiles = glob("*.cc");
        @cppfiles = glob("*.cpp");
        @msgfiles = glob("*.msg");
        @nedfiles = glob("*.ned");
    }
    else {
        @sourceDirs = collectDirs(".", \@exceptSubdirs);
        $numSourceDirs = @sourceDirs;
        die "too long!" if ($numSourceDirs > 500);
        print join('  ', @sourceDirs);
        @ccfiles = ();
        @cppfiles = ();
        @msgfiles = ();
        @nedfiles = ();
        foreach $f (@sourceDirs) {
            push(@ccfiles, glob("$f/*.cc"));
            push(@cppfiles, glob("$f/*.cpp"));
            push(@msgfiles, glob("$f/*.msg"));
            push(@nedfiles, glob("$f/*.ned"));
        }
    }

    # try to determine if .cc or .cpp files are used
    if ($ccExt eq "") {
        if (!@ccfiles && @cppfiles) {
            $ccExt = "cpp";
        }
        elsif (@ccfiles && !@cppfiles) {
            $ccExt = "cc";
        }
        elsif (@ccfiles && @cppfiles) {
            error("you have both .cc and .cpp files -- specify -e cc or -e cpp option to select which set of files to use");
        }
        else {
            $ccExt = "cc";  # if no files, use .cc extension
        }
    }
    else {
        if ($ccExt eq "cc" && !@ccfiles && @cppfiles) {
            warning("you specified -e cc but you have only .cpp files in this directory!");
        }
        if ($ccExt eq "cpp" && @ccfiles && !@cppfiles) {
            warning("you specified -e cpp but you have only .cc files in this directory!");
        }
    }

    $objExt = $isNMake ? "obj" : "o";

    $targetSuffix = "";
    if ($type eq "EXE") {
        $targetSuffix = $isNMake ? ".exe" : "";
    } elsif ($type eq "SO") {
        $targetSuffix = $isNMake ? ".dll" : ".so";
    }

    # prepare subdirs. First, check that all specified subdirs exist
    foreach $subdir (@subdirs) {
        if (! -d $subdir) {
            error("subdirectory '$subdir' does not exist");
        }
    }

    if ($recursive) {
        foreach $f (glob("*")) {
            if (-d $f && !grep(/\Q$f\E/, @exceptSubdirs)) {  #XXX check IGNORABLE_DIRS
                push(@subdirs, $f);
            }
        }
    }

    @subdirTargets = ();
    foreach $subdir (@subdirs) {
        push(@subdirTargets, $subdir . ($isNMake ? "_dir" : ""));  #XXX make sure none contains "_dir" as substring
    }

    foreach $arg (@extraArgs) {
        if (-d $arg) {
            $arg = abs2rel($arg,$projectDir);
            push(@linkDirs, $arg);
        }
        elsif (-f $arg) {
            $arg = abs2rel($arg,$projectDir);
            push(@externalObjects, $arg);
        }
        else {
            error("'$arg' is neither an existing file/dir nor a valid option");
        }
    }

    if ($linkWithObjects) {
        foreach $i (@includeDirs) {
            if ($i ne ".") {
                push(@externaldirobjs, "$i/*.$objExt");
            }
        }
    }

    foreach $i (@linkDirs) {
        push(@externaldirobjs, "$i/*.$objExt");
    }

    foreach $i (@includeDirs) {
        if ($tstamp && $i ne ".") {
            push(@tstampDirs, $i);
        }
    }

    foreach $i (@linkDirs) {
        if ($tstamp) {
            push(@tstampDirs, $i);
        }
    }
    foreach $i (@tstampDirs) {
        push(@externaldirtstamps, quote("$i/.tstamp"));
    }

    @sources = ();
    push(@sources, @ccfiles) if ($ccExt eq "cc");
    push(@sources, @cppfiles) if ($ccExt eq "cpp");
    push(@sources, @msgfiles);
    push(@sources, @nedfiles) if (!$ignoreNedFiles);
    foreach $i (@sources)
    {
        $i =~ s/\*[^ ]*//g;
        $i =~ s/[^ ]*_n\.$ccExt$//g;
        $i =~ s/[^ ]*_m\.$ccExt$//g;
        $i =~ s/\.ned$/_n.$objExt/g;
        $i =~ s/\.msg$/_m.$objExt/g;
        $i =~ s/\.$ccExt$/.$objExt/g;
        if ($i ne '') {
            push(@objs, "\$O/$i");
        }
    }

    foreach $i (@msgfiles) {
        $h = $i; $h =~ s/\.msg$/_m.h/;
        $cc = $i; $cc =~ s/\.msg$/_m.$ccExt/;
        push(@generatedHeaders, $h);
        push(@msgccfiles, $cc);
        push(@msghfiles, $h);
    }

    $makefrags = "";
    if (@fragmentFiles) {
        foreach $frag (@fragmentFiles) {
            $makefrags .= "# inserted from file '$frag':\n";
            $makefrags .= readTextFile($frag) . "\n";
        }
    }
    else {
        $makefragFilename = $isNMake ? "makefrag.vc" : "makefrag";
        if (-f $makefragFilename) {
            $makefrags .= "# inserted from file '$makefragFilename':\n";
            $makefrags .= readTextFile($makefragFilename) . "\n";
        }
    }

    $deps = "";  #FIXME

    %m = (
        "rem" => "",  # allows putting comments into the template
        "lbrace" =>  "{",
        "rbrace" =>  "}",
        "nmake" =>  $isNMake,
        "target" =>  $target . $targetSuffix,
        "outputdir" => $outputDir,
        "progname" => "opp_makemake",  # $isNMake ? "opp_nmakemake" : "opp_makemake",
        "args" =>  quoteJoin(\@args),
        "configfile" =>  $configFile,
        "-L" =>  $isNMake ? "/libpath:" : "-L",
        "-l" =>  $isNMake ? "" : "-l",
        ".lib" =>  $isNMake ? ".lib" : "",
        "-u" =>  $isNMake ? "/include:" : "-u",
        "_dir" =>  "_dir",
        "cc" =>  $ccExt,
        "obj" =>  $objExt,
        "deps" =>  $deps,
        "exe" =>  $type eq "EXE",
        "so" =>  $type eq "SO",
        "nolink" =>  $type eq "NOLINK",
        "mode" =>  $mode,
        "allenv" => ($userInterface =~ /^A/) ne "",
        "cmdenv" =>  ($userInterface =~ /^C/) ne "",
        "tkenv" =>  ($userInterface =~ /^T/) ne "",
        "extdirobjs" =>  quoteJoin(\@externaldirobjs),
        "extdirtstamps" =>  quoteJoin(\@externaldirtstamps),
        "extraobjs" =>  quoteJoin(\@externalObjects),
        "includepath" =>  prefixQuoteJoin(\@includeDirs, "-I"),
        "libpath" =>  prefixQuoteJoin(\@libDirs, (isNMake ? "/libpath:" : "-L")),
        "libs" =>  quoteJoin(\@libs),
        "defines" => prefixQuoteJoin(\@defines, "-D"),
        "importlibs" =>  quoteJoin(\@importLibs),
        "link-o" =>  $isNMake ? "/out:" : "-o",
        "makecommand" =>  $makecommand,
        "makefile" =>  $isNMake ? "Makefile.vc" : "Makefile",
        "makefrags" =>  $makefrags,
        "msgccfiles" =>  quoteJoin(\@msgccfiles),
        "msghfiles" =>  quoteJoin(\@msghfiles),
        "msgfiles" =>  quoteJoin(\@msgfiles),
        "objs" =>  quoteJoin(\@objs),
        "subdirs" =>  quoteJoin(\@subdirs),
        "subdirtargets" =>  quoteJoin(\@subdirTargets),
        "fordllopt" =>  $compileForDll ? "/DWIN32_DLL" : "",
        "dllexportmacro" =>  $exportDefOpt ? "-P$exportDefOpt" : ""
    );

    $content = substituteIntoTemplate(template(), \%m, "{", "}");

    open(OUT, ">$makefile");
    print OUT $content;
    close OUT;

    print "$makefile created.\n";
    print "Please type `nmake -f $makefile depend' NOW to add dependencies!\n";
}

sub collectDirs($;$);
sub collectDirs($;$)
{
    my ($dir,$exceptDirsRef) = @_;
    my @exceptDirs = @$exceptDirsRef;

    my @result = ($dir);
    foreach $f (glob("$dir/*")) {
        if (-d $f && !grep(/\Q$f\E/, @exceptSubdirs)) {  #XXX better check for exceptDirs; check IGNORABLE_DIRS too
            push(@result, collectDirs($f, \@exceptDirs));
        }
    }
    return @result;
}

#
# Performs template substitution. Constructs understood are:
#  - {foo} gets replaced by the value of "foo";
#  - {bar?some text} gets replaced by "some text" if value of "bar" is true*.
#  - {~bar?some text} gets replaced by "some text" if value of "bar" is false*
#  - {bar:} only keep the rest of the line if value of "bar" is true*
#  - {~bar:} only keep the rest of the line if value of "bar" is false*
# * true/false are interpreted as in Perl: "" and "0" are false, everything else is true.
#
# Newlines inside {...} are not permitted; this allows detecting errors caused
# by misplaced braces. Also, nesting is not supported.
#
sub substituteIntoTemplate($;$;$;$)
{
    my ($template,$mapref,$startTag,$endTag) = @_;
    my %map = %$mapref;

    my $buf = "";
    my $startTagLen = length($startTag);
    my $endTagLen = length($endTag);

    my $current = 0;
    while (1) {
        my $start = index($template, $startTag, $current);
        if ($start == -1) {
            last;
        }
        else {
            my $end = index($template, $endTag, $start);
            if ($end != -1) {
                my $tag = substr2($template, $start, $end + $endTagLen);
                #print("processing $tag\n");
                my $key = substr2($template, $start+$startTagLen, $end);
                if (index($key, "\n") != -1) {
                    die("template error: newline inside \"$tag\" (misplaced start/end tag?)");
                }
                my $isNegated = substr($key, 0, 1) eq "~";
                if ($isNegated) {
                    $key = substr($key, 1);  # drop "~"
                }
                my $isOptLine = substr($key,-1,1) eq ":";
                if ($isOptLine) {
                    $key = substr($key, 0, length($key)-1);  # drop trailing ":"
                }
                my $questionmarkPos = index($key, "?");
                my $substringAfterQuestionmark = $questionmarkPos == -1 ? "" : substr($key, $questionmarkPos+1);
                if ($questionmarkPos != -1) {
                    $key = substr2($key, 0, $questionmarkPos); # drop "?..." from key
                }

                # determine replacement string, and possibly adjust start/end
                my $replacement = "";
                if ($isOptLine) {
                    # replacing a whole line
                    my $condition = getFromMapAsBool(\%map, $key);
                    if ($isNegated ? !$condition : $condition) {
                        # put line in: all variables OK
                    }
                    else {
                        # omit line
                        my $endLine = index($template, "\n", $end);
                        if ($endLine == -1) {
                            $endLine = length($template);
                        }
                        $replacement = "";
                        $end = $endLine;
                    }
                }
                elsif ($questionmarkPos != -1) {
                    # conditional
                    $replacement = getFromMapAsBool(\%map, $key)!=$isNegated ? $substringAfterQuestionmark : "";
                }
                else {
                    # plain replacement
                    if ($isNegated) {
                        die("template error: wrong syntax \"$tag\" (possible missing \"?\")");
                    }
                    $replacement = getFromMapAsString(\%map, $key);
                }

                # do it: replace substring(start, end) with replacement, unless replacement==null
                $buf .= substr2($template, $current, $start);  # template code up to the {...}
                $buf .= $replacement;
                $current = $end + $endTagLen;
            }
        }
    }
    $buf .= substr($template, $current);  # rest of the template
    return $buf;
}

sub substr2($;$;$)
{
    my($string, $startoffset, $endoffset) = @_;
    return substr($string, $startoffset, $endoffset - $startoffset);
}

sub quoteJoin($)
{
    my($listref) = @_;
    return prefixQuoteJoin($listref, "");
}

sub prefixQuoteJoin($,$)
{
    my($listref,$prefix) = @_;
    @list = @$listref;
    $sep = (@list > 5) ? " \\\n    " : " ";
    $result = "";
    foreach $i (@list) {
        $result .= $sep . $prefix . quote($i);
    }
    return $result eq "" ? "" : substr($result, 1); # chop off leading space
}

# for substituteIntoTemplate()
sub getFromMapAsString($;$)
{
    my($mapref,$key) = @_;
    my %map = %$mapref;
    die("template error: undefined template parameter '$key'") if (!defined($map{$key}));
    return $map{$key};
}

# for substituteIntoTemplate()
sub getFromMapAsBool($;$)
{
    my($mapref,$key) = @_;
    my %map = %$mapref;
    die("template error: undefined template parameter '$key'") if (!defined($map{$key}));
    $value = $map{$key};
    return $value ? 1 : 0;
}

#
# Converts absolute path $inputpath to relative path (relative to the current
# directory $referencedir), provided that both $inputpath and $referencedir are under a
# "project base directory" $projectdir. Otherwise it returns the original path.
# All "\" are converted to "/".
#
sub abs2rel($;$;$;)
{
    my($inputpath, $projectdir, $referencedir) = @_;

    if ($projectdir eq '') {
        return $inputpath;
    }
    if ($referencedir eq '') {
        $referencedir = cwd;
    }

    # some normalization
    $inputpath =~ s|\\|/|g;
    $referencedir =~ s|\\|/|g;
    $projectdir =~ s|\\|/|g;

    $inputpath =~ s|/\./|/|g;
    $referencedir =~ s|/\./|/|g;
    $projectdir =~ s|/\./|/|g;

    $inputpath =~ s|//+|/|g;
    $referencedir =~ s|//+|/|g;
    $projectdir =~ s|//+|/|g;

    $referencedir =~ s|/*$|/|;
    $projectdir =~ s|/*$|/|;

    if (!($inputpath =~ /^\Q$projectdir\E/i && $referencedir =~ /^\Q$projectdir\E/i)) {
        return $inputpath;
    }

    while (1)
    {
       # keep cutting off common prefixes until no more
       $inputpath =~ m|^(.*?/)|;
       my $prefix = $1;
       last if ($prefix eq '');
       if ($referencedir =~ /^\Q$prefix\E/i) {
           $inputpath =~ s/^\Q$prefix\E//i;
           $referencedir =~ s/^\Q$prefix\E//i;
       } else {
           last;
       }
    }


    # assemble relative path: change every directory name in $referencedir to "..",
    # then add $inputpath to it.
    $referencedir =~ s|[^/]+|..|g;
    my $rel = $referencedir.$inputpath;

    return $rel;
}


sub quote($)
{
    my($dir) = @_;
    if ($dir =~ / /) {$dir = "\"$dir\"";}
    return $dir;
}

sub readTextFile($)
{
    my($file) = @_;
    open(INFILE, $file) || die "cannot open $file";
    read(INFILE, $content, 1000000) || die "cannot read $file";
    return $content;
}

sub error($)
{
    my($text) = @_;
    print STDERR "$progname: error: $text\n";
    exit(1);
}

sub warning($)
{
    my($text) = @_;
    print STDERR "$progname: warning: $text\n";
}

sub usage()
{
    print <<END
$progname: create a Makefile for an OMNeT++/OMNEST model, based on
source files in current directory

$progname [options] [directories, library and object files]...
    -h, --help            This help text
    -f, --force           Force overwriting existing Makefile
    --nmake               Generate Makefile.vc for Visual C++ and nmake.exe
    -e ext, --ext ext     C++ source file extension, usually "cc" or "cpp".
                          By default, this is determined by looking at
                          existing files in the directory.
    -o filename, --outputfile filename
                          Name of simulation executable/library
    -r, --recurse         Call make recursively in all subdirectories. If you
                          need to maintain a specific order, declare dependen-
                          cies in the makefrag.vc file.
    -X directory, -Xdirectory, --except directory
                          With -r (recurse) option: ignore the given directory
    -P directory, --projectdir directory
                          Project base (root) directory; all absolute paths
                          (-I, -L, object file names, etc.) which point into
                          this directory will be converted to relative, to
                          ease compiling the project in a different directory.
                          Defaults to first ancestor directory that contains
                          a ".project" file.
    -M mode, --mode mode  Selects the build mode, "debug" or "release".
                          Defaults to "debug". This setting can still be
                          overridden on the make command line, by specifying
                          "MAKE=debug" or "MAKE=release" as an extra argument.
    -Dname=value, -D name=value, --define name=value
                          Preprocessor symbol to be passed to the C++ compiler.
    -n, --nolink          Produce object files but do not create executable or
                          library. Useful for models with parts in several
                          directories. With this option, -u and -l have
                          no effect.
    -s, --make-so         Build a DLL. Useful if you want to load the
                          model dynamically (via the load-libs= omnetpp.ini or
                          the -l Cmdenv/Tkenv command-line option).
    -t library, --importlib library
                          With -t (build DLL) option: specifies an import
                          library for the DLL.
    -d, --fordll          Compile C++ files for use in DLLs (i.e. with the
                          WIN32_DLL symbol defined). The -s (build DLL) option
                          implies this one.
    -w, --withobjects     Link with all object files found in -I directories,
                          or include them if library is created. Ignored when
                          -n option is present. Dependencies between directo-
                          ries have be handled in high Makefiles (see -r
                          option).
    -x, --notstamp        Do not require a .tstamp file to be present in the
                          link directories and (if -w option is present)
                          -I directories after this option.
    -u name, --userinterface name
                          Selects the user interface libraries to link with.
                          Possible values are "all", "Cmdenv", and "Tkenv".
                          Defaults to "all".
    -Idir                 Additional NED and C++ include directory
    -Ldir                 Add a directory to the library path
    -llibrary             Additional library to link against
                          (e.g. -lmylibrary.lib)
    -p symbol, -psymbol   -P option to be passed to opp_msgc
    -c filename, --configfile filename
                          Included config file (default:"../../configuser.vc")
    -i filename, --includefragment filename
                          Append file to near end of Makefile. The file
                          makefrag.vc (if exists) is appended automatically
                          if no -i options are given. This option is useful
                          if a source file (.ned, .msg or .cc) is to be
                          generated from other files.
    directory             Link with all object files in that directory.
                          Dependencies between directories have to be added
                          manually. See also -w option.
    library or object     Link with that file

Default output is Makefile.vc, which you can invoke by typing
  nmake -f Makefile.vc
With the -n and -s options, -u and -l have no effect. makefrag.vc (and the
-i option) is useful when a source file (.ned, .msg or .cc) is to be generated
from other files, or when you want to add extra dependencies that opp_makemake
could not figure out.
END
}

sub template()
{
    #
    # NOTE: the following template must be kept in sync with the file:
    # <omnetpp>/ui/org.omnetpp.cdt/src/org/omnetpp/cdt/makefile/Makefile.TEMPLATE
    #
    return <<'ENDTEMPLATE'
#
# OMNeT++/OMNEST Makefile for {target}
#
# This file was generated with the command:
#  {progname} {args}
#


# Name of target to be created (-o option)
TARGET = {target}

# User interface (uncomment one) (-u option)
{~allenv?#}USERIF_LIBS = $(TKENV_LIBS) $(CMDENV_LIBS)
{~cmdenv?#}USERIF_LIBS = $(CMDENV_LIBS)
{~tkenv?#}USERIF_LIBS = $(TKENV_LIBS)

# C++ include paths (with -I)
INCLUDE_PATH = {includepath}

# Misc additional object and library files to link with
EXTRA_OBJS = {extraobjs}

# Object files from other directories to link with
EXT_DIR_OBJS = {extdirobjs}

# Timestamps of other directories (used as dependency)
EXT_DIR_TSTAMPS = {extdirtstamps}

# Additional libraries (-L, -l, -t options)
LIBS = {libpath}{libs}{importlibs}

# Output directory
O = {outputdir}

# Object files for local .{cc} and .msg files
OBJS = {objs}

# Message files
MSGFILES = {msgfiles}

# C++ files generated from msg files
MSG_CC_FILES = {msgccfiles}
MSG_H_FILES = {msghfiles}

{subdirs:}# Subdirectories to recurse into
{subdirs:}SUBDIRS = {subdirs}
{subdirs:}{nmake:}SUBDIR_TARGETS = {subdirtargets}
{subdirs:}
{mode:}# Default mode (-M option); can be overridden with {nmake?n}make MODE=debug (or =release)
{mode:}{nmake?!}ifndef MODE
{mode:}MODE = {mode}
{mode:}{nmake?!}endif
{mode:}
#------------------------------------------------------------------------------

# Pull in OMNeT++ configuration (Makefile.inc or configuser.vc)
{nmake:}!if "$(OMNETPP_CONFIGFILE)"!=""
{nmake:}CONFIGFILE = $(OMNETPP_CONFIGFILE)
{nmake:}!elseif "$(OMNETPP_ROOT)"!=""
{nmake:}CONFIGFILE = $(OMNETPP_ROOT)/configuser.vc
{nmake:}!else
{nmake:}CONFIGFILE = {configfile}
{nmake:}!endif
{nmake:}
{nmake:}!if !exist($(CONFIGFILE))
{nmake:}!error '$(CONFIGFILE)' does not exist -- specify "configuser.vc" in the OMNETPP_CONFIGFILE variable (as environment variable or command-line nmake argument), or edit or re-generate this makefile.
{nmake:}!endif
{nmake:}
{nmake:}!include $(CONFIGFILE)
{~nmake:}CONFIGFILE = $(shell opp_configfilepath)
{~nmake:}include $(CONFIGFILE)

{rem:}# Check that MODE is valid (not enabled, to allow implementing other MODEs)
{rem:}{nmake:}!if "$(MODE)"!="debug" && "$(MODE)"!="release"
{rem:}{nmake:}error MODE must be "debug" or "release"
{rem:}{nmake:}!endif
{rem:}{~nmake:}ifneq ($(MODE),"debug")
{rem:}{~nmake:}ifneq ($(MODE),"release")
{rem:}{~nmake:}$(error MODE must be "debug" or "release")
{rem:}{~nmake:}endif
{rem:}{~nmake:}endif

# User interface libs
CMDENV_LIBS = {-u}_cmdenv_lib {-l}envir{.lib} {-l}cmdenv{.lib}
TKENV_LIBS = {-u}_tkenv_lib {-l}envir{.lib} {-l}tkenv{.lib} {-l}layout{.lib} $(TK_LIBS) $(ZLIB_LIBS)

# Simulation kernel
KERNEL_LIBS = {-l}sim_std{.lib}

{nmake:}!if "$(WITH_NETBUILDER)"=="yes"
{~nmake:}ifeq ($(WITH_NETBUILDER),yes)
KERNEL_LIBS {~nmake?+}= {nmake?$(KERNEL_LIBS)} {-l}nedxml{.lib} $(XML_LIBS)
{~nmake:}endif
{nmake:}!endif

KERNEL_LIBS {~nmake?+}= {nmake?$(KERNEL_LIBS)} {-l}common{.lib}

{nmake:}!if "$(WITH_PARSIM)"=="yes"
{~nmake:}ifeq ($(WITH_PARSIM),yes)
KERNEL_LIBS {~nmake?+}= {nmake?$(KERNEL_LIBS)} $(MPI_LIBS)
{~nmake:}endif
{nmake:}!endif

# Simulation kernel and user interface libraries
OMNETPP_LIB_SUBDIR = $(OMNETPP_LIB_DIR)/$(TOOLCHAIN_NAME)-$(MODE)
OMNETPP_LIBS = {-L}"$(OMNETPP_LIB_SUBDIR)" {-L}"$(OMNETPP_LIB_DIR)" $(USERIF_LIBS) $(KERNEL_LIBS) $(SYS_LIBS)

{nmake:}# When using simkernel in DLL form, declare symbols in simkernel headers as "dllimport"
{nmake:}!if "$(LIB_SUFFIX)"==".dll"
{nmake:}CFLAGS=$(CFLAGS) -DWIN32_DLL
{nmake:}!endif

COPTS = $(CFLAGS) {fordllopt} {defines} $(INCLUDE_PATH) -I$(OMNETPP_INCL_DIR)
MSGCOPTS = $(INCLUDE_PATH) {dllexportmacro}

#------------------------------------------------------------------------------
# User-supplied makefile fragment(s)
# >>>
{makefrags:}{makefrags}
# <<<
#------------------------------------------------------------------------------

# Main target
{exe:}$(TARGET): print-info $(OBJS) $(EXTRA_OBJS) $(EXT_DIR_TSTAMPS) {subdirs?subdirs} {makefile}
{exe:}	$({nmake?LINK}{~nmake?CXX}) $(LDFLAGS) $(OBJS) $(EXTRA_OBJS) $(EXT_DIR_OBJS) $(LIBS) $(OMNETPP_LIBS) {link-o}$(TARGET)
{exe:}	@echo{nmake?.} >.tstamp
{so:}$(TARGET): print-info $(OBJS) $(EXTRA_OBJS) $(EXT_DIR_TSTAMPS) {subdirs?subdirs} {makefile}
{so:}	$(SHLIB_LD) -o $(TARGET) $(OBJS) $(EXTRA_OBJS) $(EXT_DIR_OBJS)
{so:}	@echo{nmake?.} >.tstamp
{nolink:}$(TARGET): print-info $(OBJS) {subdirs?subdirs} {makefile} .tstamp
{nolink:}	@{nmake?rem}{~nmake?#} Do nothing
{nolink:}
{nolink:}.tstamp: $(OBJS)
{nolink:}	@echo{nmake?.} >.tstamp

print-info:
{~nmake:}	@if [ -d "$(OMNETPP_LIB_SUBDIR)" ]; then echo "*** Info: MODE=$(MODE), using libs from \"$(OMNETPP_LIB_SUBDIR)\""; fi
{~nmake:}	@if [ ! -d "$(OMNETPP_LIB_SUBDIR)" ]; then echo "*** WARNING: Selected libs not available: directory \"$(OMNETPP_LIB_SUBDIR)\" doesn't exist"; fi
{nmake:}	@if exist "$(OMNETPP_LIB_SUBDIR)" echo *** Info: MODE=$(MODE), using libs from "$(OMNETPP_LIB_SUBDIR)"
{nmake:}	@if not exist "$(OMNETPP_LIB_SUBDIR)" echo *** WARNING: Selected libs not available: directory "$(OMNETPP_LIB_SUBDIR)" doesn't exist

{subdirs:}subdirs: $(SUBDIR_TARGETS)
{subdirs:}
{subdirs:}$(SUBDIR_TARGETS):
{subdirs:}{~nmake:}	cd $@ && {makecommand}
{subdirs:}{nmake:}	cd $(@:{_dir}=) && echo [Entering $(@:{_dir}=)] && {makecommand} && echo [Leaving $(@:{_dir}=)]
{subdirs:}
{msgfiles:}{nmake:}$(MSG_CC_FILES) $(MSG_H_FILES) :: $(MSGFILES)
{msgfiles:}{~nmake:}%_m.{cc} %_m.h: %.msg
{msgfiles:}	$(MSGC{nmake?:/=\}) -s _m.{cc} $(MSGCOPTS) $**
{msgfiles:}
.SUFFIXES: .{cc}

{nmake:}{lbrace}.{rbrace}.cc{lbrace}$O{rbrace}.{obj}:
{~nmake:}$O/%.{obj}: %.{cc}
{~nmake:}	@mkdir -p $O
{nmake:}	- md $(O:/=\) 2>nul
	$(CXX) -c $(COPTS) {nmake?/Fo"$@"}{~nmake?-o $@} {nmake?-Tp} $<

{objs:}$(OBJS): $(MSG_H_FILES)
{objs:}
generateheaders: $(MSG_H_FILES)
{subdirs:}{nmake:}	@if not "$(SUBDIRS)"=="" for %%i in ( $(SUBDIRS) ) do @cd %%i && echo [opp_msgc in %%i] && nmake /nologo /f Makefile.vc generateheaders && cd .. || exit /b 1
{subdirs:}{~nmake:}	for i in $(SUBDIRS); do (cd \$\$i && \$(MAKE) generateheaders) || exit 1; done

clean:
{nmake:}	-del *.obj .tstamp *.idb *.pdb *.ilk *.exp $(TARGET) $(TARGET:.exe=.lib) $(TARGET:.dll=.lib) 2>NUL
{nmake:}	-del *_n.{cc} *_n.h *_m.{cc} *_m.h 2>NUL
{nmake:}	-del *.vec *.sca 2>NUL
{~nmake:}	rm -f *.o *_n.{cc} *_n.h *_m.{cc} *_m.h .tstamp
{~nmake:}	rm -f *.vec *.sca
{subdirs:}{nmake:}	-if not "$(SUBDIRS)"=="" for %%i in ( $(SUBDIRS) ) do cd %%i && echo [clean in %%i] && nmake /nologo /f Makefile.vc clean && cd .. || exit /b 1
{subdirs:}{~nmake:}	for i in $(SUBDIRS); do (cd $$i && $(MAKE) clean); done

depend:
	$(MAKEDEPEND) $(INCLUDE_PATH) -f Makefile.vc -- *.{cc}
{nmake:}	if not "$(SUBDIRS)"=="" for %%i in ( $(SUBDIRS) ) do cd %%i && echo [depend in %%i] && nmake /nologo /f Makefile.vc depend && cd .. || exit /b 1
{~nmake:}	for i in $(SUBDIRS); do (cd $$i && $(MAKE) depend) || exit 1; done

makefiles:
	{progname} {args}
{nmake:}	if not "$(SUBDIRS)"=="" for %%i in ( $(SUBDIRS) ) do cd %%i && echo [makemake in %%i] && nmake /nologo /f Makefile.vc makefiles && cd .. || exit /b 1
{~nmake:}	for i in $(SUBDIRS); do (cd $$i && $(MAKE) makefiles) || exit 1; done

# DO NOT DELETE THIS LINE -- make depend depends on it.
{deps}
ENDTEMPLATE
}


