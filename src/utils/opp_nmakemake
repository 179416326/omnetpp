eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}' && eval 'exec perl -S $0 $argv:q'
  if 0;

#!perl
#line 6
#
# opp_nmakemake
#
#  Creates an MSVC makefile for a given OMNeT++ model.
#  Assumes that .ned, .msg, .cc and .h files are in one directory.
#  The name of the program defaults to the name of the directory ('myproject').
#
#  --VA
#

use Cwd;

#
# process command line args
#

# input parameters
$outfile = cwd;
$outfile  =~ s/[\/\\]$//;
$outfile  =~ s/.*[\/\\]//;

$userif = "TKENV";
$type = "exe";
$includes = "";
$libpath = "";
$libs = "";
$dirs = "";
$xobjs = "";
$sobjs = "";
@fragments = ();
$doxyconf = "doxy.cfg";
@nedfiles = ();
#@msgfiles = ();
$ccext = "cpp";
$cfgfile="../../configuser.vc";

$force="n";
$pvm="n";
$mpi="n";

$args = join(' ',@ARGV);

# process arg vector
while (@ARGV)
{
    $arg = shift @ARGV;
    if ($arg eq '-h' || $arg eq '--help')
    {
        print '
opp_nmakemake: create MSVC makefile for an OMNeT++ model, based on source
files in current directory

opp_nmakemake [-h] [-f] [-e ext] [-o make-target] [-n] [-u user-interface]
              [-p] [-M] [-Idir] [-Ldir] [-llibrary] [-c configdir]
              [-i makefile-fragment-file]
              [directories, library and object files]...
    -h, --help            This help text
    -f, --force           Force overwriting existing Makefile
    -e, --ext             Assumed extension of C++ sources (default is "cpp")
    -o, --outputfile      Name of simulation executable/library
    -n, --nolink          Produce object files but do not create executable or
                          library. Useful for models with parts in several
                          directories. With this option, -u, -p and -l have
                          no effect.
    -u, --userinterface   Use Cmdenv or Tkenv. Defaults to Tkenv
    -M, --mpi             Link executable with MPI
    -p, --pvm             Link executable with PVM
    -Idir                 Additional NED and C++ include directory
    -Ldir                 Add a directory to the library path
    -llibrary             Additional library to link against
                          (e.g. -lmylibrary.lib)
    -c, --configfile      Included config file (default is "../../configuser.vc")
    -i, --includefragment Append file to near end of Makefile. The file
                          makefrag.vc (if exists) is appended automatically
                          if no -i options are given. This option is useful
                          if a source file (.ned, .msg or .cc) is to be
                          generated from other files.
    directory             Recursive make in that dir. Makemake will need to
                          call "make" there to determine the list of object
                          files to be added to the Makefile.
    library or object     Link with that file

Default output is Makefile.vc, which you can invoke by typing
  nmake -f Makefile.vc
If your model is in multiple directories instead of a single directory, run
  opp_nmakemake -n
in the subdirectories, and then
  opp_nmakemake dir1 dir2 ...
in your top-level directory.
';
        exit(1);
    }
    elsif ($arg eq '-f' || $arg eq '--force')
    {
        $force = 'y';
    }
    elsif ($arg eq '-e' || $arg eq '--ext')
    {
        $ccext = shift @ARGV;
    }
    elsif ($arg eq '-o' || $arg eq '--outputfile')
    {
        $outfile = shift @ARGV;
    }
    elsif ($arg eq '-c' || $arg eq '--configfile')
    {
        $cfgfile = shift @ARGV;
    }
    elsif ($arg eq '-n' || $arg eq '--nolink')
    {
        $type = "o";
    }
    # elsif ($arg eq '-s' || $arg eq '--make-so')
    # {
    #    $type = "so";
    # }
    elsif ($arg eq '-u' || $arg eq '--userinterface')
    {
        $userif = shift @ARGV;
        $userif = uc($userif);
        if ($userif ne "CMDENV" && $userif ne "TKENV")
        {
            print STDERR "opp_nmakemake: -u: valid user interface names are Cmdenv or Tkenv";
            exit(1);
        }
    }
    elsif ($arg eq '-M' || $arg eq '--mpi')
    {
        $mpi = "y";
    }
    elsif ($arg eq '-p' || $arg eq '--pvm')
    {
        $pvm = "y";
    }
    elsif ($arg eq '-i' || $arg eq '--includefragment')
    {
        push(@fragments, shift @ARGV);
    }
    elsif ($arg =~ /^-I/)
    {
        $includes .= " ".$arg;
    }
    elsif ($arg =~ /^-L/)
    {
        $arg =~ s/^-L//;
        $libpath .= " /libpath:\"$arg\"";
    }
    elsif ($arg =~ /^-l/)
    {
        $arg =~ s/^-l//;
        $libs .= " $arg";
    }
    else
    {
        if (-d $arg)
        {
            push(@dirs, $arg);
        }
        elsif (-f $arg)
        {
            push(@xobjs, $arg);
        }
        else
        {
            print STDERR "opp_nmakemake: $arg is neither an existing file/dir nor a valid option";
            exit(1);
        }
    }
}

$makefile = "Makefile.vc";

if (-f $makefile && $force ne "y")
{
    print STDERR "opp_nmakemake: use -f to force overwriting existing $makefile\n";
    exit(1);
}

if (! -f $cfgfile) {
    print STDERR "opp_nmakemake: warning: config file $cfgfile not found -- try -c option\n";
}

@sobj_list = ();

$makecommand = 'nmake /nologo /f Makefile.vc';

$curdir = cwd;
foreach $i (@dirs)
{
    print "*** Running make in $i to see object and ned file names\n";
    if (chdir($i) && system($makecommand)==0)
    {
        chdir($curdir);
        if (cwd ne $curdir) {
            print STDERR "opp_nmakemake: cannot cd back from $i to $curdir, exiting\n";
            exit(1);
        }

        @o = glob("$i/*.obj");
        if (@o == ())
        {
            print STDERR "opp_nmakemake: warning: no object files in $i\n";
        }
        else
        {
            push(@sobj_list, @o);
        }

        # collect ned files of subdirectory for target neddoc.html.
        @nedf = glob("$i/*.ned");
        push(@nedfiles, @nedf);

        ## collect ned files of subdirectory for target neddoc.html.
        #@msgf = glob("$i/*.msg");
        #push(@msgfiles, @msgf);
    }
    else
    {
        print STDERR "opp_nmakemake: make in $i failed, exiting\n";
        exit(1);
    }
}

@objs = glob("*.ned *.msg *.$ccext");
foreach $i (@objs)
{

    $i =~ s/\*[^ ]*//g;
    $i =~ s/[^ ]*_n\.$ccext//g;
    $i =~ s/[^ ]*_m\.$ccext//g;
    $i =~ s/\.ned/_n.obj/g;
    $i =~ s/\.msg/_m.obj/g;
    $i =~ s/\.$ccext/.obj/g;
}

#
# now the Makefile creation
#
open(OUT, ">$makefile");

print OUT "#
#  Makefile for $outfile
#
#  ** This file was automatically generated by the command:
#  opp_nmakemake $args
#
#  By the Perl version of opp_makemake for MSVC
#
";

$suffix = '.exe';
if ($type eq "so")
{
    $suffix = '.dll';
}
if ($type eq "o")
{
    $suffix = '';
}

if ($userif eq 'CMDENV')
{
    $c_cmd = '';
    $c_tk = '# ';
}
elsif ($userif eq 'TKENV')
{
    $c_cmd = '# ';
    $c_tk = '';
}


$c_std = '';
$c_pvm = '# ';
$c_mpi = '# ';

if ($pvm eq "y")
{
    $c_std = '# ';
    $c_pvm = '';
    $c_mpi = '#';
}

if ($mpi eq "y")
{
    $c_std = '# ';
    $c_pvm = '#';
    $c_mpi = '';
}


$sobjs = join( " \\\n            ", @sobj_list);


print OUT "

# Name of target to be created (-o option)
TARGET = $outfile$suffix

# User interface (uncomment one) (-u option)
${c_cmd}USERIF_LIBS=\$(CMDENV_LIBS)
${c_tk}USERIF_LIBS=\$(TKENV_LIBS)

# uncomment 1 of the 3 lines to support either serial or parallel operation
${c_std}KERNEL_LIBS=\$(STD_KERNEL_LIBS)
${c_pvm}KERNEL_LIBS=\$(PVM_KERNEL_LIBS)
${c_mpi}KERNEL_LIBS=\$(MPI_KERNEL_LIBS)

# .ned or .h include paths with -I
INCLUDE_PATH=$includes

# misc additional object and library files to link
EXRA_OBJS=$xobjs

# object files in subdirectories
SUBDIR_OBJS=$sobjs

# Additional libraries (-L option -l option)
LIBS=$libpath$libs

#------------------------------------------------------------------------------
";

# Makefile
print OUT "

!include \"$cfgfile\"

# User interface libs
CMDENV_LIBS=envir.lib cmdenv.lib
TKENV_LIBS=envir.lib tkenv.lib \$(TK_LIBS)

# Simulation kernel
STD_KERNEL_LIBS=sim_std.lib
MPI_KERNEL_LIBS=sim_mpi.lib \$(MPI_LIBS)
PVM_KERNEL_LIBS=sim_pvm.lib \$(PVM_LIBS)

# Simulation kernel and user interface libraries
OMNETPP_LIBS=/libpath:\$(OMNETPP_LIB_DIR) \$(USERIF_LIBS) \$(KERNEL_LIBS) \$(SYS_LIBS)

COPTS=\$(CFLAGS) \$(INCLUDE_PATH) -I\$(OMNETPP_INCL_DIR)
NEDCOPTS=\$(CFLAGS) \$(NEDCFLAGS) \$(INCLUDE_PATH) -I\$(OMNETPP_INCL_DIR)

#------------------------------------------------------------------------------
";

if ($dirs ne "" )
{
    $subdirsphony = "subdirs-phony";
}
else
{
    $subdirsphony = "";
}

# rules for $(TARGET)
$objs = join(" ", @objs);
print OUT "# Object files from this directory to link\n";
print OUT "OBJS= $objs\n";
print OUT "\n";

# include external Makefile fragments at top, so that they can
# override the default target if they want
if (@fragments != ())
{
    foreach $frag (@fragments)
    {
        print OUT "# inserted from file '$frag':\n";
        open(FRAG,$frag);
        while(<FRAG>)  {print OUT;}
        close FRAG;
        print OUT "\n";
    }
}
else
{
    if (-f "makefrag.vc")
    {
        print OUT "# inserted from file 'makefrag.vc':\n";
        open(FRAG,"makefrag.vc");
        while(<FRAG>)  {print OUT;}
        close FRAG;
        print OUT "\n";
    }
}

if ($type eq 'exe')
{
    print OUT "\$(TARGET): \$(OBJS) \$(EXRA_OBJS) $makefile $subdirsphony\n";
    print OUT "\t\$(LINK) \$(LDFLAGS) \$(OBJS) \$(EXRA_OBJS) \$(SUBDIR_OBJS) \$(LIBS) \$(OMNETPP_LIBS) /out:\$(TARGET)\n";
}
elsif ($type eq 'so')
{
    print OUT "\$(TARGET): \$(OBJS) \$(EXRA_OBJS) $subdirsphony $makefile\n";
    print OUT "\t\$(SHLIB_LD) -o \$(TARGET) \$(OBJS) \$(EXRA_OBJS) \$(SUBDIR_OBJS)\n";
}
elsif ($type eq 'o')
{
    print OUT "\$(TARGET): \$(OBJS) $makefile\n";
}
print OUT "\n";

# rule for Purify
print OUT "# purify: \$(OBJS) \$(EXRA_OBJS) $subdirsphony $makefile\n";
print OUT "# \tpurify \$(CXX) \$(LDFLAGS) \$(OBJS) \$(EXRA_OBJS) \$(SUBDIR_OBJS) \$(LIBS) -L\$(OMNETPP_LIB_DIR) \$(KERNEL_LIBS) \$(USERIF_LIBS) \$(SYS_LIBS_PURE) -o \$(TARGET).pure\n";
print OUT "\n";

if ($type ne "o")
{
    if ($dirs ne "")
    {
        print OUT 'subdirs-phony:';
        foreach $i (@dirs)
        {
           print OUT "\t(cd $i && make)\n";
        }
        print OUT "\n";
    }
}

# rules for NED files
foreach $i (glob("*.ned"))
{
    # extend list for target neddoc.html
    push(@nedfiles, $i);

    $obj = $i;
    $obj =~ s/\.ned/_n.obj/g;
    $c = $i;
    $c =~ s/\.ned/_n.$ccext/g;

    print OUT "$obj: $c\n";
    print OUT "\t\$(CXX) -c \$(NEDCOPTS) /Tp $c\n";
    print OUT "\n";

    print OUT "$c: $i\n";
    print OUT "\t\$(NEDC:/=\\) -s _n.$ccext \$(INCLUDE_PATH) $i\n";
    print OUT "\n";
}

# rules for MSG files
foreach $i (glob("*.msg"))
{
    ## extend list for target neddoc.html
    #push(@msgfiles, $i);

    $obj = $i;
    $obj =~ s/\.msg/_m.obj/g;
    $c = $i;
    $c =~ s/\.msg/_m.$ccext/g;

    print OUT "$obj: $c\n";
    print OUT "\t\$(CXX) -c \$(NEDCOPTS) /Tp $c\n";
    print OUT "\n";

    print OUT "$c: $i\n";
    print OUT "\t\$(MSGC:/=\\) -s _m.$ccext \$(INCLUDE_PATH) $i\n";
    print OUT "\n";
}

# rules for normal (not generated) C++ files
foreach $i (glob("*.$ccext"))
{
    if ($i =~ /_n\.$ccext/ || $i =~ /_m\.$ccext/)
    {
        next;
    }

    $obj = $i;
    $obj =~ s/\.$ccext/.obj/g;
    print OUT "$obj: $i\n";
    print OUT "\t\$(CXX) -c \$(COPTS) /Tp $i\n";
    print OUT "\n";
}

# documentation targets
print OUT "
doc: neddoc.html htmldocs

neddoc.html: $nedfiles
\t\@opp_neddoc $nedfiles > neddoc.html
\t\@echo File neddoc.html generated.

htmldocs:
\t\@doxygen -g- | sed \"s/^PROJECT_NAME.*/PROJECT_NAME = $outfile/;\\
\ts|^INPUT *=.*|INPUT = . $dirs|;\\
\ts/^EXTRACT_ALL *=.*/EXTRACT_ALL = yes/;\\
\ts/^EXTRACT_PRIVATE *=.*/EXTRACT_PRIVATE = yes/;\\
\ts/^EXCLUDE_PATTERNS *=.*/EXCLUDE_PATTERNS = *_n.$ccext *_n.h/;\\
\ts/^ALPHABETICAL_INDEX *=.*/ALPHABETICAL_INDEX = yes/;\\
\ts/^HTML_OUTPUT *=.*/HTML_OUTPUT = htmldoc/;\\
\ts/^GENERATE_LATEX *=.*/GENERATE_LATEX = no/;\\
\ts/^GENERATE_TREEVIEW *=.*/GENERATE_TREEVIEW = yes/;\\
\ts/^HIDE_UNDOC_RELATIONS *=.*/HIDE_UNDOC_RELATIONS = no/;\\
\ts|^TAGFILES *=.*|TAGFILES = \$(OMNETPP_ROOT)/doc/api/opptags.xml=\$(OMNETPP_ROOT)/doc/api|;\\
\ts|^GENERATE_TAGFILE *=.*|GENERATE_TAGFILE = htmldoc/tags.xml|;\\
\ts/^QUIET *=.*/QUIET = yes/\" > $doxyconf
\t\@doxygen $doxyconf
\t\@echo Code documentation generated. Now, point your web browser to ./htmldoc/index.html.
";

# rule for 'clean'
print OUT "
clean:
\t-del *.obj *_n.$ccext *_n.h *_m.$ccext *_m.h \$(TARGET)\$(EXE_SUFFIX) 2>NUL
\t-del *.vec *.sca 2>NUL
\t-del /S neddoc.html htmldoc 2>NUL
";

# makedepend, re-makemake
@args1 = @ARGV;
foreach $i (@args1)
{
    $i =~ s/ / /g;
    $i =~ s/ -f / /g;
    $i =~ s/ -m / /g;
}
$args1 = join(" ",@args1);

print OUT "
depend:
\t\$(MAKEDEPEND) \$(INCLUDE_PATH) -f $makefile -- *.$ccext

re-makemake:
\topp_nmakemake_vc -f $args1  #recreate Makefile

# DO NOT DELETE THIS LINE -- make depend depends on it.

";

close OUT;

print "$makefile created.\n";
print "Please type `nmake -f $makefile depend' NOW to add dependencies!\n";



