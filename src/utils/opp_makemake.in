#!/bin/sh
# opp_makemake (formerly jar_mkmk)
#
#  Creates a makefile for a given OMNeT++ model.
#  Assumes that .ned, .msg, .cc and .h files are in one directory.
#  The name of the program defaults to the name of the directory ('myproject').
#
#  Original script written by Jan Heijmans et al.
#
#  --VA
#

#
# process command line args
#
args="$*"

MAKEDEPEND="@MAKEDEPEND@"

userif=TKENV
outfile=`pwd | sed "s/\/$//;s/.*\///"`
recursive=n
type="exe"
includes=""
libpath=""
libs=""
linkdirs=""
xobjs=""
fragments=""
makefilein=n
doxyconf="doxy.cfg"
cfgfile=""
linkwithobjects=n

while [ ! $# = 0 ] ; do
    case "$1" in

        -h | --help)
        cat <<EOT
opp_makemake: generate OMNeT++ Makefile based on contents of current directory

opp_makemake [-h] [-f] [-m] [-o make-target] [-r] [-n] [-s] [-u userinterface]
        [-c configfile] [-p] [-Idir] [-Llibrary-path] [-llibrary]
        [-i makefile-fragment-file] [directories, library and object files]...
    -h, --help            This help text
    -f, --force           Force overwriting existing Makefile
    -m, --makefile-in     Create Makefile.in instead of Makefile
    -c, --configfile      Omit variable definitions from generated Makefile,
                          and let the Makefile include the given config file
                          instead.
    -o, --outputfile      Name of simulation executable/library
    -r, --recurse         Call make recursively in all subdirectories. If you
                          need to maintain a specific order, declare dependen-
                          cies in the makefrag file.
    -n, --nolink          Produce object files but do not create executable or
                          library. Useful for models with parts in several dirs.
    -s, --make-so         Make shared library. Useful if you want to load the
                          model dynamically (Cmdenv/Tkenv -l so-file switch).
    -w, --withobjects     Link with all object files found in -I directories,
                          or include them if library is created. Ignored when
                          -n option is present. Dependencies between directo-
                          ries have be handled in high Makefiles (see -r
                          option).
    -u, --userinterface   Use Cmdenv or Tkenv. Defaults to Tkenv.
    -Idir                 Additional NED and C++ include directory
    -Llibrary-path        Additional library path
    -llibrary             Additional library to link against
    -i, --includefragment Append file to near end of Makefile. The file makefrag
                          is appended implicitly if no -i options are given.
    directory             Link with object files in that directory. Dependencies
                          between directories have to be added manually. See also
                          -w option.
    library or object     Link with that file

With the -n and -s options, -u, -p and -l have no effect. makefrag (and the
-i option) is useful when a source file (.ned, .msg or .cc) is to be generated
from other files, or when you want to add extra dependencies that opp_makemake
could not figure out.
EOT
        exit
        ;;

        -f | --force)
        force=y
        ;;

        -c | --configfile)
        shift
        cfgfile=$1
        ;;

        -o | --outputfile)
        shift
        outfile=$1
        ;;

        -r | --recurse)
        recursive=y
        ;;

        -n | --nolink)
        type="o"
        ;;

        -s | --make-so)
        type="so"
        ;;

        -w | --withobjects)
        linkwithobjects=y
        ;;

        -m | --makefile-in)
        makefilein=y
        ;;

        -u | --userinterface)
        shift
        userif=`echo $1 | tr [a-z] [A-Z]`
        case "$userif" in
            CMDENV | TKENV)
            ;;
            *)
            echo "opp_makemake: -u: valid user interface names are Cmdenv or Tkenv" 1>&2
            exit
            ;;
        esac
        ;;

        -M | --mpi)
        mpi=y
        ;;

        -p | --pvm)
        pvm=y
        ;;

        -i | --includefragment)
        shift
        fragments="$fragments $1"
        ;;

        -I*)
        includes="$includes $1"
        ;;

        -L*)
        libpath="$libpath $1"
        ;;

        -l*)
        libs="$libs $1"
        ;;

        *)
        if [ -d $1 ]; then
            linkdirs="$linkdirs $1"
        else
            if [ ! -f $1 ]; then
                echo "opp_makemake: $1 is neither an existing file/dir nor a valid option" 1>&2
                exit
            fi
            xobjs="$xobjs $1"
        fi
        ;;

    esac
    shift
done

if [ $makefilein = "y" ]; then
    outputfile="Makefile.in"
else
    outputfile="Makefile"
fi

if [ -f $outputfile ]; then
    if [ ! "$force" = "y" ]; then
        echo "opp_makemake: use -f to force overwriting existing $outputfile" 1>&2
        exit
    fi
fi

subdirs=
for i in *; do
    if [ -d $i -a $i != "CVS" -a $i != "backups" -a $i != "." -a $i != ".." ]; then
        subdirs="$subdirs $i"
    fi
done

extdirobjs=
if [ "$linkwithobjects" = "y" ]; then
    for i in $includes; do
        dir=`echo $i | sed 's/^-I//'`
        extdirobjs="$extdirobjs $dir/*.o"
    done
fi

for i in $linkdirs; do
    extdirobjs="$extdirobjs $i/*.o"
done

objs=`echo *.ned *.msg *.cc | sed 's/\*[^ ]*//g; s/[^ ]*_n\.cc//g; s/[^ ]*_m\.cc//g; s/\.ned/_n.o/g; s/\.msg/_m.o/g; s/\.cc/.o/g'`

#
# now the Makefile creation
#
(

cat <<EOT
#
#  Makefile for $outfile
#
#  ** This file was automatically generated by the command:
#  opp_makemake $args
#
EOT

suffix=''
if [ "$type" = "so" ]; then
    suffix='.so'
fi
if [ "$type" = "o" ]; then
    suffix=''
fi

case "$userif" in
    CMDENV)
    c_cmd=''; c_tk='# '; ;;
    TKENV)
    c_cmd='# '; c_tk=''; ;;
esac

c_std=''; c_pvm='# '; c_mpi='# ';

if [ "$pvm" = "y" ]; then
    c_std='# '; c_pvm=''; c_mpi='#';
fi

if [ "$mpi" = "y" ]; then
    c_std='# '; c_pvm='#'; c_mpi='';
fi

cat <<EOT

# Name of target to be created (-o option)
TARGET = $outfile$suffix

# User interface (uncomment one) (-u option)
${c_cmd}USERIF_LIBS=\$(CMDENV_LIBS)
${c_tk}USERIF_LIBS=\$(TKENV_LIBS)

# .ned or .h include paths with -I
INCLUDE_PATH=$includes

# misc additional object and library files to link
EXTRA_OBJS=$xobjs

# object files from other directories to link with
EXT_DIR_OBJS=$extdirobjs

# Additional libraries (-L option -l option)
LIBS=$libpath$libs

#------------------------------------------------------------------------------
EOT

if [ "$cfgfile" != "" ]; then

  echo "# Import generic settings from $cfgfile"
  echo "include $cfgfile"
  echo

elif [ $makefilein = "n" ]; then
# Makefile
cat <<EOT

# Generic definitions. To avoid redundancies across Makefiles, you can
# import them from a common file -- see opp_makemake -c flag.
NEDC=@NEDC@
MSGC=@MSGC@
CXX=@CXX@
CC=@CC@
AR=@AR@
SHLIB_LD=@SHLIB_LD@
MAKEDEPEND=@MAKEDEPEND@

CFLAGS=@CFLAGS@
NEDCFLAGS=@NEDCFLAGS@
LDFLAGS=@LDFLAGS@
EXE_SUFFIX=@EXE_SUFFIX@

WITH_PARSIM=@WITH_PARSIM@
WITH_NETBUILDER=@WITH_NETBUILDER@

OMNETPP_INCL_DIR=@OMNETPP_INCL_DIR@
OMNETPP_LIB_DIR=@OMNETPP_LIB_DIR@

TK_LIBS=@TK_LIBS@
MPI_LIBS=@MPI_LIBS@
XML_LIBS=@XML_LIBS@
SYS_LIBS=@SYS_LIBS@
SYS_LIBS_PURE=-ldl -lsocket -lnsl -lm \$(shell \$(CXX) -print-file-name=libstdc++.a)
EOT

else

# Makefile.in
null=
cat <<EOT

NEDC=@${null}NEDC@
MSGC=@${null}MSGC@
CXX=@${null}CXX@
CC=@${null}CC@
AR=@${null}AR@
SHLIB_LD=@${null}SHLIB_LD@
MAKEDEPEND=@${null}MAKEDEPEND@

CFLAGS=@${null}CFLAGS@
NEDCFLAGS=@${null}NEDCFLAGS@
LDFLAGS=@${null}LDFLAGS@
EXE_SUFFIX=@${null}EXE_SUFFIX@

WITH_PARSIM=@${null}WITH_PARSIM@
WITH_NETBUILDER=@${null}WITH_NETBUILDER@

OMNETPP_INCL_DIR=@${null}OMNETPP_INCL_DIR@
OMNETPP_LIB_DIR=@${null}OMNETPP_LIB_DIR@

TK_LIBS=@${null}TK_LIBS@
MPI_LIBS=@${null}MPI_LIBS@
XML_LIBS=@${null}XML_LIBS@
SYS_LIBS=@${null}SYS_LIBS@
SYS_LIBS_PURE=-lm \$(shell \$(CXX) -print-file-name=libstdc++.a)
EOT

fi

if [ "$cfgfile" = "" ]; then
cat <<EOT

# User interface libs
CMDENV_LIBS=-lenvir -lcmdenv
TKENV_LIBS=-lenvir -ltkenv \$(TK_LIBS)

# Simulation kernel
KERNEL_LIBS=-lsim_std

ifeq (\$(WITH_NETBUILDER),yes)
KERNEL_LIBS += -lnedxml \$(XML_LIBS)
endif

ifeq (\$(WITH_PARSIM),yes)
KERNEL_LIBS += \$(MPI_LIBS)
endif

# Simulation kernel and user interface libraries
OMNETPP_LIBS=-L\$(OMNETPP_LIB_DIR) \$(USERIF_LIBS) \$(KERNEL_LIBS) \$(SYS_LIBS)

COPTS=\$(CFLAGS) \$(INCLUDE_PATH) -I\$(OMNETPP_INCL_DIR)
NEDCOPTS=\$(CFLAGS) \$(NEDCFLAGS) \$(INCLUDE_PATH) -I\$(OMNETPP_INCL_DIR)

EOT
fi

echo "#------------------------------------------------------------------------------"
echo

echo '# subdirectories to recurse into'
echo "SUBDIRS= $subdirs"
echo
echo '# object files in this directory'
echo "OBJS= $objs"
echo

# include external Makefile fragments here, so that they can override
# the default target if they want
if [ ! "$fragments" = "" ]; then
    echo "#------------------------------------------------------------------------------"
    echo "# contents of file(s) $fragments:"
    cat $fragments
    echo
else
    if [ -f makefrag ]; then
        echo "#------------------------------------------------------------------------------"
        echo "# contents of file makefrag:"
        cat makefrag
        echo
    fi
fi

echo "#------------------------------------------------------------------------------"
echo

# note: if "subdirs" were always among the target dependencies, it would cause
# the executable to re-link every time (which is not good).
if [ $recursive = "y" ]; then
    subdirs_target='subdirs'
else
    subdirs_target=
fi

case "$type" in
exe)
    echo '$(TARGET): $(OBJS) $(EXTRA_OBJS)' $subdirs_target 'Makefile'
    echo '	$(CXX) $(LDFLAGS) $(OBJS) $(EXTRA_OBJS) $(EXT_DIR_OBJS) $(LIBS) $(OMNETPP_LIBS) -o $(TARGET)'
    ;;
so)
    echo '$(TARGET): $(OBJS) $(EXTRA_OBJS)' $subdirs_target 'Makefile'
    echo '	$(SHLIB_LD) -o $(TARGET) $(OBJS) $(EXTRA_OBJS) $(EXT_DIR_OBJS)'
    ;;
o)
    echo '$(TARGET): $(OBJS)' $subdirs_target 'Makefile'
    echo '	'
    ;;
esac
echo
echo 'purify: $(OBJS) $(EXTRA_OBJS)' $subdirs_target 'Makefile'
echo '	purify $(CXX) $(LDFLAGS) $(OBJS) $(EXTRA_OBJS) $(EXT_DIR_OBJS) $(LIBS) -L$(OMNETPP_LIB_DIR) $(KERNEL_LIBS) $(USERIF_LIBS) $(SYS_LIBS_PURE) -o $(TARGET).pure'
echo


# rules for recursive build
echo ".PHONY: subdirs \$(SUBDIRS)"
echo
echo 'subdirs: $(SUBDIRS)'
echo
for i in $subdirs; do
     echo "$i:"
     echo '	cd' $i '&& $(MAKE)'
     echo
done

# rules for ned files
for i in *.ned; do
        if [ "$i" = "*.ned" ]; then break; fi;

        obj=`echo $i | sed 's/\.ned/_n.o/g'`
        c=`echo $i | sed 's/\.ned/_n.cc/g'`

        echo "$obj: $c"
        echo '	$(CXX) -c $(NEDCOPTS) '$c
        echo

        echo "$c: $i"
        echo '	$(NEDC) $(INCLUDE_PATH) '$i
        echo
done

# rules for msg files
for i in *.msg; do
        if [ "$i" = "*.msg" ]; then break; fi;

        obj=`echo $i | sed 's/\.msg/_m.o/g'`
        c=`echo $i | sed 's/\.msg/_m.cc/g'`
        h=`echo $i | sed 's/\.msg/_m.h/g'`

        echo "$obj: $c"
        echo '	$(CXX) -c $(NEDCOPTS) '$c
        echo

        echo "$c $h: $i"
        echo '	$(MSGC) $(INCLUDE_PATH) '$i
        echo
done

# rules for normal (not generated) C++ files
for i in `echo *.cc | sed 's/[^ ]*_n\.cc//g; s/[^ ]*_m\.cc//g'`
do
        if [ "$i" = "*.cc" ]; then break; fi;

        obj=`echo $i | sed 's/\.cc/.o/g'`
        echo "$obj: $i"
        echo '	$(CXX) -c $(COPTS) '$i
        echo
done

args1=`echo " $args " | sed 's/	/ /g;s/ -f / /g;s/ -m / /g'`

# documentation targets
cat <<EOT

#doc: neddoc doxy

#neddoc:
#	opp_neddoc -a

#doxy: $doxyconf
#	doxygen $doxyconf

clean:
	rm -f *.o *_n.cc *_n.h *_m.cc *_m.h \$(TARGET)\$(EXE_SUFFIX)
	rm -f *.vec *.sca
	for i in \$(SUBDIRS); do (cd \$\$i && \$(MAKE) clean); done

depend:
	\$(MAKEDEPEND) \$(INCLUDE_PATH) -- *.cc
	# \$(MAKEDEPEND) \$(INCLUDE_PATH) -fMakefile.in -- *.cc

re-makemake:
	opp_makemake -f $args1  #recreate Makefile

re-makemake-m:
	opp_makemake -f -m $args1  #recreate Makefile.in


# DO NOT DELETE THIS LINE -- make depend depends on it.

EOT

) > $outputfile

echo "$outputfile created, adding dependencies..."

if ! $MAKEDEPEND $includes -f$outputfile -- *.cc; then
    echo "Error: command '$MAKEDEPEND $includes -f$outputfile -- *.cc' returned nonzero exit code"
else
    echo "Done."
fi

