//=========================================================================
//  FILETOKENIZER.H - part of
//                  OMNeT++/OMNEST
//           Discrete System Simulation in C++
//
//=========================================================================

/*--------------------------------------------------------------*
  Copyright (C) 1992-2005 Andras Varga

  This file is distributed WITHOUT ANY WARRANTY. See the file
  `license' for details on this and other legal matters.
*--------------------------------------------------------------*/

#ifndef __FILETOKENIZER_H_
#define __FILETOKENIZER_H_

#include <vector>
#include <string>

/**
 * Tokenizes a file, line by line. Supposed to be VERY efficient because
 * it'll be used on several hundred-megabyte files: the code avoids
 * string copies, avoids scanning the string more than once, etc.
 */
class FileTokenizer
{
  public:
    enum StatusCode {OK, EOFREACHED, CANNOTOPEN, CANNOTREAD, INCOMPLETELINE,
                     UNMATCHEDQUOTE, LINETOOLONG, TOOMANYTOKENS};

  private:
    // the file
    std::string fname;
    FILE *f;
    bool eofreached;

    // the buffer
    size_t buffersize;
    char *buffer;
    char *bufferend;  // =buffer+buffersize

    // the currently used region in buffer
    char *databeg;
    char *dataend;

    // the pointer returned by readLine(); becomes NULL after tokenization
    char *wholeline;
    char *wholelineend;

    // storage of tokens
    char **vec;
    int vecsize;
    int numtokens;

    // num of line last returned
    int linenum;

    // status
    StatusCode errcode;

  private:
    // moves remaining data (databeg,dataend) to beginning of buffer,
    // reads new bytes to the buffer, and returns offset by which
    // existing data were moved.
    size_t readMore();

    // nulls out wholeline/wholelineend, and returns null
    char *zapline();

  public:
    /**
     * Creates a tokenizer object for the given file, with the given
     * buffer size. The file doesn't get opened yet.
     */
    FileTokenizer(const char *fileName, size_t bufferSize=64*1024);

    /**
     * Destructor.
     */
    ~FileTokenizer();

    /**
     * Tokenizes a line, results can be accessed via numTokens() and
     * tokens(). Return is true if there's no error; it's false if
     * file could not be opened/read, last line was incomplete line
     * (missing CRLF), line was too long (>bufferSize) or there
     * were too many items on the line (currently >16,000), or
     * there was an unmatched quote. See StatusCode values.
     */
    bool readAndTokenizeLine();

    /**
     * Reads a line from the file, and returns it untokenized.
     * It returns NULL after EOF and on error (file could not be opened/read,
     * last line was incomplete (missing CRLF), line was too long
     * (>bufferSize)); see StatusCode values.
     */
    const char *readLine();

    /**
     * Tokenizes the line returned by the last readLine() call.
     * It tokenizes at most maxtokens tokens, plus the rest of the
     * line is also returned as an additional "token".
     */
    void tokenizeLine(int maxtokens);

    /**
     * Number of tokens read by the last readAndTokenizeLine() call.
     */
    int numTokens() {return numtokens;}

    /**
     * Array that holds the tokens read by the last readAndTokenizeLine() call;
     * contents will be overwritten with the next call.
     */
    char **tokens() {return vec;}

    /**
     * True if more readAndTokenizeLine() calls are permitted.
     */
    bool ok() const {return errcode==OK;}

    /**
     * True if end of input file was reached without any error.
     */
    bool eof() const {return errcode==EOFREACHED;}

    /**
     * Number of last line parsed by readAndTokenizeLine().
     */
    int lineNum() const {return linenum;}

    /**
     * Detailed error code; this completes ok() and eof().
     */
    StatusCode errorCode() const {return errcode;}

    /**
     * Produces a textual error message, based on the error code
     * and the line number.
     */
    std::string errorMsg() const;
};

#endif

