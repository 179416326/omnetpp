//==========================================================================
//   CPPEXPRGENERATOR.H -
//            part of OMNeT++
//
//==========================================================================

/*--------------------------------------------------------------*
  Copyright (C) 1992-2002 Andras Varga
  Technical University of Budapest, Dept. of Telecommunications,
  Stoczek u.2, H-1111 Budapest, Hungary.

  This file is distributed WITHOUT ANY WARRANTY. See the file
  `terms' for details on this and other legal matters.
*--------------------------------------------------------------*/

#ifndef __CPPEXPRGENERATOR_H
#define __CPPEXPRGENERATOR_H

#include "iostream.h"
#include "nedelements.h"
#include <string>
#include <map>
#include <vector>


/**
 * Helper class for NEDCppGenerator.
 *
 * @ingroup CppGenerator
 */
class CppExpressionGenerator
{
  protected:
    typedef std::vector<NEDElement *> NEDElementVector;
    struct ExpressionInfo {
        ExpressionNode *expr;
        int ctxtype; // tagcode of toplevel element which contains this expr.
        std::string name;
        NEDElementVector args;
    };
    typedef std::map<ExpressionNode *,ExpressionInfo> NEDExpressionMap;

    static int count;
    NEDExpressionMap exprMap;

    enum {
      MODE_INLINE_EXPRESSION,
      MODE_EXPRESSION_CLASS,
    };

    void doExtractArgs(ExpressionInfo& info, NEDElement *node);
    void doCollectExpressions(NEDElement *node);
    void collectExpressionInfo(ExpressionNode *expr);
    void generateExpressionClass(ostream& out, ExpressionInfo& info);
    const char *getTypeForArg(NEDElement *node);
    const char *getNameForArg(NEDElement *node);
    void doValueForArg(ostream& out, NEDElement *node);

    void generateChildren(ostream& out, NEDElement *node, const char *indent, int mode);
    void generateItem(ostream& out, NEDElement *node, const char *indent, int mode);
    void doOperator(ostream& out, OperatorNode *node, const char *indent, int mode);
    void doFunction(ostream& out, FunctionNode *node, const char *indent, int mode);
    void doParamref(ostream& out, ParamRefNode *node, const char *indent, int mode);
    void doIdent(ostream& out, IdentNode *node, const char *indent, int mode);
    void doConst(ostream& out, ConstNode *node, const char *indent, int mode);
    void doExpression(ostream& out, ExpressionNode *node, const char *indent, int mode);

    bool needsExpressionClass(ExpressionNode *expr);

  public:
    /**
     * Recursively finds all <expression> tags within the passed node, and
     * stores references to them.
     */
    void collectExpressions(NEDElement *node);

    /**
     * Generate compiled expression classes (those derived from cExpression)
     * from all stored expressions. The evaluate() methods of the generated
     * classes will hold the expressions.
     */
    void generateExpressionClasses(ostream& out);

    /**
     * Generate a cPar initializatiom code that uses the compiled expression
     * classes generated by generateExpressionClasses().
     */
    void generateExpressionUsage(ostream& out,ExpressionNode *expr, const char *indent);
};

#endif


