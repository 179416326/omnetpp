- olyan toolt nem lehet felvenni ami source file-t general. (ld msg compiler)
  ha a tool megvaltoztatja az output directoryt (ImanagedOutpuFileNameProvider) 
  es a source filemelle teszi a kimenetet nem medig a target/config dirbe, 
  akkor a compiler utana mar iszont nem a target/config
  be teszi az object file-t hanem szinten a source melle...
- ha include ban pl: ${workspace_loc:/inetfw/Src/Nodes} van megadva es a konyvtar nem letezik akkor egy ures -I opciot general
  ami hibat okoz mert a compiler lenyeli a kovetkezo opciot. (ne genraljon ilyenkor -I-t)
? nem lehet egy meglevo toolhoz/project tipushoz hozzaadni mondjuk egy macroSupplier osztalyt
  az egyetlen megioldas ha a teljes toolchain-t lemasolom es ujrairom.
- ha uj project tiust veszek fel (ami orokol egy regibol), 
  akkor ha abban definialok egy uj config-t (az oroklottek melle) es a new project wizardban 
  ilyen konfigot valasztok, akkor jol jon letre a project az uj tipussal, ha azonben
  olyan configot valasztok amit orokolt, akkor a project tipus nema kivalasztott lesz
  hanem a base project type (meg akkor is, ha tenyleg az uj project tipus volt kivalasztva)
- pre and postbuild steps run *only* if cc files are not up to date. needs a checkbox
  to run the buildsteps even if the cc files up to date
- CWizardHandler.canFinich !!!


patform:
- the ${} parser should match the correct ending }. 
  constructs like ${var1:${var2}} are not working




=====================================================================
Lack of Javadoc comments in CDT sources

Many (most?) CDT sources (not only *.internal.* ones) lack proper Javadoc class and
method comments. I am currently looking at ManagedBuildManager which has about a zillion 
static methods, about half of which are completely undocumented. This makes it VERY hard 
to figure out things. A random sample of other classes that almost completely lack 
documentation: CfgInfoContext, IBuildProperties, IBuildProperty, IBuildPropertyManager, 
IBuildObject, ..., bui I guess I could look anywhere. This is in sharp contrast with the
Eclipse Platform sources which usually have very high quality documentation.

Perhaps a documenting campaign could help, while CDT developers still remember
what is what?

Other example: in Core, org.eclipse.cdt.core.parser.* -- almost everything there
written by jcamelon, practically not documented.

=====================================================================

Problems with the toolchain extensibility model

Current way of adding a tool to a toolchain is to "extend" it, that is, 
create a new toolchain which "subclasses" the existing toolchain, and 
add the tool to that. It seems to be not possible to add a tool to
an *existing* toolchain. (When I tried it, I got "Managed Build system manifest
file error: Duplicate identifier cdt.managedbuild.toolchain.gnu.mingw.base 
for element type ToolChain", and further NPE in the "New C++ Project"
wizard, so I assume this kind of usage is not envisioned. Please mark this bug
as invalid if I have overseen something.)

This creates the following problems: suppose Team A extends CDT by integrating
some tools (say bison and flex), creating com.teama.* toolchains, and publishes 
it as a plug-in. Meanwhile, an independent team (Team B) integrates some other 
tools, for example swig, resulting in com.teamb.* toolchains, and also 
release it as a new plug-in. Now, if you are in a third team that would 
like to use both bison/flex and swig in the same project (without creating 
yet another toolchain) -- what can you do??? You can have either bison/flex 
or swig, but not both!

It looks like even smaller additions like a new macro resolver mandates
subclassing from the toolchain. Worse, you have to subclass from several 
toolchains (mingw, cygwin, linux/gcc, macosx, solaris,..), although the 
usage of bison, flex, swig, etc is exactly the same!

Combinatoric explosion of toolchains.

If it was possible to add tools to an existing toolchain, this problem would
not exist. Both Team A and Team B would contribute their tools to the root
of the toolchain hierarchy, and it would automatically appear everywhere.

To further highlight the point, please imagine if the way of extending 
a perspective in the Eclipse platform (say adding a menu item) would be
to "subclass" from it... Each vendor would subclass it in different ways,
and we'd end up with a huge number of slightly difference perspectives...)




