
To "19.4.3 Java proxy classes":

Every wrapper object contains SEVERAL swigCPtrs, one for each subclass.
With single inheritance they are all the same values, but with multiple
inheritance, they may be different (as different base classes may be at
different offsets in the object).

By default, SWIG does not provide methods to get the CPtr of the base class;
here I added getBaseCPtr() for this.

------

To: "19.4.3.1 Memory management"

%newobject exists to set swigCMemOwn=true for C++ objects returned from
wrapped functions. However, there reverse is missing: there is currently
no "official" way to set swigCMemOwn=false for objects passed into
methods that take ownership the object (as it is typical with "insert"
methods of containers). So, there is nothing like

   %feature("javadisown",args="obj") Queue::insert; //not supported

There are two workarounds, however. javain typemaps will match by the
name of the parameter name in addition to the type. So if you name
the parameters to be "disowned" differently in the C++ declaration,
you can write a typemap for them:

   %typemap(javain) Foo *objDISOWN "...code with objDISOWN.swigCMemOwn=false..."

   class Queue {
       ...
       void insert(Foo *objDISOWN);  // typemap applies
       bool contains(Foo *obj);      // typemap does not apply
   };

Alternatively, you can utilize the javaout typemap. It can be given a
method name to match, so it can be used to inject "disown" code into
selected methods:

     %typemap(javaout) void Queue::insert { objDISOWN.swigCMemOwn=false; $jnicall }

     class Queue {
       ...
       void insert(Foo* obj);  // javaout inserts disown code into it
       void remove(Foo* obj);  // leaves it alone
     };



ALTERNATIVE WAYS OF MEMORY MANAGEMENT.

In highly dynamic applications


Another way is going for EXPLICIT MEMORY MANAGEMENT (i.e. requiring the
delete() method of the wrapper to be explicitly called when the C++ object
is not needed any more). swigCMemOwn would always be set to false, or could
even be removed from generated code. The code is too lengthy to quote here,
but it involves several (fairly straightforward) changes to the original
java.swg version of the following typemaps:

    %typemap(javabody) SWIGTYPE %{ ... %}
    %typemap(javabody_derived) SWIGTYPE %{ ... %}
    %typemap(javaconstruct) SWIGTYPE { ... }
    %typemap(javafinalize) SWIGTYPE %{ ... %}
    %typemap(javadestruct, methodname="delete") SWIGTYPE { ... }
    %typemap(javadestruct_derived, methodname="delete") SWIGTYPE { ... }



JAVA OBJECT IDENTITY.

By default, SWIG creates a new Java wrapper object every time a C++ method
returns an object. This has drawbacks:

    1. one cannot use "==" with wrapper objects, the CPtrs have to be
       compared instead.

       In OMNeT++ we use the getBaseCPtr() and sameAs() methods, as defined
       in the custom javabody typemap.

    2. if finalize() methods of wrapper objects are allowed to delete
       their C++ objects (swigCMemOwn=true), then sane memory management
       is very hard. One wrapper object may delete the C++ object while
       other wrappers with the same CPtr still exist. In highly dynamic
       applications (where several objects get created, passed around
       and deleted, possibly by both the C++ and Java code), users
       must be extremely cautius in writing the Java code to prevent
       crashes!

How to guarantee Java object identity (ie at most one Java wrapper per
C++ object)? There are several methods, all with some difficulty:

   - store the wrapper object reference (jobject) inside the C++ object.
     One may use global weak reference (instead of ordinary global reference)
     to allow the wrapper to be garbage collected.
     Constructor of the wrapper should set the jobject field of the C++ object,
     and finalize() should clear it. C++ destructor should set CPtr in the
     Java wrapper object to zero.

     Drawback: C++ base class has to be modified (extra jobject field, dtor)!

   - use a hashtable that maps a CPtr to the Java proxy object:
     HashMap<Long,Object> or HashMap<Long,WeakReference> (the latter allows
     wrappers to be garbage collected.) When we get a C++ object to wrap, we
     look up cPtr in the hashtable. This promises to get by without
     modifying the C++ classes.

     Problem: when we find CPtr in the hashtable, how do we know it's the
     same object, or a new object allocated on the same memory address after
     the original object got deleted? There are several possible solutions,
     each involving some modification to the C++ classes though:

     1. C++ destructors (ie cPolymorphic destructor) should remove the
        cPtr from the Java hashtable. TOO COSTLY? Not if we add a
        hasJavaProxy flag into the C++ class...
        REQUIRES MODIFICATION TO OMNET++ (modifying cPolymorphic dtor).

     2. Add unique IDs to C++ objects to identify them. I.e. into the
        ctor: id = lastId++. Then, hashtable lookup would also check
        that object ID matches.
        REQUIRES MODIFICATION TO OMNET++ (adding ID to cPolymorphic.)

     3. BEST: we can get by with only ONE BIT in the C++ object: the
        hasJavaWrapper bit. The constructor of the wrapper has to set
        it to 1 (at the same time the wrapper is put into the hashtable),
        and finalize() should clear it. New C++ objects are created with
        this bit set to false.

        If C++ code can delete the object behind the back of the Java code,
        the C++ destructor still has to be modified to remove invalidate
        the wrapper object and remove it from the hash table.


