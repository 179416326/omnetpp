
Notes about SWIG:

Every wrapper object contains SEVERAL swigCPtrs, one for each subclass.
With single inheritance they are all the same values, but with multiple
inheritance, they may be different (as different base classes may be at
different offsets in the object).

By default, SWIG does not provide methods to get the CPtr of the base class;
here I added getBaseCPtr() for this.

ISSUES WITH C++/JAVA INTEGRATION:

1.

2. JAVA OBJECT IDENTITY. By default, SWIG creates a new Java wrapper
   object every time a C++ method returns an object. This has drawbacks:
    1. one cannot use "==" with wrapper objects, the CPtrs have to be
       compared instead;
    2. if finalize() methods of wrapper objects are allowed to delete
       their C++ objects (swigCMemOwn=true), then sane memory management
       is very hard. One wrapper object may delete the C++ object while
       other wrappers with the same CPtr still exist. In highly dynamic
       applications (where several objects get created, passed around
       and deleted, possibly by both the C++ and Java code), users
       must be extremely cautius in writing the Java code to prevent
       crashes!

   How to guarantee Java object identity (ie at most one Java wrapper per
   C++ object)? There are several methods, all with some difficulty:

   - store the wrapper object reference (jobject) inside the C++ object.
     One may use global weak reference (instead of ordinary global reference)
     to allow the wrapper to be garbage collected.
     Constructor of the wrapper should set the jobject field of the C++ object,
     and finalize() should clear it. C++ destructor should set CPtr in the
     Java wrapper object to zero.

     Drawback: C++ base class has to be modified (extra jobject field, dtor)!

   - use a hashtable that maps a CPtr to the Java proxy object:
     HashMap<Long,Object> or HashMap<Long,WeakReference> (the latter allows
     wrappers to be garbage collected.) When we get a C++ object to wrap, we
     look up cPtr in the hashtable. This promises to get by without
     modifying the C++ classes.

     Problem: when we find CPtr in the hashtable, how do we know it's the
     same object, or a new object allocated on the same memory address after
     the original object got deleted? There are several possible solutions,
     each involving some modification to the C++ classes though:

     1. C++ destructors (ie cPolymorphic destructor) should remove the
        cPtr from the Java hashtable. TOO COSTLY? Not if we add a
        hasJavaProxy flag into the C++ class...
        REQUIRES MODIFICATION TO OMNET++ (modifying cPolymorphic dtor).

     2. Add unique IDs to C++ objects to identify them. I.e. into the
        ctor: id = lastId++. Then, hashtable lookup would also check
        that object ID matches.
        REQUIRES MODIFICATION TO OMNET++ (adding ID to cPolymorphic.)

     3. BEST: we can get by with only ONE BIT in the C++ object: the
        hasJavaWrapper bit. The constructor of the wrapper has to set
        it to 1 (at the same time the wrapper is put into the hashtable),
        and finalize() should clear it. New C++ objects are created with
        this bit set to false.

        If C++ code can delete the object behind the back of the Java code,
        the C++ destructor still has to be modified to remove invalidate
        the wrapper object and remove it from the hash table.

3. Polymorphic return types. When a method returns an object, we create
   it into a Java proxy object that corresponds to its actual type,
   not the declared return type of the method. We derive the Java class
   as "org.omnetpp.simkernel.<cplusplus-classname>".

   TOO COSTLY? (Class.forName() each time we return an object!) Java object
   identity would help (less frequent need for wrapping).

   Immediately creating the wrapper object of the right (dynamic)
   type would cause a high runtime cost in every method that returns an object.
   The code would have to invoke className() on the C++ object to get the
   C++ class name, prefix it with "org.omnetpp.simkernel." to get a fully
   qualified Java class name, then invoke Class.forName() and newInstance().
   This is far more costly than a plain "new cObject(cPtr, false)" call.
   Caching of the Java Class would alleviate the pain, but would require
   modification to the underlying C++ classes, i.e. this Java extension would
   not be able to run on an unmodified OMNeT++ installation.

   TODO: cMessage.castFrom() example
