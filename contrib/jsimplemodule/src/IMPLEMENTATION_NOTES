
PLANNED changes to normal SWIG proxy object behaviour (NOT WORKING YET!):

1. Java object identity. By default, SWIG creates a new Java proxy
   object every time a C++ method returns an object. Here we
   return the same proxy object every time, from a hashtable that
   maps a C++ pointer to the Java proxy object. This functionality
   is provided by the ProxyObjectMap class.

   *** PROBLEM ***:
        When we get a C++ object to wrap, we look up cPtr in the hashtable.
        How do we know it's the same object for which we have the wrapper
        object in the table, or is it a new object allocated on the same
        memory address after the original object got deleted???

        Two possible solutions:
          1. C++ destructors (ie cPolymorphic destructor) should remove the
             cPtr from the Java hashtable. TOO COSTLY? Not if we add a
             hasJavaProxy flag into the C++ class...
             REQUIRES MODIFICATION TO OMNET++ (modifying cPolymorphic dtor).

          2. Add unique IDs to C++ objects to identify them. I.e. into the
             ctor: id = lastId++. Then, hashtable lookup would also check
             that object ID matches.
             REQUIRES MODIFICATION TO OMNET++ (adding ID to cPolymorphic.)

2. Polymorphic return types. When a method returns an object, we create
   it into a Java proxy object that corresponds to its actual type,
   not the declared return type of the method. We derive the Java class
   as "org.omnetpp.simkernel.<cplusplus-classname>".

   TOO COSTLY? (Class.forName() each time we return an object!) Java object
   identity would help (less frequent need for wrapping).


Rationale: Implementing one-to-one mapping of C++ objects to Java wrapper
   objects is not done, because it would not be possible without modifying
   the C++ base class, and the extension could not be run on an unmodified
   OMNeT++ installation. (If we accepted modification of the C++ base class,
   then storing a jobject reference in it would be the best solution. One
   might think that by introducing a global hash table [to store cptr-to-
   wrapperobject mapping] we could spare the need for modifying the C++ base
   class, but that doesn't work in practice. Given a CPtr, we cannot tell if
   it is still the same object, or a new object allocated on the same memory
   location after the original object was destroyed. This problem could only
   be resolved either with help from the C++ destructor (it would remove
   the entry from the hashtable), or by introducing a unique object ID into
   C++ objects.)


Rationale: immediately creating the wrapper object of the right (dynamic)
   type would cause a high runtime cost in every method that returns an object.
   The code would have to invoke className() on the C++ object to get the
   C++ class name, prefix it with "org.omnetpp.simkernel." to get a fully
   qualified Java class name, then invoke Class.forName() and newInstance().
   This is far more costly than a plain "new cObject(cPtr, false)" call.
   Caching of the Java Class would alleviate the pain, but would require
   modification to the underlying C++ classes, i.e. this Java extension would
   not be able to run on an unmodified OMNeT++ installation.
