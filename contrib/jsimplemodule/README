JSimpleModule
=============

This is an extension that makes it possible to write OMNeT++ simple modules
in Java. Java and C++-based simple modules can be freely mixed in
simulations. Integration is not seamless though, there are limitations as
to what OMNeT++ features are available, as well special coding rules to
obey in the Java code.

Operation is based on the JSimpleModule class. This is an ordinary C++
simple module, which receives the name of a Java class in a module parameter.
During initialize, it loads the Java Virtual Machine (if not already loaded),
instantiates the given Java class, then simply delegates initialize(),
handleMessage() and finish() calls to it. The Java class should be subclassed
from org.omnetpp.simkernel.JSimpleModule, which provides the usual methods:
send(), scheduleAt(), cancelEvent(), etc. Messages are instances of
org.omnetpp.simkernel.cMessage, and the org.omnetpp.simkernel package contains
Java versions of most simulation kernel classes.

The org.omnetpp.simkernel.* Java classes are just JNI-based wrappers around
the corresponding C++ classes: every Java object holds a pointer to a
corresponding C++ object, and delegates all method calls to it. This
has a few consequences about the programming model, as will be covered later.
The wrapper classes have been generated using SWIG (www.swig.org).

SO, SHOULD I DEVELOP MY SIMULATIONS IN JAVA? No. This is extension has far
too many limitations to be recommended as a primary means of writing
simulation models. However, it can be useful if you have some existing
body of Java code which you want to reuse as part of a simulation.


Contents
--------
1. Building the simulation executable
2. Writing NED files
3. Writing Java-based simple modules
4. Compiling the Java code and running the simulation


1. Building the simulation executable
-------------------------------------

Prerequisite: JDK. The code is not very sensitive to the particular JDK version.

First, you'll need a simulation executable that contains JSimpleModule,
plus the C++ simple modules you'll need in the simulation. For this,
the provided .cc files need to be compiled and linked into the executable:

   JSimpleModule.cc
   simkernel_wrap.cc
   SimkernelJNI_registerNatives.cc

These files need the JNI headers to compile, and the simulation executable
needs to be linked against the JVM. If you generate the makefile with
opp_(n)makemake, the provided makefrag(.vc) file gets built into the
makefile, and modifies the INCLUDE_PATH and LIBS variables accordingly.
makefrag(.vc) needs the JAVA_HOME variable, you can define it either as an
environment variable, or add it directly into makefrag(.vc).

If you get a compiler error message that <jni.h> is not found or a linker
message that the "jvm" library is not found, review the settings in
makefrag(.vc), and re-run opp_(n)makemake.


2. Creating the simulation
--------------------------

Your Java-based simple modules will be run by JSimpleModule instances,
which get the Java class name in a parameter. That is, you would write
something like this in the NED file:

   module Net
       submodules:
           source: JSimpleModule;
               parameters:
                   javaClass = "Source";
           sink: JSimpleModule;
               parameters:
                   javaClass = "Sink";
       connections:
           source.out++ --> sink.in++;
   endmodule

JSimpleModule has the following NED declaration:

   simple JSimpleModule
       parameters:
           javaClass: string;
       gates:
           in: in[];
           out: out[];
   endsimple

That is, it has in[]/out[] vector gates and no parameters. Gates can be
conveniently created and connected with the in++/out++ syntax as in the
example above. It is a bigger problem that the simple module cannot
have parameters (unless you add them into JSimpleModule.ned itself).
In practice, this can be resolved by using the parent module's parameters.
From the Java code they can be accessed as getParentModule().par("hello").


3. Writing simple modules in Java
---------------------------------

Simple module classes need to subclass from JSimpleModule, and redefine
at least handleMessage() [activity() is not supported] and possibly also
initialize() and finish():

  import org.omnetpp.simkernel.*;

  public class MyModule extends JSimpleModule
  {
      ...
      public MyModule(long cptr) { super(cptr); }
      protected void initialize() { ... }
      protected void handleMessage(cMessage msg) { ... }
      protected void finish() { ... }
      ...
  }

The constructor taking (long cptr) is needed by SWIG, and must always be
present. The module class can make use of cMessage, cQueue, cOutVector
and other OMNeT++ classes. The same methods and operations are available
as in C++; the only difference is that accessor ("getter") method names
have been prefixed with "get" to follow the Java convention, for example,
name() is available as getName().

The above Java classes are just wrappers around the corresponding C++
classes. They all hold a pointer to an underlying C++ object, and delegate
method calls to it.

When you write

   cMessage msg = new cMessage();

in Java, the org.omnetpp.simkernel.cMessage wrapper object will actually
create an underlying C++ cMessage object via JNI, and hold on to its pointer.
When you perform

   send(msg, "out");

which is actually

   this.send(msg, "out");

then the underlying C++ simple module's and the C++ cMessage object's
pointer will be taken from the Java objects, and the corresponding
module->send(msg, "out") C++ call will be made. At the same time, a flag in
the "msg" Java object will be cleared to indicate that it no longer has
control over the C++ object. After sending out a message, the corresponding
Java object should no longer be referenced (i.e. should be allowed to be
garbage-collected by the VM).


MEMORY MANAGEMENT. The above mentioned flag is named swigCMemOwn, and it is
associated with memory management of the underlying C++ object. swigMemOwn
is member of every SWIG-generated Java wrapper class. It is automatically
managed most of the time, but because Java garbage collection and C++
explicit new/delete are a difficult match, it is useful to know how it
works.

Most importantly: when swigCMemOwn is set (==true), then garbage collecting
the Java object will delete the underlying C++ object as well: finalize()
calls the delete() method, which deallocates the C++ object with a JNI
call. (Actually, delete() may be invoked explicitly too; after calling it,
the Java object should be considered zombie, and no method should be called
on it any more.) When swigCMemOwn is false, finalize() has no effect.

Explicitly creating a Java object will create an underlying C++ object too,
and will initialize swigCMemOwn to true. Certain methods, such as sending a
message or inserting it into a cQueue, will cause the Java object to
"disown" the C++ pointer, i.e. swigCMemOwn set to false.

Methods which return an object (such as parentModule() or cQueue.pop())
make a JNI call to retrieve a C++ object pointer, then wrap it into a Java
object. The Java object's swigCMemOwn flag will be initialized to either
true or false, depending on who owns the C++ object: still the simulation
library (-->false), or the Java code (-->true). For example, parentModule()
will return a Java object with swigCMemOwn==false, while cQueue.pop() with
swigCMemOwn==true.


There are two other artifacts (as a consequence of the wrapping), that you
should know about to be able to write correct Java code with this extension:

NO JAVA OBJECT IDENTITY. If you retrieve the same C++ object twice, it will
be wrapped into two different Java objects! That is, Java's "==" operator
is not really useful, for example

   if (parentModule() == parentModule()) ...    // WRONG!

would yield FALSE! Rather, the underlying C++ pointers have to be compared:

   parentModule().getBaseCPtr() == parentModule().getBaseCPtr()

gives the expected result of true. There is a convenience method for this test,
isSameAs():

   if (parentModule().isSameAs(module)) ...

The same holds especially for message objects. In C++ simple modules it is
a common practice to remember the pointer of self-messages, and in
handleMessage() to test using pointer comparison if the same message
arrived. In Java, isSameAs() has to be used for this purpose too, because
the C++ message gets wrapped into a different Java object when
handleMessage is called:

   if (msg == timoutMsg) ... // WRONG!

   if (msg.isSameAs(timoutMsg)) ... // correct -- it compares the C++ pointers

This requires some attention during coding to avoid bad surprises.

   Rationale: Implementing one-to-one mapping of C++ objects to Java wrapper
   objects is not done, because it would not be possible without modifying
   the C++ base class, and the extension could not be run on an unmodified
   OMNeT++ installation. (If we accepted modification of the C++ base class,
   then storing a jobject reference in it would be the best solution. One
   might think that by introducing a global hash table [to store cptr-to-
   wrapperobject mapping] we could spare the need for modifying the C++ base
   class, but that doesn't work in practice. Given a CPtr, we cannot tell if
   it is still the same object, or a new object allocated on the same memory
   location after the original object was destroyed. This problem could only
   be resolved either with help from the C++ destructor (it would remove
   the entry from the hashtable), or by introducing a unique object ID into
   C++ objects.)


NO POLYMORPHIC RETURN TYPES. When a method returns an object, the C++ object
object will be wrapped into a Java object of the declared return type of the
method, and no the actual C++ type. That is, the following code causes
ClassCastException even if the actual C++ object retrieved from the queue
is a cMessage:

  cQueue queue = new cQueue();
  queue.insert(new cMessage());
  ...
  cObject obj = queue.pop();
  cMessage msg = (cMessage)obj; // BANG: ClassCastException!

The correct solution is to re-wrap the C++ object into a Java object
of the correct type:

  cObject obj = queue.pop();
  cMessage msg = cMessage.convertFrom(obj); // correct: re-wraps the C++ object

This behaves like C++ dynamic_cast<>, in that the convertFrom() method
returns null if the conversion cannot be performed. (It actually indeed
contains a C++ dynamic_cast<> inside the JNI code.) Also, the conversion
transfers ownership of the C++ object (swigCMemOwn) to new wrapper object,
that is, the original Java wrapper object (obj above) should be considered
a zombie afterwards and should not be touched.

   Rationale: immediately creating the wrapper object of the right (dynamic)
   type would cause a high runtime cost in every method that returns an object.
   The code would have to invoke className() on the C++ object to get the
   C++ class name, prefix it with "org.omnetpp.simkernel." to get a fully
   qualified Java class name, then invoke Class.forName() and newInstance().
   This is far more costly than a plain "new cObject(cPtr, false)" call.
   Caching of the Java Class would alleviate the pain, but would require
   modification to the underlying C++ classes, i.e. this Java extension would
   not be able to run on an unmodified OMNeT++ installation.


4. Compiling the Java code and running the simulation
-----------------------------------------------------

When invoking the Java compiler, make sure that the provided simkernel.jar
is in the compile-time classpath.

Running the simulaton is no different from running any OMNeT++ simulation,
but make sure simkernel.jar is in the CLASSPATH, and that the JVM can be loaded
(i.e. JRE/bin is in the PATH).


COMMENT, QUESTIONS:
Please post to the mailing list.


--
Andras


