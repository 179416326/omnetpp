<?xml version="1.0" encoding="UTF-8"?>
<scave:Analysis xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:scave="http://www.omnetpp.org/omnetpp/scave">
  <inputs>
    <inputs name="/resultfiles/aloha/*.vec"/>
    <inputs name="/resultfiles/aloha/*.sca"/>
    <inputs name="/resultfiles/fifo/*.vec"/>
    <inputs name="/resultfiles/fifo/*.sca"/>
    <inputs name="/resultfiles/routing/*.vec"/>
    <inputs name="/resultfiles/routing/*.sca"/>
    <inputs name="/resultfiles/routing2/*.vec"/>
    <inputs name="/resultfiles/routing2/*.sca"/>
  </inputs>
  <charts>
    <items xsi:type="scave:MatplotlibChart" name="simplecursor" script="from matplotlib.widgets import Cursor&#xA;import pylab&#xA;&#xA;fig = pylab.figure()&#xA;ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])&#xA;&#xA;x,y = 4*(pylab.rand(2,100)-.5)&#xA;ax.plot(x,y,'o')&#xA;ax.set_xlim(-2,2)&#xA;ax.set_ylim(-2,2)&#xA;&#xA;&quot;&quot;&quot; Setting useblit to True should improve latency! &quot;&quot;&quot;&#xA;cursor = Cursor(ax, useblit=False, color='red', linewidth=2 )&#xA;&#xA;pylab.show()&#xA;pylab.title(&quot;Move the mouse in the chart!&quot;)"/>
    <items xsi:type="scave:MatplotlibChart" name="trifinder" script="import matplotlib.pyplot as plt&#xA;from matplotlib.tri import Triangulation&#xA;from matplotlib.patches import Polygon&#xA;import numpy as np&#xA;import math&#xA;import time&#xA;&#xA;def update_polygon(tri):&#xA;    if tri == -1:&#xA;        points = [0, 0, 0]&#xA;    else:&#xA;        points = triangulation.triangles[tri]&#xA;    xs = triangulation.x[points]&#xA;    ys = triangulation.y[points]&#xA;    polygon.set_xy(list(zip(xs, ys)))&#xA;&#xA;&#xA;def motion_notify(event):&#xA;    if event.inaxes is None:&#xA;        tri = -1&#xA;    else:&#xA;        tri = trifinder(event.xdata, event.ydata)&#xA;    update_polygon(tri)&#xA;    print('In triangle %i' % tri)&#xA;    plt.title('In triangle %i' % tri)&#xA;    event.canvas.draw()&#xA;&#xA;&#xA;# Create a Triangulation.&#xA;n_angles = 16&#xA;n_radii = 5&#xA;min_radius = 0.25&#xA;radii = np.linspace(min_radius, 0.95, n_radii)&#xA;angles = np.linspace(0, 2*math.pi, n_angles, endpoint=False)&#xA;angles = np.repeat(angles[..., np.newaxis], n_radii, axis=1)&#xA;angles[:, 1::2] += math.pi / n_angles&#xA;x = (radii*np.cos(angles)).flatten()&#xA;y = (radii*np.sin(angles)).flatten()&#xA;triangulation = Triangulation(x, y)&#xA;xmid = x[triangulation.triangles].mean(axis=1)&#xA;ymid = y[triangulation.triangles].mean(axis=1)&#xA;mask = np.where(xmid*xmid + ymid*ymid &lt; min_radius*min_radius, 1, 0)&#xA;triangulation.set_mask(mask)&#xA;&#xA;# Use the triangulation's default TriFinder object.&#xA;trifinder = triangulation.get_trifinder()&#xA;&#xA;# Setup plot and callbacks.&#xA;plt.subplot(111, aspect='equal')&#xA;plt.triplot(triangulation, 'bo-')&#xA;polygon = Polygon([[0, 0], [0, 0]], facecolor='y')  # dummy data for xs,ys&#xA;update_polygon(-1)&#xA;plt.gca().add_patch(polygon)&#xA;plt.gcf().canvas.mpl_connect('motion_notify_event', motion_notify)&#xA;plt.show()">
      <properties name="Legend.Display" value="false"/>
    </items>
    <items xsi:type="scave:MatplotlibChart" name="lorenz" script="import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;from mpl_toolkits.mplot3d import Axes3D&#xA;&#xA;&#xA;def lorenz(x, y, z, s=10, r=28, b=2.667):&#xA;    x_dot = s*(y - x)&#xA;    y_dot = r*x - y - x*z&#xA;    z_dot = x*y - b*z&#xA;    return x_dot, y_dot, z_dot&#xA;&#xA;&#xA;dt = 0.01&#xA;stepCnt = 10000&#xA;&#xA;# Need one more for the initial values&#xA;xs = np.empty((stepCnt + 1,))&#xA;ys = np.empty((stepCnt + 1,))&#xA;zs = np.empty((stepCnt + 1,))&#xA;&#xA;# Setting initial values&#xA;xs[0], ys[0], zs[0] = (0., 1., 1.05)&#xA;&#xA;# Stepping through &quot;time&quot;.&#xA;for i in range(stepCnt):&#xA;    # Derivatives of the X, Y, Z state&#xA;    x_dot, y_dot, z_dot = lorenz(xs[i], ys[i], zs[i])&#xA;    xs[i + 1] = xs[i] + (x_dot * dt)&#xA;    ys[i + 1] = ys[i] + (y_dot * dt)&#xA;    zs[i + 1] = zs[i] + (z_dot * dt)&#xA;&#xA;fig = plt.figure()&#xA;ax = fig.gca(projection='3d')&#xA;&#xA;ax.plot(xs, ys, zs, lw=0.5)&#xA;ax.set_xlabel(&quot;X Axis&quot;)&#xA;ax.set_ylabel(&quot;Y Axis&quot;)&#xA;ax.set_zlabel(&quot;Z Axis&quot;)&#xA;ax.set_title(&quot;Lorenz Attractor&quot;)&#xA;&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="xkcd" script="&#xA;with plt.xkcd():&#xA;    # Based on &quot;Stove Ownership&quot; from XKCD by Randall Monroe&#xA;    # http://xkcd.com/418/&#xA;&#xA;    fig = plt.figure()&#xA;    ax = fig.add_axes((0.05, 0.2, 0.4, 0.7))&#xA;    ax.spines['right'].set_color('none')&#xA;    ax.spines['top'].set_color('none')&#xA;    plt.xticks([])&#xA;    plt.yticks([])&#xA;    ax.set_ylim([-30, 10])&#xA;&#xA;    data = np.ones(100)&#xA;    data[70:] -= np.arange(30)&#xA;&#xA;    plt.annotate(&#xA;        'THE DAY I REALIZED\nI COULD COOK BACON\nWHENEVER I WANTED',&#xA;        xy=(70, 1), arrowprops=dict(arrowstyle='->'), xytext=(15, -10))&#xA;&#xA;    plt.plot(data)&#xA;&#xA;    plt.xlabel('time')&#xA;    plt.ylabel('my overall health')&#xA;    fig.text(&#xA;        0.25, 0.05,&#xA;        '&quot;Stove Ownership&quot; from xkcd by Randall Monroe',&#xA;        ha='center')&#xA;&#xA;    # Based on &quot;The Data So Far&quot; from XKCD by Randall Monroe&#xA;    # http://xkcd.com/373/&#xA;&#xA;    ax = fig.add_axes((0.55, 0.2, 0.4, 0.7))&#xA;    ax.bar([0, 1], [0, 100], 0.25)&#xA;    ax.spines['right'].set_color('none')&#xA;    ax.spines['top'].set_color('none')&#xA;    ax.xaxis.set_ticks_position('bottom')&#xA;    ax.set_xticks([0, 1])&#xA;    ax.set_xlim([-0.5, 1.5])&#xA;    ax.set_ylim([0, 110])&#xA;    ax.set_xticklabels(['CONFIRMED BY\nEXPERIMENT', 'REFUTED BY\nEXPERIMENT'])&#xA;    plt.yticks([])&#xA;&#xA;    plt.title(&quot;CLAIMS OF SUPERNATURAL POWERS&quot;)&#xA;&#xA;    fig.text(&#xA;        0.75, 0.05,&#xA;        '&quot;The Data So Far&quot; from xkcd by Randall Monroe',&#xA;        ha='center')&#xA;&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="annotation" script="ax = plt.subplot(111)&#xA;&#xA;t = np.arange(0.0, 5.0, 0.01)&#xA;s = np.cos(2*np.pi*t)&#xA;line, = plt.plot(t, s, lw=2)&#xA;&#xA;plt.annotate('local max', xy=(2, 1), xytext=(3, 1.5),&#xA;            arrowprops=dict(facecolor='black', shrink=0.05),&#xA;            )&#xA;&#xA;plt.ylim(-2,2)&#xA;&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="polarannotation" script="&#xA;fig = plt.figure()&#xA;ax = fig.add_subplot(111, polar=True)&#xA;r = np.arange(0,1,0.001)&#xA;theta = 2*2*np.pi*r&#xA;line, = ax.plot(theta, r, color='#ee8d18', lw=3)&#xA;&#xA;ind = 800&#xA;thisr, thistheta = r[ind], theta[ind]&#xA;ax.plot([thistheta], [thisr], 'o')&#xA;ax.annotate('a polar annotation',&#xA;            xy=(thistheta, thisr),  # theta, radius&#xA;            xytext=(0.05, 0.05),    # fraction, fraction&#xA;            textcoords='figure fraction',&#xA;            arrowprops=dict(facecolor='black', shrink=0.05),&#xA;            horizontalalignment='left',&#xA;            verticalalignment='bottom',&#xA;            )&#xA;plt.show()">
      <properties name="Legend.Display" value="false"/>
    </items>
    <items xsi:type="scave:MatplotlibChart" name="closestpoint" script="import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;import matplotlib.cm as cm&#xA;import scipy.spatial as spatial&#xA;&#xA;def fmt(x, y):&#xA;    return 'x: {x:0.2f}\ny: {y:0.2f}'.format(x=x, y=y)&#xA;&#xA;class FollowDotCursor(object):&#xA;    &quot;&quot;&quot;Display the x,y location of the nearest data point.&#xA;    https://stackoverflow.com/a/4674445/190597 (Joe Kington)&#xA;    https://stackoverflow.com/a/20637433/190597 (unutbu)&#xA;    &quot;&quot;&quot;&#xA;    def __init__(self, ax, x, y, formatter=fmt, offsets=(-20, 20)):&#xA;        try:&#xA;            x = np.asarray(x, dtype='float')&#xA;        except (TypeError, ValueError):&#xA;            x = np.asarray(mdates.date2num(x), dtype='float')&#xA;        y = np.asarray(y, dtype='float')&#xA;        mask = ~(np.isnan(x) | np.isnan(y))&#xA;        x = x[mask]&#xA;        y = y[mask]&#xA;        self._points = np.column_stack((x, y))&#xA;        self.offsets = offsets&#xA;        y = y[np.abs(y - y.mean()) &lt;= 3 * y.std()]&#xA;        self.scale = x.ptp()&#xA;        self.scale = y.ptp() / self.scale if self.scale else 1&#xA;        self.tree = spatial.cKDTree(self.scaled(self._points))&#xA;        self.formatter = formatter&#xA;        self.ax = ax&#xA;        self.fig = ax.figure&#xA;        self.ax.xaxis.set_label_position('top')&#xA;        self.dot = ax.scatter(&#xA;            [x.min()], [y.min()], s=130, color='green', alpha=0.7)&#xA;        self.annotation = self.setup_annotation()&#xA;        plt.connect('motion_notify_event', self)&#xA;&#xA;    def scaled(self, points):&#xA;        points = np.asarray(points)&#xA;        return points * (self.scale, 1)&#xA;&#xA;    def __call__(self, event):&#xA;        ax = self.ax&#xA;        # event.inaxes is always the current axis. If you use twinx, ax could be&#xA;        # a different axis.&#xA;        if event.inaxes == ax:&#xA;            x, y = event.xdata, event.ydata&#xA;        elif event.inaxes is None:&#xA;            return&#xA;        else:&#xA;            inv = ax.transData.inverted()&#xA;            x, y = inv.transform([(event.x, event.y)]).ravel()&#xA;        annotation = self.annotation&#xA;        x, y = self.snap(x, y)&#xA;        annotation.xy = x, y&#xA;        annotation.set_text(self.formatter(x, y))&#xA;        self.dot.set_offsets((x, y))&#xA;        event.canvas.draw()&#xA;&#xA;    def setup_annotation(self):&#xA;        &quot;&quot;&quot;Draw and hide the annotation box.&quot;&quot;&quot;&#xA;        annotation = self.ax.annotate(&#xA;            '', xy=(0, 0), ha = 'right',&#xA;            xytext = self.offsets, textcoords = 'offset points', va = 'bottom',&#xA;            bbox = dict(&#xA;                boxstyle='round,pad=0.5', fc='yellow', alpha=0.75),&#xA;            arrowprops = dict(&#xA;                arrowstyle='->', connectionstyle='arc3,rad=0'))&#xA;        return annotation&#xA;&#xA;    def snap(self, x, y):&#xA;        &quot;&quot;&quot;Return the value in self.tree closest to x, y.&quot;&quot;&quot;&#xA;        dist, idx = self.tree.query(self.scaled((x, y)), k=1, p=1)&#xA;        try:&#xA;            return self._points[idx]&#xA;        except IndexError:&#xA;            # IndexError: index out of bounds&#xA;            return self._points[0]&#xA;&#xA;&#xA;np.random.seed(6)&#xA;numdata = 100&#xA;t = np.linspace(0.05, 0.11, numdata)&#xA;y1 = np.cumsum(np.random.random(numdata) - 0.5) * 40000&#xA;y2 = np.cumsum(np.random.random(numdata) - 0.5) * 0.002&#xA;&#xA;fig = plt.figure()&#xA;ax1 = fig.add_subplot(111)&#xA;ax2 = ax1.twinx()&#xA;&#xA;ax1.plot(t, y1, 'r-', label='y1')&#xA;ax2.plot(t, y2, 'g-', label='y2')&#xA;&#xA;cursor1 = FollowDotCursor(ax1, t, y1)&#xA;cursor2 = FollowDotCursor(ax2, t, y2)&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="widgets" script="from numpy import pi, sin&#xA;import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;from matplotlib.widgets import Slider, Button, RadioButtons&#xA;&#xA;def signal(amp, freq):&#xA;    return amp * sin(2 * pi * freq * t)&#xA;&#xA;axis_color = 'lightgoldenrodyellow'&#xA;fig = plt.figure()&#xA;&#xA;# Draw the plot&#xA;ax = fig.add_subplot(111)&#xA;fig.subplots_adjust(left=0.25, bottom=0.25)&#xA;t = np.arange(0.0, 1.0, 0.001)&#xA;amp_0 = 5&#xA;freq_0 = 3&#xA;[line] = ax.plot(t, signal(amp_0, freq_0), linewidth=2, color='red')&#xA;ax.set_xlim([0, 1])&#xA;ax.set_ylim([-10, 10])&#xA;&#xA;# Add two sliders for tweaking the parameters&#xA;amp_slider_ax  = fig.add_axes([0.25, 0.15, 0.65, 0.03])&#xA;amp_slider = Slider(amp_slider_ax, 'Amp', 0.1, 10.0, valinit=amp_0)&#xA;freq_slider_ax = fig.add_axes([0.25, 0.1, 0.65, 0.03])&#xA;freq_slider = Slider(freq_slider_ax, 'Freq', 0.1, 30.0, valinit=freq_0)&#xA;def sliders_on_changed(val):&#xA;    line.set_ydata(signal(amp_slider.val, freq_slider.val))&#xA;    fig.canvas.draw_idle()&#xA;amp_slider.on_changed(sliders_on_changed)&#xA;freq_slider.on_changed(sliders_on_changed)&#xA;&#xA;# Add a button for resetting the parameters&#xA;reset_button_ax = fig.add_axes([0.8, 0.025, 0.1, 0.04])&#xA;reset_button = Button(reset_button_ax, 'Reset', color=axis_color, hovercolor='0.975')&#xA;def reset_button_on_clicked(mouse_event):&#xA;    freq_slider.reset()&#xA;    amp_slider.reset()&#xA;reset_button.on_clicked(reset_button_on_clicked)&#xA;&#xA;# Add a set of radio buttons for changing color&#xA;color_radios_ax = fig.add_axes([0.025, 0.5, 0.15, 0.15])&#xA;color_radios = RadioButtons(color_radios_ax, ('red', 'blue', 'green'), active=0)&#xA;def color_radios_on_clicked(label):&#xA;    line.set_color(label)&#xA;    fig.canvas.draw_idle()&#xA;color_radios.on_clicked(color_radios_on_clicked)&#xA;&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="subplots" script="def add_subplot_axes(ax,rect,axisbg='w'):&#xA;    fig = plt.gcf()&#xA;    box = ax.get_position()&#xA;    width = box.width&#xA;    height = box.height&#xA;    inax_position  = ax.transAxes.transform(rect[0:2])&#xA;    transFigure = fig.transFigure.inverted()&#xA;    infig_position = transFigure.transform(inax_position)    &#xA;    x = infig_position[0]&#xA;    y = infig_position[1]&#xA;    width *= rect[2]&#xA;    height *= rect[3]  # &lt;= Typo was here&#xA;    subax = fig.add_axes([x,y,width,height])&#xA;    x_labelsize = subax.get_xticklabels()[0].get_size()&#xA;    y_labelsize = subax.get_yticklabels()[0].get_size()&#xA;    x_labelsize *= rect[2]**0.5&#xA;    y_labelsize *= rect[3]**0.5&#xA;    subax.xaxis.set_tick_params(labelsize=x_labelsize)&#xA;    subax.yaxis.set_tick_params(labelsize=y_labelsize)&#xA;    return subax&#xA;&#xA;def example1():&#xA;    fig = plt.figure(figsize=(10,10))&#xA;    ax = fig.add_subplot(111)&#xA;    rect = [0.2,0.2,0.7,0.7]&#xA;    ax1 = add_subplot_axes(ax,rect)&#xA;    ax2 = add_subplot_axes(ax1,rect)&#xA;    ax3 = add_subplot_axes(ax2,rect)&#xA;    plt.show()&#xA;&#xA;def example2():&#xA;    fig = plt.figure(figsize=(10,10))&#xA;    axes = []&#xA;    subpos = [0.2,0.6,0.3,0.3]&#xA;    x = np.linspace(-np.pi,np.pi)&#xA;    for i in range(4):&#xA;        axes.append(fig.add_subplot(2,2,i+1))&#xA;    for axis in axes:&#xA;        axis.set_xlim(-np.pi,np.pi)&#xA;        axis.set_ylim(-1,3)&#xA;        axis.plot(x,np.sin(x))&#xA;        subax1 = add_subplot_axes(axis,subpos)&#xA;        subax2 = add_subplot_axes(subax1,subpos)&#xA;        subax1.plot(x,np.sin(x))&#xA;        subax2.plot(x,np.sin(x))&#xA;&#xA;example2()&#xA;plt.show()&#xA;"/>
    <items xsi:type="scave:MatplotlibChart" name="multicursor" script="from matplotlib.widgets import MultiCursor&#xA;&#xA;t = np.arange(0.0, 2.0, 0.01)&#xA;s1 = np.sin(2*np.pi*t)&#xA;s2 = np.sin(4*np.pi*t)&#xA;fig = plt.figure()&#xA;ax1 = fig.add_subplot(211)&#xA;ax1.plot(t, s1)&#xA;&#xA;&#xA;ax2 = fig.add_subplot(212, sharex=ax1)&#xA;ax2.plot(t, s2)&#xA;&#xA;# setting useblit to False should not be necessary&#xA;multi = MultiCursor(fig.canvas, (ax1, ax2), color='r', lw=1)&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="histogram" script="import numpy as np&#xA;import matplotlib.pyplot as plt&#xA;&#xA;mu, sigma = 120, 15&#xA;x = mu + sigma * np.random.randn(10000)&#xA;&#xA;# the histogram of the data&#xA;n, bins, patches = plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75)&#xA;&#xA;&#xA;plt.xlabel('Smarts')&#xA;plt.ylabel('Probability')&#xA;plt.title('Histogram of IQ')&#xA;plt.text(60, .025, r'$\mu=100,\ \sigma=15$')&#xA;plt.axis([40, 160, 0, 0.03])&#xA;plt.grid(True)&#xA;plt.show()">
      <properties name="Legend.Display" value="false"/>
    </items>
    <items xsi:type="scave:MatplotlibChart" name="kendelltau" script="print(&quot;This chart will fail if scipy and seaborn are not installed&quot;)&#xA;&#xA;from scipy.stats import kendalltau&#xA;import seaborn as sns&#xA;sns.set(style=&quot;ticks&quot;)&#xA;&#xA;rs = np.random.RandomState(11)&#xA;x = rs.gamma(2, size=1000)&#xA;y = -.5 * x + rs.normal(size=1000)&#xA;&#xA;sns.jointplot(x, y, kind=&quot;hex&quot;, stat_func=kendalltau, color=&quot;#4CB391&quot;)&#xA;"/>
    <items xsi:type="scave:MatplotlibChart" name="big vector" script="import pandas as pd&#xA;import prettyplotlib as ppl&#xA;import time&#xA;&#xA;startTime = time.perf_counter()&#xA;#vectors = opp.getVectors('*')&#xA;#vectors = opp.getVectors('module(&quot;Aloha.server&quot;)')&#xA;vectors = results.getVectors('name(serverChannelState:vector)')&#xA;&#xA;endTime = time.perf_counter()&#xA;&#xA;print(&quot;getVectors took &quot; + str((endTime - startTime) * 1000.0) + &quot; ms&quot;)&#xA;&#xA;print(str(len(vectors)))&#xA;&#xA;df = vectors[vectors.type == &quot;vector&quot;]&#xA;&#xA;print(str(df.head()))&#xA;&#xA;&#xA;startTime = time.perf_counter()&#xA;for t in df[[&quot;vectime&quot;, &quot;vecvalue&quot;]].itertuples(index=False):&#xA;    plt.plot(t[0], t[1], drawstyle='steps-post')&#xA;&#xA;endTime = time.perf_counter()&#xA;print(&quot;plotting took &quot; + str((endTime - startTime) * 1000.0) + &quot; ms&quot;)&#xA;&#xA;#plt.tight_layout()&#xA;&#xA;#plt.show()&#xA;"/>
    <items xsi:type="scave:MatplotlibChart" name="print scalars" script="pd.set_option('display.width', 1000)&#xA;pd.set_option('display.max_columns', 500)&#xA;scalars = results.getScalars('*')&#xA;print(scalars)&#xA;&#xA;plt.title(&quot;Check the 'Console' View...&quot;)&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="print vectors" script="vectors = results.getVectors('*')&#xA;print(vectors)&#xA;&#xA;plt.title(&quot;Check the 'Console' View...&quot;)&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="print histograms" script="histograms = results.getHistograms('*')&#xA;&#xA;print(histograms)&#xA;&#xA;plt.title(&quot;Check the 'Console' View...&quot;)&#xA;plt.show()"/>
    <items xsi:type="scave:MatplotlibChart" name="aloha mpl" script="aloha = results.getScalars('run(&quot;PureAlohaExperiment*&quot;) AND attr:replication(#1)')&#xA;&#xA;aloha = aloha.assign(qname = aloha.module + &quot;.&quot; + aloha.name)&#xA;&#xA;scalars = aloha[(aloha.type=='scalar') | (aloha.type=='itervar')]  # filter rows&#xA;scalars = scalars.assign(qname = scalars.attrname.combine_first(scalars.module + '.' + scalars.name))  # add qname column&#xA;scalars.value = scalars.value.combine_first(scalars.attrvalue.astype('float64'))  # merge value columns&#xA;&#xA;scalars_wide = scalars.pivot('run', columns='qname', values='value')&#xA;&#xA;aloha_pivot = scalars_wide.pivot_table(index='iaMean', columns='numHosts', values='Aloha.server.channelUtilization:last')  # note: aggregation function = mean (that's the default)&#xA;aloha_pivot.plot.line()&#xA;&#xA;plt.ylabel('channel utilization')"/>
    <items xsi:type="scave:LineChart" name="aloha xy" script="aloha = results.getScalars('run(&quot;PureAlohaExperiment*&quot;) AND attr:replication(#1)')&#xA;&#xA;aloha = aloha.assign(qname = aloha.module + &quot;.&quot; + aloha.name)&#xA;&#xA;scalars = aloha[(aloha.type=='scalar') | (aloha.type=='itervar')]  # filter rows&#xA;scalars = scalars.assign(qname = scalars.attrname.combine_first(scalars.module + '.' + scalars.name))  # add qname column&#xA;scalars.value = scalars.value.combine_first(scalars.attrvalue.astype('float64'))  # merge value columns&#xA;&#xA;scalars_wide = scalars.pivot('run', columns='qname', values='value')&#xA;&#xA;aloha_pivot = scalars_wide.pivot_table(index='iaMean', columns='numHosts', values='Aloha.server.channelUtilization:last')  # note: aggregation function = mean (that's the default)&#xA;&#xA;print(aloha_pivot)&#xA;&#xA;aloha_pivot *= 100&#xA;print(aloha_pivot.index.name)&#xA;print(aloha_pivot.columns.name)&#xA;&#xA;for c in aloha_pivot:&#xA;    chart.plotVectors(pd.DataFrame({&quot;time&quot;:aloha_pivot.index, &quot;numHosts=&quot; + str(c): aloha_pivot[c]}))&#xA;&#xA;print(chart.getProperties())&#xA;&#xA;chart.setProperties({&#xA;    &quot;Graph.Title&quot;: &quot;Pure Aloha Experiment&quot;,&#xA;    &quot;X.Axis.Title&quot;: &quot;Mean packet inter-arrival time (s)&quot;,&#xA;    &quot;Y.Axis.Title&quot;: &quot;Channel utilization (%)&quot;&#xA;})&#xA;" lineNameFormat="">
      <properties name="Graph.Title" value="Pure Aloha Experiment"/>
      <properties name="Axis.Title.Font" value="Sans-regular-16"/>
      <properties name="Legend.Display" value="false"/>
    </items>
    <items xsi:type="scave:MatplotlibChart" name="hover annotation" script="import matplotlib.pyplot as plt&#xA;import numpy as np; np.random.seed(1)&#xA;&#xA;x = np.random.rand(15)&#xA;y = np.random.rand(15)&#xA;names = np.array(list(&quot;ABCDEFGHIJKLMNO&quot;))&#xA;c = np.random.randint(1,5,size=15)&#xA;&#xA;norm = plt.Normalize(1,4)&#xA;cmap = plt.cm.RdYlGn&#xA;&#xA;fig,ax = plt.subplots()&#xA;sc = plt.scatter(x,y,c=c, s=100, cmap=cmap, norm=norm)&#xA;&#xA;annot = ax.annotate(&quot;&quot;, xy=(0,0), xytext=(20,20),textcoords=&quot;offset points&quot;,&#xA;                    bbox=dict(boxstyle=&quot;round&quot;, fc=&quot;w&quot;),&#xA;                    arrowprops=dict(arrowstyle=&quot;->&quot;))&#xA;annot.set_visible(False)&#xA;&#xA;def update_annot(ind):&#xA;&#xA;    pos = sc.get_offsets()[ind[&quot;ind&quot;][0]]&#xA;    annot.xy = pos&#xA;    text = &quot;{}, {}&quot;.format(&quot; &quot;.join(list(map(str,ind[&quot;ind&quot;]))), &#xA;                           &quot; &quot;.join([names[n] for n in ind[&quot;ind&quot;]]))&#xA;    annot.set_text(text)&#xA;    annot.get_bbox_patch().set_facecolor(cmap(norm(c[ind[&quot;ind&quot;][0]])))&#xA;    annot.get_bbox_patch().set_alpha(0.4)&#xA;&#xA;&#xA;def hover(event):&#xA;    vis = annot.get_visible()&#xA;    if event.inaxes == ax:&#xA;        cont, ind = sc.contains(event)&#xA;        if cont:&#xA;            update_annot(ind)&#xA;            annot.set_visible(True)&#xA;            fig.canvas.draw_idle()&#xA;        else:&#xA;            if vis:&#xA;                annot.set_visible(False)&#xA;                fig.canvas.draw_idle()&#xA;&#xA;fig.canvas.mpl_connect(&quot;motion_notify_event&quot;, hover)&#xA;&#xA;plt.title(&quot;Hover the mouse over the dots!&quot;)&#xA;plt.show()&#xA;&#xA;# source: https://stackoverflow.com/a/47166787/635587"/>
    <items xsi:type="scave:BarChart" name="pivotScalars" script="df = results.getScalars(&quot;&quot;&quot;ADD scalars WHERE name(txBytes:sum) OR name(rxBytes:sum)&quot;&quot;&quot;)&#xA;df = results.pivotScalars(df)&#xA;chart.plotScalars(df)">
      <properties name="Legend.Display" value="false"/>
    </items>
    <items xsi:type="scave:LineChart" name="line and points" script="# chart.plotVector(&quot;nice line&quot;, [1, 2, 5, 8], [4,3,6,1])&#xA;# chart.plotVector(&quot;nicer line&quot;, [1, 2, 5, 8], [14,13,16,11])&#xA;&#xA;&#xA;chart.plotVectors([(&quot;A&quot;, [1, 2, 3], [10, 20, 30]), (&quot;B&quot;, [4,5,6],[11, 12, 13])])&#xA;&#xA;chart.setProperty(&quot;Line.Type/A&quot;, &quot;Dots&quot;)&#xA;&#xA;#df = results.getVectors('name(&quot;rxBytes:vector&quot;)')&#xA;#df.vecvalue = df.vecvalue.apply(np.cumsum)&#xA;#chart.plotVectors(df)&#xA;" lineNameFormat="">
      <properties name="Legend.Display" value="false"/>
    </items>
    <items xsi:type="scave:MatplotlibChart" name="queue length" script="df = results.getVectors(&quot;name(qlen:vector)&quot;)&#xA;&#xA;for t in df.itertuples():&#xA;    if t.type == &quot;vector&quot;:&#xA;        plt.plot(t.vectime, t.vecvalue, label=t.module, drawstyle='steps-post')&#xA;&#xA;plt.xlabel('Simulation time (s)')&#xA;plt.ylabel('Queue length')&#xA;&#xA;plt.legend()&#xA;plt.tight_layout()&#xA;"/>
    <items xsi:type="scave:MatplotlibChart" name="legend toggle" script="&#xA;t = np.arange(0.0, 0.2, 0.1)&#xA;y1 = 2*np.sin(2*np.pi*t)&#xA;y2 = 4*np.sin(2*np.pi*2*t)&#xA;&#xA;fig, ax = plt.subplots()&#xA;ax.set_title('Click on legend line to toggle line on/off')&#xA;line1, = ax.plot(t, y1, lw=2, color='red', label='1 HZ')&#xA;line2, = ax.plot(t, y2, lw=2, color='blue', label='2 HZ')&#xA;leg = ax.legend(loc='upper left', fancybox=True, shadow=True)&#xA;leg.get_frame().set_alpha(0.4)&#xA;&#xA;&#xA;# we will set up a dict mapping legend line to orig line, and enable&#xA;# picking on the legend line&#xA;lines = [line1, line2]&#xA;lined = dict()&#xA;for legline, origline in zip(leg.get_lines(), lines):&#xA;    legline.set_picker(5)  # 5 pts tolerance&#xA;    lined[legline] = origline&#xA;&#xA;&#xA;def onpick(event):&#xA;    # on the pick event, find the orig line corresponding to the&#xA;    # legend proxy line, and toggle the visibility&#xA;    legline = event.artist&#xA;    origline = lined[legline]&#xA;    vis = not origline.get_visible()&#xA;    origline.set_visible(vis)&#xA;    # Change the alpha on the line in the legend so we can see what lines&#xA;    # have been toggled&#xA;    if vis:&#xA;        legline.set_alpha(1.0)&#xA;    else:&#xA;        legline.set_alpha(0.2)&#xA;    fig.canvas.draw()&#xA;&#xA;fig.canvas.mpl_connect('pick_event', onpick)&#xA;"/>
    <items xsi:type="scave:MatplotlibChart" name="zoom" script="&quot;&quot;&quot;&#xA;If you click on a point in the first window, the z and y limits of the&#xA;second will be adjusted so that the center of the zoom in the second&#xA;window will be the x,y coordinates of the clicked point.&#xA;&#xA;Note the diameter of the circles in the scatter are defined in&#xA;points**2, so their size is independent of the zoom&#xA;&quot;&quot;&quot;&#xA;from matplotlib.pyplot import figure, show&#xA;import numpy&#xA;fig = figure()&#xA;&#xA;axsrc = fig.add_subplot(211, xlim=(0, 1), ylim=(0, 1), autoscale_on=False)&#xA;axzoom = fig.add_subplot(212, xlim=(0.45, 0.55), ylim=(0.4, .6),&#xA;                             autoscale_on=False)&#xA;axsrc.set_title('Click to')&#xA;axzoom.set_title('zoom ')&#xA;x, y, s, c = numpy.random.rand(4, 200)&#xA;s *= 200&#xA;&#xA;&#xA;axsrc.scatter(x, y, s, c)&#xA;axzoom.scatter(x, y, s, c)&#xA;&#xA;&#xA;def onpress(event):&#xA;    if event.button != 1 or event.inaxes != axsrc:&#xA;        return&#xA;    x, y = event.xdata, event.ydata&#xA;    if x and y:&#xA;        axzoom.set_xlim(x - 0.1, x + 0.1)&#xA;        axzoom.set_ylim(y - 0.1, y + 0.1)&#xA;    fig.canvas.draw()&#xA;&#xA;fig.canvas.mpl_connect('motion_notify_event', onpress)&#xA;fig.canvas.mpl_connect('button_press_event', onpress)&#xA;fig.canvas.mpl_connect('button_release_event', onpress)&#xA;show()"/>
  </charts>
</scave:Analysis>
