<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<analysis version="2">
    <inputs>
        <input pattern="/resultfiles/routing/Net5SaturatedQueue-*.vec"/>
        <input pattern="/resultfiles/routing/Net5SaturatedQueue-*.sca"/>
    </inputs>
    <charts>
        <chart name="" script="import results&#10;import operations as ops&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;try:&#10;    import seaborn as sbs&#10;    sbs.set()&#10;except:&#10;    # this is optional&#10;    pass &#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;    (attr:experiment(Net5SaturatedQueue) AND attr:replication(#0))&#10;AND&#10;    (name(txBytes:vector) OR name(rxBytes:vector))&#10;AND&#10;(&#10;  module(Net5.rte[2].queue[3]) OR&#10;  module(Net5.rte[2].queue[3])&#10;)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;df = results.transform_results(df)&#10;&#10;# You can perform any transformations on the data here&#10;&#10;# ops.apply(df, ops.vector_mean, lambda r: 'rx' in r.name[4])&#10;# ops.apply(df, ops.vector_sum)&#10;&#10;# df = ops.apply(df, ops.vector_mean)&#10;# df = ops.compute(df, ops.vector_mean)&#10;&#10;# df = ops.apply(df, ops.vector_add, -2000, condition=lambda r: 'rx' in r.name[4])&#10;&#10;# df = ops.apply(df, ops.vector_compare, 1337, less=-1, equal=10, greater=1)&#10;&#10;print(df)&#10;&#10;&#10;# df = ops.apply(df, ops.vector_timewinavg, 10)&#10;# df = ops.compute(df, ops.vector_aggregator, &quot;average&quot;)&#10;&#10;df = ops.compute(df, ops.vector_merger)&#10;&#10;&quot;&quot;&quot;&#10;import traceback&#10;try:&#10;    avgt, avgv = ops.apply(df, ops.vector_aggregator, &quot;count&quot;)&#10;    mint, minv = ops.apply(df, ops.vector_aggregator, &quot;minimum&quot;)&#10;    maxt, maxv = ops.apply(df, ops.vector_aggregator, &quot;maximum&quot;)&#10;except:&#10;    print(traceback.format_exc())&#10;&#10;plt.plot(avgt, avgv, label=&quot;cnt&quot;)&#10;plt.plot(mint, minv, label=&quot;min&quot;)&#10;plt.plot(maxt, maxv, label=&quot;max&quot;)&#10;&quot;&quot;&quot;&#10;&#10;# df = ops.apply(df, ops.vector_crop, 75, 100)&#10;&#10;# df = ops.apply(df, ops.vector_diffquot)&#10;# df = ops.apply(df, ops.vector_difference)&#10;# df = ops.apply(df, ops.vector_mean)&#10;&#10;# df = ops.apply(df, ops.vector_divide_by, 2000)&#10;&#10;# df = ops.compute(df, ops.vector_divtime)&#10;&#10;# df = ops.apply(df, ops.vector_expression, &quot;t * (y + t * 10)&quot;)&#10;&#10;&quot;&quot;&quot;&#10;df1 = ops.apply(df, ops.vector_integrate, &quot;sample-hold&quot;)&#10;df2 = ops.apply(df, ops.vector_integrate, &quot;backward-sample-hold&quot;)&#10;df3 = ops.apply(df, ops.vector_integrate, &quot;linear&quot;)&#10;&#10;df = df.append(df1)&#10;df = df.append(df2)&#10;df = df.append(df3)&#10;&quot;&quot;&quot;&#10;&#10;# df = ops.compute(df, ops.vector_lineartrend, 100)&#10;&#10;&quot;&quot;&quot;&#10;import traceback&#10;&#10;try:&#10;    mergedt, mergedv = ops.apply(df, ops.vector_merger)&#10;except:&#10;    print(traceback.format_exc())&#10;&#10;plt.plot(mergedt, mergedv, label=&quot;merged&quot;)&#10;&quot;&quot;&quot;&#10;&#10;# # df = ops.apply(df, ops.vector_divide_by, -1)&#10;# df = ops.apply(df, ops.vector_modulo, 1000)&#10;&#10;# df = ops.compute(df, ops.vector_movingavg, 0.1)&#10;&#10;# df = ops.compute(df, ops.vector_multiply_by, 0.1)&#10;&#10;# df = ops.apply(df, ops.vector_removerepeats)&#10;&#10;# df = ops.apply(df, ops.vector_slidingwinavg, 10)&#10;&#10;# df = ops.apply(df, ops.vector_subtractfirstval)&#10;&#10;# df = ops.apply(df, ops.vector_timeavg, &quot;linear&quot;)&#10;&#10;# df = ops.apply(df, ops.vector_timediff)&#10;&#10;# df = ops.apply(df, ops.vector_timeshift, 100)&#10;&#10;# df = ops.apply(df, ops.vector_timetoserial)&#10;&#10;# df = ops.apply(df, ops.vector_timewinavg, 10)&#10;&#10;&#10;# df = ops.apply(df, ops.vector_winavg, 100)&#10;&#10;# print(df.iloc[0][('result','vecvalue')])&#10;&#10;for i, r in df.iterrows():&#10;    # print(r[('result', 'vecvalue')])&#10;    plt.plot(r[('result', 'vectime')], r[('result', 'vecvalue')], label=r[('attr', 'title')] + &quot; (&quot; + r[('attr', 'unit')] + &quot;)&quot;)&#10;&#10;&#10;plt.legend()&#10;#plt.grid()&#10;&#10;plt.tight_layout()&#10;&#10;# Finally, the results are plotted&#10;# chart.plotVectors(df)&#10;" type="MatplotlibChart"/>
        <chart name="" script="import results&#10;import operations as ops&#10;import numpy as np&#10;import matplotlib.pyplot as plt&#10;&#10;&#10;try:&#10;    import seaborn as sbs&#10;    sbs.set()&#10;except:&#10;    # this is optional&#10;    pass &#10;&#10;# This expression selects the results (you might be able to logically simplify it)&#10;filter_expression = &quot;&quot;&quot;&#10;    (attr:experiment(Net5SaturatedQueue) AND attr:replication(#0))&#10;AND&#10;    (name(txBytes:vector) OR name(rxBytes:vector))&#10;AND&#10;(&#10;  module(Net5.rte[2].queue[3]) OR&#10;  module(Net5.rte[2].queue[3])&#10;)&#10;&quot;&quot;&quot;&#10;&#10;# The data is returned as a Pandas DataFrame&#10;df = results.getVectors(filter_expression)&#10;df = results.transform_results(df)&#10;&#10;# You can perform any transformations on the data here&#10;&#10;# ops.apply(df, ops.vector_mean, lambda r: 'rx' in r.name[4])&#10;# ops.apply(df, ops.vector_sum)&#10;&#10;# df = ops.apply(df, ops.vector_mean)&#10;# df = ops.compute(df, ops.vector_mean)&#10;&#10;# df = ops.apply(df, ops.vector_add, -2000, condition=lambda r: 'rx' in r.name[4])&#10;&#10;# df = ops.apply(df, ops.vector_compare, 1337, less=-1, equal=10, greater=1)&#10;&#10;print(df)&#10;&#10;&#10;# df = ops.apply(df, ops.vector_timewinavg, 10)&#10;# df = ops.compute(df, ops.vector_aggregator, &quot;average&quot;)&#10;&#10;df = ops.compute(df, ops.vector_merger)&#10;&#10;&quot;&quot;&quot;&#10;import traceback&#10;try:&#10;    avgt, avgv = ops.apply(df, ops.vector_aggregator, &quot;count&quot;)&#10;    mint, minv = ops.apply(df, ops.vector_aggregator, &quot;minimum&quot;)&#10;    maxt, maxv = ops.apply(df, ops.vector_aggregator, &quot;maximum&quot;)&#10;except:&#10;    print(traceback.format_exc())&#10;&#10;plt.plot(avgt, avgv, label=&quot;cnt&quot;)&#10;plt.plot(mint, minv, label=&quot;min&quot;)&#10;plt.plot(maxt, maxv, label=&quot;max&quot;)&#10;&quot;&quot;&quot;&#10;&#10;# df = ops.apply(df, ops.vector_crop, 75, 100)&#10;&#10;# df = ops.apply(df, ops.vector_diffquot)&#10;# df = ops.apply(df, ops.vector_difference)&#10;# df = ops.apply(df, ops.vector_mean)&#10;&#10;# df = ops.apply(df, ops.vector_divide_by, 2000)&#10;&#10;# df = ops.compute(df, ops.vector_divtime)&#10;&#10;# df = ops.apply(df, ops.vector_expression, &quot;t * (y + t * 10)&quot;)&#10;&#10;&quot;&quot;&quot;&#10;df1 = ops.apply(df, ops.vector_integrate, &quot;sample-hold&quot;)&#10;df2 = ops.apply(df, ops.vector_integrate, &quot;backward-sample-hold&quot;)&#10;df3 = ops.apply(df, ops.vector_integrate, &quot;linear&quot;)&#10;&#10;df = df.append(df1)&#10;df = df.append(df2)&#10;df = df.append(df3)&#10;&quot;&quot;&quot;&#10;&#10;# df = ops.compute(df, ops.vector_lineartrend, 100)&#10;&#10;&quot;&quot;&quot;&#10;import traceback&#10;&#10;try:&#10;    mergedt, mergedv = ops.apply(df, ops.vector_merger)&#10;except:&#10;    print(traceback.format_exc())&#10;&#10;plt.plot(mergedt, mergedv, label=&quot;merged&quot;)&#10;&quot;&quot;&quot;&#10;&#10;# # df = ops.apply(df, ops.vector_divide_by, -1)&#10;# df = ops.apply(df, ops.vector_modulo, 1000)&#10;&#10;# df = ops.compute(df, ops.vector_movingavg, 0.1)&#10;&#10;# df = ops.compute(df, ops.vector_multiply_by, 0.1)&#10;&#10;# df = ops.apply(df, ops.vector_removerepeats)&#10;&#10;# df = ops.apply(df, ops.vector_slidingwinavg, 10)&#10;&#10;# df = ops.apply(df, ops.vector_subtractfirstval)&#10;&#10;# df = ops.apply(df, ops.vector_timeavg, &quot;linear&quot;)&#10;&#10;# df = ops.apply(df, ops.vector_timediff)&#10;&#10;# df = ops.apply(df, ops.vector_timeshift, 100)&#10;&#10;# df = ops.apply(df, ops.vector_timetoserial)&#10;&#10;# df = ops.apply(df, ops.vector_timewinavg, 10)&#10;&#10;&#10;# df = ops.apply(df, ops.vector_winavg, 100)&#10;&#10;# print(df.iloc[0][('result','vecvalue')])&#10;&#10;# for i, r in df.iterrows():&#10;    # print(r[('result', 'vecvalue')])&#10;    # plt.plot(r[('result', 'vectime')], r[('result', 'vecvalue')], label=r[('attr', 'title')] + &quot; (&quot; + r[('attr', 'unit')] + &quot;)&quot;)&#10;&#10;&#10;# plt.legend()&#10;#plt.grid()&#10;&#10;# plt.tight_layout()&#10;&#10;# Finally, the results are plotted&#10;chart.plotVectors(df)&#10;" type="LineChart"/>
    </charts>
</analysis>
