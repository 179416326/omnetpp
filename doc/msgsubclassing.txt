EXPERIMENTAL MESSAGE SUBCLASSING SUPPORT
========================================

The message subclassing compiler is opp_msgc (bin/). It processes .msg files;
see example.msg to get an idea about the possibilities.

samples/dyna2 demonstrates the use of message subclassing:
- dynapacket.msg defines DynaPacket and DynaDataPacket;
- dynapacket_m.h and dynapacket_m.cc are produced by opp_msgc from it, and
  contain the generated DynaPacket and DynaDataPacket C++ classes (plus code
  for Tkenv inspectors);
- other model files (client.cc, server.cc, ...) use the generated message
  classes as any other C++ classes

Message subclassing support is still experimental, details might change
in future versions.

Below you'll find documentation of current state.


MESSAGE SUBCLASSING
===================

Motivation
==========
Formerly, cPars were the only way to add data to message objects. cPars are
fairly complex objects themselves so they add both execution and memory
overhead, and they were also error-prone because cPar objects have to be
added dynamically and individually to each message object.

The solution is to leave out cPar objects, and define new C++ message classes
with the necessary parameters as instance variables. The simulation library
is based on C++, and it is very easy to subclass cMessage:

    class RadioMsg : public cMessage {
      public:
        int freq;
        double power;
        ...
    };

Now it is possible to write code like this:

    RadioMsg *m = new RadioMsg;
    m->freq = 1;
    m->power = 10.0;
    ...

(In practice you'd want to make freq and power private members, and add
get/set methods for accessing them. For good programming style one should
avoid public data members, but as an example it is fine here.)

In one test (slotted Aloha simulation with 10 nodes), the simulation was
8 times faster when using this technique. Of course, if your simulation
doesn't create and destroy many messages (compared to other activities),
you may not benefit this much.

However, you'll notice one drawback of this solution when you try to use
Tkenv for debugging. While cPar-based message parameters can be viewed in
message inspector windows, parameters added by subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because the C++ language
does not support "reflection" (extracting class information, etc.)
like for example Java does.

There is a solution however: you can supply Tkenv with missing "reflection"
information about you new class. An example for the RadioMsg class could
look like this:

    class RadioMsgDescriptor : public Descriptor
    {
      public:
        virtual int getFieldCount() {return 2;}

        virtual const char *getFieldName(int k) {
            const char *fieldname[] = {"freq", "power";}
            if (k<0 || k>=2) return NULL;
            return fieldname[k];
        }

        virtual double getFieldAsDouble(RadioMsg *msg, int k) {
            if (k==0) return msg->freq;
            if (k==1) return msg->power;
            return 0.0; // not found
        }
        //...
    };

Then you have to inform Tkenv that a RadioMsgDescriptor exists and that it
should be used whenever Tkenv finds messages of type RadioMsg (as it is
currently implemented, whenever the object's className() method returns
"RadioMsg"). So when you inspect a RadioMsg in your simulation, Tkenv
can use RadioMsgDescriptor to extract and display the values of the freq
and power variables.

The actual implementation is somewhat more complicated than this, but not
much.

To relieve the simulation programmer from having to write this extra code,
messages are described in a higher-level syntax, and a compiler is used to
generate the necessary C++ code with subclasses of cMessage and cPacket.
The message compiler can add the necessary data members and their get/set
methods. It also generates the necessary reflection code which makes it
possible to inspect message contents in Tkenv.

The original idea is described in:
  http://www.hit.bme.hu/phd/vargaa/omnetpp/subclass.htm

See also the NED II draft at:
  http://www.hit.bme.hu/phd/vargaa/omnetpp/neddraft.htm


Experimental message subclassing
================================
This is an experimental implementation of the message subclassing feature
described above. "Experimental" means that:
 1. The message description syntax and features may change in the future,
    based on feedback from the community;
 2. The compiler that translates message descriptions into C++ is a perl script
    (this is a temporary solution until nedtool becomes stable and tested)

Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a mypacket.msg file with the following contents:

message MyPacket
{
    fields:
       int srcAddress;
       int destAddress;
       int hops = 0;
};

If you process this file with "message subclassing compiler", it will
create the following files for you: mypacket_m.h and mypacket_m.cc.
mypacket_m.h is supposed to be included into your C++ sources
where you want to use ...


The task of the "message subclassing compiler" is to generate C++ classes
you can use from your models as well as "reflection" classes that allow
Tkenv to inspect these data stuctures. From a file called foo.msg,
the compiler will generate the foo_m.h and foo_m.cc files. You'll need to
#include foo_m.h into your C++ sources to be able to use the generated
classes. The foo_m.cc file contains implementation of the generated classes
as well as "reflection" code that (at some point in the future) will allow
you to inspect these data stuctures from the Tkenv GUI. The foo_m.cc file
should be compiled and linked into you simulation (the generated makefile
will take care of this).


Features in nutshell
====================
You're strongly advised to experiment with the source and always check out
the generated code!!!

For lack of time, syntax is not described here -- you should study the
example.msg file instead!  What you find here however is very brief
explanations of certain keywords or features you find in example.msg.

1. cppinclude directive:

 cppinclude "mystuff.h"

Adds a C++ #include to the generated header file.
This is likely to change to something like this in the future:

 cplusplus {
 #include "mystuff.h"
 }

2. enums:
An enum {..} generates a normal C++ enum, plus creates an object which stores
textual representations of the constants. The object makes it possible to
display symbolic names in Tkenv.
An example:

 // create an enum
 enum ProtocolTypes
 {
    IP = 1;
    TCP = 2;
 };

It is possible to "extend" an enum with new values.

 // add new values to ProtocolTypes
 enum MoreProtocolTypes extends ProtocolTypes
 {
    CLNP = 3;
    TP4 = 4;
 };

What is generated from this???

3. class, message declarations:
Different flavours of the same thing -- generated data classes with associated
descriptor objects which make them inspectable in Tkenv.
- class: class (default base class: none [NOT cObject!!!])
- message: class (default base class: cMessage)
- struct: public data members instead of set/get methods
Slightly different code is generated for classes that are rooted in cObject
than for those that are not. (For the latter, no className() or dup() method
is generated, and the constructor doesn't have the 'name' argument.)


4. struct declarations:
Generated structs have public data members instead of set/get methods.
They have no virtual functions (no vtable!). Inheritance is supported, but
"generation gap" or virtual fields are not (they build upon virtual functions).


5. fields, properties sections within the class/message/struct declarations:
fields section: data members to be generated.
properties section: contains meta info that affects how generated code will
look like.


6. 'customize' property (true/false):
When set, the 'generation gap' pattern is used which allows the programmer
to customize the generated class by redefining virtual member functions.


7. announcing your C++ types to the compiler
Announcement of all types unknown to msgc is mandatory. Use the struct, cobject,
noncobject keywords.
Examples:
  struct IPAddress;
  cobject PayloadPacket;
Types announced this way are assumed to have NO associated descriptor objects.


8. 'abstract' fields:
No data member is generated, and generated getter/setter methods are pure
virtual. Purpose is to allow the programmer to store the value of this field
in whatever way he/she wants. Assumes that the class has the 'customize'
property set.
Example:
   abstract int a;


9. enum declarations for fields:
It is possible to tell the message compiler if an integral field will take
values from an enum.
Example:
   int p enum(ProtocolTypes);



-----------------------------
//
// An example to the experimental message subclassing support. This file has
// to be processed by opp_msgc which generates C++ classes you can use from
// your models, as well as "reflection" classes that allow Tkenv to inspect
// these data stuctures.
//
// Check doc/msgsubclassing.txt for more information.
//
// The syntax and features shown in this file are all experimental.
// Feedback is welcome!
//


// necessary #includes for the
cppinclude <stdio.h>
cppinclude "mystuff.h"

// announce types that come from included C++ code
struct IPAddress;
cobject BasicPacket;
cobject PayloadPacket;
noncobject mystringclass;

// imports are not yet supported :-(
import "othermsgs.msg";

// create an enum
enum ProtocolTypes
{
    IP = 1;
    TCP = 2;
};

// add new values to ProtocolTypes
enum MoreProtocolTypes extends ProtocolTypes
{
    CLNP = 3;
    TP4 = 4;
};

// message object
message FooPacket extends BasicPacket
{
    fields:
        char type='x';
        IPAddress *x;
        short version=2;
        int protocolId enum(ProtocolTypes);
        bool hasPayload;
        long length;
        long route[4];
        string host[];
        IPAddress src;
        IPAddress dest;
        PayloadPacket payload[];
};

// demonstrate subclassing
message BarPacket extends FooPacket
{
    properties:
        customize = true;
    fields:
        int hopcount;
        double delay;
        abstract int myvar;
};

// class without base class (NOT derived from cObject!)
class MyClass
{
    properties:
        customize = true;
    fields:
        abstract char type='x';
        abstract short version=2;
};

// class not derived from cObject
class MyDerivedClass extends MyClass
{
    fields:
        char bla='x';
        short blabla=2;
};

// class derived from cObject
class MyCObjectClass extends cObject
{
    fields:
        char type='x';
        short version=2;
        mystringclass dunno;
};

// plain C struct (public members, no getter/setter methods, etc)
struct MyStruct
{
    fields:
        char array[10];
        char vect[];
        short version;
};


// inheritance with structs
struct MyDerivedStruct extends MyStruct
{
    fields:
        char code;
        short prot enum(ProtocolTypes); 
        MyStruct substruct;  // also as embedded data member
};


