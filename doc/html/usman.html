<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>OMNeT++ - Manual</TITLE>
   <META NAME="Author" CONTENT="Andras Varga">
</HEAD>

<style type="text/css">

H1 {
color: #006f00;
}

H2 {
color: #006f00;
}

H3 {
color: #006f00;
}

.subheading {
color: black;
font-weight: bold;
}

</style>

<BODY TEXT="#000000" BGCOLOR="#FFFFE8" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<P><FONT COLOR="#FF0000"><B><FONT SIZE=+4>OMNeT++ </FONT></B>
<I><FONT SIZE=+1>Discrete Event Simulation System</FONT></I></FONT></P>

<!--
<br>
<P><FONT SIZE=-1>Note: HTML rendering of this manual is not 100% -- use PDF when in doubt</FONT></P>
-->
<H1><B>User Manual</B></H1><H3>OMNeT++ version 2.3</H3><H1>Chapters</H1>
<B><A HREF="#toc_1.">1. Introduction</A></B><BR>
<B><A HREF="#toc_2.">2. Overview</A></B><BR>
<B><A HREF="#toc_3.">3. An Example: The Nim Game</A></B><BR>
<B><A HREF="#toc_4.">4. The NED Language</A></B><BR>
<B><A HREF="#toc_5.">5. Simple Modules</A></B><BR>
<B><A HREF="#toc_6.">6. Messages</A></B><BR>
<B><A HREF="#toc_7.">7. The Simulation Library</A></B><BR>
<B><A HREF="#toc_8.">8. Building Simulation Programs</A></B><BR>
<B><A HREF="#toc_9.">9. Documenting NED and Messages</A></B><BR>
<B><A HREF="#toc_10.">10. Running The Simulation</A></B><BR>
<B><A HREF="#toc_11.">11. Analyzing Simulation Results</A></B><BR>
<B><A HREF="#toc_12.">12. Parallel Execution</A></B><BR>
<B><A HREF="#toc_13.">13. Customization and Embedding</A></B><BR>
<B><A HREF="#toc_14.">14. NED Language Grammar</A></B><BR>
<B><A HREF="#toc_15.">15. References</A></B><BR>
<HR><H1>Table of Contents</H1>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_1."></A><A HREF="#sec100">1. Introduction</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.1."></A><A HREF="#sec101">1.1. What is OMNeT++?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.2."></A><A HREF="#sec102">1.2. Where is OMNeT++ in the world of simulation tools?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.3."></A><A HREF="#sec103">1.3. Organization of this manual</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.4."></A><A HREF="#sec104">1.4. History</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.5."></A><A HREF="#sec105">1.5. Authors</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_2."></A><A HREF="#sec106">2. Overview</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1."></A><A HREF="#sec107">2.1. Modeling concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.1."></A><A HREF="#sec108">2.1.1. Hierarchical modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.2."></A><A HREF="#sec109">2.1.2. Module types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.3."></A><A HREF="#sec110">2.1.3. Messages, gates, links</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.4."></A><A HREF="#sec111">2.1.4. Modeling of packet transmissions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.5."></A><A HREF="#sec112">2.1.5. Parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.6."></A><A HREF="#sec113">2.1.6. Topology description method</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2."></A><A HREF="#sec114">2.2. Programming the algorithms</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.1."></A><A HREF="#sec115">2.2.1. Creating simple modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.2."></A><A HREF="#sec116">2.2.2. Object mechanisms</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.3."></A><A HREF="#sec117">2.2.3. Derive new classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.4."></A><A HREF="#sec118">2.2.4. Self-describing objects to ease debugging</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3."></A><A HREF="#sec119">2.3. Using OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.1."></A><A HREF="#sec120">2.3.1. Building and running simulations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.2."></A><A HREF="#sec121">2.3.2. What is what in the directories</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_3."></A><A HREF="#sec122">3. An Example: The Nim Game</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1."></A><A HREF="#sec123">3.1. Topology</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.2."></A><A HREF="#sec124">3.2. Simple modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.3."></A><A HREF="#sec125">3.3. Running the simulation</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.4."></A><A HREF="#sec126">3.4. Other examples</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_4."></A><A HREF="#sec127">4. The NED Language</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1."></A><A HREF="#sec128">4.1. NED overview</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.1."></A><A HREF="#sec129">4.1.1. Components of a NED description</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.2."></A><A HREF="#sec130">4.1.2. Reserved words</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.3."></A><A HREF="#sec131">4.1.3. Identifiers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.4."></A><A HREF="#sec132">4.1.4. Case sensitivity</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.5."></A><A HREF="#sec133">4.1.5. Comments</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2."></A><A HREF="#sec134">4.2. The import directive</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3."></A><A HREF="#sec135">4.3. Channel definitions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4."></A><A HREF="#sec136">4.4. Simple module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.1."></A><A HREF="#sec137">4.4.1. Simple module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.2."></A><A HREF="#sec138">4.4.2. Simple module gates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5."></A><A HREF="#sec139">4.5. Compound module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.1."></A><A HREF="#sec140">4.5.1. Compound module parameters and gates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.2."></A><A HREF="#sec141">4.5.2. Submodules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.3."></A><A HREF="#sec142">4.5.3. Submodule type as parameter</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.4."></A><A HREF="#sec143">4.5.4. Assigning values to submodule parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.5."></A><A HREF="#sec144">4.5.5. Defining sizes of submodule gate vectors</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.6."></A><A HREF="#sec145">4.5.6. Conditional parameters and gatesizes sections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.7."></A><A HREF="#sec146">4.5.7. Connections</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6."></A><A HREF="#sec147">4.6. Network definitions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7."></A><A HREF="#sec148">4.7. Expressions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.1."></A><A HREF="#sec149">4.7.1. Constants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.2."></A><A HREF="#sec150">4.7.2. Referencing parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.3."></A><A HREF="#sec151">4.7.3. Operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.4."></A><A HREF="#sec152">4.7.4. The <tt>sizeof()</tt> and <tt>index</tt> operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.5."></A><A HREF="#sec153">4.7.5. Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.6."></A><A HREF="#sec154">4.7.6. Random values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7.7."></A><A HREF="#sec155">4.7.7. Defining new functions</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8."></A><A HREF="#sec156">4.8. Display strings</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.1."></A><A HREF="#sec157">4.8.1. Submodule display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.2."></A><A HREF="#sec158">4.8.2. Compound module display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.3."></A><A HREF="#sec159">4.8.3. Connection display strings</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9."></A><A HREF="#sec160">4.9. Parameterized compound modules</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.1."></A><A HREF="#sec161">4.9.1. Examples</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.2."></A><A HREF="#sec162">4.9.2. Design patterns for compound modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.3."></A><A HREF="#sec163">4.9.3. Topology templates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.10."></A><A HREF="#sec164">4.10. Large networks</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.10.1."></A><A HREF="#sec165">4.10.1. Generating NED files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.10.2."></A><A HREF="#sec166">4.10.2. Building the network from C++ code</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11."></A><A HREF="#sec167">4.11. XML support</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.12."></A><A HREF="#sec168">4.12. GNED - Graphical NED Editor</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.12.1."></A><A HREF="#sec169">4.12.1. Comment parsing</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.12.2."></A><A HREF="#sec170">4.12.2. Keyboard and mouse bindings</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_5."></A><A HREF="#sec171">5. Simple Modules</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1."></A><A HREF="#sec172">5.1. Simulation concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.1."></A><A HREF="#sec173">5.1.1. Discrete Event Simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.2."></A><A HREF="#sec174">5.1.2. The event loop</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.3."></A><A HREF="#sec175">5.1.3. Simple modules in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.4."></A><A HREF="#sec176">5.1.4. Events in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.5."></A><A HREF="#sec177">5.1.5. FES implementation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2."></A><A HREF="#sec178">5.2. Packet transmission modeling</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.1."></A><A HREF="#sec179">5.2.1. Delay, bit error rate, data rate</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.2."></A><A HREF="#sec180">5.2.2. Multiple transmissions on links</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3."></A><A HREF="#sec181">5.3. Defining simple module types</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.1."></A><A HREF="#sec182">5.3.1. Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.2."></A><A HREF="#sec183">5.3.2. The module declaration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.3."></A><A HREF="#sec184">5.3.3. Several modules, single NED interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.4."></A><A HREF="#sec185">5.3.4. The class declaration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.5."></A><A HREF="#sec186">5.3.5. Decomposing activity()/handleMessage()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.6."></A><A HREF="#sec187">5.3.6. Using inheritance</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.7."></A><A HREF="#sec188">5.3.7. Global variables</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.4."></A><A HREF="#sec189">5.4. Adding functionality to cSimpleModule</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.4.1."></A><A HREF="#sec190">5.4.1. activity()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.4.2."></A><A HREF="#sec191">5.4.2. handleMessage()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.4.3."></A><A HREF="#sec192">5.4.3. initialize() and finish()</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.5."></A><A HREF="#sec193">5.5. Finite State Machines in OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6."></A><A HREF="#sec194">5.6. Sending and receiving messages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.1."></A><A HREF="#sec195">5.6.1. Sending messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.2."></A><A HREF="#sec196">5.6.2. Broadcasts and retransmissions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.3."></A><A HREF="#sec197">5.6.3. Delayed sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.4."></A><A HREF="#sec198">5.6.4. Direct message sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.5."></A><A HREF="#sec199">5.6.5. Receiving messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.6."></A><A HREF="#sec200">5.6.6. The wait() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.7."></A><A HREF="#sec201">5.6.7. Modeling events using self-messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6.8."></A><A HREF="#sec202">5.6.8. Stopping the simulation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.7."></A><A HREF="#sec203">5.7. Accessing module parameters</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8."></A><A HREF="#sec204">5.8. Accessing gates and connections</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.1."></A><A HREF="#sec205">5.8.1. Gate objects</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.2."></A><A HREF="#sec206">5.8.2. Link parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.3."></A><A HREF="#sec207">5.8.3. Transmission state</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.4."></A><A HREF="#sec208">5.8.4. Connectivity</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.9."></A><A HREF="#sec209">5.9. Walking the module hierarchy</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.10."></A><A HREF="#sec210">5.10. Dynamic module creation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.10.1."></A><A HREF="#sec211">5.10.1. When do you need dynamic module creation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.10.2."></A><A HREF="#sec212">5.10.2. Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.10.3."></A><A HREF="#sec213">5.10.3. Creating modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.10.4."></A><A HREF="#sec214">5.10.4. Deleting modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.10.5."></A><A HREF="#sec215">5.10.5. Module deletion and finish()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.10.6."></A><A HREF="#sec216">5.10.6. Creating connections</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_6."></A><A HREF="#sec217">6. Messages</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1."></A><A HREF="#sec218">6.1. Messages and packets</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.1."></A><A HREF="#sec219">6.1.1. The cMessage class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.2."></A><A HREF="#sec220">6.1.2. Message encapsulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.3."></A><A HREF="#sec221">6.1.3. Information about the last sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.4."></A><A HREF="#sec222">6.1.4. Context pointer</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.5."></A><A HREF="#sec223">6.1.5. Modeling packets and frames</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1.6."></A><A HREF="#sec224">6.1.6. Attaching parameters and objects</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2."></A><A HREF="#sec225">6.2. Message definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.1."></A><A HREF="#sec226">6.2.1. Introduction</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.2."></A><A HREF="#sec227">6.2.2. Declaring enums</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.3."></A><A HREF="#sec228">6.2.3. Message declarations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.4."></A><A HREF="#sec229">6.2.4. Inheritance, composition</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.5."></A><A HREF="#sec230">6.2.5. Using existing C++ types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.6."></A><A HREF="#sec231">6.2.6. Customizing the generated class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.7."></A><A HREF="#sec232">6.2.7. Using STL in message classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.8."></A><A HREF="#sec233">6.2.8. Summary</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2.9."></A><A HREF="#sec234">6.2.9. What else is there in the generated code?</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_7."></A><A HREF="#sec235">7. The Simulation Library</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.1."></A><A HREF="#sec236">7.1. Class library conventions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2."></A><A HREF="#sec237">7.2. Utilities</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3."></A><A HREF="#sec238">7.3. Generating random numbers</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.1."></A><A HREF="#sec239">7.3.1. Random number generators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.2."></A><A HREF="#sec240">7.3.2. Random variates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.3."></A><A HREF="#sec241">7.3.3. Random numbers from histograms</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.4."></A><A HREF="#sec242">7.4. Container classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.4.1."></A><A HREF="#sec243">7.4.1. Queue class: cQueue</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.4.2."></A><A HREF="#sec244">7.4.2. Expandable array: cArray</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.5."></A><A HREF="#sec245">7.5. Non-object container classes</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6."></A><A HREF="#sec246">7.6. The parameter class: cPar</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6.1."></A><A HREF="#sec247">7.6.1. Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6.2."></A><A HREF="#sec248">7.6.2. Random number generation through cPar</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6.3."></A><A HREF="#sec249">7.6.3. Storing object and non-object pointers in cPar</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6.4."></A><A HREF="#sec250">7.6.4. Reverse Polish expressions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6.5."></A><A HREF="#sec251">7.6.5. Using redirection</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6.6."></A><A HREF="#sec252">7.6.6. Type characters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.6.7."></A><A HREF="#sec253">7.6.7. Summary</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.7."></A><A HREF="#sec254">7.7. Routing support: cTopology</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.7.1."></A><A HREF="#sec255">7.7.1. Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.7.2."></A><A HREF="#sec256">7.7.2. Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.7.3."></A><A HREF="#sec257">7.7.3. Shortest paths</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.8."></A><A HREF="#sec258">7.8. Statistics and distribution estimation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.8.1."></A><A HREF="#sec259">7.8.1. cStatistic and descendants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.8.2."></A><A HREF="#sec260">7.8.2. Distribution estimation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.8.3."></A><A HREF="#sec261">7.8.3. The k-split algorithm</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.8.4."></A><A HREF="#sec262">7.8.4. Transient detection and result accuracy</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.9."></A><A HREF="#sec263">7.9. Recording simulation results</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.9.1."></A><A HREF="#sec264">7.9.1. Output vectors: cOutVector</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.9.2."></A><A HREF="#sec265">7.9.2. Output scalars</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.10."></A><A HREF="#sec266">7.10. Tracing and debugging aids</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.10.1."></A><A HREF="#sec267">7.10.1. Displaying information about module activity</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.10.2."></A><A HREF="#sec268">7.10.2. Watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.10.3."></A><A HREF="#sec269">7.10.3. Snapshots</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.10.4."></A><A HREF="#sec270">7.10.4. Breakpoints</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.10.5."></A><A HREF="#sec271">7.10.5. Disabling warnings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.10.6."></A><A HREF="#sec272">7.10.6. Getting coroutine stack usage</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.11."></A><A HREF="#sec273">7.11. Changing the network graphics at run-time</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.11.1."></A><A HREF="#sec274">7.11.1. Setting display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.11.2."></A><A HREF="#sec275">7.11.2. The cDisplayStringParser class</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.12."></A><A HREF="#sec276">7.12. Deriving new classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.12.1."></A><A HREF="#sec277">7.12.1. cObject or not?</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.12.2."></A><A HREF="#sec278">7.12.2. cObject virtual methods</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.12.3."></A><A HREF="#sec279">7.12.3. Class registration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.12.4."></A><A HREF="#sec280">7.12.4. Details</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13."></A><A HREF="#sec281">7.13. Object ownership management</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13.1."></A><A HREF="#sec282">7.13.1. Ownership tree</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13.2."></A><A HREF="#sec283">7.13.2. Purpose</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13.3."></A><A HREF="#sec284">7.13.3. Objects are deleted by their owners</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13.4."></A><A HREF="#sec285">7.13.4. Ownership is managed transparently</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13.5."></A><A HREF="#sec286">7.13.5. Garbage collection</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13.6."></A><A HREF="#sec287">7.13.6. What cQueue and cArray do</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.13.7."></A><A HREF="#sec288">7.13.7. Change of implementation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.14."></A><A HREF="#sec289">7.14. Tips for speeding up the simulation</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_8."></A><A HREF="#sec290">8. Building Simulation Programs</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.1."></A><A HREF="#sec291">8.1. Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2."></A><A HREF="#sec292">8.2. Using Unix and gcc</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.1."></A><A HREF="#sec293">8.2.1. Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.2."></A><A HREF="#sec294">8.2.2. Building simulation models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.3."></A><A HREF="#sec295">8.2.3. Multi-directory models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.4."></A><A HREF="#sec296">8.2.4. Static vs shared OMNeT++ system libraries</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3."></A><A HREF="#sec297">8.3. Using Windows and Microsoft Visual C++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3.1."></A><A HREF="#sec298">8.3.1. Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3.2."></A><A HREF="#sec299">8.3.2. Building simulation models on the command line</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3.3."></A><A HREF="#sec300">8.3.3. Building simulation models from the MSVC IDE</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_9."></A><A HREF="#sec301">9. Documenting NED and Messages</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1."></A><A HREF="#sec302">9.1. Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2."></A><A HREF="#sec303">9.2. Writing the documentation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.1."></A><A HREF="#sec304">9.2.1. Documentation comments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.2."></A><A HREF="#sec305">9.2.2. Text layout and formatting</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.3."></A><A HREF="#sec306">9.2.3. Additional text formatting using HTML</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.4."></A><A HREF="#sec307">9.2.4. Turning off HTML</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.5."></A><A HREF="#sec308">9.2.5. Where to put comments</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.6."></A><A HREF="#sec309">9.2.6. Customizing the title page</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.7."></A><A HREF="#sec310">9.2.7. Adding extra pages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.8."></A><A HREF="#sec311">9.2.8. Incorporating externally created pages</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3."></A><A HREF="#sec312">9.3. Generating HTML</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.1."></A><A HREF="#sec313">9.3.1. Multiple projects</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4."></A><A HREF="#sec314">9.4. How does opp_neddoc work?</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_10."></A><A HREF="#sec315">10. Running The Simulation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1."></A><A HREF="#sec316">10.1. User interfaces</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2."></A><A HREF="#sec317">10.2. The configuration file: omnetpp.ini</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.1."></A><A HREF="#sec318">10.2.1. An example</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.2."></A><A HREF="#sec319">10.2.2. The concept of simulation runs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.3."></A><A HREF="#sec320">10.2.3. File syntax</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.4."></A><A HREF="#sec321">10.2.4. File inclusion</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.5."></A><A HREF="#sec322">10.2.5. Sections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2.6."></A><A HREF="#sec323">10.2.6. The [General] section</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3."></A><A HREF="#sec324">10.3. Cmdenv: the command-line interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.1."></A><A HREF="#sec325">10.3.1. Command-line switches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.2."></A><A HREF="#sec326">10.3.2. Cmdenv ini file options</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.3."></A><A HREF="#sec327">10.3.3. Interpreting Cmdenv output</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.4."></A><A HREF="#sec328">10.4. Tkenv: the graphical user interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.4.1."></A><A HREF="#sec329">10.4.1. Command-line switches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.4.2."></A><A HREF="#sec330">10.4.2. Tkenv ini file settings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.4.3."></A><A HREF="#sec331">10.4.3. Using the graphical environment</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.4.4."></A><A HREF="#sec332">10.4.4. In Memoriam... </A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.5."></A><A HREF="#sec333">10.5. More about omnetpp.ini</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.5.1."></A><A HREF="#sec334">10.5.1. Module parameters in the configuration file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.5.2."></A><A HREF="#sec335">10.5.2. Configuring output vectors</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.5.3."></A><A HREF="#sec336">10.5.3. Display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.5.4."></A><A HREF="#sec337">10.5.4. Specifying seed values</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.6."></A><A HREF="#sec338">10.6. Choosing good seed values: the seedtool utility</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.7."></A><A HREF="#sec339">10.7. Repeating or iterating simulation runs</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.7.1."></A><A HREF="#sec340">10.7.1. Executing several runs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.7.2."></A><A HREF="#sec341">10.7.2. Variations over parameter values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.7.3."></A><A HREF="#sec342">10.7.3. Variations over seed value (multiple independent runs)</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.8."></A><A HREF="#sec343">10.8. Akaroa support: Multiple Replications in Parallel</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.8.1."></A><A HREF="#sec344">10.8.1. Introduction</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.8.2."></A><A HREF="#sec345">10.8.2. What is Akaroa</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.8.3."></A><A HREF="#sec346">10.8.3. Using Akaroa with OMNeT++</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.9."></A><A HREF="#sec347">10.9. Typical problems</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.9.1."></A><A HREF="#sec348">10.9.1. Stack problems</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.9.2."></A><A HREF="#sec349">10.9.2. Memory leaks and crashes</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_11."></A><A HREF="#sec350">11. Analyzing Simulation Results</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.1."></A><A HREF="#sec351">11.1. Output vectors</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2."></A><A HREF="#sec352">11.2. Plotting output vectors with Plove</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.1."></A><A HREF="#sec353">11.2.1. Plove features</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.2."></A><A HREF="#sec354">11.2.2. Usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.3."></A><A HREF="#sec355">11.2.3. Writing filters</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3."></A><A HREF="#sec356">11.3. Format of output vector files</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.4."></A><A HREF="#sec357">11.4. Working without Plove</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.4.1."></A><A HREF="#sec358">11.4.1. Extracting vectors from the file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.4.2."></A><A HREF="#sec359">11.4.2. Using splitvec</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.5."></A><A HREF="#sec360">11.5. Visualization tools</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.5.1."></A><A HREF="#sec361">11.5.1. Grace</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.5.2."></A><A HREF="#sec362">11.5.2. ROOT</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.5.3."></A><A HREF="#sec363">11.5.3. Using Gnuplot</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_12."></A><A HREF="#sec364">12. Parallel Execution</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.1."></A><A HREF="#sec365">12.1. OMNeT++ support for parallel execution</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.1.1."></A><A HREF="#sec366">12.1.1. Introduction to Parallel Discrete Event Simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.1.2."></A><A HREF="#sec367">12.1.2. In work</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_13."></A><A HREF="#sec368">13. Customization and Embedding</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.1."></A><A HREF="#sec369">13.1. Architecture</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.2."></A><A HREF="#sec370">13.2. Embedding OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3."></A><A HREF="#sec371">13.3. Sim: the simulation kernel and class library</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.1."></A><A HREF="#sec372">13.3.1. The global simulation object</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.3.2."></A><A HREF="#sec373">13.3.2. The coroutine package</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.4."></A><A HREF="#sec374">13.4. The Model Component Library</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5."></A><A HREF="#sec375">13.5. Envir, Tkenv and Cmdenv</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.1."></A><A HREF="#sec376">13.5.1. The main() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.2."></A><A HREF="#sec377">13.5.2. The cEnvir interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.3."></A><A HREF="#sec378">13.5.3. Customizing Envir</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.5.4."></A><A HREF="#sec379">13.5.4. Implementation of the user interface: simulation applications</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_14."></A><A HREF="#sec380">14. NED Language Grammar</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_15."></A><A HREF="#sec381">15. References</A></B></FONT><BR>
 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><b>Document History</b>

<p>
<table border>
<TR> <TD align=left>

<p><b>Date</b> </TD> <TD align=left> <b>Author</b> </TD> <TD align=left> <b>Change</b></TD></TR>
<TR> <TD align=left> 2003/06 </TD> <TD align=left> AV </TD> <TD align=left> Mentioned Grace and ROOT in section "Visualizing...".
               Added section "Using STL in message classes".
               </TD></TR>
<TR> <TD align=left> 2003/06 </TD> <TD align=left> AV </TD> <TD align=left> OMNeT++ 2.3 released</TD></TR>
<TR> <TD align=left> 2003/04-06 </TD> <TD align=left> AV </TD> <TD align=left> "Design of OMNeT++" chapter revised, extended, and renamed to
               "Customization and Embedding".
               Added "Interpreting Cmdenv output" section to the
               "Running the Simulation" chapter. Added section about Akaroa
               in "Running the Simulation" chapter. Expanded section about
               writing shell scripts to control the simulation.
               Added background info about RNGs and warning about old RNG
               in "Class Library" chapter;
               revised/extended "Deriving new classes" section in same chapter.
               Bibliography converted to Bibtex, expanded and cleaned up;
               citations added to text.
               "Parallel Simulation" chapter: contents removed until new PDES
               implementation gets released.
               Revised and reorganized NED chapter. Section about message
               sending/receiving and other simple module related functions
               moved to chapter "Simple Modules"; cMessage treatment from
               "Simulation Library" merged with message subclassing chapter
               into new chapter "Messages". Deprecated cPacket.
               Removed sections "Simulation techniques" and
               "Coding conventions", and their useful fragments were incorporated
               elsewhere. Added/created sections about message transmission
               modeling, and using global variables. Added sections explaining
               how to implement broadcasts and retransmissions. Revised section
               about dynamic module creation. Deprecated putaside-queue,
               receiveNew(), receiveOn().
               Added section "Object ownership management"; removed section
               on "Using shared objects". </TD></TR>
<TR> <TD align=left> 2003/03 </TD> <TD align=left> AV </TD> <TD align=left> OMNeT++ 2.3b2 released</TD></TR>
<TR> <TD align=left> 2003/02 </TD> <TD align=left> AV </TD> <TD align=left> OMNeT++ 2.3b1 released</TD></TR>
<TR> <TD align=left> 2003/01 </TD> <TD align=left> AV </TD> <TD align=left> Added chapter about message subclassing; revised chapter about
               running the simulation and incorporated new Cmdenv options; added new
               distributions and clarified many details in NED expr. handling section</TD></TR>
<TR> <TD align=left> Summer 2002 </TD> <TD align=left> Ulrich Kaage </TD> <TD align=left> Converted from Word to LaTeX</TD></TR>
<TR> <TD align=left> 2002/03/18 </TD> <TD align=left> AV </TD> <TD align=left> Documented new ini file options about Envir plugins</TD></TR>
<TR> <TD align=left> 2002/01/24 </TD> <TD align=left> AV </TD> <TD align=left> Refinements on the Parsec chapter</TD></TR>
<TR> <TD align=left> 2001/10/23 </TD> <TD align=left> AV </TD> <TD align=left> Updated to reflect changes since 2.1 release (see include/ChangeLog)</TD></TR>
<TR> <TD align=left> </table>

<p>

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 18 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec100"/>1. Introduction</H1>
<a name="cha:introduction"></a>

<p>
<hr><H2><A NAME="sec101"/>1.1. What is OMNeT++?</H2>

<p>OMNeT++ is an object-oriented modular discrete event simulator.
The name itself stands for Objective Modular Network Testbed
in C++. OMNeT++ has its distant roots in OMNeT, a simulator written
in Object Pascal by dr. Gy&ouml;rgy Pongor.

<p>The simulator can be used for:
<UL>
  <li><strong></strong>traffic modeling of telecommunication networks
  <li><strong></strong>protocol modeling
  <li><strong></strong>modeling queueing networks
  <li><strong></strong>modeling multiprocessors and other distributed hardware systems
  <li><strong></strong>validating hardware architectures
  <li><strong></strong>evaluating performance aspects of complex software systems
  <li><strong></strong>... modeling any other system where the discrete event approach is
    suitable.
</UL>

<p>
An OMNeT++ model consists of hierarchically nested modules. The
depth of module nesting is not limited, which allows the user
to reflect the logical structure of the actual system in the
model structure. Modules communicate with message passing. Messages
can contain arbitrarily complex data structures. Modules can
send messages either directly to their destination or along a
predefined path, through gates and connections.

<p>
Modules can have parameters which are used for three main purposes:
to customize module behaviour; to create flexible model topologies
(where parameters can specify the number of modules, connection
structure etc); and for module communication, as shared variables.

<p>Modules at the lowest level of the module hierarchy are to be
provided by the user, and they contain the algorithms in the
model. During simulation execution, simple modules appear to
run in parallel, since they are implemented as coroutines (sometimes
termed lightweight processes). To write simple modules, the user
does not need to learn a new programming language, but he/she
is assumed to have some knowledge of C++ programming.

<p>OMNeT++ simulations can feature different user interfaces for
different purposes: debugging, demonstration and batch execution.
Advanced user interfaces make the inside of the model visible
to the user, allow him/her to start/stop simulation execution
and to intervene by changing variables/objects inside the model.
This is very important in the development/debugging phase
of the simulation project. User interfaces also facilitate demonstration
of how a model works.

<p>The simulator as well as user interfaces and tools are portable:
they are known to work on Windows and on several Unix flavours,
using various C++ compilers.

<p>OMNeT++ also supports parallel simulation (as of OMNeT++ 2.3,
currently this feature is currently being redesigned.)

<p>

<p>
<hr><H2><A NAME="sec102"/>1.2. Where is OMNeT++ in the world of simulation tools?</H2>

<p>There are numerous network simulation tools on the market today,
both commercial and non-commercial. In this section I will try
to give an overview by picking some of the most important or
most representative ones in both categories and comparing them
to OMNeT++: PARSEC, SMURPH, NS, Ptolemy, NetSim++, C++SIM, CLASS
as non-commercial, and OPNET, COMNET III as commercial tools.
(The OMNeT++ Home Page contains a list of Web sites with collections
of references to network simulation tools where the reader can
get a more complete list.) In the commercial category, OPNET
is widely held to be the state of the art in network simulation.
OMNeT++ is targeted at roughly the same segment of network simulation
as OPNET.&nbsp;

<p>
Seven issues are examined to get an overview about the network
simulation tools:

<p>
<STRONG>Detail Level</STRONG>. <EM>Does the simulation tool have the necessary
power to express details in the model?</EM> In other words, can the
user implement arbitrary new building blocks like in OMNeT++
or he is confined to the predefined blocks implemented by the
supplier? Some tools like COMNET III are not programmable by
the user to this extent therefore they cannot be compared to
OMNeT++. Specialized network simulation tools like NS (for IP)
and CLASS (for ATM) also rather fall into this category.

<p>
<STRONG>Available Models.</STRONG> <EM>What protocol models are readily available
for the simulation tool?</EM> On this point, non-commercial simulation
tools cannot compete with some commercial ones (especially OPNET)
which have a large selection of ready-made protocol models. OMNeT++
is no exception.

<p>
<STRONG>Defining Network Topology</STRONG>. <EM>How does the simulation
  tool support defining the network topology?</EM> Is it possible to
create some form of hierarchy (nesting) or only ``flat'' topologies
are supported? Network simulation tools naturally share the property
that a model (network) consists of ``nodes'' (blocks, entities,
modules, etc.) connected by ``links'' (channels, connections, etc.).
Many commercial simulators have graphical editors to define the
network; however, this is only a good solution if there is an
alternative form of topology description (e.g. text file) which allows
one to generate the topology by program. OPNET follows a unique way:
the network topology is stored in a proprietary binary file format
which can be generated (and read) by the graphical editor and C
programs linked against a special library. On the other hand, most
non-commercial simulation tools do not provide explicit support for
topology description: one must program a ``driver entity'' which will
boot the model by creating the necessary nodes and interconnecting
them (PARSEC, SMURPH, NS). Finally, a large part of the tools that do
support explicit topology description supports only flat topologies
(CLASS). OMNeT++ probably uses the most flexible method: it has a
human-readable textual topology description format (the NED language)
which is easy to create with any text-processing tool (<tt>perl</tt>,
<tt>awk</tt>, etc.), and the same format is used by the graphical
editor. It is also possible to create a ``driver entity'' to build a
network at run-time by program. OMNeT++ also supports submodule
nesting.

<p>
<STRONG>Programming Model.</STRONG> <EM>What is the programming model supported
by the simulation environment?</EM> Network simulators typically use
either thread/coroutine-based programming (such as <tt>activity()</tt>
in OMNeT++), or FSMs built upon a <tt>handleMessage()</tt>-like function.
For example, OPNET, SMURPH and NetSim++ use FSMs (with underlying
handleMessage()), PARSEC and C++SIM use threads. OMNeT++ supports
both programming models; the author does not know of another
simulation tool that does so.

<p>
<STRONG>Debugging and Tracing Support.</STRONG> <EM>What debugging or tracing
facilities does the simulation tool offer?</EM> Simulation programs
are infamous for long debugging periods. C++-based simulation
tools rarely offer much more than <tt>printf()</tt>-style debugging; often
the simulation kernel is also capable of dumping selected debug
information on the standard output. Animation is also often supported,
either off-line (record&amp;playback) or in some client-server architecture,
where the simulation program is the ``server'' and
it can be viewed using the ``client''. Off-line animation
naturally lacks interactivity and is therefore little use in
debugging. The client-server solution typically has limited power
because the simulation and the viewer run as independent operating
system processes, and the viewer has limited access to the simulation
program's internals and/or it does not have enough control over
the course of simulation execution. OPNET has a very good support
for command-line debugging and provides both off-line and client-server
style animation. NetSim++ and Ptolemy use the client-server method
of animation. OMNeT++ goes a different way by linking the GUI
library with the debugging/tracing capability into the simulation
executable. This architecture enables the GUI to be very powerful:
every user-created object is visible (and modifiable) in the
GUI via inspector windows and the user has tight control over
the execution. To the author's best knowledge, the tracing feature
OMNeT++ provides is unique among the C++-based simulation tools.

<p>
<STRONG>Performance.</STRONG> <EM>What performance can be expected from the
simulation?</EM> Simulation programs typically run for several hours.
Probably the most important factor is the programming language;
almost all network simulation tools are C/C++-based. Performance
is a particularly interesting issue with OMNeT++ since the GUI
debugging/tracing support involves some extra overhead in the
simulation library. However, in a reported case, an OMNeT++ simulation
was only 1.3 slower than its counterpart implemented in plain
C (i.e. one containing very little administration overhead),
which is a very good showing. A similar result was reported in
a performance comparison with a PARSEC simulation.

<p>
<STRONG>Source Availability.</STRONG> <EM>Is the simulation library available
in source?</EM> This is a trivial question but it immediately becomes
important if one wants to examine or teach the internal workings
of a simulation kernel, or one runs into trouble because some
function in the simulation library has a bug and/or it is not
documented well enough. In general it can be said that non-commercial
tools (like OMNeT++) are open-source and commercial ones are
not. This is also true for OPNET: the source for simulation kernel
is not available (although the ready-made protocol models come
with sources).

<p>
In conclusion, it can be said that OMNeT++ has enough features
to make it a good alternative to most network simulation tools,
and it has a strong potential to become one of the most widely
used network simulation packages in academic and research environments.
The most serious shortcoming is the lack of available protocol
models, but since this is mostly due to the fact that it is a
relatively new simulation tool, with the help of the OMNeT++
user community the situation is likely to become much better
in the future.

<p>

<p>

<p><hr><H2><A NAME="sec103"/>1.3. Organization of this manual</H2>

<p>The manual is organized around the following topics:
<UL>
  <li><strong></strong>The Chapters <a href="#cha:introduction">[click]</a>, <a href="#cha:overview">[click]</a> and
    <a href="#cha:the-nim-game">[click]</a> contain introductory material: some
    overview and an example simulation.
  <li><strong></strong>The second group of Chapters, <a href="#cha:the-ned-language">[click]</a>,
    <a href="#cha:simple-modules">[click]</a> and <a href="#cha:the-simulation-library">[click]</a> are
    the programming guide. They present the NED language, the
    simulation concepts and their implementation in OMNeT++, explain
    how to write simple modules and describe the class library.
  <li><strong></strong>The following chapters,
    <a href="#cha:building-simulation-programs">[click]</a>,
    <a href="#cha:running-the-simulation">[click]</a> and
    <a href="#cha:analyzing-simulation-results">[click]</a> deal with practical issues
    like building and running simulations and analyzing results, and
    present the tools OMNeT++ has to support these tasks.
  <li><strong></strong>Chapter <a href="#cha:parallel-execution">[click]</a> is devoted to the support
    for distributed execution.
  <li><strong></strong>Finally, Chapter <a href="#cha:the-design-of-omnet">[click]</a> explains the
    architecture and the internals of OMNeT++. This chapter will be
    useful to those who want to extend the capabilities of the
    simulator or want to embed it into a larger application.
  <li><strong></strong>Appendice <a href="#cha:ned-language-grammar">[click]</a> provides a reference
    of the NED language.
</UL>

<p>

<p>
<hr><H2><A NAME="sec104"/>1.4. History</H2>

<p>The development of OMNeT++ started as a semester's programming
assignment at the Technical University of Budapest (BME) in 1992.
The assignment (``creation of an object-oriented discrete event
simulation system in C++'') was handed out by Prof. Dr Gy&ouml;rgy
Pongor, and two students signed up: &Aacute;kos Kun and Andr&aacute;s Varga.
The basis for the design was Mr. Pongor's existing simulation
software written in Pascal, named OMNeT.

<p>We started developing the code in Borland C++ 3.1. The idea
of multiple runtime environments, a significant addition to the
original OMNeT design, was there from the very beginning.
We used Turbo Vision (Borland's then successful character-based
GUI) for the first `graphical' user interface.

<p>In 1992, we submitted a paper about OMNeT++ to the
student's annual university conference
(named ``TDK'') and won first prize in the ``Software'' section.
Later we also won 1st prize in the national ``TDK''. Then the
idea came to port OMNeT++ to Unix (first for AIX on an RS/6000
with only 16MB RAM, later Linux), until all development was done
in Linux and BC3.1 could no longer be supported.

<p>Well, here's a brief list of events since then - maybe one time
I'll make up my mind to enhance them to a whole story...

<p>1994: XEnv (a GUI in pure MOTIF, superceded by Tkenv by now)
was written as diploma work

<p>1994: used OPNET for several simulation projects. OPNET features
(and flaws) gave lots of ideas how to continue with OMNeT++.

<p>1995: initial version of nedc was written by a group of exchange
students from Delft

<p>1996: initial version of PVM support was programmed by Zoltan
Vass as diploma work

<p>1997: started working on Tkenv

<p>1997 Dec: added GNED

<p>1997 Sept: web site set up, first public release

<p>1997 Feb-1998 Sept: simulation projects for a small company in
Hungary. We used a version of OMNeT++.

<p>1998 March: added Plove

<p>1998 June: animation implemented in Tkenv

<p>1998 Sept-1999 May: work at MeTechnology (later Brokat) in Leipzig

<p>2000 Jan: MSVC porting

<p>2000 Sept: contributed model repository set up

<p>2000: IP-suite created in Karlsruhe

<p>2001 June: the CVS is hosted in Karlsruhe

<p>...

<p>

<p>

<p><hr><H2><A NAME="sec105"/>1.5. Authors</H2>

<p>OMNeT++ has been developed mostly by Andr&aacute;s Varga at the Technical
University of Budapest, Department of Telecommunications (BME-HIT).

<p>  Andr&aacute;s Varga    BME-HIT, andras@omnetpp.org

<p>
Since leaving the university in 1998, I've been doing the development
in my free time.

<p>Several people have worked for shorter periods (1..3 months)
on different topics within OMNeT++. Credit for organizing this
goes to Dr. Gy&ouml;rgy Pongor (BME-HIT, <a href="mailto:pongor@hit.bme.hu">pongor@hit.bme.hu</a>), my
advisor at the University. Here is a more-or-less complete list
of people:

<p>Old NED compiler, 1992-93:<br>
  &Aacute;kos Kun    BME

<p>JAR compiler (now called NEDC), sample simulations; summer 1995:<br>
  Jan Heijmans    TU Delft<br>
  Alex Paalvast    TU Delft<br>
  Robert van der Leij  TU Delft

<p>New feaures, testing, new examples; fall 1995:<br>
  Maurits Andr&eacute;    TU Delft, M.J.A.Andre@twi.tudelft.nl<br>
  George van Montfort  TU Delft, G.P.R.vanMontfort@twi.tudelft.nl<br>
  Gerard van de Weerd  TU Delft, G.vandeweerd@twi.tudelft.nl

<p>JAR (NEDC) support for distributed execution:<br>
  G&aacute;bor Lencse    BME-HIT, lencse@hit.bme.hu

<p>PVM support (as final project), spring 1996:<br>
  Zolt&aacute;n Vass    BME-HIT

<p>P<sup>2</sup>, k-split algorithms and more, from fall 1996:<br>
  Babak Fakhamzadeh  TU Delft

<p>
We have to mention Dr. Leon Rothkranz from the Technical University
of Delft whose work made it possible for the Delft students to
come to Budapest in 1995.

<p>Several bugfixes and valuable suggestions for improvements came
from the user community of OMNeT++. It would be impossible to
mention everyone here, and the list is constantly growing -
instead, the README file contains acknowledgements to those I
can remember.

<p>Since the summer of 2001, the OMNeT++ sources are kept in the
CVS server at the University of Karlsruhe. Credit for setting
up and maintaining the CVS server goes to Ulrich Kaage.

<p>The starting point of this manual was the 1995 report of Jan
Heijmans, Alex Paalvast and Robert van der Leij.

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec106"/>2. Overview</H1>
<a name="cha:overview"></a>

<p>
<hr><H2><A NAME="sec107"/>2.1. Modeling concepts</H2>

<p>OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are:
<UL>
<li><strong></strong>hierarchically nested modules
<li><strong></strong>modules are instances of module types
<li><strong></strong>modules communicate with messages through channels
<li><strong></strong>flexible module parameters
<li><strong></strong>topology description language
</UL>

<p><H3><A NAME="sec108"/>2.1.1. Hierarchical modules</H3>

<p>
An OMNeT++ model consists of hierarchically nested
modules which communicate with messages.
OMNeT++ models are often referred to as <EM>networks</EM>. The top
level module is the <EM>system module</EM>.  The system module
contains <EM>submodules</EM>, which can also contain submodules
themselves (Fig. <a href="#fig:ch-overview:modules">[click]</a>). The depth of module
nesting is not limited; this allows the user to reflect the logical
structure of the actual system in the model structure.

<p>
<DIV ALIGN=center>
<img src="figures/usmanFig2.gif">
<center><i>Figure: Simple and compound modules</i></center>
<a name="fig:ch-overview:modules"></a>
</DIV>

<p>

<p>Modules that contain submodules are termed <EM>compound
  modules</EM>, as opposed <EM>simple
  modules</EM> which are at the lowest level of the
module hierarchy. Simple modules contain the algorithms in the model.
The user implements the simple modules in C++, using the OMNeT++
simulation class library.

<p>
<H3><A NAME="sec109"/>2.1.2. Module types</H3>


<p>Both simple and compound modules are instances of <EM>module
  types</EM>. While describing the model, the user defines module types;
instances of these module types serve as components for more complex
module types. Finally, the user creates the system module as an
instance of a previously defined module type; all modules of the
network are instantiated as submodules and sub-submodules of the
system module.

<p>
When a module type is used as a building block, there is no
distinction whether it is a simple or a compound module. This allows
the user to split a simple module into several
simple modules embedded into a compound module,
or vica versa, aggregate the functionality of a compound module into a
single simple module, without affecting existing users of the module
type.

<p>
Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <EM>component libraries</EM>. This feature
will be discussed later, in Chapter <a href="#cha:running-the-simulation">[click]</a>.

<p>

<p><H3><A NAME="sec110"/>2.1.3. Messages, gates, links</H3>

<p>Modules communicate by exchanging
<EM>messages</EM>. In an actual simulation,
messages can represent frames or packets in a computer network, jobs
or customers in a queuing network or other types of mobile entities.
Messages can contain arbitrarily complex data structures. Simple
modules can send messages either directly to their destination or
along a predefined path, through gates and connections.

<p>
The ``local simulation time'' of a module advances when the module
receives a message. The message can arrive from another module
or from the same module (<EM>self-messages</EM> are used to implement
timers).

<p>
<EM>Gates</EM> are the input and output interfaces of
modules; messages are sent out through output gates and arrive through
input gates.

<p>Each <EM>connection</EM> (also called
<EM>link</EM>) is created within a single level of the
module hierarchy: within a compound module, one can connect the
corresponding gates of two submodules, or a gate of one submodule and
a gate of the compound module (Fig.
<a href="#fig:ch-overview:connections">[click]</a>).

<p>
<DIV ALIGN=center>
<img src="figures/usmanFig3.gif">
<center><i>Figure: Connections</i></center>
<a name="fig:ch-overview:connections"></a>
</DIV>

<p>
Due to the hierarchical structure of the model, messages typically
travel through a series of connections, to start and arrive in simple
modules. Such series of connections that go from simple module to
simple module are called <EM>routes</EM>.  Compound modules act as
`cardboard boxes' in the model, transparently relaying messages
between their inside and their outside world.

<p>
<H3><A NAME="sec111"/>2.1.4. Modeling of packet transmissions</H3>

<p>Connections can be assigned three parameters which facilitate
the modeling of communication networks, but can be useful for
other models too: <EM>propagation delay</EM>, <EM>bit error rate</EM>
and <EM>data rate</EM>, all three being optional. One can specify
link parameters individually for each connection, or define link types
and use them throughout the whole model.

<p>Propagation delay is the amount of time the arrival of
the message is delayed by when it travels through the channel.

<p>Bit error rate speficifies the probability that a bit is incorrectly
transmitted, and allows for simple noisy channel modelling.

<p>Data rate is specified in bits/second, and it is used for calculating
transmission time of a packet.

<p>When data rates are in use, the sending of the message in the model
corresponds to the transmission of the first bit, and
the arrival of the message corresponds to the reception
of the last bit. This model is not always applicable,
for example protocols like Token Ring and FDDI do not wait
for the frame to arrive in its entirety, but rather start repeating
its first bits soon after they arrive - in other words,
frames ``flow through'' the stations, being delayed only a few bits.
If you want to model such networks, the data rate modeling feature
of OMNeT++ cannot be used.

<p>

<p><H3><A NAME="sec112"/>2.1.5. Parameters</H3>



<p>Modules can have parameters. Parameters are used for three purposes:
<OL>
  <li><strong></strong>to parameterize module topology
  <li><strong></strong>to customize simple module behaviour
  <li><strong></strong>for module communication, as shared variables
</OL>

<p>Parameters can take string, numeric or pointer values; numeric
values include expressions using other parameters and calling
C functions, random variables from different distributions, and
values input interactively by the user.

<p>
Numeric-valued parameters can be used to construct topologies in a
flexible way. Within a compound module, parameters can define the
number of submodules, number of gates, and the way the internal
connections are made.

<p>
Compound modules can pass parameters or expressions of parameters
to their submodules. Parameter passing can be done by value or
by reference.

<p>During simulation execution, if a module changes the value of
a parameter taken by reference, the changed value propagates
to other modules. This effect can be used to tune the model or
as a second means of module communication.

<p>
<H3><A NAME="sec113"/>2.1.6. Topology description method</H3>

The user defines the structure of the model in NED language descriptions
(Network Description).The NED language will be discussed in detail
in Chapter <a href="#cha:the-ned-language">[click]</a>.

<p>
<hr><H2><A NAME="sec114"/>2.2. Programming the algorithms</H2>

<p>The simple modules of a model contain the algorithms as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.

<p>
OMNeT++ supports a process-style description method for describing
activities. During simulation execution, simple module functions
appear to run in parallel, because they are implemented as coroutines
(also termed lightweight processes). Coroutines were chosen because
they allow an intuitive description of the algorithm and they
can also serve as a good basis for implementing other description
methods like state-transition diagrams or Petri nets.

<p>OMNeT++ has a consistent object-oriented design. One can freely
use OOP concepts (inheritance, polymorphism etc) to extend the
functionality of the simulator.

<p>Elements of the simulation (messages, modules, queues etc.) are
represented as objects. These classes are part of the simulation
class library:
<UL>
<li><strong></strong>modules, gates, connections etc.
<li><strong></strong>parameters
<li><strong></strong>messages
<li><strong></strong>container classes (e.g. queue, array)
<li><strong></strong>data collection classes
<li><strong></strong>statistic and distribution estimation classes (histograms, $P^2$
algorithm for calculating quantiles etc.)
<li><strong></strong>transient detection and result accuracy detection classes
</UL>

<p>The objects are designed so that they can efficiently work together,
creating a powerful framework for simulation programming.

<p>
<H3><A NAME="sec115"/>2.2.1. Creating simple modules</H3>


<p>Each simple module type is implemented with a C++ class. Simple
module classes are derived from a simple module base class, by
redefining the virtual function that contains the algorithm.
The user can add other member functions to the class to split
up a complex algorithm; he can also add data members to the class.

<p>It is also possible to derive new simple module classes from
existing ones. For example, if one wants to experiment with retransmission
timeout schemes in a transport protocol, he can implement the
protocol in one class, create a virtual function for the retransmission
algorithm and then derive a family of classes that implement
concrete schemes. This concept is further supported by the fact
that in the network description, actual module types can be parameters.

<p>
<H3><A NAME="sec116"/>2.2.2. Object mechanisms</H3>

<p>The use of smart container classes allows the user to build
<EM>aggregate data structures</EM>.
For example, one can add any number of objects to a message object as
parameters. Since the added objects can contain further objects,
complex data structures can be built.

<p>There is an efficient <EM>ownership</EM> mechanism
built in. The user can specify an owner for each object; then, the
owner object will have the responsibility of destroying that object.
Most of the time, the ownership mechanism works transparently;
ownership only needs to be explicitly managed when the user wants to
do something non-typical.

<p>
The <EM>foreach</EM> mechanism allows one to
enumerate the objects inside a container object in a uniform way and
do some operation on them. This feature which makes it possible to
handle many objects together. (The <EM>foreach</EM> feature is extensively used
by the user interfaces with debugging capability and the snapshot
mechanism; see later.)

<p>
<H3><A NAME="sec117"/>2.2.3. Derive new classes</H3>

<p>It most cases, the functionality offered by the OMNeT++ classes
is enough for the user. But if it is needed, one can derive new
classes from the existing ones or create entirely new classes.
For flexibility, several member functions are declared virtual.
When the user creates new classes, certain rules need to be kept
so that the object can fully work together with other objects.

<p>
<H3><A NAME="sec118"/>2.2.4. Self-describing objects to ease debugging</H3>


<p>The class library is designed so that objects can give textual
information about themselves. This makes it possible to peek
into a running simulation program: through an appropriate user
interface, one can examine (and modify) the internal data structures
of a running simulation. This feature helps the user to get some
insight what is happening inside the model and get hands-on experience.

<p>
A unique feature called <EM>snapshot</EM> allows the
user to dump the contents of the simulation model or a part of it into
a text file. The file will contain textual reports about every object;
this can be of invaluable help at times of debugging. Ordinary
variables can also be made to appear in the snapshot file. Snapshot
creations can be scheduled from within the simulation program or done
from the user interface.

<p>

<p><hr><H2><A NAME="sec119"/>2.3. Using OMNeT++</H2>

<p>
<H3><A NAME="sec120"/>2.3.1. Building and running simulations</H3>



<p>This section gives some idea how to work with OMNeT++ in practice:
issues like model files, compiling and running simulations are
discussed.

<p>An OMNeT++ model consists of the following parts:
<UL>
  <li><strong></strong>NED language topology description(s) which
    describe the module structure with parameters, gates etc. They are
    files with .ned suffix. NED files can be written with any text
    editor or using the GNED graphical editor.
  <li><strong></strong> Simple modules sources. They are C++ files, with <SAMP>.h</SAMP>/<SAMP>.cc</SAMP> suffix.
</UL>

<p>The simulation system provides the following components:
<UL>
  <li><strong></strong>Simulation kernel. This contains the
    code that manages the simulation and the simulation class library.
    It is written in C++, compiled and put together to form a library
    (a file with .a or .lib extension)
  <li><strong></strong>User interfaces.
    \indexuser interface|seesimulation interface OMNeT++ user interfaces
    are used with simulation execution, to facilitate debugging,
    demonstration, or batch execution of simulations. There are
    several user interfaces, written in C++, compiled and put together
    into libraries (<SAMP>.a</SAMP> or <SAMP>.lib</SAMP> files).
</UL>

<p>
Simulation programs are built from the above components. First, the
NED files are compiled into C++ source code, using
the NEDC\indexned!compiler compiler which is part of OMNeT++. Then
all C++ sources are compiled and linked with the simulation kernel and
a user interface to form a simulation executable.

<p>
<br><P class="subheading">Running the simulation and analyzing the results</P>

<p>The simulation executable is a standalone program,
thus it can be run on other machines without OMNeT++ or the model files
being present. When the program is started, it reads in a configuration
file (usually called
<SAMP>omnetpp.ini</SAMP>); it contains settings that
control how the simulation is run, values for model parameters, etc.
The configuration file can also prescribe several simulation runs; in
the simplest case, they will be executed by the simulation program one
after another.

<p>The output of the simulation is written into data files: output vector
files, output scalar files
, and possibly the user's own output files.
OMNeT++ provides a GUI tool named Plove to view and plot the contents
of output vector files. But it is not expected that someone will
process the result files using OMNeT++ alone: output files are text
files in a format which (maybe after some preprocessing using
<tt>sed</tt>, <tt>awk</tt> or <tt>perl</tt>) can be read into math
packages like Matlab or its free equivalent Octave, or imported into
spreadsheets like Excel. All these external programs have rich
functionality for statistical analysis and visualization, and OMNeT++
does not try to duplicate their efforts. This manual briefly describes
some data plotting programs and how to use them with OMNeT++.

<p>
<br><P class="subheading">User interfaces</P>


<p>The primary purpose of user interfaces is to make the inside
of the model visible to the user, to start/stop simulation execution,
and possibly allow the user intervene by changing variables/objects
inside the model. This is very important in the development/debugging
phase of the simulation project. Just as important, a hands-on
experience allows the user to get a `feel' about the model's
behaviour. A nice graphical user interface can also be used to
demonstrate how the model works internally.

<p>
The same simulation model can be executed with different user
interfaces, without any change in the model files themselves.
The user would test and debug the simulation with a powerful
graphical user interface, and finally run it with a simple and
fast user interface that supports batch execution.

<p>
<br><P class="subheading">Component libraries</P>


<p>Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create component libraries.

<p>
<br><P class="subheading">Universal standalone simulation programs</P>

<p>
A simulation executable can store several independent models
that use the same set of simple modules. The user can specify
in the configuration file which model he/she wants to run. This
allows one to build one large executable that contains several
simulation models, and distribute it as a standalone simulation
tool. The flexibility of the topology description language also
supports this approach.

<p>
<H3><A NAME="sec121"/>2.3.2. What is what in the directories</H3>

<p>To help you navigate among files in the OMNeT++ distribution,
here's a list what you can find in the different directories.

<p>The <SAMP>omnetpp</SAMP> directory contains the following subdirectories.

<p>The simulation system itself:

<p><pre>
  <b>omnetpp/</b>         OMNeT++ root directory
    <b>bin/</b>           OMNeT++ executables (GNED, nedc, etc.)
    <b>include/</b>       header files for simulation models
    <b>lib/</b>           library files
    <b>bitmaps/</b>       icons that can be used in network graphics
    <b>doc/</b>           manual (PDF), readme, license, etc.
      <b>html/</b>        manual in HTML
       <b>api/</b>        API reference in HTML
       <b>nedxml-api/</b> API reference for the NEDXML library
    <b>src/</b>           OMNeT++ sources
      <b>nedc/</b>        NED compiler
      <b>sim/</b>         simulation kernel
        <b>std/</b>       files for non-distributed execution
        <b>pvm/</b>       files for distributed execution over PVM
        <b>mpi/</b>       files for distributed execution using MPI
      <b>envir/</b>       common code for user interfaces
      <b>cmdenv/</b>      command-line user interface
      <b>tkenv/</b>       Tcl/Tk-based user interface
      <b>gned/</b>        graphical NED editor
      <b>plove/</b>       output vector analyzer and plotting tool
      <b>nedxml/</b>      NEDXML library (experimental)
      <b>utils/</b>       makefile-autocreator etc
    <b>test/</b>          regression test suite
      <b>distrib/</b>     regression test suite for built-in distributions
</pre>

<p>There is a tutorial, contributed by Nick van Foreest

<p><pre>
    <b>tutorial/</b>    the tutorial document
      <b>queues/</b>    sample simulation that supports the tutorial
      <b>doc_src/</b>   the Latex sources for the tutorial doc
</pre>

<p>Sample simulations are within the <SAMP>samples</SAMP> directory. Each of the
sample directories contain a network description (.ned file) and
corresponding simple module code (<SAMP>.h</SAMP>, <SAMP>.cc</SAMP> files).
Makefiles are included.

<p><pre>
    <b>samples/</b>     directories for sample simulations
      <b>aloha/</b>     models the Aloha protocol
      <b>cqn/</b>       Closed Queueing Network
      ...
</pre>

<p>
The <SAMP>contrib</SAMP> directory contains material from the OMNeT++ community.

<p><pre>
    <b>contrib/</b>     directory for contributed material
      <b>octave/</b>    Octave scripts for result processing
      <b>emacs/</b>     NED syntax highlight for Emacs
</pre>

<p>You may also find additional directories like <SAMP>msvc/</SAMP>, which contain
integration components for Microsoft Visual C++, etc.

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb  2 2004</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jan 21 2004</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec122"/>3. An Example: The Nim Game</H1>
<a name="cha:the-nim-game"></a>

<p>
This chapter contains a full example program that can give you
some basic idea of using the simulator. An enhanced version of
the Nim example can be found among the sample programs.

<p>Nim is an ancient game with two players and a bunch of sticks.
The players take turns, removing 1, 2, 3 or 4 sticks from the
heap of sticks at each turn. The one who takes the last stick
is the loser.

<p>
Of course, building a model of the Nim game is not much of a
simulation project, but it nicely demonstrates the modeling approach
used by OMNeT++.

<p>
Describing the model consists of two phases:
<UL>
<li><strong></strong>topology description
<li><strong></strong>defining the operation of components
</UL>

<p>

<p><hr><H2><A NAME="sec123"/>3.1. Topology</H2>

<p>The game can be modelled in OMNeT++ as a network with three modules:
the ``game'' (a manager module) and two players.
The modules will communicate by exchanging messages. The ``game''
module keeps the current number of tokens and organizes the game;
in each turn, the player modules receives the number of tokens
from the Game module and sends back its move.

<p>
<DIV ALIGN=center>
<img src="figures/usmanFig6.gif">
<center><i>Figure: Module structure for the Nim game.</i></center>
</DIV>

<p>
<SAMP>Player1</SAMP>, <SAMP>Player2</SAMP> and <SAMP>Game</SAMP> are simple
modules (e.g. they have no submodules.) Each module is an instance of
a module type. We'll need a module type to represent the <SAMP>Game</SAMP> module;
let's call it <SAMP>Game</SAMP> too.

<p>We can implement two kinds of players: <SAMP>SmartPlayer</SAMP>, which knows
the winning algorithm, and <SAMP>SimplePlayer</SAMP>, which simply takes a
random number of sticks. In our example, <SAMP>Player1</SAMP> will be a <SAMP>SmartPlayer</SAMP>
and <SAMP>Player2</SAMP> will be a <SAMP>SimplePlayer</SAMP>.

<p>The enclosing module, <SAMP>Nim</SAMP> is a compound module (it has submodules).
It is also defined as a module type of which one instance is
created, the system module.

<p>Modules have input and output gates (the tiny boxes
labeled <SAMP>in</SAMP>, <SAMP>out</SAMP>, <SAMP>fromPlayer1</SAMP>, etc. in the
figure). An input and an output gate can be connected: connections (or
links) are shown as in the figure as arrows.  During the simulation,
modules communicate by sending messages through the connections.

<p>
The user defines the topology of the network in NED files.

<p>
We placed the model description in two files; the first file
defines the simple module types and the second one the system
module.

<p>The first file (NED keywords are typed in boldface):

<p><pre>
//-
// file: nim_mod.ned
// Simple modules in nim.ned
//-

<p>
// Declaration of simple module type Game.

<p><STRONG>simple</STRONG> Game
    <STRONG>parameters</STRONG>:
         numSticks, // initial number of sticks
         firstMove; // 1=Player1, 2=Player2

<p>    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>:
             fromPlayer1, // input and output gates
             fromPlayer2; // for connecting to Player1/Player2
        <STRONG>out</STRONG>:
             toPlayer1,
             toPlayer2;
<STRONG>endsimple</STRONG>

<p>
// Now the declarations of the two simple module types.
// Any one of the two types can be Player1 or Player2.

<p>// A player that makes random moves
<STRONG>simple</STRONG> SimplePlayer
    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>: in; // gates for connecting to Game
        <STRONG>out</STRONG>: out;
<STRONG>endsimple</STRONG>

<p>// A player who knows the winning algorithm
<STRONG>simple</STRONG> SmartPlayer
    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>: in; // gates for connecting to Game
        <STRONG>out</STRONG>: out;
<STRONG>endsimple</STRONG>
</pre>

<p>The second file:

<p><pre>
//-
// file: nim.ned
// Nim compound module + system module
//-

<p><STRONG>import</STRONG> "nim_mod";

<p><STRONG>module</STRONG> Nim
    <STRONG>submodules</STRONG>:
        game: Game
            <STRONG>parameters</STRONG>:
                numSticks = intuniform(21, 31),
                firstMove = intuniform(1, 2);
        player1: SmartPlayer;
        player2: SimplePlayer;
    <STRONG>connections</STRONG>:
        player1.out -&gt; game.fromPlayer1,
        player1.in &lt;- game.toPlayer1,
        player2.out -&gt; game.fromPlayer2,
        player2.in &lt;- game.toPlayer2;
<STRONG>endmodule</STRONG>

<p>// system module creation
<STRONG>network</STRONG>
    nim: Nim
<STRONG>endnetwork</STRONG>
</pre>

<p>

<p><hr><H2><A NAME="sec124"/>3.2. Simple modules</H2>

<p>The module types <SAMP>SmartPlayer</SAMP>, <SAMP>SimplePlayer</SAMP> and <SAMP>Game</SAMP> are implemented
in C++, using the OMNeT++ library classes and functions.

<p>Each simple module type is derived from the C++
class <tt>cSimpleModule</tt>, with its <tt>activity()</tt> member
function redefined. The <tt>activity()</tt> functions of all
simple modules in the network are executed as
coroutines, so they appear as if they were running in
parallel.  Messages are instances of the class <tt>cMessage</tt>.

<p>We present here the C++ sources of the <SAMP>SmartPlayer</SAMP> and <SAMP>Game</SAMP> module
types.

<p>The <SAMP>SmartPlayer</SAMP> first introduces himself by sending its name
to the <SAMP>Game</SAMP> module. Then it enters an infinite loop; with each
iteration, it receives a message from <SAMP>Game</SAMP> with the number of
sticks left, it calculates its move and sends back a message
containing the move.

<p>Here's the source:

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#include &lt;omnetpp.h&gt;

// derive SmartPlayer from cSimpleModule
class SmartPlayer : public cSimpleModule
{
    Module_Class_Members( SmartPlayer, cSimpleModule, 8192)
    // this is a macro; it expands to constructor definition etc.
    // 8192 is the size for the coroutine stack (in bytes)

virtual void activity();
    // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( SmartPlayer );

// define operations of SmartPlayer
void SmartPlayer::activity()
{
    int move;

    // initialization phase: send module type to Game module
    // create a message with the name "SmartPlayer" and send it to Game

    cMessage *msg = new cMessage("SmartPlayer");
    send(msg, "out");

    // infinite loop to process moves;
    // simulation will be terminated by Game

    for (;;)
    {
        // messages have several fields; here, we'll use the message
        // kind member to store the number of sticks
        cMessage *msgin = receive();    // receive message from Game
        int numSticks = msgin-&gt;kind();  // extract message kind (an int)
                                        // it hold the number of sticks
                                        // still on the stack
        delete msgin;                   // dispose of the message

        move = (numSticks + 4) % 5;     // calculate move
        if (move == 0)                  // we cannot take zero
            move = 1;                   // seems like we going to lose

        ev &lt;&lt; "Taking " &lt;&lt; move         // some debug output. The ev
           &lt;&lt; " out of " &lt;&lt; numSticks   // object represents the user
           &lt;&lt; " sticks.\n";             // interface of the simulator

        cMessage *msgout = new cMessage;// create empty message
        msgout-&gt;setKind( move );        // use message kind as storage
                                        // for move
        send( msgout, "out"); // send the message to Game
    }
}
</pre>
<p>
The <SAMP>Game</SAMP> module first waits for a message from both players
and extracts the message names that are also the players' names.  Then
it enters a loop, with the <SAMP>playerToMove</SAMP> variable
alternating between 1 and 2. With each iteration, it sends out a
message with the current number of sticks to the corresponding player
and gets back the number of sticks taken by that player. When the
sticks are out, the module announces the winner and ends the
simulation.

<p>The source:

<p>
<pre>
//-------------------------------------------------------------
// file: game.cc
// (part of NIM - an OMNeT++ demo simulation)
//-------------------------------------------------------------

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;omnetpp.h&gt;

// derive Game from cSimpleModule
class Game : public cSimpleModule
{
    Module_Class_Members(Game,cSimpleModule,8192)
      // this is a macro; it expands to constructor definition etc.
      // 8192 is the size for the coroutine stack (in bytes)

    virtual void activity();
      // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( Game );

// operation of Game:
void Game::activity()
{
    // strings to store player names; player[0] is unused
    char player[3][32];

    // read parameter values
    int numSticks = par("numSticks");
    int playerToMove = par("firstMove");

    // waiting for players to tell their names
    for (int i=0; i&lt;2; i++)
    {
        cMessage *msg = receive();
        if (msg-&gt;arrivedOn("fromPlayer1"))
            strcpy( player[1], msg-&gt;name());
        else
            strcpy( player[2], msg-&gt;name());
        delete msg;
    }

    // ev represents the user interface of the simulator
    ev &lt;&lt; "Let the game begin!\n";
    ev &lt;&lt; "Player 1: " &lt;&lt; player[1] &lt;&lt; "   Player 2: " &lt;&lt; player[2]
       &lt;&lt; "\n\n";

    do
    {
        ev &lt;&lt; "Sticks left: " &lt;&lt; numSticks &lt;&lt; "\n";
        ev &lt;&lt; "Player " &lt;&lt; playerToMove &lt;&lt; " ("
           &lt;&lt; player[playerToMove] &lt;&lt; ") to move.\n";

        cMessage *msg = new cMessage("", numSticks);
                        // numSticks will be the msg kind

        if (playerToMove == 1)
            send(msg, "toPlayer1");
        else
            send(msg, "toPlayer2");

        msg = receive();
        int sticksTaken = msg-&gt;kind();
        delete msg;

        numSticks -= sticksTaken;

        ev &lt;&lt; "Player " &lt;&lt; playerToMove &lt;&lt; " ("
           &lt;&lt; player[playerToMove] &lt;&lt; ") took "
           &lt;&lt; sticksTaken &lt;&lt; " stick(s).\n";

        playerToMove = 3 - playerToMove;
    }
    while (numSticks&gt;0);

    ev &lt;&lt; "\nPlayer " &lt;&lt; playerToMove &lt;&lt; " ("
       &lt;&lt; player[playerToMove] &lt;&lt; ") won!\n";

    endSimulation();
}
</pre>

<p>

<p>
<hr><H2><A NAME="sec125"/>3.3. Running the simulation</H2>

<p>Once the source files are ready, one needs to compile and link
them into a simulation executable. One can specify the user interface
to be linked.

<p>Before running the simulation, one can put parameter values and
all sorts of other settings into an initialization file that
will be read when the simulation program starts:

<p>

<pre>
#
# file: omnetpp.ini
#

[General]
network = nim
random-seed = 3
ini-warnings = false

[Cmdenv]
express-mode = no
</pre>
<p>
Suppose we link the Nim simulation with the command line user
interface. We get the executable <tt>nim</tt> (<tt>nim.exe</tt> under Windows).
When we run it, we'll get the following screen output:

<pre>
% ./nim
</pre>
<p>
Or:

<pre>
C:\OMNeT++\samples\nim&gt; nim

OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Preparing for Run #1...
Setting up network `nim'...
Running simulation...

Let the game begin!
Player 1: SmartPlayer Player 2: SimplePlayer

Sticks left: 29
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 2 out of 29 sticks.
Player 2 (SimplePlayer) took 2 stick(s).
Sticks left: 27
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 1 out of 27 sticks.
Player 1 (SmartPlayer) took 1 stick(s).
Sticks left: 26
[...]
Sticks left: 5
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 4 out of 5 sticks.
Player 1 (SmartPlayer) took 4 stick(s).
Sticks left: 1
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 1 out of 1 sticks.
Player 2 (SimplePlayer) took 1 stick(s).

Player 1 (SmartPlayer) won!
&lt;!&gt; Module nim.game: Simulation stopped with endSimulation().

End run of OMNeT++
</pre>
<p>

<p>
<hr><H2><A NAME="sec126"/>3.4. Other examples</H2>

<p>An enhanced version of the Nim example can be found among the sample
programs. It adds a third, interactive player and derives specific
player types from a <SAMP>Player</SAMP> abstract class. It also adds the
possibility that actual types for <SAMP>player1</SAMP> and
<SAMP>player2</SAMP> can be specified in the ini file or interactively
entered by the user at the beginning of the simulation.

<p>Nim does not show very much of how complex algorithms like communication
protocols can be implemented in OMNeT++. To have an idea about
that, look at the Token Ring example. It is also extensively
commented, though you may need to peep into the user manual to
fully understand it. The Dyna simulation models a simple
client-server network and demonstrates dynamic module creation.
The FDDI example is an accurate FDDI MAC simulation
which was written on the basis of the ANSI standard.

<p>
The following table summarizes the sample simulations:

<p><table border>
<TR> <TD align=left>

<p><STRONG>NAME</STRONG> </TD> <TD align=left> <STRONG>TOPIC</STRONG> </TD> <TD align=left> <STRONG>DEMONSTRATES</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>nim</STRONG> </TD> <TD align=left> a simple two-player game
</TD> <TD align=left>
 module inheritance;
module type as parameter</TD></TR>
<TR> <TD align=left> <STRONG>hcube</STRONG>
</TD> <TD align=left>
 hypercube network with deflection routing
</TD> <TD align=left>
 hypercube topology with dimension as parameter;
topology templates;
output vectors</TD></TR>
<TR> <TD align=left> <STRONG>token</STRONG> </TD> <TD align=left> Token Ring network
</TD> <TD align=left>
 ring topology with the number of nodes as parameter;
using <tt>cQueue</tt>;
<tt>wait()</tt>;
output vectors</TD></TR>
<TR> <TD align=left> <STRONG>fifo1</STRONG> </TD> <TD align=left> single-server queue
</TD> <TD align=left>
 simple module inheritance;
decomposing <tt>activity()</tt> into several functions;
using simple statistics and output vectors;
printing stack usage info to help optimize memory consumption;
using <tt>finish()</tt></TD></TR>
<TR> <TD align=left> <STRONG>fifo2</STRONG> </TD> <TD align=left> another fifo implementation
</TD> <TD align=left>
 using <tt>handleMessage()</tt>;
decomposing <SAMP>handleMessage()</SAMP> into several functions;
the FSM macros;
simple module inheritance;
using simple statistics and output vectors;
using <SAMP>finish()</SAMP></TD></TR>
<TR> <TD align=left> <STRONG>fddi</STRONG> </TD> <TD align=left> FDDI MAC simulation
</TD> <TD align=left>
 using statistics classes;
and many other features</TD></TR>
<TR> <TD align=left> <STRONG>hist</STRONG> </TD> <TD align=left> demo of the histogram classes
</TD> <TD align=left>
 collecting observations into statistics objects;
saving statistics objects to file and restoring them</TD></TR>
<TR> <TD align=left> <STRONG>dyna</STRONG> </TD> <TD align=left> a client-server network
</TD> <TD align=left>
 dynamic module creation;
using <tt>WATCH()</tt>;
star topology with the number of modules as parameters</TD></TR>
<TR> <TD align=left> <STRONG>topo</STRONG> </TD> <TD align=left> various topologies
</TD> <TD align=left>
 using NED for creating parametrized topologies</TD></TR>
<TR> <TD align=left> <STRONG>demo</STRONG> </TD> <TD align=left> tour of OMNeT++ samples </TD> <TD align=left> shows how to link several sim. models into one executable</TD></TR>
</table>

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec127"/>4. The NED Language</H1>
<a name="cha:the-ned-language"></a>

<p>
<hr><H2><A NAME="sec128"/>4.1. NED overview</H2>

<p>The topology of a model is specified using
the NED language.
The NED language supports modular
description of a network. This means that a network
description consists of a number of
component descriptions (channels,
simple/compound module
types). The channels, simple modules and compound
modules of one network description can be reused in another network
description. As a consequence, the NED language makes it possible for
users to build their own module libraries.

<p>Files containing network descriptions generally have a <SAMP>.ned</SAMP>
suffix.  NED files are not used directly: they are
translated into C++ code by the NEDC compiler, then compiled by the
C++ compiler and linked into the simulation executable.

<p>The EBNF description of the language can be found in Appendix
<a href="#cha:ned-language-grammar">[click]</a>.

<p>
<H3><A NAME="sec129"/>4.1.1. Components of a NED description</H3>


<p>A NED description can contain the following components, in arbitrary
number or order:
<UL>
  <li><strong></strong>import directives
  <li><strong></strong>channel definitions
  <li><strong></strong>simple and compound module definitions
  <li><strong></strong>network definitions
</UL>

<p>
<H3><A NAME="sec130"/>4.1.2. Reserved words</H3>


<p>The writer of the network description has to take care that no
reserved words are used for names. The reserved words of the
NED language are:
<pre>
  import include channel endchannel simple endsimple module endmodule
  error delay datarate const parameters gates submodules connections
  gatesizes on if machines for do endfor network endnetwork nocheck
  ref ancestor true false like input numeric string bool char
</pre>

<p>
<H3><A NAME="sec131"/>4.1.3. Identifiers</H3>


<p>Identifiers are the names of modules, channels, networks,
submodules, parameters, gates, channel attributes and functions.

<p>Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and the underscore ``_''.
Identifiers may only begin with a letter or the underscore.
If you want to begin an identifier with a digit, prefix the name
you'd like to have with an underscore, e.g. <tt>_3Com</tt>.

<p>If you have identifiers that are composed of several words, the convention
is to capitalize the beginning of every word. Also, it is recommended
that you begin the names of modules, channels and networks with
a capital letter, and the names of parameters, gates and submodules
with a lower-case letter. Underscores are rarely used.

<p>
<H3><A NAME="sec132"/>4.1.4. Case sensitivity</H3>


<p>The network description and all identifiers in it are case sensitive.
For example, <tt>TCP</tt> and <tt>Tcp</tt> are two different names.

<p>
<H3><A NAME="sec133"/>4.1.5. Comments</H3>

<p>

<p>Comments can be placed anywhere in the NED file, with the usual C++
syntax: comments begin with a double slash `//', and last until
the end of the line. Comments are ignored by the NED compiler.

<p>It is planned that future OMNeT++ versions will use comments
for documentation generation, much like JavaDoc or Doxygen.

<p>
<hr><H2><A NAME="sec134"/>4.2. The import directive</H2>

<p>


<p>The <tt>import</tt> directive
is used to import declarations from another network description file.
After importing a network description, one can use the components
(channels, simple/compound module types) defined in it.

<p>When a file is imported, only the declaration information is used.
Also, importing a <tt>.ned</tt> file does not cause that file to be compiled
with the NED compiler when the parent file is NEDC compiled, i.e.,
one must compile and link all network description files -
not only the top-level ones.

<p>You can specify the name of the files with or without the
<SAMP>.ned</SAMP> extension. You can also include a path in the
filenames, or better, use the NEDC compiler's
<tt>-I &lt;path&gt;</tt> command-line option to name the directories where the
imported files reside.

<p>Example:

<p><pre>
<b>import</b> "ethernet";   // imports ethernet.ned
</pre>

<p>

<p>
<hr><H2><A NAME="sec135"/>4.3. Channel definitions</H2>

<p>





<p>A channel definition specifies a connection type of given characteristics.
The channel name can be used later in the NED description to
create connections with these parameters.

<p>The syntax:

<p><pre>
<b>channel</b> ChannelName
    //...
<b>endchannel</b>
</pre>

<p>Three attributes can be assigned values in the body of the channel declaration,
all of them optional: <tt>delay</tt>, <tt>error</tt> and <tt>datarate</tt>.
<tt>delay</tt> is the propagation delay in (simulated) seconds;
<tt>error</tt> is the bit error rate that speficifies the probability
that a bit is incorrectly transmitted; and <tt>datarate</tt>
is the channel bandwidth in bits/second, used for calculating
transmission time of a packet. The attributes can appear
in any order.

<p>The values must be constants, or expressions that do not contain
external references (e.g. names of module parameters).
If you assign a random-valued expression (e.g. <tt>truncnormal(0.005,0.001)</tt>),
it will be evaluated and a new random number generated for each
packet transmission.

<p>Example:

<p><pre>
<b>channel</b> DialUpConnection
    <b>delay</b> normal (0.004, 0.0018)
    <b>error</b> 0.00001
    <b>datarate</b> 14400
<b>endchannel</b>
</pre>

<p>

<p><hr><H2><A NAME="sec136"/>4.4. Simple module definitions</H2>

<p>
Simple modules are the basic building blocks for other (compound)
modules. Simple module types are identified by names.
By convention, module names begin with upper-case letters.

<p>A simple module is defined by
declaring its parameters and
gates.

<p>Simple modules are declared with the following syntax:

<p><pre>
<b>simple</b> SimpleModuleName
    <b>parameters</b>:
        //...
    <b>gates</b>:
        //...
<b>endsimple</b>
</pre>

<p>

<p><H3><A NAME="sec137"/>4.4.1. Simple module parameters</H3>
<a name="sec:ch-ned-lang:simple-module-param"></a>

<p>

<p>Parameters are variables that belong to a module. Simple module
parameters can be queried and used by simple module algorithms.
For example, a module called <SAMP>TrafficGen</SAMP> may have a parameter
called <tt>numOfMessages</tt> that determines how many messages it
should generate.

<p>Parameters are identified by names.
By convention, parameter names begin with lower-case letters.

<p>Parameters are declared by listing their names in the
parameters: section of a
module description. The parameter type can optionally be specified as
<tt>numeric</tt>, <tt>numeric const</tt>
(or simply <tt>const</tt>),
<tt>bool</tt>, <tt>string</tt>, or
<tt>anytype</tt>.

<p>
Example:

<p><pre>
<b>simple</b> TrafficGen
    <b>parameters</b>:
        interArrivalTime,
        numOfMessages : <b>const</b>,
        address : <b>string</b>;
    <b>gates</b>: //...
<b>endsimple</b>
</pre>

<p>If the parameter type is omitted, <tt>numeric</tt>
is assumed. Practically, this means that you only need to explicitly
specify the type for string, bool or char-valued parameters.

<p>Note that the actual parameter values are given later, when the module
is used as a building block of a compound module type or as a system
module.

<p>
<br><P class="subheading">Const parameters</P>
<a name="sec:ch-ned-lang:const"></a>



<p>When you declare a parameter to be <tt>const</tt>,
it will be evaluated and replaced by the resulting constant value
at the beginning of the simulation. This can be important when the
original value was a random number or an
expression. One is advised to write out the
<tt>const</tt> keyword for each parameter that
should be constant.

<p>Beware when using <tt>const</tt> and by-reference
parameter passing (<tt>ref</tt> modifier, see later)
at the same time. Converting the parameter to constant can affect
other modules and cause errors that are difficult to discover.

<p>

<p>
<H3><A NAME="sec138"/>4.4.2. Simple module gates</H3>
<a name="sec:ch-ned-lang:simple-module-gates"></a>

<p>


<p>Gates are the connection points of modules. The starting and
ending points of the connections between modules are gates. OMNeT++
supports simplex (one-directional) connections, so there are
two kinds of gates: input and output. Messages are sent through
output gates and received through input gates.

<p>Gates are identified with their names.
By convention, gate names begin with lower-case letters.

<p>Gate vectors are supported: a gate vector
contains a number of single gates.

<p>Gates are declared by listing their names in the
<tt>gates:</tt> section of a module description. An
empty bracket pair [] denotes a gate vector.
Elements of the vector are numbered starting with zero.

<p>Examples:

<p><pre>
<b>simple</b> DataLink
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>:  fromPort, fromHigherLayer;
        <b>out</b>: toPort, toHigherLayer;
<b>endsimple</b>

<p><b>simple</b> RoutingModule
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>:  output[];
        <b>out</b>: input[];
<b>endsimple</b>
</pre>

<p>The sizes of gate vectors are given later, when the module is used as
a building block of a compound module type. Thus, every instance of
the module can have gate vectors of different sizes.

<p>

<p>

<p><hr><H2><A NAME="sec139"/>4.5. Compound module definitions</H2>

<p>
Compound modules are modules composed of one or more submodules.
Any module type (simple or compound module) can be used as a submodule.
Like simple modules, compound modules can also have gates and parameters,
and they can be used wherever simple modules can be used.

<p>It is useful to think about compound modules as ``cardboard boxes''
that help you organize your simulation model and bring structure into
it. No active behaviour is associated with compound modules - they
are simply for grouping modules into larger components that can
can be used either as a model (see section <a href="#sec:ch-ned-lang:network">[click]</a>)
or as a building block for other compound modules.

<p>By convention, module type names (and so compound module type names, too)
begin with upper-case letters.

<p>Submodules may use parameters of the compound module.
They may be connected with each other and/or with
the compound module itself.

<p>A compound module definition looks
similar to a simple module definition:
it has <SAMP>gates</SAMP> and <SAMP>parameters</SAMP> sections.
There are two additional sections, <SAMP>submodules</SAMP> and
<SAMP>connections</SAMP>.

<p>The syntax for compound modules is the following:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        //...
    <b>gates</b>:
        //...
    <b>submodules</b>:
        //...
    <b>connections</b>:
        //...
<b>endmodule</b>
</pre>

<p>All sections (<SAMP>parameters</SAMP>, <SAMP>gates</SAMP>, <SAMP>submodules</SAMP>,
<SAMP>connections</SAMP>) are optional.

<p>

<p><H3><A NAME="sec140"/>4.5.1. Compound module parameters and gates</H3>

<p>Parameters and gates 
for compound modules are declared and work in the same way
as with simple modules, described in sections
<a href="#sec:ch-ned-lang:simple-module-param">[click]</a>
and <a href="#sec:ch-ned-lang:simple-module-gates">[click]</a>.

<p>Typically, compound module parameters are passed to submodules and
used for initializing their parameters.

<p>Parameters can also be used in defining the internal structure of
the compound module: the number of submodules, gate vector sizes
can be define with the help of parameters, and parameters can
also be used in defining the connections inside the compound module.
As a practical example, you can create a <tt>Router</tt> compound module
with a variable number of ports, specified in a <tt>numOfPorts</tt> parameter.

<p>Parameters affecting the internal structure should always be declared
<tt>const</tt>, so that accessing them always yields the same value.
(Otherwise, if the parameter was assigned a random value, one could
get a different value each time the parameter is accessed during building
the internals of the compound module, which is surely not what was meant.)

<p>Example:

<p><pre>
<b>module</b> Router
    <b>parameters</b>:
        packetsPerSecond : <b>numeric</b>,
        bufferSize : <b>numeric</b>,
        numOfPorts : <b>const</b>;
    <b>gates</b>:
        <b>in</b>: inputPort[];
        <b>out</b>: outputPort[];
    <b>submodules</b>: //...
    <b>connections</b>: //...
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec141"/>4.5.2. Submodules</H3>

<p>Submodules are defined in the
<tt>submodules:</tt> section of a compound
module declaration. Submodules are identified by names.
By convention, submodule names begin with lower-case letters.

<p>Submodules are instances of a module type, either simple
or compound - there is no distinction. The module type
must be known to the NED compiler, that is, it must have appeared
earlier in the same NED file or have been imported from another
NED file.

<p>It is possible to define vectors of submodules, and the
size of the vector may come from a parameter value.

<p>When defining submodules, you can assign values to their
parameters, and if the corresponding module type has gate vectors,
you have to specify their sizes.

<p>
Example:

<p><pre>
<b>module</b> CompoundModuleName
    //...
    <b>submodules</b>:
        submodule1: ModuleType1
            <b>parameters</b>:
                //...
            <b>gatesizes</b>:
                //...
        submodule2: ModuleType2
            <b>parameters</b>:
                //...
            <b>gatesizes</b>:
                //...
<b>endmodule</b>
</pre>

<p>
<br><P class="subheading">Module vectors</P>

<p>
It is possible to create an array of
submodules (a module
vector).  This is done with an expression between
brackets right behind the module type name. The expression can refer
to module parameters. A zero value as module count is also allowed.

<p>Example:

<p><pre>
<b>module</b> BigCompoundModule
    <b>parameters</b>:
        size: <b>const</b>;
    <b>submodules</b>:
        submod1: Node[3]
            //...
        submod2: Node[size]
            //...
        submod3: Node[2*size+1]
            //...
<b>endmodule</b>
</pre>

<p>

<p><H3><A NAME="sec142"/>4.5.3. Submodule type as parameter</H3>
<a name="sec:ch-ned-lang:like"></a>


<p>Sometimes it is convenient to make the name of a submodule type a parameter,
so that one can easily `plug in' any module there.

<p>For example, assume the purpose of your simulation study is
to compare different routing algorithms. Suppose you programmed
the needed routing algorithms as simple modules: <SAMP>DistVecRoutingNode</SAMP>,
<SAMP>AntNetRouting1Node</SAMP>, <SAMP>AntNetRouting2Node</SAMP>, etc.
You have also created the network topology as a compound module
called <tt>RoutingTestNetwork</tt>, which will serve as a testbed for your routing
algorithms. Currently, <tt>RoutingTestNetwork</tt> has <SAMP>DistVecRoutingNode</SAMP>
hardcoded (all submodules are of this type), but you want
to be able to switch to other routing algorithms easily.

<p>NED gives you the possibility to add a string-valued parameter,
say <tt>routingNodeType</tt> to the <tt>RoutingTestNetwork</tt> compound module.
Then you can tell NED that types of the submodules inside <tt>RoutingTestNetwork</tt>
are not of any fixed module type, but contained in the <tt>routingNodeType</tt>
parameter. That's all - now you are free to assign any of
the <SAMP>"DistVecRoutingNode"</SAMP>, <SAMP>"AntNetRouting1Node"</SAMP> or
<SAMP>"AntNetRouting2Node"</SAMP> string constants to this parameter
(you can do that in NED, in the config file (<tt>omnetpp.ini</tt>),
or even enter it interactively),
and your network will use the routing algorithm you chose.

<p>If you specify a wrong value, say <SAMP>"FooBarRoutingNode"</SAMP>
whereas you have no <tt>FooBarRoutingNode</tt> module implemented,
you'll get a runtime error at the beginning of the simulation:
<EM>module type definition not found</EM>.

<p>Inside the <tt>RoutingTestNetwork</tt> module you assign parameter values
and connect the gates of the routing modules. To provide some degree
of type safety, NED wants to make sure you didn't misspell
parameter or gate names and you used them correctly.
To be able to do such checks, NED requires some help from you:
you have to name an existing module type (say <tt>RoutingNode</tt>)
and promise NED that all modules you're going you specify
in the <tt>routingNodeType</tt> parameter will have (at least) the same
parameters and gates as the <tt>RoutingNode</tt> module.
  <br><ul><font size=-1>[If you like, the above solution somewhat similar to polymorphism
  in object-oriented languages - <tt>RoutingNode</tt> is like a
  ``base class'', <SAMP>DistVecRoutingNode</SAMP> and <SAMP>AntNetRouting1Node</SAMP>
  are like ``derived classes'', and the <tt>routingNodeType</tt> parameter
  is like a ``pointer to a base class'' which may be downcast to specific
  types.]</font></ul>

<p>All the above is achieved via the <tt>like</tt> keyword.
The syntax is the following:

<p><pre>
<b>module</b> RoutingTestNetwork
    <b>parameters</b>:
        routingNodeType: <b>string</b>; // should hold the name
                                  // of an existing module type
    <b>gates</b>: //...
    <b>submodules</b>:
        node1: routingNodeType <b>like</b> RoutingNode;
        node2: routingNodeType <b>like</b> RoutingNode;
        //...
    <b>connections nocheck</b>:
        node1.out0 -&gt; node2.in0;
        //...
<b>endmodule</b>
</pre>

<p>The <SAMP>RoutingNode</SAMP> module type does not need to be implemented in
C++, because no instance of it is created; it is merely used
to check the correctness of the NED file.

<p>On the other hand, the actual module types that will be substituted
(e.g. <SAMP>DistVecRoutingNode</SAMP>, <SAMP>AntNetRouting1Node</SAMP>,etc.)
do not need to be declared in the NED files.

<p>The <tt>like</tt> phrase lets you create families
of modules that serve similar purposes and implement the same interface
(they have the same gates and parameters)
and to use them interchangeably in NED files.

<p>

<p>
<H3><A NAME="sec143"/>4.5.4. Assigning values to submodule parameters</H3>

<p>

<p>If the module type used as submodule has parameters, you can assign
values to them in the <SAMP>parameters</SAMP> section of the submodule
declaration.
As a value you can use a constant (such as <SAMP>42</SAMP> or
<SAMP>"www.foo.org"</SAMP>), various parameters (most commonly, parameters
of the compound module), or write an arbitrary expression containing
the above.

<p>It is not mandatory to mention and assign all parameters.
Unassigned parameters can get their values at runtime: either from
the configuration file (<SAMP>omnetpp.ini</SAMP>), or if the value
isn't there either, the simulator will prompt you to enter it
interactively. Indeed, for flexibility reasons it is often very useful
not to ``hardcode'' parameter values in the NED file,
but to leave them to <SAMP>omnetpp.ini</SAMP> where they can be
changed more easily.

<p>
Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        param1: numeric,
        param2: numeric,
        useParam1: bool;
    <b>submodules</b>:
        submodule1: Node
            <b>parameters</b>:
                p1 = 10,
                p2 = param1+param2,
                p3 = useParam1==true ? param1 : param2;
        //...
<b>endmodule</b>
</pre>

<p>
The expression syntax  is very similar to C.
Expressions may contain constants (literals) and parameters of the
compound module being defined. Parameters can be passed by value
or by reference. The latter means that the expression is evaluated
at runtime each time its value is accessed (e.g. from simple module
code), opening up interesting possibilities for the modeler.
You can also refer to parameters of the already defined submodules,
with the syntax <tt>submodule.parametername</tt>
(or <tt>submodule[index].parametername</tt>).

<p>Expressions are described in detail in section <a href="#ch-ned-lang:sec:expressions">[click]</a>.

<p>
<br><P class="subheading">The <tt>input</tt> keyword</P>
<a name="sec:ch-ned-lang:input"></a>

<p>When a parameter does not receive a value inside NED files or in
the configuration file (<tt>omnetpp.ini</tt>), the user will be prompted
to enter its value at the beginning of the simulation.
If you plan to make use of interactive prompting, you can specify
a prompt text and a default value.

<p>The syntax is the following:

<p><pre>
    <EM>&lt;paramname&gt;</EM> = <b>input</b>(<EM>&lt;default-value&gt;</EM>, <EM>&lt;prompt&gt;</EM>)
    <EM>&lt;paramname&gt;</EM> = <b>input</b>(<EM>&lt;default-value&gt;</EM>)
    <EM>&lt;paramname&gt;</EM> = <b>input</b>
</pre>

<p>The third version is actually equivalent to simply and quietly
leaving out the parameter from the list of assignments, but
you can use it to make it explicit that you do not want to
assign a value from within the NED file.

<p>Examples:

<p><pre>
   parameters:
      numProc = <b>input</b>(10, "Number of processors?"),
      processingTime = <b>input</b>(10ms);
</pre>

<p>

<p><H3><A NAME="sec144"/>4.5.5. Defining sizes of submodule gate vectors</H3>

<p>


<p>The sizes of gate vectors are defined with the
<tt>gatesizes</tt> keyword.  Gate vector sizes
can be given as constants, parameters or expressions.

<p>An example:

<p><pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>in</b>: inputs[];
        <b>out</b>: outputs[];
<b>endsimple</b>

<p><b>module</b> CompoundModule
    <b>parameters</b>:
        numPorts: <b>const</b>;
    <b>submodules</b>:
        node1: Node
            <b>gatesizes</b>:
                inputs[2], outputs[2];
        node2: Node
            <b>gatesizes</b>:
                inputs[numPorts], outputs[numPorts];
        //...
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec145"/>4.5.6. Conditional parameters and gatesizes sections</H3>

<p>
Multiple <tt>parameters</tt> and
<SAMP>gatesizes</SAMP> sections can exist in a submodule
definition and each of them can be tagged with
conditions.

<p>Example:

<p><pre>
<b>module</b> Tandem
    <b>parameters</b>: count: <b>const</b>;
    <b>submodules</b>:
        node : Node [count]
            <b>parameters</b>:
                position = "middle";
            <b>parameters</b> <b>if</b> index==0:
                position = "beginning";
            <b>parameters</b> <b>if</b> index==count-1:
                position = "end";
            <b>gatesizes</b>:
                in[2], out[2];
            <b>gatesizes</b> <b>if</b> index==0 || index==count-1:
                in[1], in[1];
    <b>connections</b>:
        //...
<b>endmodule</b>
</pre>

<p>
If the conditions are not disjoint and a parameter value or a
gate size is defined twice, the last definition will take effect,
overwriting the former ones. Thus, values intended as defaults
should appear in the first sections.

<p>

<p><H3><A NAME="sec146"/>4.5.7. Connections</H3>

<p>
The compound module definition specifies how the gates of the compound
module and its immediate sub-modules are connected.

<p>You can connect two submodules or a submodule with its enclosing
compound module. (For completeness, you can also connect two gates
of the compound module on the inside, but this is rarely needed).
This means that NED does not permit connections that span
multiple levels of hieararchy - this restriction
enforces compound modules to be self-contained, and thus promotes
reusability. Gate directions must also be observed,
that is, you cannot connect two output gates or two input gates.

<p>Only one-to-one connections are supported. One-to-many and many-to-one
connections can be achieved using simple modules that duplicate
messages or merge message flows. The rationale is that wherever
such fan-in or fan-out occurs in a model, it is usually associated
with some processing anyway that makes it necessary to use
simple modules.

<p>A gate can only be connected once: if two connections refer to
the same gate, a compilation or runtime error will occur.

<p>By default, NED expects every gate to be connected, resulting in
a compilation or runtime error if an unconnected gate is found.
This check can be turned off with the <tt>nocheck</tt> modifier,
described later in this section.

<p>Connections are specified in the
<tt>connections:</tt> section of a compound
module definition. It lists the connections, separated by semicolons.

<p>Example:

<p><pre>
<b>module</b> CompoundModule
    <b>parameters</b>: //...
    <b>gates</b>: //...
    <b>submodules</b>: //...
    <b>connections</b>:
        node1.output -&gt; node2.input;
        node1.input &lt;- node2.output;
        //...
<b>endmodule</b>
</pre>

<p>
Each connection can be:
<UL>
  <li><strong></strong>simple (that is, no delay, bit error rate or data rate), can
    use a named channel, or a channel given with delay, error and
    data rate values;
<li><strong></strong>single or multiple (loop) connection;
<li><strong></strong>conditional or non-conditional.
</UL>

<p>These connection types are described in the following sections.

<p>
<br><P class="subheading">Single connections and channels</P>

<p>


<p>The source gate can be an output gate of a submodule or an input
gate of the compound module, and the destination gate can be
an input gate of a submodule or an output gate of the compound
module.

<p>
If you do not specify a channel, the connection will have
no propagation delay, no transmission delay and no bit errors:
<pre>
    sender.outGate --&gt; receiver.inGate;
</pre>

<p>The arrow can point either left-to-right or right-to-left.

<p>You can specify a channel by its name:
<pre>
    sender.outGate --&gt; Dialup14400 --&gt; receiver.inGate;
</pre>

<p>In this case, the NED sources must contain the definition of
the channel.

<p>One can also specify the channel parameters directly:
<pre>
    sender.outGate --&gt; error 1e-5 delay 0.001 --&gt; receiver.inGate;
</pre>

<p>Either of the parameters can be omitted and they can be in any
order.

<p>
<br><P class="subheading">Loop connections</P>

<p>
If submodule or gate vectors are used, it is possible to create
more than one connection with one statement. This is termed a <EM>multiple</EM>
or <EM>loop connection</EM>.

<p>A multiple connection is created with the <tt>for</tt>
statement:

<p><pre>
<b>for</b> i=0..4 <b>do</b>
    sender.outGate[i] -&gt; receiver[i].inGate
<b>endfor</b>;
</pre>

<p>
The result of the above loop connection can be illustrated as
depicted in Fig. <a href="#fig:ch-ned-lang:loop-connection">[click]</a>.

<p>
<DIV ALIGN=center>
<img src="figures/usmanFig7.gif">
<center><i>Figure: Loop connection</i></center>
<a name="fig:ch-ned-lang:loop-connection"></a>
</DIV>

<p>

<p>One can place several connections in the body of the
<tt>for</tt> statement, separated by semicolons.

<p>One can create nested loops
by specifying more than one indices in the <SAMP>for</SAMP> statement,
with the first variable forming the outermost loop.

<p><pre>
<b>for</b> i=0..4, j=0..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>One can also use an index in the lower and upper bound expressions
of the subsequent indices:

<p><pre>
<b>for</b> i=0..3, j=i+1..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>
<br><P class="subheading">Conditional connections</P>

<p>

<p>Creation of a connection can be made conditional, using the <tt>if</tt>
keyword:

<p>

<p><pre>
<b>for</b> i=0..n <b>do</b>
    sender.outGate[i] -&gt; receiver[i].inGate <b>if</b> i%2==0;
<b>endfor</b>;
</pre>

<p>The <tt>if</tt> condition is evaluated for each connection
(in the above example, for each <EM>i</EM> value), and the
decision is made individually each time whether to create the
the connection or not. In the above example we connected every
second gate. Conditions may also use random variables, as
shown in the next section.

<p>
<br><P class="subheading">The nocheck modifier</P>

<p>By default, NED requires that all gates be connected. Since this
check can be inconvenient at times, it can be turned off
using the <tt>nocheck</tt> modifier.

<p>The following example generates a random subgraph of a full graph.

<p><pre>
<b>module</b> RandomConnections
    <b>parameters</b>: //..
    <b>gates</b>: //..
    <b>submodules</b>: //..
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..n-1, j=0..n-1 <b>do</b>
            node[i].out[j] -&gt; node[j].in[i] <b>if</b> uniform(0,1)&lt;0.3;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>When using <tt>nocheck</tt>, it is the
simple modules' responsibility not to send messages on gates
that are not connected.

<p>
<hr><H2><A NAME="sec147"/>4.6. Network definitions</H2>
<a name="sec:ch-ned-lang:network"></a>


<p>Module module declarations (compound and simple module declarations)
just define module types. To actually get a simulation model that
can be run, you need to write a <EM>network definition</EM>.

<p>A network definition declares a simulation model as an instance
of a previously defined module type. You'll typically want to use
a compound module type here, although it is also possible to
program a model as a self-contained simple module and instantiate it
as a ``network''.

<p>There can be several network definitions in your NED file or NED files.
The simulation program that uses those NED files will be
able to run any of them; you typically select the desired one
in the config file (<tt>omnetpp.ini</tt>).

<p>The syntax of a network definition is similar that of a submodule
declaration:

<p><pre>
<b>network</b> wirelessLAN: WirelessLAN
    <b>parameters</b>:
        numUsers=10,
        httpTraffic=true,
        ftpTraffic=true,
        distanceFromHub=truncnormal(100,60);
<b>endnetwork</b>
</pre>

<p>Here, <tt>WirelessLAN</tt> is the name of previously defined
compound module type, which presumably contains further
compound modules of types <tt>WirelessHost</tt>, <tt>WirelessHub</tt>, etc.

<p>Naturally, only compound module types without gates can
be used in network definitions.

<p>Just as for submodules, you do not need to assign values to all
parameters. Unassigned parameters will get their values from the
config file (<tt>omnetpp.ini</tt>) or interactively prompted for.

<p>

<p><hr><H2><A NAME="sec148"/>4.7. Expressions</H2>
<a name="ch-ned-lang:sec:expressions"></a>

<p>In the NED language there are a number of places where
expressions are expected.

<p>Expressions have a C-style syntax. They are built with the usual math
operators; they can use parameters taken by
value or by reference; call C functions; contain random and input
values etc.

<p>When an expression is used for a parameter value, it is evaluated
each time the parameter value is accessed (unless the parameter is
declared <tt>const</tt>, see <a href="#sec:ch-ned-lang:const">[click]</a>). This means
that a simple module querying a non-const parameter during simulation
may get different values each time (e.g. if the value involves a
random variable, or it contains other parameters taken by reference).
Other expressions (including <tt>const</tt> parameter values)
are evaluated only once.

<p>
<H3><A NAME="sec149"/>4.7.1. Constants</H3>

<p><br><P class="subheading">Numeric and string constants</P>

<p>Numeric constants are accepted in their usual decimal or
scientific notations.

<p>
<br><P class="subheading">String constants</P>

<p>String constants use double quotes.

<p>
<br><P class="subheading">Time constants</P>

<p>Anywhere you would put numeric constants
(integer or real) to mean time in seconds, you can also specify the
time in units like milliseconds, minutes or hours:

<p>
<pre>
    ...
    <b>parameters</b>:
        propagationDelay = 560ms, // 0.560s
        connectionTimeout = 6m 30s 500ms, // 390.5s
        recoveryIntvl = 0.5h; // 30 min
</pre>

<p>
The following units can be used:

<p><table border>
<TR> <TD align=center>

<p><b>Unit</b> </TD> <TD align=left> <b>Meaning</b> </TD> <TD align=left> <b>Seconds</b> </TD></TR>
<TR> <TD align=center> <tt>ns</tt> </TD> <TD align=left> nanoseconds </TD> <TD align=left> $*10^-9$ </TD></TR>
<TR> <TD align=center> <tt>us</tt> </TD> <TD align=left> microseconds </TD> <TD align=left> $*10^-6$ </TD></TR>
<TR> <TD align=center> <tt>ms</tt> </TD> <TD align=left> milliseconds </TD> <TD align=left> $*10^-3$ </TD></TR>
<TR> <TD align=center> <tt>s</tt>  </TD> <TD align=left> seconds </TD> <TD align=left> $*1$ </TD></TR>
<TR> <TD align=center> <tt>m</tt>  </TD> <TD align=left> minutes </TD> <TD align=left> $*60$ </TD></TR>
<TR> <TD align=center> <tt>h</tt>  </TD> <TD align=left> hours </TD> <TD align=left> $*3600$ </TD></TR>
<TR> <TD align=center> <tt>d</tt>  </TD> <TD align=left> days </TD> <TD align=left> $*24*3600$ </TD></TR>
</table>

<p>
<H3><A NAME="sec150"/>4.7.2. Referencing parameters</H3>

<p>Expressions can use the parameters of the enclosing compound module
(the one being defined) and of submodules defined earlier in NED file.
The syntax for the latter is <tt>submod.param</tt> or <tt>submod[index].param</tt>.

<p>You can refer to a compound module parameter called <tt>param</tt>
in several ways: as <tt>param</tt>, <tt><STRONG>ref</STRONG> param</tt>,
<tt><STRONG>ancestor</STRONG> param</tt>, or <tt><STRONG>ref</STRONG> <STRONG>ancestor</STRONG> param</tt>.
They all have different semantics.

<p>The first two variations, <tt>param</tt> and <tt><STRONG>ref</STRONG> param</tt>
lets you access the parameters of the compound module being
defined. In the third and fourth versions, the keyword
<tt>ancestor</tt> means that the parameter will be searched for upwards,
in the module nesting hierarchy. Naturally, this kind of reference can
only be resolved at runtime, when the whole network has been built up.
The parameter which is found first is used. If no such parameter can be
found in any of the enclosing modules, it is a runtime error.

<p>The <tt>ref</tt> and <tt>ref</tt>-less versions differ in how the parameter
is taken: by value or by reference. If you take a parameter by reference,
then runtime changes to that parameter will be reflected in the
assigned parameter: each time a simple module reads the parameter
value, the expression is evaluated, and you may get a different value.
In contrast, if you take the parameter by value, then runtime changes
do not affect the assigned parameter.
  <br><ul><font size=-1>[This also means that if an expression doesn't contain any parameter
  taken by reference, the NED compiler may have the possibility to evaluate
  the expression only once, at compile time. If an expression refers
  to parameters taken by reference, only runtime evaluation can be used.]</font></ul>

<p>Reference parameters open up interesting possibilities for the modeler.
For example, you can define a parameter that at the highest level
of the model, and let other modules take it by reference -
then if you change the parameter value at runtime
(manually or from a simple module), it will affect the whole model.
You can use this arrangement to ``tune'' model parameters at runtime,
in search for an optimal setting.

<p>In another setup, reference parameters can be used by to propagate
status values to neighbouring modules.

<p>

<p><H3><A NAME="sec151"/>4.7.3. Operators</H3>

<p>The set of operators supported in NED is similar to C/C++,
with the following differences:

<p><UL>
  <li><strong></strong>^ is used for power-of (and not bitwise XOR as in C)
  <li><strong></strong># is used for logical XOR (same as != between logical values), and
        ## is used for bitwise XOR
  <li><strong></strong>the precedence of bitwise operators (&amp;, |, #) have been raised
        to bind stronger than relational operations. This precedence is usually
        more convenient than the C/C++ one.
</UL>

<p>All values are represented as <tt>double</tt>s. For the bitwise operators,
<tt>double</tt>s are converted to <tt>unsigned long</tt>
  <br><ul><font size=-1>[In case you are worried about <tt>long</tt> values being not accurately
  represented in <tt>double</tt>s, this is not the case. IEEE-754 <tt>double</tt>s
  have 52 bit mantissas, and integer numbers in that range are represented
  without rounding errors.]</font></ul>
using the C/C++ builtin conversion (type cast), the operation is performed,
then the result is converted back to <tt>double</tt>.
Similarly, for the logical operators &amp;&amp;, || and ##,
the operands are converted to <tt>bool</tt> using the C/C++ builtin
conversion (type cast), the operation is performed, then the result
is converted back to <tt>double</tt>. For modulus (%), the operands are
converted to <tt>long</tt>.

<p>Here's the complete list of operators, in order of decreasing precendence:

<p><table border>
<TR> <TD align=left>

<p><b>Operator</b>          </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> -, !, <IT>~</IT> </TD> <TD align=left> unary minus, negation, bitwise complement </TD></TR>
<TR> <TD align=left> ^      </TD> <TD align=left> power-of </TD></TR>
<TR> <TD align=left> $*$, /, %              </TD> <TD align=left> multiply, divide, modulus </TD></TR>
<TR> <TD align=left> +, -                    </TD> <TD align=left> add, subtract </TD></TR>
<TR> <TD align=left> <tt>&lt;&lt;</tt>, <tt>&gt;&gt;</tt>      </TD> <TD align=left> bitwise shifting </TD></TR>
<TR> <TD align=left> &amp;, |, #               </TD> <TD align=left> bitwise and, or, xor </TD></TR>
<TR> <TD align=left> ==                      </TD> <TD align=left> equal </TD></TR>
<TR> <TD align=left> !=                      </TD> <TD align=left> not equal </TD></TR>
<TR> <TD align=left> <tt>&gt;</tt>, <tt>&gt;=</tt>       </TD> <TD align=left> greater, greater or equal </TD></TR>
<TR> <TD align=left> <tt>&lt;</tt>, <tt>&lt;=</tt>       </TD> <TD align=left> less, less or equal </TD></TR>
<TR> <TD align=left> &amp;&amp;, ||, ##          </TD> <TD align=left> logical operators and, or, xor </TD></TR>
<TR> <TD align=left> ?:                      </TD> <TD align=left> the C/C++ ``inline if'' </TD></TR>
</table>

<p>

<p><H3><A NAME="sec152"/>4.7.4. The <tt>sizeof()</tt> and <tt>index</tt> operators</H3>

<p>A useful operator is <tt>sizeof()</tt>, which gives the
size of a vector gate. The <tt>index</tt>
operator gives the index of the current
submodule in its module vector.

<p>An example for both:

<p><pre>
<b>module</b> Compound
    <b>gates</b>: <b>in</b>: fromgens[];
    <b>submodules</b>:
        proc: Processor[ <b>sizeof</b>(fromgens) ];
            <b>parameters</b>: address = 10*(1+<b>index</b>);
    <b>connections</b>:
        <b>for</b> i = 0.. <b>sizeof</b>(fromgens)-1 <b>do</b>
            in[i] -&gt; proc[i].input;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
Here, we create as many processors as there are input gates for
this compound module in the network. The address parameters of
the processors are 10, 20, 30 etc.

<p>

<p>
<H3><A NAME="sec153"/>4.7.5. Functions</H3>


<p>In NED expressions, you can use the following mathematical functions:
<UL>
  <li><strong></strong>many of the C language's <tt>&lt;math.h&gt;</tt> library functions:
    <tt>exp()</tt>, <tt>log()</tt>, <tt>sin()</tt>, <tt>cos()</tt>, <tt>floor()</tt>,
    <tt>ceil()</tt>, <tt>etc.</tt>
  <li><strong></strong>functions that generate random variables: <tt>uniform</tt>,
    <tt>exponential</tt>, <tt>normal</tt> and others were already
    discussed.
</UL>

<p>It is possible to add new ones, see <a href="#sec:ch-ned-lang:defining-functions">[click]</a>.

<p><H3><A NAME="sec154"/>4.7.6. Random values</H3>

<p>Expressions may contain random variates from different distributions.
This has the effect that unless the parameter was declared <tt>const</tt>,
it returns a different value each time it is evaluated.

<p>If the parameter <EM>was</EM> declared <tt>const</tt>, it is only evaluated
once at the beginning of the simulation, and subsequent queries
on the parameter will always return the same value.

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNeT++. By default this is generator 0, but you can specify
which one to be used.

<p>OMNeT++ has the following predefined distributions:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <EM>rng=0</tt>)</EM> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <EM>rng=0</tt>)</EM> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <EM>rng=0</tt>)</EM> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <EM>rng=0</tt>)</EM> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left> 
</table>


If you do not specify the optional <tt>rng</tt> argument, the functions will
use random number generator 0.

<p>Examples:

<pre>
intuniform(0,10)/10  // one of: 0, 0.1, 0.2, ..., 0.9, 1
exponential(5)       // exponential with mean=5 (thus parameter=0.2)
2+truncnormal(5,3)   // normal distr with mean 7 truncated to &gt;=2 values
</pre>
<p>
The above distributions are implemented with C functions, and you can easily
add new ones (see section <a href="#sec:ch-ned-lang:defining-functions">[click]</a>).
Your distributions will be treated in the same way as the built-in ones.

<p>

<p><H3><A NAME="sec155"/>4.7.7. Defining new functions</H3>

<a name="sec:ch-ned-lang:defining-functions"></a>

<p>To use user-defined functions, one has
to code the function in C++.  The C++ function must take 0, 1, 2, 3, or 4
arguments of type double and return a double. The function must be
registered in one of the C++ files with the <tt>Define_Function()</tt>
macro.

<p>An example function (the following code must appear in one of the C++
sources):

<p>
<pre>
#include &lt;omnetpp.h&gt;

double average(double a, double b)
{
  return (a+b)/2;
}

Define_Function(average, 2);
</pre>

<p>
The number 2 means that the <tt>average()</tt> function has 2
arguments.  After this, the <tt>average()</tt> function can be used in
NED files:

<p>
<pre>
<b>module</b> Compound
    <b>parameter</b>: a,b;
    <b>submodules</b>:
        proc: Processor
            <b>parameters</b>: av = average(a,b);
<b>endmodule</b>
</pre>

<p>
If your function takes parameters that are <tt>int</tt> or <tt>long</tt> or
some other type which is not <tt>double</tt>, you can create wrapper function
that takes all doubles and does the conversion. In this case you have
to register the wrapper function with the <tt>Define_Function2()</tt> macro
which allows a function to be registered with a name different from the
name of the function that implements it. You can do the same
if the return value differs from <tt>double</tt>.

<pre>
#include &lt;omnetpp.h&gt;

long factorial(int k)
{
  ...
}

static double _wrap_factorial(double k)
{
  return factorial((int)k);
}

Define_Function2(factorial, _wrap_factorial, 1);
</pre>
<p>

<p>
<hr><H2><A NAME="sec156"/>4.8. Display strings</H2>
<a name="sec:ch-ned-lang:display-strings"></a>

<p>
Display strings specify the arrangement and
appearance of modules in graphical user interfaces (currently only
Tkenv): they control how the objects (compound modules, their
submodules and connections) are displayed. Display strings occur in
NED description's <tt>display:</tt>
phrases.

<p>The display string format is a semicolon-separated list of tags.
Each tag consists of a key (usually one letter), an equal sign
and a comma-separated list of parameters, like:

<pre>
  "p=100,100;b=60,10,rect;o=blue,black,2"
</pre>
<p>
Parameters may be omitted also at the end and also inside the
parameter list, like:

<pre>
  "p=100,100;b=,,rect;o=blue,black"
</pre>
<p>
Module/submodule parameters can be included with the <tt>$name</tt> notation:

<pre>
  "p=$xpos,$ypos;b=rect,60,10;o=$fillcolor,black,2"
</pre>
<p>
Objects that may have display strings are:
<UL>
  <li><strong></strong>compound modules (as the enclosing module in the drawing),
  <li><strong></strong>submodules
  <li><strong></strong>connections
</UL>

<p>The following NED sample shows where to place display strings in the code.

<p><pre>
<b>module</b> ClientServer
    <b>submodules</b>:
        pc: Host;
            <b>display</b>: "p=66,55;i=comp"; // position and icon
        server: Server;
            <b>display</b>: "p=135,73;i=server1";
    <b>connections</b>:
        pc.out -&gt; server.in
            <b>display</b> "m=m,61,40,41,28"; // note missing ":"
        server.out -&gt; pc.in
            <b>display</b> "m=m,15,57,35,69";
    <b>display</b>: "o=#ffffff"; // affects background
<b>endmodule</b>
</pre>

<p>
<H3><A NAME="sec157"/>4.8.1. Submodule display strings</H3>

<p>
The following table lists the tags used in submodule display strings:

<p>

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>
</TD> <TD align=left>
 Place submodule at (<EM>xpos</EM>,<EM>ypos</EM>) pixel position,
with the origin being the top-left corner of the enclosing module.

<p>Defaults: an appropriate automatic layout is where submodules do not overlap.

<p>If applied to a submodule vector, <EM>ring</EM> or <EM>row</EM> layout is
selected automatically.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>row</b>,<EM>deltax</EM> </TD> <TD align=left>
 Used for module vectors. Arranges submodules in a row starting
at (<EM>xpos</EM>,<EM>ypos</EM>), keeping <EM>deltax</EM> distances.

<p>Defaults: <EM>deltax</EM> is chosen so that submodules do not overlap.

<p><b>row</b> may be abbreviated as <b>r</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>column</b>,<EM>deltay</EM>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in a column starting
at (<EM>xpos</EM>,<EM>ypos</EM>), keeping <EM>deltay</EM> distances.

<p>Defaults: <EM>deltay</EM> is chosen so that submodules do not overlap.

<p><b>column</b> may be abbreviated as <b>col</b> or <b>c</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>matrix</b>,
<EM>itemsperrow</EM>,<EM>deltax</EM>,<EM>deltay</EM>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in a matrix starting
at (<EM>xpos</EM>,<EM>ypos</EM>), at most <EM>itemsperrow</EM> submodules in
a row, keeping <EM>deltax</EM> and <EM>deltay</EM> distances.

<p>Defaults: <EM>itemsperrow</EM>=5, <EM>deltax,deltay</EM> are chosen so that
submodules do not overlap.

<p><b>matrix</b> may be abbreviated as <b>m</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>ring</b>,<EM>width,height</EM>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in an ellipse,
with the top-left corner of its bounding boxes at (<EM>xpos</EM>,<EM>ypos</EM>),
with the <EM>width</EM> and <EM>height</EM>.

<p>Defaults: <EM>width</EM>=40, <EM>height</EM>=24

<p><b>ring</b> may be abbreviated as <b>ri</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>exact</b>,<EM>deltax</EM>,<EM>deltay</EM>
</TD> <TD align=left>
 Used for module vectors. Each submodule is placed at
<EM>(xpos+deltax</EM>, <EM>ypos+deltay)</EM>.
This is useful if <EM>deltax</EM> and <EM>deltay</EM> are parameters
 (e.g.:<EM>''p=100,100,exact,$x,$y''</EM>)
which take different values for each module in the vector.

<p>Defaults: <EM>none</EM>

<p><b>exact</b> may be abbreviated as <b>e</b> or <b>x</b>.</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>rect</b>
</TD> <TD align=left>
 Rectangle with the given <EM>height</EM> and <EM>width</EM>.

<p>Defaults: <EM>width</EM>=40, <EM>height</EM>=24</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>oval</b>
</TD> <TD align=left>
 Ellipse with the given <EM>height</EM> and <EM>width</EM>.

<p>Defaults: <EM>width</EM>=40, <EM>height</EM>=24</TD></TR>
<TR> <TD align=left> <b>o=</b><EM>fillcolor</EM>,<EM>outlinecolor</EM>,<EM>borderwidth</EM>
</TD> <TD align=left>
 Specifies options for the rectangle or oval. Any valid Tk color
specification is accepted: English color names or <EM>#rgb</EM>, <EM>#rrggbb</EM>
format (where <EM>r</EM>,<EM>g</EM>,<EM>b</EM> are hex digits).

<p>Defaults: <EM>fillcolor</EM>=#8080ff (a lightblue), <EM>outlinecolor</EM>=black,
<EM>borderwidth</EM>=2</TD></TR>
<TR> <TD align=left> <b>i=</b><EM>iconname</EM>
</TD> <TD align=left>
 Use the named icon.

<p>No default. If no icon name is present, <EM>box</EM> is used.</TD></TR>
</table>

<p>
Examples:

<pre>
  "p=100,60;i=workstation"
  "p=100,60;b=30,30,rect;o=4"
</pre>
<p>

<p>
<H3><A NAME="sec158"/>4.8.2. Compound module display strings</H3>

<p>The tags that can be used in enclosing module display strings are:

<p>
<table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b></TD></TR>
<TR> <TD align=left>
<b>p=</b><EM>xpos</EM>,<EM>ypos</EM> </TD> <TD align=left> Place enclosing module at
(<EM>xpos</EM>,<EM>ypos</EM>) pixel position, with (0,0) being
the top-left corner of the window.</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>rect</b>
</TD> <TD align=left>
 Display enclosing module as a rectangle with the given <EM>height</EM>
and <EM>width</EM>.

<p>Defaults: <EM>width,</EM> <EM>height</EM> are chosen automatically</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>oval</b>
</TD> <TD align=left>
 Display enclosing module as an ellipse with the given <EM>height</EM>
and <EM>width</EM>.

<p>Defaults: <EM>width,</EM> <EM>height</EM> are chosen automatically</TD></TR>
<TR> <TD align=left> <b>o=</b><EM>fillcolor</EM>,<EM>outlinecolor</EM>,<EM>borderwidth</EM>
</TD> <TD align=left>
 Specifies options for the rectangle or oval. Any valid Tk color
specification is accepted: English color names or <EM>#rgb</EM>, <EM>#rrggbb</EM>
format (where <EM>r</EM>,<EM>g</EM>,<EM>b</EM> are hex digits).

<p>Defaults: <EM>fillcolor</EM>=#8080ff (a lightblue), <EM>outlinecolor</EM>=black,
<EM>borderwidth</EM>=2</TD></TR>
</table>

<p>
<H3><A NAME="sec159"/>4.8.3. Connection display strings</H3>

<p>Tags that can be used in connection display strings:

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b></TD></TR>
<TR> <TD align=left> <b>m=auto</b> <br>
<b>m=north</b> <br>
<b>m=west</b> <br>
<b>m=east</b> <br>
<b>m=south</b>
</TD> <TD align=left>
Drawing mode. Specifies the exact placement of the connection
arrow. The arguments can be abbreviated as a,e,w,n,s.</TD></TR>
<TR> <TD align=left>  <b>m=manual</b>,<EM>srcpx</EM>,<EM>srcpy</EM>,<EM>destpx</EM>,<EM>destpy</EM>
</TD> <TD align=left>
 The manual mode takes four parameters that explicitly specify
anchoring of the ends of the arrow: <EM>srcpx</EM>, <EM>srcpy</EM>,
<EM>destpx</EM>, <EM>destpy</EM>.
Each value is a percentage of the width/height of the source/destination
module's enclosing rectangle, with the upper-left corner being
the origin. Thus,
<pre>
m=m,50,50,50,50
</pre>
would connect the centers of the two module rectangles.</TD></TR>
<TR> <TD align=left> <b>o=</b><EM>color</EM>,<EM>width</EM> </TD> <TD align=left>
Specifies the appearance of the arrow. Any valid Tk color specification
is accepted: English color names or #rgb, #rrggbb specification
(where r,g,b are hex digits).

<p>Defaults: <EM>color</EM>=black, <EM>width</EM>=2</TD></TR>
</table>

<p>
Examples:
<pre>
  "m=a;o=blue,3"
</pre>

<p>

<p>
<hr><H2><A NAME="sec160"/>4.9. Parameterized compound modules</H2>

<p>

<p>With the help of conditional parameter and gatesize blocks and
conditional connections, one can
create complex topologies.

<p>
<H3><A NAME="sec161"/>4.9.1. Examples</H3>

<p><br><P class="subheading">Example 1: Router</P>

<p>The following example contains a router module with the number of
ports taken as parameter. The compound module is built using three
module types: Application, RoutingModule, DataLink. We assume that
their definition is in a separate NED file which we will import.

<p><pre>
<b>import</b> "modules";
<b>module</b> Router
    <b>parameters</b>:
        rteProcessingDelay, rteBuffersize,
        numOfPorts: <b>const</b>;
    <b>gates</b>:
        <b>in</b>: inputPorts[];
        <b>out</b>: outputPorts[];
    <b>submodules</b>:
        localUser: Application;
        routing: RoutingModule
            <b>parameters</b>:
                processingDelay = rteProcessingDelay,
                buffersize = rteBuffersize;
            <b>gatesizes</b>:
                input[numOfPorts+1],
                output[numOfPorts+1];
        portIf: DataLink[numOfPorts]
            <b>parameters</b>:
                retryCount = 5,
                windowSize = 2;
    <b>connections</b>:
        <b>for</b> i=0..numOfPorts-1 <b>do</b>
            routing.output[i] -&gt; portIf[i].fromHigherLayer;
            routing.input[i] &lt;- portIf[i].toHigherLayer;
            portIf[i].toPort -&gt; outputPorts[i];
            portIf[i].fromPort &lt;- inputPorts[i];
        <b>endfor</b>;
        routing.output[numOfPorts] -&gt; localUser.input;
        routing.input[numOfPorts] &lt;- localUser.output;
<b>endmodule</b>
</pre>

<p>
<br><P class="subheading">Example 2: Chain</P>

<p>
For example, one can create a chain of modules like this:

<p><pre>
<b>module</b> Chain
    <b>parameters</b>: count: <b>const</b>;
    <b>submodules</b>:
        node : Node [count]
            <b>gatesizes</b>:
                in[2], out[2];
            <b>gatesizes</b> <b>if</b> index==0 || index==count-1:
                in[1], out[1];
    <b>connections</b>:
        <b>for</b> i = 0..count-2 <b>do</b>
            node[i].out[i!=0 ? 1 : 0] -&gt; node[i+1].in[0];
            node[i].in[i!=0 ? 1 : 0] &lt;- node[i+1].out[0];
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
<br><P class="subheading">Example 3: Binary Tree</P>

<p>
One can use conditional connections to build a binary tree.
The following NED code loops through all possible node pairs, and
creates the connections needed for a binary tree.

<p><pre>
<b>simple</b> BinaryTreeNode
    <b>gates</b>:
        <b>in</b>: fromupper;
        <b>out</b>: downleft;
        <b>out</b>: downright;
<b>endsimple</b>

<p><b>module</b> BinaryTree
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i = 0..2^height-2, j = 0..2^height-2 <b>do</b>
            node[i].downleft -&gt; node[j].fromupper <b>if</b> j==2*i+1;
            node[i].downright -&gt; node[j].fromupper <b>if</b> j==2*i+2;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note that not every gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the <tt>nocheck</tt> modifier.  Consequently, it
is the simple modules' responsibility not to send on a gate which is
not leading anywhere.

<p>An alert reader might notice that there is a better alternative
to the above code. Each node except the ones at the lowest level
of the tree has to be connected to exactly two nodes,
so we can use a single loop to create the connections.

<p><pre>
<b>module</b> BinaryTree2
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..2^(height-1)-2 <b>do</b>
            node[i].downleft -&gt; node[2*i+1].fromupper;
            node[i].downright -&gt; node[2*i+2].fromupper;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>

<p><br><P class="subheading">Example 4: Random graph</P>

<p>Conditional connections can also be used to generate random
topologies.  The following code generates a
random subgraph of a full graph:

<p><pre>
<b>module</b> RandomGraph
    <b>parameters</b>:
        count: <b>const</b>,
        connectedness; // 0.0&lt;x&lt;1.0
    <b>submodules</b>:
        node: Node [count];
            <b>gatesizes</b>: <b>in</b>[count], <b>out</b>[count];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..count-1, j=0..count-1 <b>do</b>
            node[i].out[j] -&gt; node[j].in[i]
                <b>if</b> i!=j && uniform(0,1)&lt;connectedness;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note the use of the <tt>nocheck</tt> modifier
here too, to turn off error messages given by the network setup code
for unconnected gates.

<p>
<H3><A NAME="sec162"/>4.9.2. Design patterns for compound modules</H3>

<p>


<p>Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are
described below.

<p>
<br><P class="subheading">`Subgraph of a Full Graph'</P>

<p>
This pattern takes a subset of the connections of a full graph.  A
condition is used to ``carve out'' the necessary interconnection from
the full graph:

<p><pre>
for i=0..N-1, j=0..N-1 do
    node[i].out[...] -&gt; node[j].in[...] if condition(i,j);
endfor;
</pre>

<p>The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate <EM>condition(i,j)</EM> can be formulated. For example,
when generating a tree structure, the condition
would return whether node <EM>j</EM> is a child of node <EM>i</EM> or
vica versa.

<p>Though this pattern is very general, its usage can be prohibitive if
the <EM>N</EM> number of nodes is high and the graph is sparse (it has
much fewer connections that <EM>N</EM><sup><i>2</i></sup>). The following
two patterns do not suffer from this drawback.

<p>
<br><P class="subheading">`Connections of Each Node'</P>

<p>The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

<p><pre>
for i=0..Nnodes, j=0..Nconns(i)-1 do
    node[i].out[j] -&gt; node[rightNodeIndex(i,j)].in[j];
endfor;
</pre>

<p>The Hypercube compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

<p>The applicability of this pattern depends on how easily the <EM>rightNodeIndex(i,j)</EM>
function can be formulated.

<p>
<br><P class="subheading">`Enumerate All Connections'</P>

<p>
A third pattern is to list all connections within a loop:

<p><pre>
for i=0..Nconnections-1 do
    node[leftNodeIndex(i)].out[...] -&gt; node[rightNodeIndex(i)].in[...];
endfor;
</pre>

<p>The pattern can be used if <EM>leftNodeIndex(i)</EM> and <EM>rightNodeIndex(i)</EM>
mapping functions can be sufficiently formulated.

<p>The Serial module is an example of this approach where the mapping
functions are extremely simple: <EM>leftNodeIndex(i)=i</EM> and <EM>rightNodeIndex(i)=i+1</EM>.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

<p>In the case of irregular structures where none of the above patterns
can be employed, you can resort to specifying constant submodule/gate
vector sizes and explicitly listing all connections, like you
would do it in most existing simulators.

<p>

<p>
<H3><A NAME="sec163"/>4.9.3. Topology templates</H3>
<a name="sec:ch-ned-lang:topology-templates"></a>

<p>
<br><P class="subheading">Overview</P>

<p>
Topology templates are nothing more than compound modules where one or
more submodule types are left as parameters (using the
<tt>like</tt> phrase of the NED language).  You can
write such modules which implement mesh,
hypercube,
butterfly, perfect
shuffle or other topologies, and you
can use them wherever needed in you simulations.  With topology
templates, you can reuse
<EM>interconnection structure</EM>.

<p>

<p><br><P class="subheading">An example: hypercube</P>

<p>
The concept is demonstrated on a network with hypercube interconnection.
When building an N-dimension hypercube, we can exploit the fact
that each node is connected to N others which differ from it
only in one bit of the binary representations of the node indices
(see Fig. <a href="#fig:ch-ned-lang:hypercube-topology">[click]</a>).

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig8.gif">
    <center><i>Figure: Hypercube topology</i></center>
    <a name="fig:ch-ned-lang:hypercube-topology"></a>
  </DIV>

<p>

<p>The hypercube topology template is the
following (it can be placed into a separate file, e.g <tt>hypercube.ned</tt>):

<p>
<pre>
<b>simple</b> Node
    <b>gates</b>:
        <b>out</b>: out[];
        <b>in</b>: in[];
<b>endsimple</b>

<p><b>module</b> Hypercube
    <b>parameters</b>:
        dim, nodetype;
    <b>submodules</b>:
        node: nodetype[2^dim] <b>like</b> Node
        <b>gatesizes</b>:
            out[dim], in[dim];
    <b>connections</b>:
        <b>for</b> i=0..2^dim-1, j=0..dim-1 <b>do</b>
            node[i].out[j] -&gt; node[i # 2^j].in[j]; // # is bitwise XOR
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>

<p>When you create an actual hypercube, you substitute the name
of an existing module type (e.g. <tt>"Hypercube_PE"</tt>) for the nodetype
parameter. The module type implements the algorithm the user
wants to simulate and it must have the same gates that the Node
type has. The topology template code can be used through importing
the file:

<p>
<pre>
<b>import</b> "hypercube.ned";

<p><b>simple</b> Hypercube_PE
    <b>gates</b>: <b>out</b>: out[]; <b>in</b>: in[];
<b>endsimple</b>

<p><b>network</b> hypercube: Hypercube
    <b>parameters</b>:
        dim = 4,
        nodetype = "Hypercube_PE";
<b>endnetwork</b>
</pre>

<p>

<p>If you put the nodetype parameter to the ini file, you can use the
same simulation model to test e.g. several routing algorithms in a
hypercube, each algorithm implemented with a different
simple module type - you just have to supply
different values to nodetype, such as <tt>"WormholeRoutingNode"</tt>,
<tt>"DeflectionRoutingNode"</tt>, etc.

<p>

<p><hr><H2><A NAME="sec164"/>4.10. Large networks</H2>

<p>There are situations when using hand-written NED files to describe
network topology is inconvenient, for example when
the topology information comes from
an external source like
a network management program.

<p>In such case, you have two possibilities:

<p><OL>
  <li><strong></strong>generating NED files from data files
  <li><strong></strong>building the network from C++ code
</OL>

<p>The two solutions have different advantages and disadvantages.
The first is more useful in the model development phase, while
the second one is better for writing larger scale, more productized
simulation programs. In the next sections we examine both methods.

<p>

<p><H3><A NAME="sec165"/>4.10.1. Generating NED files</H3>

<p>
Text processing programs like <tt>awk</tt> or <tt>perl</tt> are
excellent tools to read in textual data files and generate NED files
from them.  Perl also has extensions to
access SQL databases, so it can also be used if the network topology
is stored in a database.

<p>The advantage is that the necessary <tt>awk</tt> or <tt>perl</tt>
program can be written in a releatively short time, and it is
inexpensive to maintain afterwards: if the structure of the data files
change, the NED-creating program can be easily modified. The
disadvantage is that the resulting NED files are often quite big and
the C++ compilation of the <SAMP>*_n.cc</SAMP> files may take long.

<p>This method is best suited in the first phase of a simulation
project when the topology, the format of the data files, etc.
have not yet stabilized.

<p>

<p><H3><A NAME="sec166"/>4.10.2. Building the network from C++ code</H3>

<p>Another alternative is to write C++ code which becomes part of the
simulation executable. The code would read the topology data from data
files or a database, and build the network directly, using
dynamic module creation (to be described later, in section
<a href="#ch:simple-modules:dynamic-module-creation">[click]</a>).
The code which builds the network would be similar to the <tt>*_n.cc</tt>
files output by nedc.

<p>Since writing such code is more complex than letting perl generate
NED files, this method is recommended when the simulation program
has to be somewhat more productized, for example when OMNeT++
and the simulation model is embedded into a larger program, e.g.
a network design tool.

<p>
<hr><H2><A NAME="sec167"/>4.11. XML support</H2>

<p>Future OMNeT++ versions will contain strong XML support.
NED files will have XML representations, and the two forms
can be freely converted to each other. XML is much more suited
for machine processing, e.g. XSLT can be used to
produce NED via XML, extract information from NED files,
generating HTML documentation from NED, etc.

<p>The current version (2.3) contains an alpha version of
these tools. <EM>nedtool</EM> is going to replace nedc,
and it offers much more functionality.

<p>Converting a NED file to XML:

<pre>
nedtool -x wireless.ned
</pre>
<p>
It generates <tt>wireless_n.xml</tt>.
Several switches control the exact content and details
of the resulting XML as well as the amount of checks
made on the input.

<p>Converting the XML representation back to NED:

<pre>
nedtool -n wireless.xml
</pre>
<p>
The result is <tt>wireless_n.ned</tt>.

<p>Using nedtool as nedc to generate C++ code:

<pre>
nedtool wireless.ned
</pre>
<p>
The resulting code is more compact and less redundant than the
one created by nedc. As a result, nedtool-created <tt>_n.cc</tt>
C++ files compile much faster.

<p>You can generate C++ code from the XML format, too:

<pre>
nedtool wireless.xml
</pre>
<p>
The opp_nedtool command uses XSLT to produce HTML documentation
from the given NED files, much like Javadoc or Doxygen.
   <br><ul><font size=-1>[You're going to need xsltproc (part of libxml/libxslt)
   installed on your system. Since Gnome and KDE also heavily rely
   on these components, there's a good chance it is already present
   on your system.]</font></ul>

<pre>
opp_neddoc *.ned
</pre>
<p>
The output file is called <tt>neddoc.html</tt>. opp_nedtool can be
very useful in discovering and understanding the structure
of large models like the IP-Suite. On Unix, you'd use it like this:

<pre>
cd IPSuite
opp_neddoc `find . -name *.ned`
</pre>
<p>
The HTML output is currently rather plain,
but it is going to be improved.

<p>
<hr><H2><A NAME="sec168"/>4.12. GNED - Graphical NED Editor</H2>

<p>

<p>The GNED editor allows you to design compound modules graphically.
GNED works with NED files - it doesn't use any nasty internal file
format. You can load any of your existing NED files, edit the compound
modules in it graphically and then save the file back. The rest of the
stuff in the NED file (simple modules, channels, networks etc.) will
survive the operation. GNED puts all graphics-related data into
display strings.

<p>
GNED works by parsing your NED file into an internal data structure,
and regenerating the NED text when you save the file. One consequence
of this is that indentation will be ``canonized''
- hopefully you consider this fact as a plus and not as a minus.
Comments in the original NED are preserved - the parser associates
them with the NED elements they belong to, so comments won't
be messed up even if you edit the graphical representation to
death by removing/adding submodules, gates, parameters, connections,
etc.

<p>GNED is now a fully two-way visual tool. While editing the graphics,
you can always switch to NED source view, edit in there and switch
back to graphics. Your changes in the NED source will be immediately
backparsed to graphics; in fact, the graphics will be totally
reconstructed from the NED source and the display strings in
it.

<p>GNED is still under development. There are some missing functions
and bugs, but overall it should be fairly reliable. See the TODO
file in the GNED source directory for problems and missing features.

<p>
<H3><A NAME="sec169"/>4.12.1. Comment parsing</H3>

<p>
It is useful to know how exactly GNED identifies the comments
in the NED file. The following (maybe a bit long) NED code should
explain it:

<pre>
// ---------------------------------------------------------------
// File: sample.ned
//
// This is a file comment. File comments reach from the top of
// the file till the last blank line above the first code line.
// ---------------------------------------------------------------
//

// The file comment can also contain blank lines, so this is
// still part of the above file comment.
//
// Module1 --
//
// This is a banner comment for the Module1 declaration below.
// Banner comments can be multi-line, but they are not supposed
// to contain blank lines. (Otherwise the lines above the blank
// one will be taken as part of a file comment or trailing comment.)
//
module Module1
    submodules: // and this is right-comment
        // This is another banner comment, for the submodule
        submod1: Module;
            display: "p=120,108;b=96,72,rect";
            connections:
                out --&gt; submod1.in; // Right-comments can also be
                                    // multi-line.
endmodule

// Finally, this is a trailing comment, belonging to the above
// module. It may contain blank lines. Trailing comments are
// mostly used to put separator lines into the file, like this:
// --------------------------------------------------------------
// Module2 --
//
// an empty module
//
module Module2
endmodule
</pre>
<p>

<p><H3><A NAME="sec170"/>4.12.2. Keyboard and mouse bindings</H3>

<p>

<p>In graphics view, there are two editing modes: draw and select/mode.
The mouse bindings are the following:

<p>
<table border>
<TR> <TD align=left>

<b>Mouse</b> </TD> <TD align=left> <b>Effect</b></TD></TR>
<TR> <TD align=center colspan=2><b>In <EM>draw</EM> mode:</b> </TD></TR>
<TR> <TD align=left>
Drag out a rectangle in empty area: </TD> <TD align=left>  create new submodule </TD></TR>
<TR> <TD align=left> Drag from one submodule to another: </TD> <TD align=left>  create new connection </TD></TR>
<TR> <TD align=left> Click in empty area: </TD> <TD align=left> switch to select/move mode </TD></TR>
<TR> <TD align=center colspan=2><b>In <EM>select/move</EM> mode:</b> </TD></TR>
<TR> <TD align=left> Click submodule/connection: </TD> <TD align=left> select it</TD></TR>
<TR> <TD align=left> Ctrl-click submodule/conn.: </TD> <TD align=left> add to selection </TD></TR>
<TR> <TD align=left> Click in empty area: </TD> <TD align=left> clear selection</TD></TR>
<TR> <TD align=left> Drag a selected object: </TD> <TD align=left> move selected objects </TD></TR>
<TR> <TD align=left> Drag submodule or connection: </TD> <TD align=left> move it </TD></TR>
<TR> <TD align=left> Drag either end of connection: </TD> <TD align=left> move that end </TD></TR>
<TR> <TD align=left> Drag corner of (sub)module: </TD> <TD align=left> resize module</TD></TR>
<TR> <TD align=left> Drag starting in empty area: </TD> <TD align=left> select enclosed submodules/connections </TD></TR>
<TR> <TD align=left> <EM>Del</EM> key </TD> <TD align=left> delete selected objects </TD></TR>
<TR> <TD align=center colspan=2><b>Both editing modes:</b> </TD></TR>
<TR> <TD align=left> Right-click on module/submodule/connection: </TD> <TD align=left> popup menu </TD></TR>
<TR> <TD align=left> Double-click on submodule: </TD> <TD align=left> go into submodule </TD></TR>
<TR> <TD align=left> Click name label </TD> <TD align=left> edit name </TD></TR>
<TR> <TD align=left> Drag&amp;drop module type from the tree view to the canvas </TD> <TD align=left>
create a submodule of that type </TD></TR>
</table>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec 18 2003</samp></font>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec171"/>5. Simple Modules</H1>
<a name="cha:simple-modules"></a>

<p>The activities of simple modules are implemented by the user.
The algorithms are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction
to discrete event simulation in general, how its concepts are
implemented in OMNeT++, and gives an overview and practical advice
on how to design and code simple modules.

<p>

<p>
<hr><H2><A NAME="sec172"/>5.1. Simulation concepts</H2>

<p>This section contains a very brief introduction into how Discrete
Event Simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts and
implementation. If you're familiar with DES, you can skip
the next few sections.

<p>

<p>
<H3><A NAME="sec173"/>5.1.1. Discrete Event Simulation</H3>

<p>A <EM>Discrete Event System</EM> is a system where state changes
(events) happen at discrete points of time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events (in contrast to
<EM>continuous</EM> systems where state changes are continuous). Those
systems that can be viewed as Discrete Event Systems can be modeled
using Discrete Event Simulation.
(Continuous systems are modelled using differential equations and
suchlike.)

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:

<p><UL>
  <li><strong></strong>start of a packet transmission
  <li><strong></strong>end of a packet transmission
  <li><strong></strong>expiry of a retransmission timeout
</UL>

<p>
This implies that between two events such as <EM>start of a packet
transmission</EM> and <EM>end of a packet transmission</EM>, nothing
interesting happens. That is, the packet's state remains <EM>being
transmitted</EM>. Note that the definition of ``interesting'' events and states always
depends on the intent and purposes of the person doing the modeling.
If we were interested in the transmission of individual bits, we would
have included something like <EM>start of bit transmission</EM> and
<EM>end of bit transmission</EM> among our events.

<p>
The time when events occur is often called <EM>event timestamp</EM>
\indexevent timestamp; with OMNeT++ we'll say
<EM>arrival time</EM> (because in the class
library, the word ``timestamp'' is reserved for a user-settable
attribute in the event class). Time within the model is often called
<EM>simulation time</EM>, <EM>model time</EM>
 or <EM>virtual time</EM>
as opposed to real time or CPU time
or which refers to how long the simulation program has been running or
how much CPU time it has consumed.

<p>

<p><H3><A NAME="sec174"/>5.1.2. The event loop</H3>

<p>Discrete event simulations maintain the set of future
events in a data structure often called
FES (Future Event Set) or FEL (Future Event List).
Such simulators usually work according to the following pseudocode:

<p><pre>
<EM>initialize - this includes building the model and</EM>
              <EM>inserting initial events to FES</EM>

<p><EM>while (FES not empty and simulation not yet complete)</EM>
<EM>{</EM>
    <EM>retrieve first event from FES</EM>
    <EM>t:= timestamp of this event</EM>
    <STRONG><EM>process event</EM></STRONG>
    <EM>(processing may insert new events in  FES or delete existing ones)</EM>
<EM>}</EM>
<EM>finish simulation (write statistical results, etc.)</EM>
</pre>

<p>
The first, initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events
into the FES to ensure that the simulation can start. Initialization
strategy can be quite different from one simulator to another.

<p>
The subsequent loop consumes events from the FES and processes
them. Events are processed in strict timestamp order in order
to maintain causality, that is, to ensure that no event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a ``timeout
expired'' event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another ``timeout''
event, and so on. The user code may also remove events from the FES,
for example when cancelling timeouts.

<p>Simulation stops when there are no more events left (this happens
rarely in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the simulation
programmer will typically want to record statistics into output
files.

<p>

<p><H3><A NAME="sec175"/>5.1.3. Simple modules in OMNeT++</H3>

<p>In OMNeT++, events occur inside simple modules.
Simple modules encapsulate C++ code that generate and react to events,
in other words, implement the behaviour of the model.

<p>The user creates simple module types by subclassing the <tt>cSimpleModule</tt>
class, which is part of the OMNeT++ class library.
<tt>cSimpleModule</tt>, just as <tt>cCompoundModule</tt>, is derived
from a common base class, <tt>cModule</tt>.

<p><tt>cSimpleModule</tt>, although stuffed with simulation-related
functionality, doesn't do anything useful by itself - you have
to redefine some virtual member functions to make it do useful work.

<p>
These member functions are the following:
<UL>
  <li><strong></strong>void <tt>initialize()</tt>
  <li><strong></strong>void <tt>activity()</tt>
  <li><strong>void \fname[handleMessage()]</strong>handleMessage(cMessage *msg)
  <li><strong></strong>void <tt>finish()</tt>
</UL>

<p>In the initialization step, OMNeT++ builds the network: it creates the
necessary simple and compound modules and
connects them according to the NED definitions. OMNeT++ also calls the
<tt>initialize()</tt> functions of all modules.

<p>The <tt>activity()</tt> and <tt>handleMessage()</tt> functions are
called during event processing. This means that the user will
implement the model's behavior in these functions.
<tt>activity()</tt> and <tt>handleMessage()</tt> implement
different event processing strategies: for each simple module, the user
has to redefine exactly one of these functions. <tt>activity()</tt> is
a coroutine-based solution which implements the
process interaction approach (coroutines are non-preemptive
[cooperative] threads). <tt>handleMessage()</tt> is a method that is called
by the simulation kernel when the module receives a message.
Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt>
can be freely mixed within a simulation model.

<p>The <tt>finish()</tt> functions are called when the simulation
terminates successfully. The most typical use of <tt>finish()</tt>
is the recording of statistics collected during simulation.

<p>All these functions will be discussed later in detail.

<p>

<p><H3><A NAME="sec176"/>5.1.4. Events in OMNeT++</H3>

<p>OMNeT++ uses messages to represent
events. Each event is represented by an instance of the
<tt>cMessage</tt> class or one its subclasses; there is no separate
event class. Messages are sent from one module to another - this
means that the place where the ``event will occur'' is the
<EM>message's destination module</EM>, and the model time when the
event occurs is the <EM>arrival time</EM> of the
message. Events like ``timeout expired'' are implemented with the
module sending a message to itself.

<p>Simulation time in OMNeT++ is stored in the C++ type
<tt>simtime_t</tt>, which is a typedef for <tt>double</tt>.

<p>Events are consumed from the FES in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:
<OL>
<li><strong></strong>the message with <STRONG>earlier arrival time</STRONG> is executed
    first.  If arrival times are equal,
<li><strong></strong>the one with <STRONG>smaller priority value</STRONG> is executed first.
    If priorities are the same,
<li><strong></strong>the one <STRONG>scheduled or sent earlier</STRONG> is executed first.
</OL>

<p><EM>Priority</EM> is a user-assigned integer
attribute of messages.

<p>Storing simulation time in doubles may sometimes cause inconveniences.
Due to finite machine precision, two doubles calculated in two
different ways do not always compare equal even if they mathematically
should be. For example, addition is not an associative operation
when it comes to floating point calculations: $(x+y)+z != x+(y+z)$!
(See~[<a href="#bib-Goldberg91what">Goldberg91what</a>]).
This means that if you want to explicitly rely on the
arrival times of two events being the same, you should take care that
they are calculated in exactly the same way.
Another possible approach is to avoid equal arrival times,
for example by adding/subtracting small values to schedule times to
ensure specific execution order
(<EM>inorder_epsilon</EM>).

<p>One may suggest introducing a small <EM>simtime_precision</EM> parameter in
the simulation kernel that would force $t_1$ and $t_2$ to be regarded
equal if they are ``very close'' (if they differ
less than <EM>simtime_precision</EM>). However, in addition to the problem
determining the correct value for <EM>simtime_precision</EM>,
this approach is likely to cause confusion in many cases.

<p>

<p><H3><A NAME="sec177"/>5.1.5. FES implementation</H3>

<p>The implementation of the FES is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
implemented with <EM>binary heap</EM>, the most
widely used data structure for this purpose. Heap is also the best
algorithm we know, although exotic data structures like
<EM>skiplist</EM> may perform better than heap in some
cases. In case you're interested, the FES implementation is in the
<tt>cMessageHeap</tt> class, but as a simulation programmer you won't
ever need to care about it.

<p>

<p>

<p><hr><H2><A NAME="sec178"/>5.2. Packet transmission modeling</H2>
<a name="ch:simple-modules:packet-transmission"></a>

<p><H3><A NAME="sec179"/>5.2.1. Delay, bit error rate, data rate</H3>

<p>Connections can be assigned three parameters which facilitate
the modeling of communication networks, but can be useful for
other models too:
<UL>
  <li><strong></strong>propagation delay (sec)
  <li><strong></strong>bit error rate (errors/bit)
  <li><strong></strong>data rate (bits/sec)
</UL>

<p>
Each of these parameters is optional. One can specify link parameters
individually for each connection, or define link types (also
called <EM>channel</EM> <EM>types</EM>) once and use them throughout the
whole model.

<p>The <EM>propagation delay</EM> is the amount of time the arrival of
the message is delayed by when it travels through the channel.
Propagation delay is specified in seconds.

<p>The <EM>bit error rate</EM> has influence on the transmission of messages
through the channel. The bit error rate is the probability that
a bit is incorrectly transmitted. Thus, the probability that
a message of <EM>n</EM> bits length is transferred correctly is:<br>

<p>
$P( <EM>sent message received properly</EM> ) = (1 - <EM>ber</EM>)^<i>n</i>$<br>
where <EM>ber</EM> = bit error rate and <EM>n</EM> = number of bits in message.<br>

<p>
The message has an error flag which is set in case of transmission
errors.

<p>The <EM>data rate</EM> is specified in bits/second, and it is used
for transmission delay calculation. The sending time of the message
normally corresponds to the transmission of the first bit, and
the arrival time of the message corresponds to the reception
of the last bit (Fig. <a href="#fig:ch-overview:message-transm">[click]</a>).

<p>
<DIV ALIGN=center>
<img src="figures/usmanFig4.gif">
<center><i>Figure: Message transmission</i></center>
<a name="fig:ch-overview:message-transm"></a>
</DIV>

<p>
The above model is not applicable for modeling some protocols like
Token Ring and FDDI where the stations repeat the bits of a frame that
arrives on the ring immediately, without waiting for the whole frame
to arrive; in other words, frames ``flow through'' the stations, being
delayed only a few bits. If you want to model such networks, the data
rate modeling feature of OMNeT++ cannot be used.

<p>If a message travels along a route, through successive links and
compound modules, the model behaves as if each module waited until the
last bit of the message arrives and only start its transmission then
(Fig. <a href="#fig:ch-overview:msg-multiple-ch">[click]</a>).

<p>
<DIV ALIGN=center>
<img src="figures/usmanFig5.gif">
<center><i>Figure: Message sending over multiple channels</i></center>
<a name="fig:ch-overview:msg-multiple-ch"></a>
</DIV>

<p>
Since the above effect is usually not the desired one, typically
you will want to assign data rate to only one connection in the
route.

<p>

<p><H3><A NAME="sec180"/>5.2.2. Multiple transmissions on links</H3>

<p>
If data rate is specified for a connection, a message
will have a certain nonzero transmission time, depending on its length.  This means that when a message is
sent out through an output gate, the message ``reserves'' the gate for
a given period (``it is being transmitted'').

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig9.gif">
    <center><i>Figure: Connection with a data rate</i></center>
    <a name="fig:ch-simple-modules:conn-w-data-rate"></a>
  </DIV>

<p>
While a message is under transmission, other messages have to wait
until the transmission finishes. You can still send messages
while the gate is busy, but the beginning of the modelled
message transmission will be delayed, just like the gate had
an internal queue for the messages waiting to be transmitted.

<p>The OMNeT++ class library provides you with functions to check
whether a certain output gate is transmitting or to learn when
it finishes transmission.

<p>If the connection with a data rate is not the immediate one connected
to the simple module's output gate but the second
one in the route, you have to check the second gate's busy
condition.

<p>
<br><P class="subheading">Implementation of message sending</P>

<p>
Message sending is implemented in the following way: the arrival
time and the bit error flag of a
message are calculated at once, when the <tt>send()</tt> (or similar)
function is invoked. That is, if the message travels through several
links until it reaches its destination, it is <EM>not</EM> scheduled
individually for each link, but rather, every calculation is done
once, within the <tt>send()</tt> call. This implementation was chosen
because of its run-time efficiency.

<p>In the actual implementation of queuing the messages at busy gates and
modeling the transmission delay, messages do not actually queue up in
gates; gates do not have internal queues. Instead, as the time when
each gate will finish transmission is known at the time of sending the
message, the arrival time of the message can be
calculated in advance. Then the message will be stored in the event
queue (FES) until the simulation time advances to its
arrival time and it is retrieved by its destination module.



<p><br><P class="subheading">Consequence</P>

<p>
The implementation has the following consequence. If you change the
delay (or the bit error rate, or the data rate) of a link during simulation, the modeling of messages sent ``just
before'' the parameter change will not be accurate. Namely, if link
parameters change while a message is ``under way'' in the model, that
message will not be affected by the parameter change, although it
should. However, all subsequent messages will be modelled correctly.
Similar for data rate: if a data rate changes during the simulation,
the change will affect only the messages that are <EM>sent</EM> after
the change.

<p>If it is important to model gates and channels with changing
properties, you can go two ways:
<UL>
  <li><strong></strong>write sender module such that they schedule events for when the
    gate finishes its current transmission and send then;
  <li><strong></strong>alternatively, you can implement channels with
    simple modules (``active channels'').
</UL>

<p>
<br><P class="subheading">The approach of some other simulators</P>

<p>
Note that some simulators (e.g. OPNET) assign <EM>packet queues</EM>
to input gates (ports), and messages sent are buffered at the
destination module (or the remote end of the link) until received by
the destination module. With that approach, events and messages are
separate entities, that is, a <EM>send</EM> operation includes placing
the message in the packet queue <EM>and</EM> scheduling an event which
will signal the arrival of the packet. In some implementations, also
output gates have packet queues where packets wait until the channel
becomes free (available for transmission).

<p>OMNeT++ gates don't have associated queues. The place
where the sent but not yet received messages are buffered is the
FES\indexFES.  OMNeT++'s approach is potentially faster
than the above mentioned solution because it doesn't have the
enqueue/dequeue overhead and also spares an event creation. The
drawback is, as mentioned above, that changes to channel parameters do
not take effect immediately.

<p>

<p>
<hr><H2><A NAME="sec181"/>5.3. Defining simple module types</H2>

<p><H3><A NAME="sec182"/>5.3.1. Overview</H3>

<p>The C++ implementation of a simple module consists of:
<UL>
<li><strong></strong>declaration of the module class: your class subclassed from <tt>cSimpleModule</tt>
(either directly or indirectly)
<li><strong></strong>a module type registration (<tt>Define_Module()</tt> or
    <tt>Define_Module_Like()</tt> macro)
<li><strong></strong>implementation of the module class
</UL>

<p>
For example, the C++ source for a Sliding Window Protocol implementation
might look like this:

<pre>
// file: swp.cc
#include &lt;omnetpp.h&gt;

// module class declaration:
class SlidingWindow : public cSimpleModule
{
    Module_Class_Members(SlidingWindow,cSimpleModule,8192)
    virtual void activity();
};

// module type registration:
Define_Module( SlidingWindow );

// implementation of the module class:
void SlidingWindow::activity()
{
  int windowSize = par("windowSize");
...
}
</pre>
<p>
In order to be able to refer to this simple module type in NED
files, we should have an associated NED declaration which might
look like this:

<p>
<pre>
// file: swp.ned
<STRONG>simple</STRONG> SlidingWindow
    <STRONG>parameters</STRONG>:
        windowSize: <STRONG>numeric const</STRONG>;
    <STRONG>gates</STRONG>:
        <STRONG>in:</STRONG> fromNet, fromUser;
        <STRONG>out:</STRONG> toNet, toUser;
<STRONG>endsimple</STRONG>
</pre>

<p>

<p>
<H3><A NAME="sec183"/>5.3.2. The module declaration</H3>


<p>The module declaration
<UL>
<li><strong></strong>announces that you're going to use the class as a
    simple module type
<li><strong></strong>associates the module class with an interface declared in NED
</UL>

<p><br><P class="subheading">Forms of module declaration</P>

<p>
Module declarations can take two forms:

<p><pre>
Define_Module(<EM>classname</EM>);
Define_Module_Like(<EM>classname</EM>, <EM>neddeclname</EM>);
</pre>

<p>The first form associates the class (subclassed from
<tt>cSimpleModule</tt>) with the NED simple
module declaration of the same name. For example, the

<pre>
Define_Module(SlidingWindow);
</pre>
<p>
line would ensure that when you create an instance of SlidingWindow in
your NED files, the module has the parameters and gates given in the
simple SlidingWindow NED declaration, and the implementation will be
an instance of the SlidingWindow C++ class.

<p>
The second form associates the class with a NED
simple module declaration of a different name.
You can use this form when you have several modules which share the
same interface. This feature will be discussed in detail in the next
section.

<p>
<br><P class="subheading">Header files</P>

<p>
Module declarations should not be put into header files, because they are macros expanding to lines for which the
compiler generates code.

<p>
<br><P class="subheading">Compound modules</P>

<p>All module types (including compound modules)
need to have module declarations. For all
compound modules, the NEDC compiler generates the
<tt>Define_Module(..)</tt> lines automatically.
However, it is your responsibility to put Define_Module(..) lines into
one of the C++ sources for all your simple module types.

<p>
<br><P class="subheading">Implementation</P>

<p>
Unless you are dying to learn about the dirty internals, you may just
as well skip this section. But if you're interested, here it is:
<tt>Define_Module()</tt> (and also <tt>Define_Module_Like()</tt>) is a
macro which expands to a function definition plus the definition of a
global object, something like this ugly code (luckily, you won't ever
need to be interested in it):

<p><pre>
static cModule *<EM>MyClass</EM>__create(const char *name, cModule *parentmod)

    return (cModule *) new <EM>MyClass</EM>(name, parentmod);


<p>cModuleType <EM>MyClass</EM>__type("<EM>MyClass</EM>","<EM>MyClass</EM>",
 (ModuleCreateFunc)<EM>MyClass</EM>__create);
</pre>

<p>
The <tt>cModuleType</tt> object can act as a factory: it is able to
create an instance of the given module type. This, together with the
fact that all <tt>cModuleType</tt> objects are available in a single
linked list, allows OMNeT++ to instantiate module types given only
their class names as strings, without having to include the class
declaration into any other C++ source.

<p>
The global object also stores the name of the NED
interface associated with the module class. The
interface description object
(another object, generated by nedc) is looked up automatically at
network construction time. Whenever a module of the given type is
created, it will automatically have the parameters and gates specified
in the associated interface description.

<p>

<p><H3><A NAME="sec184"/>5.3.3. Several modules, single NED interface</H3>

<p>To support submodule types defined as parameters in
NED files (see section <a href="#sec:ch-ned-lang:like">[click]</a>),
you can reuse an existing NED simple module definition
for several simple module types.

<p>Suppose you have three different C++ module classes (<tt>TokenRingMAC</tt>,
<tt>EthernetMAC</tt>, <tt>FDDIMAC</tt>) which have identical gates and parameters.
Then you can create a single NED declaration, <tt>GenericMAC</tt> for them
and write the following module declarations in the C++ code:

<pre>
Define_Module_Like(TokenRingMAC, GenericMAC);
Define_Module_Like(EthernetMAC, GenericMAC);
Define_Module_Like(FDDIMAC, GenericMAC);
</pre>
<p>
You won't be able to directly refer to the <tt>TokenRingMAC</tt>,
<tt>EthernetMAC</tt>, <tt>FDDIMAC</tt> module types in your NED files,
because NED doesn't know about them (their names don't appear
in any NED file you could import), but you can use them wherever
a submodule type was defined as a parameter to the compound module:

<pre>
module Host
    parameters:
        macType: string;
    submodules:
        mac: macType like GenericMAC;
                // if macType=="EthernetMAC" --&gt; OK!
     ...
endmodule
</pre>
<p>
<p>
The <tt>macType</tt> parameter should take the value <SAMP>"TokenRingMAC"</SAMP>,
<SAMP>"EthernetMAC"</SAMP> or <SAMP>"FDDIMAC"</SAMP>, and a submodule of the appropriate
type will be created. The value for the parameter can even be given in
the ini file. This gives you a powerful tool to customize simulation
models (see also <EM>Topology templates</EM>, Section
<a href="#sec:ch-ned-lang:topology-templates">[click]</a>).
</p>

<p>

<p>
<H3><A NAME="sec185"/>5.3.4. The class declaration</H3>

<p>As mentioned before, simple module classes have
to be derived from <tt>cSimpleModule</tt> (either directly or
indirectly). In addition to overwriting some of the previously
mentioned four member functions (<tt>initialize()</tt>,
<tt>activity()</tt>, <tt>handleMessage()</tt>,<tt>finish()</tt>), you
have to write a constructor and some more
functions. Some of this task can be automated, so when writing the C++
class declaration, you have two choices:
<OL>
<li><strong></strong>either use a macro which expands to the ``stock'' version of the
    functions
<li><strong></strong>or write them yourself.
</OL>

<p><br><P class="subheading">Using macro to declare the constructor</P>

<p>If you choose the first solution, you use the
<tt>Module_Class_Members()</tt> macro:

<p><pre>
Module_Class_Members(<EM>classname</EM>, <EM>baseclass</EM>, <EM>stacksize</EM>);
</pre>

<p>The first two arguments are obvious (<EM>baseclass</EM> is usually <tt>cSimpleModule</tt>),
but <EM>stacksize</EM> needs some explanation. If you use <tt>activity()</tt>,
the module code runs as a coroutine, so it will need a separate
stack. (This will be discussed in detail later.)

<p>
As an example, the class declaration

<pre>
class SlidingWindow : public cSimpleModule
{
    Module_Class_Members(SlidingWindow,cSimpleModule,8192)
    ...
};
</pre>
<p>
expands to something like this:

<pre>
class SlidingWindow : public cSimpleModule
{
  public:
    SlidingWindow(const char *name, cModule *parentmodule,
        unsigned stacksize = 8192) :
        cSimpleModule(name, parentmodule, stacksize) {}
    ...
};
</pre>
<p>
<br><P class="subheading">Expanded form of the constructor</P>

<p>If you have data members in the class that you want to initialize in the
constructor, you cannot use the <tt>Module_Class_Members()</tt> macro.
Then you have to write the constructor yourself.

<p>The constructor should take the following
arguments (which you also have to pass further to the base class):

<p><UL>
  <li><strong></strong><tt>const char *name</tt>, which is the name of the module
  <li><strong></strong><tt>cModule *parentmodule</tt>, pointer to the parent module
  <li><strong></strong><tt>unsigned stacksize=<EM>stacksize</EM></tt>, the coroutine stack size
</UL>

<p>You should not change the number or types of the arguments taken
by the constructor, because it will be called by OMNeT++-generated
code.

<p>An example:

<pre>
class TokenRingMAC : public cSimpleModule
{
  public:
    cQueue queue; // a data member
    TokenRingMAC(const char *name, cModule *parentmodule,
                 unsigned stacksize = 8192);
    ...
};

TokenRingMAC(const char *name, cModule *parentmodule,
    unsigned stacksize) :
    cSimpleModule(name, parentmodule, stacksize), queue("queue")
{
  // initialize data members
}
</pre>
<p>

<p><br><P class="subheading">Stack size decides between activity() and handleMessage()</P>

<p><UL>
<li><strong></strong>if the specified stack size is zero, <tt>handleMessage()</tt> will be used;
<li><strong></strong>if it is greater than zero, <tt>activity()</tt> will be used.
</UL>

<p>If you make a mistake (e.g. you forget to set zero stack size
 for a <tt>handleMessage()</tt>
simple module): the default versions of the
functions issue error messages telling you what is the problem.

<p>

<p>

<p><H3><A NAME="sec186"/>5.3.5. Decomposing activity()/handleMessage()</H3>

<p>It is usually a good idea to decompose a <tt>activity()</tt> or
<tt>handleMessage()</tt> function when it grows too large. ``Too
large'' is a matter of taste of course, but you should definitely
consider splitting up the function if it is more that a few screens
(say 50-100 lines) long. This will have a couple of advantages:
<UL>
<li><strong></strong>will help future readers of the code understand your program;
<li><strong></strong>will help <EM>you</EM> understand what it is you're really programming
and bring some structure into it;
<li><strong></strong>will enable you to customize the class by inheriting from it and
    overwriting member functions
</UL>

<p>If you have variables which you want to access from all member
functions (typically state variables are like that), you'll need to
add those variables to the class as data members.

<p>Let's see an example:

<pre>
class TransportProtocol : public cSimpleModule
{
  public:
    Module_Class_Members(TransportProtocol, cSimpleModule, 8192)
    int windowSize;
    int n_s; // N(s)
    int n_r; // N(r)
    cOutVector eedVector;
    cStdDev eedStats;
    //...

    virtual void activity();
    virtual void recalculateTimeout();
    virtual void insertPacketIntoBuffer(cMessage *packet);
    virtual void resendPacket(cMessage *packet);
    //...
};

Define_Module( TransportProtocol );

void TransportProtocol::activity()
{
    windowSize = par("windowSize");
    n_s = n_r = 0;
    eedVector.setName("End-to-End Delay");
    eedStats.setName("eedStats");
    //...
}

//...
</pre>
<p>
<p>
Note that you may have to use the expanded form of the
constructor (instead of
<tt>Module_Class_Members()</tt>) to pass arguments to the constructors
of member objects like eedVector and eedStats. But most often you
don't need to go as far as that; for example, you can set parameters
later from <tt>activity()</tt>, as shown in the example above.
</p>

<p>

<p><H3><A NAME="sec187"/>5.3.6. Using inheritance</H3>

<p>It is often needed to have several variants of a simple module.
A good design strategy is to create a simple module class with
the common functionality, then subclass from it to create the
specific simple module types.

<p>An example:

<pre>
class AdvancedTransportProtocol : public TransportProtocol
{
  public:
    Module_Class_Members(AdvancedTransportProtocol, TransportProtocol,
                      8192)
    virtual void recalculateTimeout();
};

Define_Module( AdvancedTransportProtocol );

void AdvancedTransportProtocol::recalculateTimeout()
{
    //...
}
</pre>
<p>

<p><H3><A NAME="sec188"/>5.3.7. Global variables</H3>


<p>If possible, avoid them. Do not use global variables, including
static class members. There are several problems with them.

<p>First, they are not reset to their initial values (to zero)
when you rebuild the simulation in Tkenv, or start another run
in Cmdenv. This may produce surprising results.

<p>Second, they prevent you from running your simulation in parallel.
When using parallel simulation, each partition of your model
(may) run in a separate process, having its own copy of the
global variables. This is usually not what you want.

<p>

<p>

<p><hr><H2><A NAME="sec189"/>5.4. Adding functionality to cSimpleModule</H2>

<p>This section discusses <tt>cSimpleModule</tt>'s four previously
mentioned member functions, intended to be redefined by the user:
<tt>initialize()</tt>, <tt>activity()</tt>, <tt>handleMessage()</tt> and
<tt>finish()</tt>.

<p>
<H3><A NAME="sec190"/>5.4.1. activity()</H3>

<p><br><P class="subheading">Process-style description</P>

<p>With <tt>activity()</tt>, you can code the simple
module much like you would code an operating system process or a
thread. You can wait for an incoming message (event) at any point of
the code, you can suspend the execution for some time (model time!),
etc. When the <tt>activity()</tt> function exits, the module is
terminated.  (The simulation can continue if there are other modules
which can run.)

<p>
The most important functions you can use in <tt>activity()</tt> are
(they will be discussed in detail later):
<UL>
<li><strong></strong><tt>receive()</tt> - to receive messages (events)
<li><strong></strong><tt>wait()</tt> - to suspend execution
    for some time (model time)
<li><strong></strong><tt>send()</tt> family of functions - to send messages to other
    modules
<li><strong></strong><tt>scheduleAt()</tt> - to schedule an event (the module ``sends
    a message to itself'')
<li><strong></strong><tt>cancelEvent()</tt> - to delete an event scheduled with
    scheduleAt()
<li><strong></strong><tt>end()</tt> - to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</UL>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><br><P class="subheading">Application area</P>

<p>
One area where the process-style description is especially convenient is when the process has many
states but transitions are very limited, ie. from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application which uses a single
network connection.  The pseudocode of the application which talks to
a transport layer protocol might look like this:

<p><pre>
<EM>activity()</EM>
{
    while(true)
    {
        open connection by sending OPEN command to transport layer
        receive reply from transport layer
        if (open not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

<p>        while(there's more to do)
        {
            send data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
            receive data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
        }
        close connection by sending CLOSE command to transport layer
        if (close not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>

<p>If you want to handle several connections simultaneously, you may
dynamically create as instances of the simple
module above as needed. Dynamic module creation will be discussed
later.

<p>
<br><P class="subheading">Activity() is run as a coroutine</P>

<p>
<tt>Activity()</tt> is run in a coroutine.
Coroutines are a sort of threads which are scheduled
non-preemptively (this is also called cooperative
multitasking). From one coroutine you
can switch to another coroutine by a
<tt>transferTo(otherCoroutine)</tt> call. Then this
coroutine is suspended and <EM>otherCoroutine</EM> will run. Later,
when <EM>otherCoroutine</EM> does a
<tt>transferTo(firstCoroutine)</tt> call, execution of
the first coroutine will resume from the point of the
<tt>transferTo(otherCoroutine)</tt> call.  The full state
of the coroutine, including local variables are preserved while the
thread of execution is in another coroutines.  This implies that each
coroutine must have an own processor stack, and
<tt>transferTo()</tt> involves a switch from one processor stack to
another.

<p>
Coroutines\indexcoroutine are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does he need to care
about the coroutine library implementation. But it is important to
understand how the event loop found in discrete event simulators works
with coroutines.

<p>
When using coroutines, the event loop looks like
this (simplified):

<p>
<pre>
<EM>while (FES not empty and simulation not yet complete)</EM>
{
    retrieve first event from FES
    t:= timestamp of this event
    <STRONG>transferTo(module containing the event)</STRONG>
}
</pre>

<p>

<p>That is, when the module has an event, the simulation
kernel transfers the control to the module's coroutine. It is expected
that when the module ``decides it has finished the processing of the
event'', it will transfer the control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple modules using <tt>activity()</tt> are
``booted'' by events (<EM>''starter messages''</EM>)
inserted into the FES by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has ``finished processing the event''?
The answer: <EM>when it requests another event</EM>.  The functions
which request events from the simulation kernel are the
<tt>receive()</tt> and <tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++:

<p>
<pre>
receive()
{
    transferTo(main)
    retrieve current event
    return the event // remember: events = messages
}

<p>wait()
{
    create event e
    schedule it at (current sim. time + wait interval)
    transferTo(main)
    retrieve current event
    if (current event is not e) {
        error
    }
    delete e  // note: actual impl. reuses events
    return
}
</pre>

<p>

<p>Thus, the <tt>receive()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function, because that's
where:

<p><UL>
  <li><strong></strong>simulation time elapses in the module, and
  <li><strong></strong>other modules get a chance to execute.
</UL>

<p>
<br><P class="subheading">Starter messages</P>

<p>
Modules written with <tt>activity()</tt> need starter
messages to ``boot''.  These starter messages
are inserted into the FES\indexFES automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<br><P class="subheading">Coroutine stack size</P>

<p>
All the simulation programmer needs to care about coroutines is to
choose the processor stack size for them.
This cannot be automated (Eerrr... at least not without hardware
support, some trick with virtual memory handling).

<p>16 kbytes is usually a good choice, but you may need more if the
module uses recursive functions or has local variables which occupy a
lot of stack space. OMNeT++ has a built-mechanism that will usually
detect if the module stack is too small and
overflows\indexstack!overflow. OMNeT++ can also tell you how much
stack space a module actually uses, so you can find
it out if you overestimated the stack needs.

<p>
<br><P class="subheading">initialize() and finish() with activity()</P>

<p>
Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>
However, you need <tt>finish()</tt> if you want to write statistics at
the end of the simulation. And because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects that contain the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>
Thus, a typical setup looks like this pseudocode:

<p>
<pre>
<EM>class MySimpleModule...</EM>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

<p>MySimpleModule::activity()
{
    declare local vars and initialize them
    initialize statistics collection variables

<p>    while(true)
    {
        ...
    }
}

<p>MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>

<p><br><P class="subheading">Advantages and drawbacks of <tt>activity()</tt> vs <tt>handleMessage()</tt></P>

<p>Advantages:
<UL>
<li><strong></strong><tt>initialize()</tt> not needed, state can be stored in local
    variables of <tt>activity()</tt>
<li><strong></strong>process-style description is a natural programming model in many
    cases
</UL>

<p>Drawbacks:
<UL>
<li><strong></strong>memory overhead: stack allocation may unacceptably increase the
    memory requirements of the simulation program if you have several
    thousands or ten thousands of simple modules;
<li><strong></strong>run-time overhead: switching between coroutines is somewhat slower
    than a simple function call
</UL>

<p>
<br><P class="subheading">Other simulators</P>

<p>
Coroutines are used by a number of other simulation packages:
<UL>
<li><strong></strong>All simulation software which inherit from SIMULA (e.g. C++SIM)
    are based on coroutines, although all in all the programming
    model is quite different.
<li><strong></strong>The simulation/parallel programming language Maisie and its successor
    PARSEC (from UCLA) also use coroutines (although implemented
    on with ``normal'' preemptive threads). The philosophy
    is quite similar to OMNeT++. PARSEC, being ``just''
    a programming language, has a more elegant syntax but much less
    features than OMNeT++.
<li><strong></strong>Many Java-based simulation libraries are based on Java
    threads.
</UL>

<p>

<p><H3><A NAME="sec191"/>5.4.2. handleMessage()</H3>

<p><br><P class="subheading">Function called for each event</P>

<p>
The idea is that at each event we simply call a
user-defined function instead of switching to a coroutine that has
<tt>activity()</tt> running in it. The ``user-defined function'' is the
<tt>handleMessage(cMessage *msg)</tt> virtual member
function of <tt>cSimpleModule</tt>; the user has to redefine the
function to make it do useful work.  Calls to <tt>handleMessage()</tt>
occur in the main stack of the program - no coroutine stack is needed
and no context switch is done.

<p>
The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>The pseudocode of the event loop which is able to handle both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules:

<p><pre>
<EM>while (FES not empty and simulation not yet complete)</EM>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <STRONG>m-&gt;handleMessage( event )</STRONG>
    else // m works with activity()
        transferTo( m )
}
</pre>

<p>Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages from the
<tt>initialize()</tt> function if you want a <tt>handleMessage()</tt>
simple module to start working ``by itself'', without first receiving
a message from other modules.

<p>
<br><P class="subheading">Programming with handleMessage()</P>

<p>
To use the <tt>handleMessage()</tt> mechanism in a
simple module, you must specify <EM>zero
  stack size</EM> for the module. This is
important, because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt> and not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:

<p><UL>
  <li><strong></strong><tt>send()</tt> family of functions - to send messages to other modules
  <li><strong></strong><tt>scheduleAt()</tt> - to schedule an event (the module ``sends a message to itself'')
  <li><strong></strong><tt>cancelEvent()</tt> - to delete an event scheduled with <tt>scheduleAt()</tt>
</UL>

<p>You cannot use the <tt>receive()</tt> family and
<tt>wait()</tt> functions in <tt>handleMessage()</tt>, because they are
coroutine-based by nature, as explained in the section about
<tt>activity()</tt>.

<p>You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class), because
they would be shared between all instances of the class.

<p>
Data members to be added to the module class will typically include
things like:

<p><UL>
  <li><strong></strong>state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
  <li><strong></strong>other variables which belong to the state of the module: retry
    counts, packet queues, etc.
  <li><strong></strong>values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
  <li><strong></strong>pointers of message objects created once and then reused for
    timers, timeouts, etc.
  <li><strong></strong>variables/objects for statistics collection
</UL>

<p>You can initialize these variables from the <tt>initialize()</tt>
function.  The constructor is not a very good place
for this purpose, because it is called in the network setup phase when
the model is still under construction, so a lot of information you may
want to use is not yet available then.

<p>Another task you have to do in <tt>initialize()</tt> is to schedule
initial event(s) which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the ``chain'' is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p><tt>finish()</tt> is used in the normal way: to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<br><P class="subheading">Application area</P>

<p>
<tt>handleMessage()</tt> is definately a better choice than <tt>activity()</tt>
in many cases:

<p><OL>
  <li><strong></strong>When you expect the module to be used in large simulations,
      involving several thousand modules. In such cases, the module stacks
      required by <tt>activity()</tt> would simply consume too much memory.
  <li><strong></strong>For modules which maintain little or no state information,
      such as packet sinks, <tt>handleMessage()</tt> is more convenient to program.
  <li><strong></strong>Other good candidates are modules with a large state space and
      many arbitrary state transition possibilities (i.e. where there
      are many possible subsequent states for any state). Such algorithms
      are difficult to program with <tt>activity()</tt>, or the result is code
      which is better suited for <tt>handleMessage()</tt> (see rule of thumb
      below). Most communication protocols are like this.
</OL>

<p>In general, if your <tt>activity()</tt> function contains no
<tt>wait()</tt> and it has only one <tt>receive()</tt> call
at the top of an infinite loop (<tt>while(true)</tt> or <tt>for(;;)</tt>),
you can trivially convert it to <tt>handleMessage()</tt>.
The body of the infinite loop becomes the body to <tt>handleMessage()</tt>,
state variables inside <tt>activity()</tt> become data members in
the module class, and you initialize them in <tt>initialize()</tt>.

<p>That is, the following code:

<p><pre>
<EM>activity()</EM>
{
    initialization code
    while(true)
    {
        msg = receive();
        // code which doesn't contain
        // receive() or wait() calls
    }
}
</pre>

<p>becomes like this:

<p><pre>
<EM>initialize()</EM>
{
    initialization code
}

<p>handleMessage( msg )
{
    // code which doesn't contain
    // receive() or wait() calls
}
</pre>

<p>

<p><br><P class="subheading">Example 1: Simple traffic generators and sinks</P>

<p>
The code for simple packet generators and sinks programmed with <tt>handleMessage()</tt> might
be as simple as this:

<p><pre>
PacketGenerator::handleMessage(m)
{
    create and send out packet
    schedule m again to trigger next call to handleMessage
      // (self-message)
}
PacketSink::handleMessage(m)
{
    delete m
}
</pre>

<p>

<p>Note that <EM>PacketGenerator</EM> will need to redefine <tt>initialize()</tt>
to create <EM>m</EM> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre>
class Generator : public cSimpleModule
{
    Module_Class_Members(Generator,cSimpleModule,0)
    // note zero stack size!
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

<p>Define_Module( Generator );

<p>void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new cMessage);
}

<p>void Generator::handleMessage(cMessage *msg)
{
    // generate & send packet
    cMessage *pkt = new cMessage;
    send(pkt, "out");
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><br><P class="subheading">Example 2: Bursty traffic generator</P>

<p>
A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of <tt>burstLength</tt> packets.

<p>
We add some data members to the class:
<UL>
<li><strong></strong><tt>burstLength</tt> will store the parameter that specifies how many
    packets a burst must contain,
<li><strong></strong><tt>burstCounter</tt> will count in how many packets are left to be sent
    in the current burst.
</UL>

<p>The code:

<p><pre>
class BurstyGenerator : public cSimpleModule
{
    Module_Class_Members(Generator,cSimpleModule,0)
    // note the zero stack size!
    int burstLength;
    int burstCounter;
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

<p>Define_Module( BurstyGenerator );
void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burstLength = par("burstLength");
    burstCounter = burstLength;
    // schedule first packet of first burst
    scheduleAt(simTime(), new cMessage);
}

<p>void BurstyGenerator::handleMessage(cMessage *msg)
{
    // generate & send packet
    cMessage *pkt = new cMessage;
    send(pkt, "out");
    // if this was the last packet of the burst
    if (-burstCounter == 0)
    {
        // schedule next burst
        burstCounter = burstLength;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else
    {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>

<p>

<p><br><P class="subheading">Advantages and drawbacks of <tt>handleMessage()</tt> vs <tt>activity()</tt></P>

<p>
Advantages:
<UL>
<li><strong></strong>consumes less memory: no separate stack needed for
    simple modules
<li><strong></strong>fast: function call is faster than switching between coroutines
</UL>

<p>
Drawbacks:
<UL>
<li><strong></strong>local variables cannot be used to store state information
<li><strong></strong>need to redefine <tt>initialize()</tt>
<li><strong></strong>programming model is inconvenient in some cases
</UL>

<p><br><P class="subheading">Other simulators</P>

<p>
Many simulation packages use a similar approach, often topped with
something like a state machine
(FSM) which hides the underlying function calls. Such
systems are:
<UL>
  <li><strong></strong>OPNET<sup>(TM)</sup> (MIL3, Inc.) which uses FSM's designed using a graphical editor;
  <li><strong></strong>NetSim++ clones OPNET's approach;
  <li><strong></strong>SMURPH (University of Alberta) defines a (somewhat eclectic)
      language to describe FSMs, and uses a precompiler to turn it
      into C++ code;
  <li><strong></strong>Ptolemy (UC Berkeley) uses a similar method.
</UL>

<p>OMNeT++'s FSM support is described in the next section.

<p>

<p><H3><A NAME="sec192"/>5.4.3. initialize() and finish()</H3>

<p><br><P class="subheading">Purpose</P>

<p>
<tt>initialize()</tt> - to provide place for any user setup code

<p><tt>finish()</tt> - to provide place where the user can record statistics
after the simulation has completed

<p>
<br><P class="subheading">When and how they are called</P>

<p>
The <tt>initialize()</tt> functions of the modules are invoked
<EM>before</EM> the first event is processed, but <EM>after</EM> the
initial events (starter messages) have been
placed into the FES by the simulation kernel.

<p>
Both simple and compound modules have <tt>initialize()</tt> functions.
A compound module has its <tt>initialize()</tt> function called
<EM>before</EM> all its submodules have.

<p>
The <tt>finish()</tt> functions are called when the event
loop has terminated, and only if it terminated
normally (i.e. not with a runtime error).  The calling order is the
reverse as with <tt>initialize()</tt>: first submodules, then the
containing compound module. (The bottom line is that in the moment
there's no ``official'' possibility to redefine <tt>initialize()</tt>
and <tt>finish()</tt> for compound modules; the unofficial way is to
write into the nedc-generated C++ code. Future versions of OMNeT++ will
support adding these functions to compound
modules.)

<p>This is summarized in the following pseudocode (although you
won't find this code ``as is'' in the simulation
kernel sources):

<p>
<pre>
<EM>perform simulation run:</EM>
    build network
      (i.e. the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on system module
        <EM>enter event loop // (described earlier)</EM>
    if (event loop terminated normally) // i.e. no errors
        do callFinish() on system module
    clean up

<p>callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on submodule
}

<p>callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on submodule
    call to user-defined finish() function
}
</pre>

<p>

<p><br><P class="subheading">initialize() vs. constructor</P>

<p>
Usually you should not put simulation-related code into the
simple module constructor. For
example, modules often need to investigate their surroundings (maybe
the whole network) at the beginning of the simulation and save the
collected info into internal tables.  Code like that cannot be placed
into the constructor since the network is still being set up when the
constructor is called.

<p>
<br><P class="subheading">finish() vs. destructor</P>

<p>
Keep in mind that <tt>finish()</tt> is not always called, so it isn't a
good place for cleanup code which should run every time the module is
deleted. <tt>finish()</tt> is only a good place for writing statistics,
result post-processing and other stuff which are to run only on
successful completion.

<p>Cleanup code should go into the destructor. But in
fact, you almost never need to write a destructor because OMNeT++
keeps track of objects you create and disposes of them automatically
(sort of automatic garbage collection). However it cannot track
objects not derived from <tt>cObject</tt>, so they may
need to be deleted manually from the destructor. Garbage collection
is discussed in more detail in section <a href="#sec:ch-sim-lib:garbage-collection">[click]</a>.

<p>

<p><br><P class="subheading">Multi-stage initialization</P>

<p>
In simulation models, when one-stage
initialization provided by <tt>initialize()</tt>
is not sufficient, one can use multi-stage
initialization.  Modules have two
functions which can be redefined by the user:

<pre>
void initialize(int stage);
int numInitStages() const;
</pre>
<p>
At the beginning of the simulation, <tt>initialize(0)</tt>
is called for <EM>all</EM> modules, then <tt>initialize(1)</tt>,
<tt>initialize(2)</tt>, etc. You can think of it like
initialization takes place in several ``waves''. For each module,
<tt>numInitStages()</tt> must be redefined to return the number of init
stages required, e.g. for a two-stage init, <tt>numInitStages()</tt>
should return 2, and <tt>initialize(int stage)</tt> must be implemented to
handle the <EM>stage=0</EM> and <EM>stage=1</EM> cases.
  <br><ul><font size=-1>[Note <tt>const</tt> in the <tt>numInitStages()</tt> declaration.
  If you forget it, by C++ rules you create a <EM>different</EM> function
  instead of redefining the existing one in the base class, thus the
  existing one will remain if effect and return 1.]</font></ul>

<p>The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for that module and all its submodules.

<p>If you do not redefine the multi-stage initialization functions, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default \fname[initialize]initialize(int
stage) simply calls <tt>initialize()</tt>.

<p>
<br><P class="subheading">``End-of-Simulation'' event</P>

<p>
The task of <tt>finish()</tt> is solved in many simulators (e.g. OPNET)
by introducing a special
<EM>end-of-simulation</EM> event. This is not
a very good practice because the simulation programmer has to code the
models (often represented as FSMs) so that they can <EM>always</EM> properly
respond to end-of-simulation events, in whichever state they are. This
often makes program code unnecessarily complicated.

<p>This fact is also evidenced in the design of the PARSEC
simulation language (UCLA). Its predecessor Maisie used
end-of-simulation events, but - as documented in the PARSEC manual -
this has led to awkward programming in many cases, so for PARSEC
end-of-simulation events were dropped in favour of <tt>finish()</tt>
(called <tt>finalize()</tt> in PARSEC).

<p>

<p>

<p><hr><H2><A NAME="sec193"/>5.5. Finite State Machines in OMNeT++</H2>

<p><br><P class="subheading">Overview</P>

<p>
Finite State Machines (FSMs)
can make life with <tt>handleMessage()</tt> easier. OMNeT++ provides a
class and a set of macros to build FSMs. OMNeT++'s FSMs work very much
like OPNET's or SDL's.

<p>
The key points are:
<UL>
<li><strong></strong>There are two kinds of states:
    <EM>transient</EM> and
    <EM>steady</EM>. At each event (that is, at
    each call to <tt>handleMessage()</tt>), the FSM transitions out of
    the current (<EM>steady</EM>) state, undergoes a series of state
    changes (runs through a number of <EM>transient</EM> states), and
    finally arrives at another <EM>steady</EM> state. Thus between two
    events, the system is always in one of the steady states.
    Transient states are therefore not really a must - they exist
    only to group actions to be taken during a transition in a
    convenient way.
<li><strong></strong>You can assign program code to entering and leaving a state
    (known as entry/exit code).
    Staying in the same state is handled as leaving and re-entering
    the state.
<li><strong></strong>Entry code should not modify the state (this is verified by
    OMNeT++).  State changes (transitions) must be put into the exit
    code.
</UL>

<p>OMNeT++'s FSMs <EM>can</EM> be nested. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it would become too large.

<p>
<br><P class="subheading">The FSM API</P>

<p>
FSM state is stored in an object of type <tt>cFSM</tt>. The possible states
are defined by an enum; the enum is also a place to tell which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parens must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre>
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>

<p>
The actual FSM is embedded in a switch-like statement,
<tt>FSM_Switch()</tt>, where you have cases for entering and leaving
each state:

<p>
<pre>
FSM_Switch(fsm)
{
  case FSM_Exit(<EM>state1</EM>):
    //...
  break;
  case FSM_Enter(<EM>state1</EM>):
    //...
  break;
  case FSM_Exit(<EM>state2</EM>):
    //...
  break;
  case FSM_Enter(<EM>state2</EM>):
    //...
  break;
    //...
};
</pre>

<p>
State transitions are done via calls to
<tt>FSM_Goto()</tt>, which simply stores the new state in the
<tt>cFSM</tt> object:

<p><pre>
FSM_Goto(fsm,<EM>newState</EM>);
</pre>

<p>The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<br><P class="subheading">Debugging FSMs</P>

<p>FSMs can log their state transitions <tt>ev</tt>,
with the output looking like this:

<pre>
...
FSM GenState: leaving state SLEEP
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SEND
FSM GenState: leaving state SEND
FSM GenState: entering state ACTIVE
...
FSM GenState: leaving state ACTIVE
FSM GenState: entering state SLEEP
...
</pre>
<p>
To enable the above output, you have to <tt>#define FSM_DEBUG</tt>
before including <tt>omnetpp.h</tt>.

<p><pre>
#define FSM_DEBUG    // enables debug output from FSMs
#include &lt;omnetpp.h&gt;
</pre>

<p>The actual logging is done via the <tt>FSM_Print()</tt> macro.
It is currently defined as follows, but you can change the
output format by undefining <tt>FSM_Print()</tt> after including
<tt>omnetpp.ini</tt> and providing a new definition instead.

<pre>
#define FSM_Print(fsm,exiting)
  (ev &lt;&lt; "FSM " &lt;&lt; (fsm).name()
      &lt;&lt; ((exiting) ? ": leaving state " : ": entering state ")
      &lt;&lt; (fsm).stateName() &lt;&lt; endl)
</pre>
<p>

<p><br><P class="subheading">Implementation</P>

<p>
The <tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch()</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM reaches a steady state. (The actual code is rather
ugly, but if you're dying to see it, it's in <SAMP>cfsm.h</SAMP>.)

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<br><P class="subheading">An example</P>

<p>
Let us write another flavour of a bursty generator. It has two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the Fifo2 sample
simulation.

<p>
<pre>
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;

<p>class BurstyGenerator : public cSimpleModule
{
 public:
  Module_Class_Members(BurstyGenerator,cSimpleModule,0);

<p>  // parameters
  double sleepTimeMean;
  double burstTimeMean;
  double sendIATime;
  cPar *msgLength;

<p>  // FSM and its states
  cFSM fsm;
  enum {
    INIT = 0,
    SLEEP = FSM_Steady(1),
    ACTIVE = FSM_Steady(2),
    SEND = FSM_Transient(1),
  };

<p>  // variables used
  int i;
  cMessage *startStopBurst;
  cMessage *sendMessage;

<p>  // the virtual functions
  virtual void initialize();
  virtual void handleMessage(cMessage *msg);
};

<p>Define_Module( BurstyGenerator );

<p>void BurstyGenerator::initialize()
{
  fsm.setName("fsm");
  sleepTimeMean = par("sleep_time_mean");
  burstTimeMean = par("burst_time_mean");
  sendIATime = par("send_ia_time");
  msgLength = &par("msg_length");
  i = 0;
  WATCH(i); // always put watches in initialize()
  startStopBurst = new cMessage("startStopBurst");
  sendMessage = new cMessage("sendMessage");
  scheduleAt(0.0,startStopBurst);
}

<p>void BurstyGenerator::handleMessage(cMessage *msg)
{
  FSM_Switch(fsm)
 {
    case FSM_Exit(INIT):
      // transition to SLEEP state
      FSM_Goto(fsm,SLEEP);
      break;
    case FSM_Enter(SLEEP):
      // schedule end of sleep period (start of next burst)
      scheduleAt(simTime()+exponential(sleepTimeMean),
                 startStopBurst);
    break;
    case FSM_Exit(SLEEP):
      // schedule end of this burst
      scheduleAt(simTime()+exponential(burstTimeMean),
                 startStopBurst);
      // transition to ACTIVE state:
      if (msg!=startStopBurst) {
        error("invalid event in state ACTIVE");
      }
      FSM_Goto(fsm,ACTIVE);
      break;
    case FSM_Enter(ACTIVE):
      // schedule next sending
      scheduleAt(simTime()+exponential(sendIATime), sendMessage);
    break;
    case FSM_Exit(ACTIVE):
      // transition to either SEND or SLEEP
      if (msg==sendMessage) {
        FSM_Goto(fsm,SEND);
      } else if (msg==startStopBurst) {
        cancelEvent(sendMessage);
        FSM_Goto(fsm,SLEEP);
      } else {
        error("invalid event in state ACTIVE");
      }
      break;
    case FSM_Exit(SEND):
    {
      // generate and send out job
      char msgname[32];
      sprintf( msgname, "job-%d", ++i);
      ev &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
      cMessage *job = new cMessage(msgname);
      job-&gt;setLength( (long) *msgLength );
      job-&gt;setTimestamp();
      send( job, "out" );
      // return to ACTIVE
      FSM_Goto(fsm,ACTIVE);
      break;
    }
  }
}
</pre>

<p>

<p>

<p><hr><H2><A NAME="sec194"/>5.6. Sending and receiving messages</H2>
<a name="ch:simple-modules:sending-and-receiving"></a>

<p>On an abstract level, an OMNeT++ simulation model is a set of
simple modules that communicate with each other via message passing.
The essence of simple modules is that they create, send, receive,
store, modify, schedule and destroy messages - everything else
is supposed to facilitate this task, and collect statistics
about what was going on.

<p>Messages in OMNeT++ are instances of the <tt>cMessage</tt> class or
one of its subclasses. Message objects are created using the C++
<tt>new</tt> operator and destroyed using the <tt>delete</tt> operator
when they are no longer needed. During their lifetimes,
messages travel between modules via gates and connections
(or are sent directly, bypassing the connections), or
they are scheduled by and delivered to modules,
representing internal events of that module.

<p>Messages are described in detail in chapter <a href="#cha:messages">[click]</a>.
At this point, all we need to know about them is that they are
referred to as <tt>cMessage *</tt> pointers. Message objects
can be given descriptive names (a <tt>const char *</tt> string)
that often helps in debugging the simulation. The message
name string can be specified in the constructor, so it
should not surprise you if you see something like
<tt>new cMessage("token")</tt> in the examples below.

<p>

<p><H3><A NAME="sec195"/>5.6.1. Sending messages</H3>

<p>Once created, a message object can be sent through an
output gate using one of the following functions:

<pre>
send(cMessage *msg, const char *gateName, int index=0);
send(cMessage *msg, int gateId);
</pre>
<p>
In the first function, the argument <tt>gateName</tt> is the name of
the gate the message has to be sent through. If this gate is
a vector gate, <tt>index</tt> determines though which particular output
gate this has to be done; otherwise, the <tt>index</tt> argument is not
needed.

<p>The second function uses the gate Id, and because it does
not have to search through the gate array, it is faster than
the first one.

<p>Examples:

<pre>
send(msg, "outGate");
send(msg, "outGates", i); // send via outGates[i]
</pre>
<p>
The following code example creates and sends messages
every 5 simulated seconds:

<pre>
int outGateId = findGate("outGate");
while(true)
{
  send(new cMessage("packet"), outGateId);
  wait(5);
}
</pre>
<p>

<p><br><P class="subheading">Modeling packet transmissions</P>

<p>If you're sending messages over a link that has (nonzero) data rate,
it is modeled in the way that has been described earlier in this
manual, in section <a href="#ch:simple-modules:packet-transmission">[click]</a>.

<p>If you want to have full control over the transmission process,
you'll probably need the <tt>isBusy()</tt> and <tt>transmissionFinishes()</tt>
member functions of <tt>cGate</tt>. They are described in section
<a href="#ch:simple-modules:cgate-transmission-state">[click]</a>.

<p>

<p><H3><A NAME="sec196"/>5.6.2. Broadcasts and retransmissions</H3>

<p>When you implement broadcasts or retransmissions, two frequently
occurring tasks in protocol simulation, you might feel tempted
to use the same message in multiple <tt>send()</tt> operations.
Do not do it - you cannot send the same message object multiple times.
The solution in such cases is duplicating the message.

<p><br><P class="subheading">Broadcasting messages</P>

<p>In your model, you may need to broadcast a message to several destinations.
Broadcast can be implemented in a simple module by sending out copies
of the same message, for example on every gate of a gate vector.
As described above, you cannot use the same message pointer for
in all <tt>send()</tt> calls - what you have to do instead is
create copies (duplicates) of the message object and send them.

<p>Example:

<pre>
for (int i=0; i&lt;n; i++)
{
    cMessage *copy = (cMessage *) msg-&gt;dup();
    send(copy, "out", i);
}
delete msg;
</pre>
<p>
You might have noticed that copying the message for the last gate is
redundant (we could send out the original message),
so it can be optimized out like this:

<pre>
for (int i=0; i&lt;n-1; i++)   // note n-1 instead of n
{
    cMessage *copy = (cMessage *) msg-&gt;dup();
    send(copy, "out", i);
}
send(msg, "out", n-1);  // send original on last gate
</pre>
<p>

<p><br><P class="subheading">Retransmissions</P>

<p>Many communication protocols involve retransmissions of packets (frames).
When implementing retransmissions, you cannot just hold a pointer
to the same message object and send it again and again - you'd get
the <EM>not owner of message</EM> error on the first resend.

<p>Instead, whenever it comes to (re)transmission, you should create and
send copies of message, and retain the original.
When you're sure there won't be any more retransmission,
you can delete the original message.

<p>Creating and sending a copy:

<pre>
// (re)transmit packet:
cMessage *copy = (cMessage *) packet-&gt;dup();
send(copy, "out");
</pre>
<p>
and finally (when no more retransmissions will occur):

<pre>
delete packet;
</pre>
<p>

<p><br><P class="subheading">Why?</P>

<p>A message is like any real world object - it cannot be at two places
at the same time. Once you've sent it, the message object
no longer belongs to the module: it is taken over by the simulation kernel,
and will eventually be delivered to the destination module.
The sender module should not even refer to its pointer any more.
Once the message arrived in the destination module, that module
will has full authority over it - it can send it further,
destroy it immediately, or store it for further handling.
The same applies to messages that have been scheduled - they
belong to the simulation kernel until they are delivered back to
the module.

<p>To enforce the rules above, all message sending functions
check that you actually own the message you are about to send.
If the message is with another module, it is currently scheduled or
in a queue etc., you'll get a runtime error: <EM>not owner of message</EM>.
  <br><ul><font size=-1>[The feature does not increase runtime overhead significantly, because
  it uses the object ownership management (described in
  Section <a href="#sec:ch-sim-lib:ownership-management">[click]</a>);
  it merely checks that the owner of the message is the module that
  wants to send it.]</font></ul>

<p>

<p><H3><A NAME="sec197"/>5.6.3. Delayed sending</H3>

<p>It is often needed to model a delay (processing time, etc.) immediately
followed by message sending. In OMNeT++, it is possible to implement
it like this:

<pre>
wait( some_delay );
send( msg, "outgate" );
</pre>
<p>

<p>If the module needs to react to messages that arrive during the delay,
<tt>wait()</tt> cannot be used and the timer mechanism described in
Section <a href="#sec:ch-sim-lib:self-messages">[click]</a>, ``Self-messages'', would
need to be employed.

<p>
However, there is a more straightforward method than the above two,
and this is delayed sending. Delayed sending
can be done with one of these functions:

<p><tt>sendDelayed(cMessage *msg, double delay, const char *gate_name, int index);</tt><br>
<tt>sendDelayed(cMessage *msg, double delay, int gate_id);</tt>

<p>
The arguments are the same as for <tt>send()</tt>, except for the extra <EM>delay</EM>
parameter. The effect of the function is the same as if the module
had kept the message for the delay interval and sent it afterwards.
That is, the sending time of the message will be the current
simulation time (time at the <tt>sendDelayed()</tt> call) plus the delay.
The delay value must be nonnegative.

<p>Example:

<pre>
sendDelayed(msg, 0.005, "outGate");
</pre>
<p>

<p>
<H3><A NAME="sec198"/>5.6.4. Direct message sending</H3>

<p>Sometimes it is necessary or convenient to ignore gates/connections
and send a message directly to a remote destination module. The <tt>sendDirect()</tt>
function does that, and it takes the pointer of the remote module
(<tt>cModule</tt> *). You can also specify a delay and an input gate of
the destination module.

<pre>
cModule *destinationmodule =...;
double delay = truncnormal(0.005, 0.0001);
sendDirect( new cMessage, delay, destinationmodule, "in" );
</pre>
<p>
The destination module receives the message as if it was sent
``normally''.

<p>

<p><H3><A NAME="sec199"/>5.6.5. Receiving messages</H3>

<p><STRONG>With activity() only!</STRONG> The message receiving functions can
only be used in the <tt>activity()</tt> function,
<tt>handleMessage()</tt> gets received messages in its argument list.

<p>Messages are received using the <tt>receive()</tt> function.
<tt>receive()</tt> is a member of <tt>cSimpleModule</tt>.

<pre>
cMessage *msg = receive();
</pre>
<p>
The <tt>receive()</tt> function accepts an optional <EM>timeout</EM>
parameter. (This is a <EM>delta</EM>, not an
absolute simulation time.) If an appropriate message doesn't arrive
within the timeout period, the function returns a NULL pointer.

<pre>
simtime_t timeout = 3.0;
cMessage *msg = receive( timeout );

if (msg==NULL)
{
    ...   // handle timeout
}
else
{
    ...  // process message
}
</pre>
<p>

<p><br><P class="subheading">Deprecated functionality: putaside-queue</P>
<a name="ch:simple-modules:putaside-queue"></a>

<p>Earlier versions of OMNeT++ supported something called <EM>putaside-queue</EM>
which stored messages that arrived while the module was waiting for
something else. For example, a function called <tt>receiveOn()</tt> waited
for a message to arrive on a specific gate, and messages that actually
arrived on another gate were inserted in the putaside-queue.
<tt>receive()</tt> returned messages from the putaside-queue first,
and it waited for new messages to arrive only if putaside-queue
was empty.

<p>Practice has shown that putaside-queue and associated functionality
bore little usefulness, and at the same time it was very confusing
to people. Therefore putaside-queue, <tt>receiveOn()</tt>, <tt>receiveNew()</tt>,
and <tt>receiveNewOn()</tt> have been deprecated in OMNeT++ 2.3, and
will be entirely removed from further releases.

<p>

<p><H3><A NAME="sec200"/>5.6.6. The wait() function</H3>

<p><STRONG>With activity() only!</STRONG> The <tt>wait()</tt> function's implementation
contains a <tt>receive()</tt> call which cannot be used in <tt>handleMessage()</tt>.

<p>The <tt>wait()</tt> function suspends the execution of the module for
a given amount of simulation time (a <EM>delta</EM>).

<pre>
wait( delay );
</pre>
<p>
In other simulation software, <tt>wait()</tt> is often called <EM>hold</EM>.
Internally, the <tt>wait()</tt> function is implemented by a
<tt>scheduleAt()</tt> followed by a <tt>receive()</tt>.
The <tt>wait()</tt> function is very convenient in modules that do not need
to be prepared for arriving messages, for example message generators.
An example:

<pre>
for(;;)
{
  // wait for a (potentially random amount of) time, specified
  // in the interArrivalTime module parameter
  wait( par("interArrivalTime") );

  // generate and send message
  ...
}
</pre>
<p>
If you expect messages to arrive during the wait period, you can
use the <tt>waitAndEnqueue()</tt> function. It takes a pointer to a queue object
(of class <tt>cQueue</tt>, described in chapter <a href="#cha:the-simulation-library">[click]</a>)
in addition to the wait interval. Messages that arrive during the
wait interval will be accumulated in the queue, so you can
process them after the <tt>wait()</tt> call has returned.

<pre>
cQueue queue("queue");
...
waitAndEnqueue(waitTime, &queue);
if (!queue.empty())
{
  // process messages arrived during wait interval
  ...
}
</pre>
<p>

<p><br><P class="subheading">Change in wait() semantics</P>

<p>The semantics of <tt>wait()</tt> has slightly changed after OMNeT++ 2.3,
due to the deprecation of the putaside-queue
(see section <a href="#ch:simple-modules:putaside-queue">[click]</a>).
Up to release 2.3, messages that arrived during the wait interval
were accumulated in the putaside-queue. In later releases,
it will be a runtime error if a message arrives during the wait interval -
if you want to allow such messages, you should use <tt>waitAndEnqueue()</tt>.

<p>

<p><H3><A NAME="sec201"/>5.6.7. Modeling events using self-messages</H3>
<a name="sec:ch-sim-lib:self-messages"></a>

<p>In most simulation models it is necessary to implement timers,
or schedule events that occur at some point in the future.
For example, when a packet is sent by a communications protocol model,
it has to schedule an event that would occur when a timeout expires,
because it will have to resent the packet then.
As another example, suppose you want to write a model of a server which
processes jobs from a queue. Whenever it begins processing
a job, the server model will want to schedule an event to occur
when the job finishes processing, so that it can begin processing
the next job.

<p>In OMNeT++ you solve such tasks by letting the simple module
sending a message to itself; the message would be delivered
to the simple module at a later point of time. Messages used
this way are called self-messages.
Self-messages are used to model events which occur within the module.

<p><br><P class="subheading">Scheduling an event</P>

<p>The module can send a message to itself using the <tt>scheduleAt()</tt> function.
<tt>scheduleAt()</tt> accepts an <EM>absolute</EM> simulation time,
usually calculated as <tt>simTime()</tt>+<EM>delta</EM>:

<pre>
scheduleAt(absoluteTime, msg);
scheduleAt(simtime()+delta, msg);
</pre>
<p>
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>);
the module may call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>As an example, here's how you could implement your own <tt>wait()</tt>
function in an <tt>activity()</tt> simple module, if the simulation kernel
didn't provide it already:

<pre>
cMessage *msg = new cMessage();
scheduleAt(simtime()+waitTime, msg);
cMessage *recvd = receive();
if (recvd!=msg)
   // hmm, some other event occurred meanwhile: error!
...
</pre>
<p>
You can determine if a message is currently in the FES
by calling its <tt>isScheduled()</tt> member:

<pre>
if (msg-&gt;isScheduled())
  // currently scheduled
else
  // not scheduled
</pre>
<p>

<p><br><P class="subheading">Re-scheduling an event</P>

<p>If you want to reschedule an event which is currently scheduled to a different
simulation time, first you have to cancel it using <tt>cancelEvent()</tt>.

<p>
<br><P class="subheading">Cancelling an event</P>

<p>Scheduled self-messages can be cancelled
 (removed from the FES).
This is particularly useful because self-messages are often used
to model timers.

<pre>
cancelEvent( msg );
</pre>
<p>
The <tt>cancelEvent()</tt> function takes a pointer to the message to
be cancelled, and also returns the same pointer. After having it
cancelled, you may delete the message or reuse it in the next
<tt>scheduleAt()</tt> calls. <tt>cancelEvent()</tt> gives an error if
the message is not in the FES.

<p>
<br><P class="subheading">Implementing timers</P>

<p>The following example shows how to implement timers:

<pre>
cMessage *timeoutEvent = new cMessage("timeout");

scheduleAt(simTime()+10.0, timeoutEvent);
//...

cMessage *msg = receive();
if (msg == timeoutEvent)
{
  // timeout expired
}
else
{
  // other message has arrived, timer can be cancelled now:
  delete cancelEvent(timeoutEvent);
}
</pre>
<p>

<p>

<p>
<H3><A NAME="sec202"/>5.6.8. Stopping the simulation</H3>

<p><br><P class="subheading">Normal termination</P>

<p>
You can finish the simulation with the <tt>endSimulation()</tt> function:

<p>
<tt>endSimulation()</tt>;

<p>
However, typically you don't need <tt>endSimulation()</tt> because you
can specify simulation time and CPU time limits in the ini file (see later).

<p>
<br><P class="subheading">Stopping on errors</P>

<p>
If your simulation detects an error condition and wants to stop
the simulation, you can do it with the <tt>error()</tt> member function
of <tt>cModule</tt>. It is used like <tt>printf()</tt>:

<pre>
if (windowSize&lt;1)
  error("Invalid window size %d; must be &gt;=1", windowSize);
</pre>
<p>

<p>Do not include a newline (``\n'') or punctuation (period
or exclamation mark) in the error text, as it will be added by OMNeT++.

<p>

<p>

<p><hr><H2><A NAME="sec203"/>5.7. Accessing module parameters</H2>
<a name="ch:simple-modules:parameters"></a>

<p>Module parameters can be accessed
with the <tt>par()</tt> member function of <tt>cModule</tt>:

<pre>
cPar& delay_par = par("delay");
</pre>
<p>
The <tt>cPar</tt> class is a general value-storing object. It supports
type casts to numeric types, so parameter values can be read
like this:

<pre>
int num_tasks = par("num_tasks");
double proc_delay = par("proc_delay");
</pre>
<p>
If the parameter is a random variable or its value can change
during execution, it is best to store a reference to it and re-read
the value each time it is needed:

<pre>
cPar& wait_time = par("wait_time");
for(;;)
{
  //...
  wait( (simtime_t)wait_time );
}
</pre>
<p>
If the wait_time parameter was given a random value (e.g. <tt>exponential(1.0)</tt>)
in the NED source or the ini file, the above code results in
a different delay each time.

<p>Parameter values can also be changed from the program, during
execution. If the parameter was taken by reference
 (with a
<tt>ref</tt> modifier in the NED file), other modules
will also see the change.  Thus, parameters taken by reference can be
used as a means of module communication.

<p>
An example:

<pre>
par("wait_time") = 0.12;
</pre>
<p>
Or:

<pre>
cPar& wait_time = par("wait_time");
wait_time = 0.12;
</pre>
<p>

<p>See <tt>cPar</tt> explanation later in this manual for further information
on how to change a <tt>cPar</tt>'s value.

<p>
<hr><H2><A NAME="sec204"/>5.8. Accessing gates and connections</H2>
<a name="ch:simple-modules:gates"></a>

<p><H3><A NAME="sec205"/>5.8.1. Gate objects</H3>

<p>
Module gates are <tt>cGate</tt> objects. Gate objects
know whether and to which gate they are connected, and they can be
asked about the parameters of the link (delay, data rate, etc.)

<p>The <tt>gate()</tt> member function of <tt>cModule</tt> returns a
pointer to a <tt>cGate</tt> object, and an overloaded form of the
function lets you to access elements of a vector gate:

<pre>
cGate *outgate = gate("out");
cGate *outvec5gate = gate("outvec",5);
</pre>
<p>

<p>For gate vectors, the first form returns the first gate in the
vector (at index 0).

<p>
The <tt>isVector()</tt> member function can be used to determine if a
gate belongs to a gate vector or not. But this is almost insignificant,
because non-vector gates are treated as vectors with size 1.

<p>
Given a gate pointer, you can use the <tt>size()</tt> and
<tt>index()</tt> member functions of <tt>cGate</tt> to determine the
size of the gate vector and the
index of the gate within the vector:

<pre>
int size2 = outvec5gate-&gt;size(); // --&gt; size of outvec[]
int index = outvec5gate-&gt;index(); // --&gt; 5 (it is gate 5 in the vector)
</pre>
<p>

<p>For non-vector gates, <tt>size()</tt> returns 1 and <tt>index()</tt> returns 0.

<p>The <tt>type()</tt> member function returns a character, 'I' for input
gates and 'O' for output gates:

<pre>
char type = outgate-&gt;type() // --&gt; 'O'
</pre>
<p>
<br><P class="subheading">Gate IDs</P>

<p>
Module gates (input and output, single and vector) are stored in an
array within their modules. The gate's position in the array is called
the <EM>gate ID</EM>. The gate ID is returned by the <tt>id()</tt>
member function:

<p>
<pre>
int id = outgate-&gt;id();
</pre>

<p>For a module with input gates from_app and in[3] and output gates
of to_app and status, the array may look like this:

<p>
<table border>
<TR> <TD align=center>

<STRONG>ID</STRONG> </TD> <TD align=center> <STRONG>dir</STRONG> </TD> <TD align=center> <STRONG>name[index]</STRONG></TD></TR>
<TR> <TD align=center> 0 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>from_app</tt> </TD></TR>
<TR> <TD align=center> 1 </TD> <TD align=center> <EM>output</EM> </TD> <TD align=center> <tt>to_app</tt> </TD></TR>
<TR> <TD align=center> 2 </TD> <TD align=center colspan=2><EM>empty</EM></TD></TR>
<TR> <TD align=center> 3 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>in[0]</tt></TD></TR>
<TR> <TD align=center> 4 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>in[1]</tt></TD></TR>
<TR> <TD align=center> 5 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>in[2]</tt></TD></TR>
<TR> <TD align=center> 6 </TD> <TD align=center> <EM>output</EM> </TD> <TD align=center> <tt>status</tt></TD></TR>
</table>

<p>

<p>The array may have empty slots. Gate vectors are guaranteed to
occupy contiguous IDs, thus it is legal to calculate the
ID of <EM>gate[k]</EM> as <tt>gate("gate",0).id()+k</tt>.

<p>Message sending and receiving functions accept both gate names
and gate IDs; the functions using gate IDs are a bit faster.
Gate IDs do not change during execution, so it is often worth
retrieving them in advance and using them instead of gate names.

<p>You can also obtain gate IDs with the <tt>findGate()</tt>
member of <tt>cModule</tt>:

<pre>
int id1 = findGate("out");
int id2 = findGate("outvect",5);
</pre>
<p>

<p><H3><A NAME="sec206"/>5.8.2. Link parameters</H3>

<p>
The following member functions return the link attributes:

<pre>
cLinkType *link = outgate-&gt;link();
cPar *d = outgate-&gt;delay();
cPar *e = outgate-&gt;error();
cPar *r = outgate-&gt;datarate();
</pre>
<p>

<p><H3><A NAME="sec207"/>5.8.3. Transmission state</H3>
<a name="ch:simple-modules:cgate-transmission-state"></a>

<p>The <tt>isBusy()</tt> member function returns whether the gate
is currently transmitting, and if so, the
<tt>transmissionFinishes()</tt> member function
returns the simulation time when the gate is going to finish
transmitting. (If the gate in not currently transmitting,
<tt>transmissionFinishes()</tt> returns the simulation time
when it finished its last transmission.)

<p>The semantics has been described in section
<a href="#ch:simple-modules:packet-transmission">[click]</a>.

<p>An example:

<pre>
cMessage *packet = new cMessage("DATA");
packet-&gt;setLength( 1000 );

if (gate("TxGate")-&gt;isBusy()) // if gate is busy, wait until it
{                             // becomes free
  wait( gate("TxGate")-&gt;transmissionFinishes() - simTime());
}
send( packet, "TxGate");
</pre>
<p>
If the connection with a data rate is not immediately the one
connected to the simple module's output gate but
the second one in the route, you have to check the second gate's busy
condition.  You would use the following code:

<pre>
if (gate("mygate")-&gt;toGate()-&gt;isBusy())
  //...
</pre>
<p>
Note that if data rates change during the
simulation, the changes will affect only the messages that are
<EM>sent</EM> after the change.

<p>

<p><H3><A NAME="sec208"/>5.8.4. Connectivity</H3>

<p>The <tt>isConnected()</tt> member function returns whether
the gate is connected. If the gate is an output gate, the gate to
which it is connected is obtained by the <tt>toGate()</tt>
member function. For input gates, the function is
<tt>fromGate()</tt>.


<pre>
cGate *gate = gate("somegate");
if (gate-&gt;isConnected())
{
  cGate *othergate = (gate-&gt;type()=='O') ?
                     gate-&gt;toGate() : gate-&gt;fromGate();

  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
}
else
{
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
}
</pre>
<p>

<p>An alternative to <tt>isConnected()</tt> is to check the return value
of <tt>toGate()</tt> or <tt>fromGate()</tt>. The following code is fully equivalent
to the one above:

<pre>
cGate *gate = gate("somegate");
cGate *othergate = (gate-&gt;type()=='O') ?
                   gate-&gt;toGate() : gate-&gt;fromGate();
if (othergate)
  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
else
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
</pre>
<p>
To find out to which simple module a given output
gate leads finally, you would have to walk
along the path like this (the <tt>ownerModule()</tt> member function
returns the module to which the gate belongs):

<pre>
cGate *gate = gate("out");
while (gate-&gt;toGate()!=NULL)
{
  gate = gate-&gt;toGate();
}

cModule *destmod = gate-&gt;ownerModule();
</pre>
<p>

<p>but luckily, there are two convenience functions which do that:
<tt>sourceGate()</tt> and
<tt>destinationGate()</tt>.

<p>

<p>

<p><hr><H2><A NAME="sec209"/>5.9. Walking the module hierarchy</H2>
<a name="ch:simple-modules:walking-module-hieararchy"></a>

<p><br><P class="subheading">Module vectors</P>

<p>
If a module is part of a module vector, the
<tt>index()</tt> and <tt>size()</tt> member functions can be used to
query its index and the vector size:

<pre>
ev &lt;&lt; "This is module [" &lt;&lt; module-&gt;index() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;size() &lt;&lt; "].\n";
</pre>
<p>

<p><br><P class="subheading">Module IDs</P>

<p>
Each module in the network has a unique ID that is returned by the
<tt>id()</tt> member function. The module ID is used
internally by the simulation kernel to identify modules.

<pre>
int myModuleId = id();
</pre>
<p>
If you know the module ID, you can ask the simulation object
(a global variable) to get back the module pointer:

<pre>
int id = 100;
cModule *mod = simulation.module( id );
</pre>
<p>

<p>Module IDs are guaranteed to be unique, even when modules are
created and destroyed dynamically. That is, an ID which once
belonged to a module which was deleted is never issued to another
module later.

<p>
<br><P class="subheading">Walking up and down the module hierarchy</P>

<p>
The surrounding compound module can be accessed by the
<tt>parentModule()</tt> member function:

<pre>
cModule *parent = parentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre>
double timeout = parentModule()-&gt;par( "timeout" );
</pre>
<p>

<p><tt>cModule</tt>'s <tt>findSubmodule()</tt> and <tt>submodule()</tt>
member functions make it possible to look up the module's submodules
by name (or name+index if the submodule
is in a module vector). The first one returns the numeric module ID of
the submodule, and the latter returns the module pointer.  If the
submodule is not found, they return -1 or NULL, respectively.

<pre>
int submodID = compoundmod-&gt;findSubmodule("child",5);
cModule *submod = compoundmod-&gt;submodule("child",5);
</pre>
<p>

<p>The <tt>moduleByRelativePath()</tt> member function can be used to find
a submodule nested deeper than one level below. For example,

<pre>
compoundmod-&gt;moduleByRelativePath("child[5].grandchild");
</pre>
<p>
would give the same results as

<pre>
compoundmod-&gt;submodule("child",5)-&gt;submodule("grandchild");
</pre>
<p>
(Provided that child[5] does exist, because otherwise the second
version will crash with an access violation because of the NULL
pointer.)

<p>
The <tt>cSimulation</tt>::<tt>moduleByPath()</tt> function is similar
to <tt>cModule</tt>'s <tt>moduleByRelativePath()</tt> function, and it
starts the search at the top-level module.

<p>
<br><P class="subheading">Iterating over submodules</P>

<p>
To access all modules within a compound module,
use <tt>cSubModIterator</tt>.

<p>For example:

<pre>
for (cSubModIterator iter(*parentModule()); !iter.end(); iter++)
{
  ev &lt;&lt; iter()-&gt;fullName();
}
</pre>
<p>
(<tt>iter()</tt> is pointer to the current module the iterator is at.)

<p>
The above method can also be used to iterate along a module
vector, since the <tt>name()</tt>
function returns the same for all modules:

<pre>
for (cSubModIterator iter(*parentModule()); !iter.end(); iter++)
{
  if (iter()-&gt;isName(name())) // if iter() is in the same
                              // vector as this module
  {
    int its_index = iter()-&gt;index();
    // do something to it
  }
}
</pre>
<p>

<p><br><P class="subheading">Walking along links</P>

<p>
To determine the module at the other end of a connection, use
<tt>cGate</tt>'s <tt>fromGate()</tt>, <tt>toGate()</tt> and
<tt>ownerModule()</tt> functions. For example:

<pre>
cModule *neighbour = gate( "outputgate" )-&gt;toGate()-&gt;ownerModule();
</pre>
<p>

<p>For input gates, you would use <tt>fromGate()</tt> instead of <tt>toGate()</tt>.

<p>

<p>

<p><hr><H2><A NAME="sec210"/>5.10. Dynamic module creation</H2>
<a name="ch:simple-modules:dynamic-module-creation"></a>


<p><H3><A NAME="sec211"/>5.10.1. When do you need dynamic module creation</H3>

<p>In some situations you need to dynamically create and maybe destroy
modules. For example, when simulating a mobile network,
you may create a new module whenever a new user enters
the simulated area, and dispose of them when they leave the area.

<p>As another example, when implementing a server or a transport
protocol, it might be convenient to dymically create modules
to serve new connections, and dispose of them when the connection
is closed. (You would write a manager module that receives connection
requests and creates a module for each connection.
The Dyna example simulation does something like this.)

<p>Both simple and compound modules can be created dynamically.
If you create a compound module, all its submodules will be created
recursively.

<p>It is often convenient to use direct message sending with dynamically
created modules.

<p>Once created and started, dynamic modules aren't any different from
``static'' modules; for example, one could also delete static modules
during simulation (only that's rarely useful.)

<p>
<H3><A NAME="sec212"/>5.10.2. Overview</H3>

<p>
To understand how dynamic module creation works, you have to know a
bit about how normally OMNeT++ instantiates modules. Each module type
(class) has a corresponding factory object of the class
<tt>cModuleType</tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
function which can instantiate the module
class (this function basically only consists of a <tt>return new
<EM>module-class</EM>(...)</tt> statement).

<p>The <tt>cModuleType</tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it's possible to call its factory method and create an
instance of the corresponding module class - without having to
include the C++ header file containing module's class declaration
into your source file.

<p>The <tt>cModuleType</tt> object also knows what gates and
parameters the given module type has to have. (This info comes from
compiled NED code.)

<p>Simple modules can be created in one step. For a compound module, the
situation is more complicated, because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules it is generally required to
first create the module itself, second, set parameter values and gate
vector sizes, and then call the method that creates its submodules and
internal connections.

<p>As you know already, simple modules with <tt>activity()</tt> need a
starter message. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>Calling <tt>initialize()</tt> has to take place after insertion of the
starter messages, because the initializing code may insert new messages
into the FES, and these messages should be processed
<EM>after</EM> the starter message.



<p><H3><A NAME="sec213"/>5.10.3. Creating modules</H3>

<p>The first step, finding the factory object:

<pre>
cModuleType *moduleType = findModuleType("TCPConnectionHandler");
</pre>
<p>

<p><br><P class="subheading">Simplified form</P>

<p><tt>cModuleType</tt> has
\fname[createScheduleInit()]createScheduleInit(const char *name,
  cModule *parentmod) convenience function to get a module up and
running in one step.

<pre>
mod = modtype-&gt;createScheduleInit("name",this);
</pre>
<p>
It does <tt>create()</tt> + <tt>buildInside()</tt> + <tt>callInitialize()</tt> +
<tt>scheduleStart(now)</tt>.

<p>This method can be used for both simple and compound modules.
However, its applicability is somewhat limited:
because it does everything in one step,
you do not have the chance to set parameters or gate sizes,
and to connect gates before <tt>initialize()</tt> is called.
(<tt>initialize()</tt> expects all parameters and gates to
be in place and the network fully built when it is called.)
Because of the above limitation, this function is mainly useful
for creating basic simple modules.


<br><P class="subheading">Expanded form</P>

<p>
If the previous simple form cannot be used. There are 5 steps:
<OL>
  <li><strong></strong>find factory object
  <li><strong></strong>create module
  <li><strong></strong>set up parameters and gate sizes (if needed)
  <li><strong></strong>call function that builds out submodules and finalizes the
    module
  <li><strong></strong>call function that creates activation message(s) for the new
    simple module(s)
</OL>
Each step (except for Step 3.) can be done with one line of code.

<p>

<p>See the following example, where Step 3 is omitted:

<pre>
// find factory object
cModuleType *moduleType = findModuleType("TCPConnectionHandler");

// create (possibly compound) module and build its submodules (if any)
cModule *module = moduleType-&gt;create( "TCPconn", this );
module-&gt;buildInside();

// create activation message
module-&gt;scheduleStart( simTime() );
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre>
cModuleType *moduleType = findModuleType("TCP-conn-handler");
cModule *module = moduleType-&gt;create( "TCPconn", this );
// set up parameters and gate sizes before we set up its submodules
module-&gt;par("window-size") = 4096;
module-&gt;setGateSize("to-apps", 3);
module-&gt;buildInside();
module-&gt;scheduleStart( simTime() );
</pre>
<p>

<p><H3><A NAME="sec214"/>5.10.4. Deleting modules</H3>

<p>
To delete a module dynamically:

<pre>
module-&gt;deleteModule();
</pre>
<p>
If the module was a compound module, this involves recursively
destroying all its submodules. A simple module can also delete itself;
in this case, the <tt>deleteModule()</tt> call does not return to the
caller.

<p>Currently, you cannot safely delete a
compound module from a simple module
in it; you must delegate the job to a module outside the compound
module.

<p>
<H3><A NAME="sec215"/>5.10.5. Module deletion and finish()</H3>

<p>When you delete a module <EM>during simulation</EM>, its <tt>finish()</tt>
function is not called automatically (<tt>deleteModule()</tt> doesn't do it.)
How the module was created doesn't play any role here:
<tt>finish()</tt> gets called for <EM>all</EM> modules - at the end of the
simulation. If a module doesn't live that long, <tt>finish()</tt> is not
invoked, but you can still manually invoke it.

<p>You can use the <tt>callFinish()</tt> function to arrange <tt>finish()</tt>
to be called. It's usually not a good idea to invoke <tt>finish()</tt>
directly. If you're deleting a compound module, <tt>callFinish()</tt> will
recursively invoke <tt>finish()</tt> for all submodules, and if you're deleting
a simple module from another module, <tt>callFinish()</tt> will do the context
switch for the duration of the call.
  <br><ul><font size=-1>[The <tt>finish()</tt> function is even made <tt>protected</tt>
  in <tt>cSimpleModule</tt>, in order to discourage its invocation from
  other modules.]</font></ul>

<p>Example:

<pre>
mod-&gt;callFinish();
mod-&gt;deleteModule();
</pre>
<p>

<p><H3><A NAME="sec216"/>5.10.6. Creating connections</H3>

<p>Connections can be created using <tt>cGate</tt>'s <tt>connectTo()</tt>
method.
  <br><ul><font size=-1>[The earlier <tt>connect()</tt> global functions that
  accepted two gates have been deprecated, and may be removed
  from further OMNeT++ releases.]</font></ul>
<tt>connectTo()</tt> should be invoked on the source gate
of the connection, and expects the destination gate pointer as
an argument:

<pre>
srcGate-&gt;connectTo(destGate);
</pre>
<p>
The <EM>source</EM> and <EM>destination</EM> words correspond
to the direction of the arrow in NED files and which is the same,
the direction of messages. That is,
you connect an output gate <EM>to</EM> another submodule's input gate;
you connect a submodule's output gate <EM>to</EM> the output gate
of its parent module; and an input gate of a compound module
<EM>to</EM> the input gate of its submodule.

<p>As an example, we create two modules and connect them in both directions:

<pre>
cModuleType *moduleType = findModuleType("TicToc");
cModule *a = modtype-&gt;createScheduleInit("a",this);
cModule *b = modtype-&gt;createScheduleInit("b",this);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"));
b-&gt;gate("out")-&gt;connectTo(a-&gt;gate("in"));
</pre>
<p>
<tt>connectTo()</tt> also accepts a channel object as an
additional, optional argument. Channels are subclassed from
<tt>cChannel</tt>. Almost always you'll want use an instance of
<tt>cSimpleChannel</tt> as channel - this is the one that supports
delay, bit error rate 
and data rate. The channel object will
be owned by the source gate of the connection, and you cannot
reuse the same channel object with several connections.

<p><tt>cSimpleChannel</tt> has <tt>setDelay()</tt>, <tt>setError()</tt>
and <tt>setDatarate()</tt> methods to set up the channel attributes.
These functions accept pointer to dynamically allocated
<tt>cPar</tt> objects. <tt>cPar</tt> will be covered in detail
in chapter <a href="#cha:the-simulation-library">[click]</a>.

<p>An example that sets up a channel with a delay:

<pre>
cSimpleChannel *channel = new cSimpleChannel("channel");

cPar *d = new cPar("delay");
d-&gt;setDoubleValue(0.001);
channel-&gt;setDelay(d);

a-&gt;gate("out")-&gt;connectTo(b-&gt;gate("in"), channel); // a,b are modules
</pre>
<p>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb  2 2004</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jan 20 2004</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec217"/>6. Messages</H1>
<a name="cha:messages"></a>

<p><hr><H2><A NAME="sec218"/>6.1. Messages and packets</H2>

<p><H3><A NAME="sec219"/>6.1.1. The cMessage class</H3>

<p><tt>cMessage</tt> is a central class in OMNeT++. Objects of <tt>cMessage</tt> and
subclasses may model a number of things: events;
messages; packets,
frames, cells, bits or signals travelling
in a network; entities travelling in a system and so on.

<p>
<br><P class="subheading">Attributes</P>

<p>
A <tt>cMessage</tt> object has number of attributes. Some are used by
the simulation kernel, others are provided just for the convenience
of the simulation programmer. A more-or-less complete list:

<p><UL>
  <li><strong></strong>The <EM>name</EM> attribute is a string (<tt>const char *</tt>),
    which can be freely used by the simulation programmer. The message
    name appears in many places in Tkenv (for example, in animations),
    and it is generally very useful to choose a descriptive name.
    This attribute is inherited from <tt>cObject</tt> (see section
    <a href="#sec:ch-sim-lib:cObject">[click]</a>).
  <li><strong></strong>The <EM>message kind</EM> attribute is supposed to carry some message
    type information. Zero and positive values can be freely used
    for any purpose. Negative values are reserved for use by the
    OMNeT++ simulation library.
  <li><strong></strong>The <EM>length</EM> attribute (understood in bits) is used to compute
    transmission delay when the message travels through a connection
    that has an assigned data rate.
  <li><strong></strong>The <EM>bit error flag</EM> attribute is set to true by the simulation
    kernel with a probability of $1-(1-<EM>ber</EM>)^<i>length</i>$ when the
    message is sent through a connection that has an assigned bit
    error rate (<EM>ber</EM>).
  <li><strong></strong>The <EM>priority</EM> attribute is used by the simulation kernel to
    order messages in the message queue (FES) that have the same
    arrival time values.
  <li><strong></strong>The <EM>time stamp</EM> attribute is not used by the simulation kernel;
    you can use it for purposes like remembering the time when the
    message was enqueued or re-sent.
  <li><strong></strong>Other attributes and data members make simulation programming
    easier, they will be discussed later: <EM>parameter list</EM>, <EM>encapsulated
      message</EM>, <EM>context pointer</EM>.
  <li><strong></strong>A number of read-only attributes store information about the
    message's (last) sending/scheduling: <EM>source/destination module
      and gate</EM>, <EM>sending (scheduling) and arrival time</EM>. They are
    mostly used by the simulation kernel while the message is in
    the FES, but the information is still in the message object when
    a module receives the message.
</UL>

<p>
<br><P class="subheading">Basic usage</P>

<p>
The <tt>cMessage</tt> constructor accepts several arguments.
Most commonly, you would create a message using an <EM>object name</EM>
(a <tt>const char *</tt> string) and a <EM>message kind</EM> (<tt>int</tt>):

<pre>
cMessage *msg = new cMessage("MessageName", msgKind);
</pre>
<p>
Both arguments are optional and initialize to the null string (<tt>""</tt>)
and 0, so the following statements are also valid:

<pre>
cMessage *msg = new cMessage();
cMessage *msg = new cMessage("MessageName");
</pre>
<p>
It is a good idea to <EM>always</EM> use message names - they can be
extremely useful when debugging or demonstrating your simulation.

<p>Message kind is usually initialized with a symbolic constant
(e.g. an <EM>enum</EM> value) which signals what the message object
represents in the simulation (i.e. a data packet, a jam signal, a job, etc.)
Please use <EM>positive values or zero</EM> only as message kind -
negative values are reserved for use by the simulation kernel.

<p>
The <tt>cMessage</tt> constructor accepts further arguments too
(<EM>length</EM>, <EM>priority</EM>, <EM>bit error flag</EM>),
but for readability of the code it is best to set them explicitly
via the <tt>set...()</tt> methods described below.
Length and priority are integers, and the bit error flag is boolean.

<p>

<p>
Once a message has been created, its data members can be changed by the following functions:

<pre>
msg-&gt;setKind( kind );
msg-&gt;setLength( length );
msg-&gt;setPriority( priority );
msg-&gt;setBitError( err );
msg-&gt;setTimestamp();
msg-&gt;setTimestamp( simtime );
</pre>
<p>

<p>With these functions the user can set the message
kind, the message length,
the priority, the error
flag and the time stamp. The <tt>setTimeStamp()</tt> function without any argument
sets the time stamp to the current simulation time.

<p>
The values can be obtained by the following functions:

<pre>
int k       = msg-&gt;kind();
int p       = msg-&gt;priority();
int l       = msg-&gt;length();
bool b      = msg-&gt;hasBitError();
simtime_t t = msg-&gt;timestamp();
</pre>
<p>

<p><br><P class="subheading">Duplicating messages</P>

<p>

<p>It is often needed to duplicate a message (for example, send
one and keep a copy). This can be done in the standard ways as
for any other OMNeT++ object:

<pre>
cMessage *copy1 = (cMessage *) msg-&gt;dup();
cMessage *copy2 = new cMessage( *msg );
</pre>
<p>

<p>The two are equivalent. The resulting message is an exact copy
of the original, including message parameters (<tt>cPar</tt> or other
object types) and encapsulated messages.

<p>

<p>
<H3><A NAME="sec220"/>6.1.2. Message encapsulation</H3>

<p><br><P class="subheading">Encapsulating one message</P>

<p>It is often necessary to encapsulate a
message into another when you're modeling
layered protocols of computer networks. Although you can encapsulate
messages by adding them to the parameter list, there's a better way.

<p>
The <tt>encapsulate()</tt> function encapsulates a message
into another one. The length of the message will grow by the length of
the encapsulated message. An exception: when the encapsulating (outer)
message has zero length, OMNeT++ assumes it is not a real packet but
some out-of-band signal, so its length is left at zero.

<pre>
cMessage *userdata = new cMessage("userdata");

userdata-&gt;setLength(8*2000);
cMessage *tcpseg = new cMessage("tcp");
tcpseg-&gt;setLength(8*24);
tcpseg-&gt;encapsulate(userdata);
ev &lt;&lt; tcpseg-&gt;length() &lt;&lt; endl; // --&gt; 8*2024 = 16192
</pre>
<p>
A message can only hold one encapsulated message at a time. The
second <tt>encapsulate()</tt> call will result in an error. It is also
an error if the message to be encapsulated isn't owned by the
module.

<p>You can get back the encapsulated message by <tt>decapsulate()</tt>:

<pre>
cMessage *userdata = tcpseg-&gt;decapsulate();
</pre>
<p>
<tt>decapsulate()</tt> will decrease the length of the message accordingly,
except if it was zero. If the length would become negative, an
error occurs.

<p>The <tt>encapsulatedMsg()</tt> function returns a pointer to the encapsulated
message, or NULL if no message was encapsulated.

<p>
<br><P class="subheading">Encapsulating several messages [New!]</P>

<p>The <tt>cMessage</tt> class doesn't directly support adding more than one
messages to a message object, but you can subclass <tt>cMessage</tt>
and add the necessary functionality. (It is recommended that you
use the message definition syntax <a href="#ch:messages:message-definitions">[click]</a>
and customized messages <a href="#sec:ch-messages:customizing-generated-class">[click]</a>
to be described later on in this chapter - it can spare you some work.)

<p>You can store the messages in a fixed-size or a dynamically allocated
array, or you can use STL classes like <tt>std::vector</tt> or <tt>std::list</tt>.
There is one additional ``trick'' that you might not expect: your message
class has to <STRONG>take ownership</STRONG> of the inserted messages, and
<STRONG>release</STRONG> them when they are removed from the message. These are
done via the <tt>take()</tt> and <tt>drop()</tt> methods. Let us see
an example which assumes you have added to the class an <tt>std::list</tt> member
called <tt>messages</tt> that stores message pointers:

<pre>
void MessageBundleMessage::insertMessage(cMessage *msg)
{
    take(msg);  // take ownership
    messages.push_back(msg);  // store pointer
}

void MessageBundleMessage::removeMessage(cMessage *msg)
{
    messages.remove(msg);  // remove pointer
    drop(msg);  // release ownership
}
</pre>
<p>
You will also have to provide an <tt>operator=()</tt> method to
make sure your message objects can be copied and duplicated
properly - this is something often needed in simulations
(think of broadcasts and retransmissions!). Section
<a href="#sec:ch-sim-lib:deriving-new-classes">[click]</a> contains more info
about the things you need to take care of when deriving new classes.

<p>

<p><H3><A NAME="sec221"/>6.1.3. Information about the last sending</H3>

<p>There are several variables in <tt>cMessage</tt> that store
information about the last time the message was sent or
scheduled. These variables can only be read.

<p><tt>isSelfMessage()</tt> returns true if the message has been scheduled
(<tt>scheduleAt()</tt>) as opposed to being sent with one of the
<tt>send...()</tt> methods.

<p><pre>
bool <tt>isSelfMessage()</tt>
</pre>

<p>The following methods can tell where the message came from and
where it arrived (will arrive).

<p><pre>
int <tt>senderModuleId()</tt>;
int <tt>senderGateId()</tt>;
int <tt>arrivalModuleId()</tt>;
int <tt>arrivalGateId()</tt>;
</pre>

<p>The following two methods are just convenience functions that
combine module id and gate id into a gate object pointer.

<p><pre>
cGate *<tt>senderGate()</tt>;
cGate *<tt>arrivalGate()</tt>;
</pre>

<p>And there are further convenience functions to tell whether
the message arrived on a specific gate given with id or
name+index.

<p><pre>
bool <tt>arrivedOn</tt>(int id);
bool <tt>arrivedOn</tt>(const char *gname, int gindex=0);
</pre>

<p>The following methods return message creation time and the last sending
and arrival times.

<p><pre>
simtime_t <tt>creationTime()</tt>
simtime_t <tt>sendingTime()</tt>;
simtime_t <tt>arrivalTime()</tt>;
</pre>

<p>

<p>
<H3><A NAME="sec222"/>6.1.4. Context pointer</H3>

<p><tt>cMessage</tt> contains a void* pointer which is
set/returned by the <tt>setContextPointer()</tt> and
<tt>contextPointer()</tt> functions:

<pre>
void *context =...;
msg-&gt;setContextPointer( context );
void *context2 = msg-&gt;contextPointer();
</pre>
<p>

<p>It can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

<p>Intended purpose: a module which schedules several self-messages
(timers) will need to identify a self-message when it arrives back to
the module, ie. the module will have to determine which timer went off
and what to do then. The context pointer can be
made to point at a data structure kept by the module which can carry
enough ``context'' information about the event.

<p>

<p>

<p><H3><A NAME="sec223"/>6.1.5. Modeling packets and frames</H3>

<p>The <tt>cPacket</tt> class is now deprecated. Please do not use it
in new models.
  <br><ul><font size=-1>[<tt>cPacket</tt> was a subclass of <tt>cMessage</tt>, and it
  was originally intended as a base class for packets or frames
  in a telecommunications network. <tt>cPacket</tt> added two data members:
  <EM>protocol</EM> and <EM>PDU</EM> (<EM>Protocol Data Unit</EM>, an OSI term).
  It was envisioned that <EM>procotol</EM> and <EM>PDU</EM> would take
  their values from globally maintained enums. As it turned out,
  this was utopistic. In practice, usage of <EM>protocol</EM> was inconsistent
  (<EM>protocol</EM> and <EM>message kind</EM> played similar roles,
  creating confusion), and models did not use <EM>PDU</EM> at all.
  Hence the deprecation of <tt>cPacket</tt>.]</font></ul>

<p>In future OMNeT++ models, the protocol should be represented
in the message subclass (i.e. instances of class
<SAMP>IPv6Packet</SAMP> represent IPv6 packets,
and <SAMP>EthernetFrame</SAMP> represents Ethernet frames) and/or
in the message kind value. PDU is usually represented
as a field inside the message class (a protocol header field).

<p>If the former case, the C++ <tt>dynamic_cast</tt> operator can be used
to determine if a message object is of a specific protocol:

<pre>
cMessage *msg = receive();
if (dynamic_cast&lt;IPv6Packet *&gt;(msg) != NULL)
{
    IPv6Packet *ipv6packet = (IPv6Packet *)msg;
    ...
}
</pre>
<p>

<p>

<p><H3><A NAME="sec224"/>6.1.6. Attaching parameters and objects</H3>

<p>If you want to add parameters or objects to a message, the preferred
way to do that is via message definitions, described in chapter
<a href="#ch:messages:message-definitions">[click]</a>.

<p><br><P class="subheading">Attaching objects</P>

<p>The <tt>cMessage</tt> class has an internal <tt>cArray</tt> object which can
carry objects. Only objects
that are derived from <tt>cObject</tt> (most OMNeT++ classes are so) can be attached.
The <tt>addObject()</tt>, <tt>getObject()</tt>, <tt>hasObject()</tt>,
<tt>removeObject()</tt> methods use the object name
as the key to the array. An example:

<pre>
cLongHistogram *pklen_distr = new cLongHistogram("pklen_distr");
msg-&gt;addObject( pklen_distr );
...
if (msg-&gt;hasObject("pklen_distr"))
{
   cLongHistogram *pklen_distr =
       (cLongHistogram *) msg-&gt;getObject("pklen_distr");
   ...
}
</pre>
<p>
You should take care that names of the attached objects do not
clash with each other or with <tt>cPar</tt> parameter names
(see next section).
If you do not attach anything to the message and do not call the
<tt>parList()</tt> function, the internal <tt>cArray</tt> object
will not be created.
This saves both storage and execution time.

<p>You can attach non-object types (or non-<tt>cObject</tt> objects) to
the message by using
<tt>cPar</tt>'s void* pointer 'P') type (see later in the description
of <tt>cPar</tt>). An example:

<pre>
struct conn_t *conn = new conn_t; // conn_t is a C struct
msg-&gt;addPar("conn") = (void *) conn;
msg-&gt;par("conn").configPointer(NULL,NULL,sizeof(struct conn_t));
</pre>
<p>

<p>

<p><br><P class="subheading">Attaching parameters</P>

<p>The preferred way of extending messages with new data fields is to use
message definitions (see section <a href="#ch:messages:message-definitions">[click]</a>).

<p>The old, deprecated way of adding new fields to messages is via
attaching <tt>cPar</tt> objects.
There are several downsides of this approach, the worst being
being large memory and execution time overhead. <tt>cPar</tt>'s are
heavy-weight and fairly complex objects themselves.
It has been reported that using <tt>cPar</tt> message parameters
might account for a large part of execution time, sometimes as much as 80%.
Using <tt>cPar</tt>s is also error-prone because <tt>cPar</tt> objects
have to be added dynamically and individually to each message object.
In contrast, subclassing benefits from static type checking:
if you mistype the name of a field in the C++ code, already the compiler
can detect the mistake.

<p>
However, if you still need to use cPars, here's a short summary
how you can do it. You add a new parameter to the message with the
<tt>addPar()</tt> member function, and get back a reference
to the parameter object with the <tt>par()</tt> member function.
<tt>hasPar()</tt> tells you if the message has a
given parameter or not.
Message parameters can be accessed also by index in the parameter
array. The <tt>findPar()</tt> function returns the index of a parameter
or -1 if the parameter cannot be found. The parameter can then be
accessed using an overloaded <tt>par()</tt> function.

<p>Example:

<pre>
msg-&gt;addPar("dest_addr");
msg-&gt;par("dest_addr") = 168;
...
long dest_addr = msg-&gt;par("dest_addr");
</pre>
<p>


<p><hr><H2><A NAME="sec225"/>6.2. Message definitions</H2>
<a name="ch:messages:message-definitions"></a>

<p><H3><A NAME="sec226"/>6.2.1. Introduction</H3>

<p>In practice, you'll need to add various fields to <tt>cMessage</tt> to
make it useful. For example, if you're modelling packets in communication
networks, you need to have a way to store protocol header fields in message
objects. Since the simulation library is written in C++, the natural way
of extending <tt>cMessage</tt> is via subclassing it.
However, because for each field you need to write at least
three things (a private data member, a getter and a setter method),
and the resulting class has to integrate with the simulation framework,
writing the necessary C++ code can be a tedious and time-consuming task.

<p>OMNeT++ offers a more convenient way called <EM>message definitions</EM>.
Message definitions provide a very compact syntax to describe
message contents. C++ code is automatically generated from message
definitions, saving you a lot of typing.

<p>A common source of complaint about code generators in general is
lost flexibility: if you have a different idea how the generated
code should look like, there's little you can do about it.
In OMNeT++, however, there's nothing to worry about: you can
customize the generated class to any extent you like.
Even if you decide to heavily customize the generated class,
message definitions still save you a great deal of manual work.

<p>The message subclassing feature in OMNeT++ is still somewhat experimental,
meaning that:

<p><UL>
  <li><strong></strong> The message description syntax and features may slightly change
    in the future, based on feedback from the community;
  <li><strong></strong> The compiler that translates message descriptions into C++ is
    a perl script <tt>opp_msgc</tt>. This is a temporary solution until
    the C++-based <tt>nedtool</tt> is finished.
</UL>

<p>The subclassing approach for adding message parameters was originally
suggested by Nimrod Mesika.

<p>
<br><P class="subheading">The first message class</P>

<p>Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a <tt>mypacket.msg</tt> file with the following contents:

<p><pre>
<b>message</b> MyPacket
{
    <b>fields</b>:
       <b>int</b> srcAddress;
       <b>int</b> destAddress;
       <b>int</b> hops = 32;
};
</pre>

<p>The task of the <EM>message subclassing compiler</EM> is to generate C++ classes
you can use from your models as well as ``reflection'' classes that allow
Tkenv to inspect these data stuctures.

<p>If you process <tt>mypacket.msg</tt> with the message subclassing compiler, it will
create the following files for you: <tt>mypacket_m.h</tt> and <tt>mypacket_m.cc</tt>.
<tt>mypacket_m.h</tt> contains the declaration of the <tt>MyPacket</tt> C++ class, and
it should be included into your C++ sources where you need to handle
<tt>MyPacket</tt> objects.

<p>The generated <tt>mypacket_m.h</tt> will contain the following class declaration:

<pre>
class MyPacket : public cMessage {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
</pre>
<p>
So in your C++ file, you could use the <tt>MyPacket</tt> class like this:

<pre>
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt-&gt;setSrcAddress( localAddr );
...
</pre>
<p>
The <tt>mypacket_m.cc</tt> file contains implementation of the generated <tt>MyPacket</tt>
class, as well as ``reflection'' code that allows you to inspect these data
stuctures in the Tkenv GUI. The <tt>mypacket_m.cc</tt> file should be compiled and
linked into your simulation. (If you use the <tt>opp_makemake</tt> tool
to generate your makefiles, the latter will be automatically taken care of.)

<p>
<br><P class="subheading">What is message subclassing <EM>not?</EM></P>

<p>There's might be some misunderstanding around the purpose and
concept of message definitions, so it seems to be a good idea
to deal with them right here.

<p>It is <EM><STRONG>not:</STRONG></EM>

<p><UL>
  <li><strong></strong><EM>... an attempt to reproduce the functionality of C++ with another
     syntax.</EM> Do not look for complex C++ types, templates, conditional compilation, etc.
     Also, it defines <EM>data</EM> only (or rather: an interface to access
     data) - not any kind of active behaviour.
  <li><strong></strong><EM>... a generic class generator.</EM> This is meant for defining message
     contents, and data structure you put in messages.
     Defining methods is not supported on purpose.
     Also, while you can probably (ab)use the syntax to
     generate classes and structs used internally in simple modules,
     this is probably not a good idea.
</UL>

<p>The goal is to define the <EM>interface</EM> (getter/setter methods) of messages
rather than their implementations in C++. A simple and straightforward
implementation of fields is provided - if you'd like a different internal
representation for some field, you can have it by customizing the class.

<p>There are questions you might ask:

<p><UL>
  <li><strong></strong><EM>Why doesn't it support <tt>std::vector</tt> and other STL classes?</EM>
     Well, it does... Message definitions focus on the interface
     (getter/setter methods) of the classes, optionally leaving the implementation
     to you - so you can implement fields (dynamic array fields)
     using <tt>std::vector</tt>.
     (This aligns with the idea behind STL - it was designed to be
     <EM>nuts and bolts</EM> for C++ programs).
  <li><strong></strong><EM>Why does it support C++ data types and not octets,
     bytes, bits, etc..?</EM>
     That would restrict the scope of message definitions to networking,
     and OMNeT++ wants to support other application areas as well.
     Furthermore, the set of necessary concepts to be supported is
     probably not bounded, there would always be new data types to
     be adopted.
  <li><strong></strong><EM>Why no embedded classes?</EM> Good question. As it does not
     conflict with the above principles, it might be added someday.
</UL>

<p>

<p>The following sections describe the message syntax and features in detail.

<p>
<H3><A NAME="sec227"/>6.2.2. Declaring enums</H3>

<p>An <tt>enum {..}</tt> generates a normal C++ enum, plus creates an object
which stores text representations of the constants. The latter makes it possible
to display symbolic names in Tkenv.
An example:

<p><pre>
<b>enum</b> ProtocolTypes
{
   IP = 1;
   TCP = 2;
};
</pre>

<p>Enum values need to be unique.

<p>

<H3><A NAME="sec228"/>6.2.3. Message declarations</H3>

<p><br><P class="subheading">Basic use</P>

<p>You can describe messages with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>int</b> sourceAddress;
        <b>int</b> destAddress;
        <b>bool</b> hasPayload;
};
</pre>

<p>Processing this description with the message compiler will produce
a C++ header file with a generated class, <tt>FooPacket</tt>.
<tt>FooPacket</tt> will be a subclass of <tt>cMessage</tt>.

<p>For each field in the above description, the generated class will have
a protected data member, a getter and a setter method. The names of the
methods will begin with <tt>get</tt> and <tt>set</tt>,
followed by the field name with its first letter converted to uppercase.
Thus, <tt>FooPacket</tt> will contain the following methods:

<pre>
virtual int getSourceAddress() const;
virtual void setSourceAddress(int sourceAddress);

virtual int getDestAddress() const;
virtual void setDestAddress(int destAddress);

virtual bool getHasPayload() const;
virtual void setHasPayload(bool hasPayload);
</pre>
<p>
Note that the methods are all declared <tt>virtual</tt> to give you the possibility
of overriding them in subclasses.

<p>Two constructors will be generated: one that optionally accepts object name and
(for <tt>cMessage</tt> subclasses) message kind, and a copy constructor:

<pre>
FooPacket(const char *name=NULL, int kind=0);
FooPacket(const FooPacket& other);
</pre>
<p>
Appropriate assignment operator (<tt>operator=()</tt>) and <tt>dup()</tt> methods will
also be generated.

<p>Data types for fields are not limited to <tt>int</tt> and <tt>bool</tt>. You can use the
following primitive types (i.e. primitive types as defined in the C++ language):

<p><UL>
   <li><strong></strong> <tt>bool</tt>
   <li><strong></strong> <tt>char</tt>, <tt>unsigned char</tt>
   <li><strong></strong> <tt>short</tt>, <tt>unsigned short</tt>
   <li><strong></strong> <tt>int</tt>, <tt>unsigned int</tt>
   <li><strong></strong> <tt>long</tt>, <tt>unsigned long</tt>
   <li><strong></strong> <tt>double</tt>
</UL>

<p>Field values are initialized to zero.

<p>
<br><P class="subheading">Initial values</P>

<p>You can initialize field values with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
        <b>int</b> sourceAddress = 0;
        <b>int</b> destAddress = 0;
        <b>bool</b> hasPayload = false;
};
</pre>

<p>Initialization code will be placed in the constructor of the generated class.

<p>
<br><P class="subheading">Enum declarations</P>

<p>You can declare that an <tt>int</tt> (or other integral type) field
takes values from an enum. The message compiler can than generate code
that allows Tkenv display the symbolic value of the field.

<p>Example:

<p><pre>
<b>message</b> FooPacket
{
  <b>fields</b>:
      <b>int</b> payloadType <b>enum</b>(PayloadTypes);
};
</pre>

<p>The enum has to be declared separately in the message file.

<p>
<br><P class="subheading">Fixed-size arrays</P>

<p>You can specify fixed size arrays:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>long</b> route[4];
};
</pre>

<p>The generated getter and setter methods will have an extra <tt>k</tt> argument,
the array index:

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
</pre>
<p>
If you call the methods with an index that is out of bounds, an exception
will be thrown.

<p>
<br><P class="subheading">Dynamic arrays</P>

<p>If the array size is not known in advance, you can declare the field
to be a dynamic array:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>long</b> route[];
};
</pre>

<p>In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
</pre>
<p>
The <tt>set...ArraySize()</tt> method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

<p>The default array size is zero. This means that you need to call the
<tt>set...ArraySize()</tt> before you can start filling array elements.

<p>
<br><P class="subheading">String members</P>

<p>You can declare string-valued fields with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>string</b> hostName;
};
</pre>

<p>The generated getter and setter methods will return and accept <tt>const char*</tt>
pointers:

<pre>
virtual const char *getHostName() const;
virtual void setHostName(const char *hostName);
</pre>
<p>
The generated object will have its own copy of the string.

<p>NOTE: a string member is different from a character array,
which is treated as an array of any other type. For example,

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>char</b> chars[10];
};
</pre>

<p>will generate the following methods:

<pre>
virtual char getChars(unsigned k);
virtual void setChars(unsigned k, char a);
</pre>
<p>

<p><H3><A NAME="sec229"/>6.2.4. Inheritance, composition</H3>

<p>So far we have discussed how to add fields of primitive types
(<tt>int</tt>, <tt>double</tt>, <tt>char</tt>, ...) to <tt>cMessage</tt>.
This might be sufficient for simple models, but if you have
more complex models, you'll probably need to:

<p><UL>
  <li><strong></strong> set up a hierarchy of message (packet) classes, that is,
    not only subclass from <tt>cMessage</tt> but also from your
    own message classes;
  <li><strong></strong> use not only primitive types as fields, but also structs,
    classes or typedefs. Sometimes you'll want to use a C++ type
    present in an already existing header file, another time you'll
    want a struct or class to be generated by the message
    compiler so that you can benefit from Tkenv inspectors.
</UL>

<p>The following section describes how to do these tasks.

<p>
<br><P class="subheading">Inheritance among message classes</P>

<p>By default, messages are subclassed from <tt>cMessage</tt>. However, you can
explicitly specify the base class using the <tt>extends</tt> keyword:

<p><pre>
<b>message</b> FooPacket <b>extends</b> FooBase
{
    <b>fields</b>:
        ...
};
</pre>

<p>For the above example, the generated C++ code will look like:

<pre>
class FooPacket : public FooBase { ... };
</pre>
<p>
Inheritance also works for structs and classes (see next sections
for details).

<p>

<p><br><P class="subheading">Defining classes</P>

<p>Until now we have used the <tt>message</tt> keyword to define classes, which
implies that the base class is <tt>cMessage</tt>, either directly or indirectly.

<p>But as part of complex messages, you'll need structs and other classes
(rooted or not rooted in <tt>cObject</tt>) as building blocks.
Classes can be created with the <tt>class</tt> class keyword;
structs we'll cover in the next section.

<p>The syntax for defining classes is almost the same as defining messages,
only the <tt>class</tt> keyword is used instead of <tt>message</tt>.

<p>Slightly different code is generated for classes that are rooted in
<tt>cObject</tt> than for those which are not.
If there is no <tt>extends</tt>, the generated class will not be
derived from <tt>cObject</tt>, thus it will not have <tt>name()</tt>,
<tt>className()</tt>, etc. methods.
To create a class with those methods, you have to explicitly write
<tt>extends cObject</tt>.

<p><pre>
<b>class</b> MyClass <b>extends</b> cObject
{
    <b>fields</b>:
        ...
};
</pre>

<p>

<p><br><P class="subheading">Defining plain C structs</P>

<p>You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods''.
(Actually, in the C++ language a struct can have methods,
and in general it can do anything a class can.)

<p>The syntax is similar to that of defining messages:

<p><pre>
<b>struct</b> MyStruct
{
    <b>fields</b>:
        <b>char</b> array[10];
        <b>short</b> version;
};
</pre>

<p>However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. For the above definition, the
following code is generated:

<pre>
// generated C++
struct MyStruct
{
    char array[10];
    short version;
};
</pre>
<p>
A struct can have primitive types or other structs are fields. It cannot
have string or class as field.

<p>Inheritance is supported for structs:

<p><pre>
<b>struct</b> Base
{
    ...
};

<p><b>struct</b> MyStruct extends Base
{
    ...
};
</pre>

<p>But because a struct has no member functions, there are limitations:

<p><UL>
   <li><strong></strong> field initialization is not supported (it would need constructor)
   <li><strong></strong> struct fields are not initialized to zero (it would need constructor)
   <li><strong></strong> dynamic arrays are not supported (no place for the array allocation code)
   <li><strong></strong> ``generation gap'' or abstract fields (see later) cannot be used,
      because they would build upon virtual functions.
</UL>

<p>
<br><P class="subheading">Using structs and classes as fields</P>

<p>In addition to primitive types, you can also use other structs or objects
as a field. For example, if you have a struct named <tt>IPAddress</tt>,
you can write the following:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       IPAddress src;
};
</pre>

<p>The <tt>IPAddress</tt> structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via <tt>cplusplus {{...}}</tt> and its type announced
(see Announcing C++ types).

<p>The generated class will contain an <tt>IPAddress</tt> data member
(that is, <STRONG>not</STRONG> a pointer to an <tt>IPAddress</tt>).
The following getter and setter methods will be generated:

<pre>
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
</pre>
<p>

<p><br><P class="subheading">Pointers</P>

<p>Not supported yet.

<p>

<p><H3><A NAME="sec230"/>6.2.5. Using existing C++ types</H3>

<p>
<br><P class="subheading">Announcing C++ types</P>

<p>If you want to use one of your own types (a class, struct or typedef,
declared in a C++ header) in a message definition, you have to
announce those types to the message compiler. You also have to make sure
that your header file gets included into the generated <tt>_m.h</tt> file
so that the C++ compiler can compile it.

<p>Suppose you have an <tt>IPAddress</tt> structure, defined in an <tt>ipaddress.h</tt>
file:

<pre>
// ipaddress.h
struct IPAddress {
    int byte0, byte1, byte2, byte3;
};
</pre>
<p>
To be able to use <tt>IPAddress</tt> in a message definition, the message
file (say <tt>foopacket.msg</tt>) should contain the following lines:

<p><pre>
<b>cplusplus</b> {{
#include "ipaddress.h"
}};

<p><b>struct</b> IPAddress;
</pre>

<p>The effect of the first three lines is simply that the <tt>#include</tt>
statement will be copied into the generated <tt>foopacket_m.h</tt>
file to let the C++ compiler know about the <tt>IPAddress</tt> class.
The message compiler itself will not try to make sense of the
text in the body of the <tt>cplusplus {{ ... }}</tt> directive.

<p>The next line, <tt>struct IPAddress</tt>, tells the message compiler that
<tt>IPAddress</tt> is a C++ struct. This information will (among others)
affect the generated code.

<p>Classes can be announced using the <tt>class</tt> keyword:

<p><pre>
<b>class</b> cSubQueue;
</pre>

<p>The above syntax assumes that the class is derived from <tt>cObject</tt>
either directly or indirectly. If it is not, the <tt>noncobject</tt>
keyword should be used:

<p><pre>
<b>class</b> <b>noncobject</b> IPAddress;
</pre>

<p>The distinction between classes derived and not derived from <tt>cObject</tt>
is important because the generated code differs at places.
The generated code is set up so that if you incidentally
forget the <tt>noncobject</tt> keyword (and so you mislead the
message compiler into thinking that your class is rooted in
<tt>cObject</tt> when in fact it is not), you'll get a C++ compiler
error in the generated header file.

<p>
<H3><A NAME="sec231"/>6.2.6. Customizing the generated class</H3>
<a name="sec:ch-messages:customizing-generated-class"></a>

<p>
<br><P class="subheading">The Generation Gap pattern</P>

<p>Sometimes you need the generated code to something
more or do something differently than the version generated
by the message compiler.
For example, when setting a integer field named <tt>payloadLength</tt>,
you might also need to adjust the packet length. That is,
the following default (generated) version of the
<tt>setPayloadLength()</tt> method is not suitable:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
Instead, it should look something like this:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    int diff = payloadLength - this-&gt;payloadLength;
    this-&gt;payloadLength = payloadLength;
    setLength( length() + diff );
}
</pre>
<p>
According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

<p>However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the <EM>Generation Gap</EM> design pattern.
It is enabled with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>properties</b>:
       customize = true;
   <b>fields</b>:
       <b>int</b> payloadLength;
};
</pre>

<p>The <tt>properties</tt> section within the message declaration contains
meta-info that affects how generated code will look like.
The customize property enables the use of the Generation Gap
pattern.

<p>If you process the above code with the message compiler,
the generated code will contain a <tt>FooPacket_Base</tt> class
instead of <tt>FooPacket</tt>. The idea is that you have
to subclass from <tt>FooPacket_Base</tt> to produce
<tt>FooPacket</tt>, while doing your customizations
by redefining the necessary methods.

<pre>
class FooPacket_Base : public cMessage
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
</pre>
<p>
There is a minimum amount of code you have to write
for <tt>FooPacket</tt>, because not everything can be
pre-generated as part of <tt>FooPacket_Base</tt>, e.g.
constructors cannot be inherited. This minimum
code is the following (you'll find it the generated C++ header
too, as a comment):

<pre>
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual cObject *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
</pre>
<p>
Note that it is important that you redefine <tt>dup()</tt> and
provide an assignment operator (<tt>operator=()</tt>).

<p>So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

<pre>
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy contructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
</pre>
<p>

<p>
<br><P class="subheading">Abstract fields</P>

<p>The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

<p>For example, this is the situation when you want to store a bitfield
in a single <tt>int</tt> or <tt>short</tt>, and still you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

<p>You can declare any field to be abstract with the following syntax:

<pre>
<b>message</b> FooPacket
{
   <b>properties</b>:
       customize = true;
   <b>fields</b>:
       <b>abstract</b> <b>bool</b> urgentBit;
};
</pre>

<p>For an <tt>abstract</tt> field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

<pre>
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
</pre>
<p>

<p>Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.

<p>

<p><H3><A NAME="sec232"/>6.2.7. Using STL in message classes</H3>

<p>You may want to use STL <tt>vector</tt> or <tt>stack</tt> classes in your message classes.
This is possible using abstract fields. After all, <tt>vector</tt> and <tt>stack</tt>
are representations of a <EM>sequence</EM> - same abstraction as dynamic-size vectors.
That is, you can declare the field as <tt>abstract T fld[]</tt>, and provide
an underlying implementation using <tt>vector&lt;T&gt;</tt>. You can also add methods
to the message class that invoke <tt>push_back()</tt>, <tt>push()</tt>, <tt>pop()</tt>, etc.
on the underlying STL object.

<p>See the following message declaration:

<p><pre>
<b>struct</b> Item
{
    <b>fields</b>:
        <b>int</b> a;
        <b>double</b> b;
}

<p><b>message</b> STLMessage
{
   <b>properties</b>:
       customize=true;
   <b>fields</b>:
       <b>abstract</b> Item foo[]; // will use vector&lt;Item&gt;
       <b>abstract</b> Item bar[]; // will use stack&lt;Item&gt;
}
</pre>

<p>If you compile the above, in the generated code you'll only find a couple of
abstract methods for <tt>foo</tt> and <tt>bar</tt>, no data members or anything concrete.
You can implement everything as you like. You can write the following C++ file
then to implement <tt>foo</tt> and <tt>bar</tt> with <tt>std::vector</tt> and <tt>std::stack</tt>:

<pre>
#include &lt;vector&gt;
#include &lt;stack&gt;
#include "stlmessage_m.h"


class STLMessage : public STLMessage_Base
{
  protected:
    std::vector&lt;Item&gt; foo;
    std::stack&lt;Item&gt; bar;

  public:
    STLMessage(const char *name=NULL, int kind=0) : STLMessage_Base(name,kind) {}
    STLMessage(const STLMessage& other) : STLMessage_Base(other.name()) {operator=(other);}
    STLMessage& operator=(const STLMessage& other) {
        if (&other==this) return *this;
        STLMessage_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual cObject *dup() {return new STLMessage(*this);}

    // foo methods
    virtual void setFooArraySize(unsigned int size) {}
    virtual unsigned int getFooArraySize() const {return foo.size();}
    virtual Item& getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, const Item& afoo) {foo[k]=afoo;}
    virtual void addToFoo(const Item& afoo) {foo.push_back(afoo);}

    // bar methods
    virtual void setBarArraySize(unsigned int size) {}
    virtual unsigned int getBarArraySize() const {return bar.size();}
    virtual Item& getBar(unsigned int k) {throw new cException("sorry");}
    virtual void setBar(unsigned int k, const Item& bar) {throw new cException("sorry");}
    virtual void barPush(const Item& abar) {bar.push(abar);}
    virtual void barPop() {bar.pop();}
    virtual Item& barTop() {return bar.top();}
};

Register_Class(STLMessage);
</pre>
<p>
Some additional notes:

<p><OL>
  <li><strong></strong><tt>setFooArraySize()</tt>, <tt>setBarArraySize()</tt> are redundant.
     <br><ul><font size=-1>[FIXME Wonder if I shouldn't generate <tt>set...ArraySize()</tt> methods
     for abstract arrays? Tkenv doesn't really need them and seems like
     they're in the way.]</font></ul>
  <li><strong></strong><tt>getBar(int k)</tt> cannot be implemented in a straightforward way
     (<tt>std::stack</tt> does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.
  <li><strong></strong><tt>setBar(int k, const Item&amp;)</tt> could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.
</OL>

<p>You may regret that the STL <tt>vector</tt>/<tt>stack</tt> are not directly exposed.
Well you could expose them (by adding a <tt>vector&lt;Item&gt;&amp; getFoo() {return foo;}</tt>
method to the class) but this is probably not a good idea.
STL itself was purposefully designed with a low-level approach, to provide
``nuts and bolts'' for C++ programming, and STL is better used in other classes
for internal representation of data.

<p>

<p><H3><A NAME="sec233"/>6.2.8. Summary</H3>

<p>This section attempts to summarize the possibilities.

<p>You can generate:

<p><UL>
  <li><strong></strong>  classes rooted in <tt>cObject</tt>
  <li><strong></strong>  messages (default base class is <tt>cMessage</tt>)
  <li><strong></strong>  classes not rooted in <tt>cObject</tt>
  <li><strong></strong>  plain C structs
</UL>

<p>The following data types are supported for fields:

<p><UL>
  <li><strong></strong>  primitive types: <tt>bool</tt>, <tt>char</tt>, <tt>short</tt>,
    <tt>int</tt>, <tt>long</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>,
    <tt>unsigned long</tt>, <tt>double</tt>
  <li><strong></strong>  <tt>string</tt>, a dynamically allocated string, presented as <tt>const char *</tt>
  <li><strong></strong>  fixed-size arrays of the above types
  <li><strong></strong>  structs, classes (both rooted and not rooted in <tt>cObject</tt>),
    declared with the message syntax or externally in C++ code
  <li><strong></strong>  variable-sized arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
</UL>

<p>Further features:

<p><UL>
  <li><strong></strong>  fields initialize to zero (except struct members)
  <li><strong></strong>  fields initializers can be specified (except struct members)
  <li><strong></strong>  assigning <tt>enum</tt>s to variables of integral types.
  <li><strong></strong>  inheritance
  <li><strong></strong>  customizing the generated class via subclassing (<EM>Generation Gap</EM> pattern)
  <li><strong></strong>  abstract fields (for nonstandard storage and calculated fields)
</UL>

<p>Generated code (all generated methods are <tt>virtual</tt>, although
this is not written out in the following table):

<p><table border>
<TR> <TD align=left>

<p>
<b>Field declaration</b>
    </TD> <TD align=left>
<b>Generated code</b>
</TD></TR>
<TR> <TD align=left> 
primitive types
<pre>
double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField();
void setField(double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
string type
<pre>
string field;
</pre>
     </TD> <TD align=left>
<pre>
const char *getField();
void setField(const char *);
</pre>
</TD></TR>
<TR> <TD align=left> 
fixed-size arrays
<pre>
double field[4];
</pre>
     </TD> <TD align=left>
<pre>
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
</pre>

<p></TD></TR>
<TR> <TD align=left> 
dynamic arrays
<pre>
double field[];
</pre>
     </TD> <TD align=left>
<pre>
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
customized class
<pre>
class Foo {
  properties:
    customize=true;
</pre>
     </TD> <TD align=left>
<pre>
class Foo_Base { ... };
</pre>
and you have to write:
<pre>
class Foo : public Foo_Base {
   ...
};
</pre>
</TD></TR>
<TR> <TD align=left> 
abstract fields
<pre>
abstract double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField() = 0;
void setField(double d) = 0;
</pre>
</TD></TR>
<TR> <TD align=left> 
</table>

<p>
<br><P class="subheading">Example simulations</P>

<p>Several of the example simulations (Token Ring, Dyna, Hypercube)
use message definitions. For example, in Dyna you'll find this:

<p><UL>
 <li><strong></strong> <tt>dynapacket.msg</tt> defines <tt>DynaPacket</tt> and <tt>DynaDataPacket</tt>;
 <li><strong></strong> <tt>dynapacket_m.h</tt> and <tt>dynapacket_m.cc</tt> are produced
   by the message subclassing compiler from it, and they contain
   the generated <tt>DynaPacket</tt> and <tt>DynaDataPacke</tt>t
   C++ classes (plus code for Tkenv inspectors);
 <li><strong></strong> other model files (<tt>client.cc</tt>, <tt>server.cc</tt>, ...)
   use the generated message classes
</UL>

<p>

<p><H3><A NAME="sec234"/>6.2.9. What else is there in the generated code?</H3>

<p>In addition to the message class and its implementation,
the message compiler also generates reflection code which makes it
possible to inspect message contents in Tkenv.
To illustrate the why this is necessary, suppose you manually subclass
<tt>cMessage</tt> to get a new message class. You could write the following:
  <br><ul><font size=-1>[Note that the code is only for illustration.
  In real code, <tt>freq</tt> and <tt>power</tt> should be private members,
  and getter/setter methods should exist to access them.
  Also, the above class definition misses several member functions
  (constructor, assignment operator, etc.) that should be written.]</font></ul>

<pre>
class RadioMsg : public cMessage
{
  public:
    int freq;
    double power;
    ...
};
</pre>
<p>
Now it is possible to use <tt>RadioMsg</tt> in your simple modules:

<pre>
RadioMsg *msg = new RadioMsg();
msg-&gt;freq = 1;
msg-&gt;power = 10.0;
...
</pre>
<p>
You'd notice one drawback of this solution when you try to use
Tkenv for debugging. While <tt>cPar</tt>-based message parameters can be viewed in
message inspector windows, fields added via subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because the C++ language
does not support ``reflection'' (extracting class information at runtime)
like for example Java does.

<p>There is a solution however: one can supply Tkenv with missing ``reflection''
information about the new class. Reflection info might take the form of
a separate C++ class whose methods return information about the
<tt>RadioMsg</tt> fields. This descriptor class might look like this:

<pre>
class RadioMsgDescriptor : public Descriptor
{
  public:
    virtual int getFieldCount() {return 2;}

    virtual const char *getFieldName(int k) {
        const char *fieldname[] = {"freq", "power";}
        if (k&lt;0 || k&gt;=2) return NULL;
        return fieldname[k];
    }

    virtual double getFieldAsDouble(RadioMsg *msg, int k) {
        if (k==0) return msg-&gt;freq;
        if (k==1) return msg-&gt;power;
        return 0.0; // not found
    }
    //...
};
</pre>
<p>
Then you have to inform Tkenv that a <tt>RadioMsgDescriptor</tt> exists and that it
should be used whenever Tkenv finds messages of type <tt>RadioMsg</tt> (as it is
currently implemented, whenever the object's <tt>className()</tt> method returns
<tt>"RadioMsg"</tt>). So when you inspect a <tt>RadioMsg</tt> in your simulation, Tkenv
can use <tt>RadioMsgDescriptor</tt> to extract and display the values of
the <tt>freq</tt> and <tt>power</tt> variables.

<p>The actual implementation is somewhat more complicated than this, but not
much.

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb  2 2004</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jan 21 2004</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec235"/>7. The Simulation Library</H1>
<a name="cha:the-simulation-library"></a>

<p>OMNeT++ has an extensive C++ class library which you can use when implementing
simple modules. Some areas of class librar have already been covered in the
previous chapters:

<p><UL>
  <li><strong></strong>events, messages, network packets: the <tt>cMessage</tt> and
    <tt>cPacket</tt> classes (chapter <a href="#cha:messages">[click]</a>)
  <li><strong></strong>sending and receiving messages, scheduling and cancelling
    events, terminating the module or the simulation
    (section <a href="#ch:simple-modules:sending-and-receiving">[click]</a>)
  <li><strong></strong>access to module gates and parameters via <tt>cModule</tt> member functions
    (sections <a href="#ch:simple-modules:parameters">[click]</a> and <a href="#ch:simple-modules:gates">[click]</a>)
  <li><strong></strong>accessing other modules in the network (section <a href="#ch:simple-modules:walking-module-hieararchy">[click]</a>)
  <li><strong></strong>dynamic module creation (section <a href="#ch:simple-modules:dynamic-module-creation">[click]</a>)
</UL>

<p>This chapter discusses the rest of the simulation library:

<p><UL>
  <li><strong></strong>random number generation: <tt>normal()</tt>,
    <tt>exponential()</tt>, etc.
  <li><strong></strong>module parameters: <tt>cPar</tt> class
  <li><strong></strong>storing data in containers: <tt>cArray</tt>,
    <tt>cQueue</tt>, <tt>cBag</tt> and
    <tt>cLinkedList</tt> classes
  <li><strong></strong>routing support and discovery of network topology: <tt>cTopology</tt> class
  <li><strong></strong>recording statistics into file: <tt>cOutVector</tt> class
  <li><strong></strong>collecting simple statistics: <tt>cStdDev</tt> and
    <tt>cWeightedStddev</tt> classes
  <li><strong></strong>distribution estimation: <tt>cLongHistogram</tt>,
    <tt>cDoubleHistogram</tt>, <tt>cVarHistogram</tt>, <tt>cPSquare</tt>,
    <tt>cKSplit</tt> classes
  <li><strong></strong>making variables inspectable in the graphical user interface
    (Tkenv): the <tt>WATCH()</tt> macro (<tt>cWatch</tt> class)
  <li><strong></strong>sending debug output to and prompting for user input in the graphical
    user interface (Tkenv): the <tt>ev</tt> object (<tt>cEnvir</tt> class)
</UL>

<p>

<p>

<p><hr><H2><A NAME="sec236"/>7.1. Class library conventions</H2>

<p><br><P class="subheading">Base class</P>
<a name="sec:ch-sim-lib:cObject"></a>

<p>
Classes in the OMNeT++ simulation library are derived from <tt>cObject</tt>.
Functionality and conventions that come from <tt>cObject</tt>:
<UL>
  <li><strong></strong>name attribute
  <li><strong></strong><tt>className()</tt> member and other member functions giving textual
    information about the object
  <li><strong></strong>conventions for assignment, copying, duplicating the object
  <li><strong></strong>ownership control for containers derived from <tt>cObject</tt>
  <li><strong></strong>support for traversing the object tree
  <li><strong></strong>support for inspecting the object in graphical user interfaces
    (Tkenv)
  <li><strong></strong>support for automatic cleanup (garbage collection) at the end
    of the simulation
</UL>

<p>
Classes inherit and redefine several <tt>cObject</tt> member functions;
in the following we'll discuss some of the practically important
ones.

<p>
<br><P class="subheading">Setting and getting attributes</P>

<p>
Member functions that set and query object attributes follow
consistent naming. The setter member function has the form setSomething(...)
and its getter counterpart is named something(), i.e. the ``get''
verb found in Java and some other libraries is omitted for brevity.
For example, the <EM>length</EM> attribute of the <tt>cMessage</tt> class can
be set and read like this:

<pre>
msg-&gt;setLength( 1024 );
length = msg-&gt;length();
</pre>
<p>

<p><br><P class="subheading">className()</P>

<p>
For each class, the <tt>className()</tt> member function returns the class
name as a string:

<pre>
const char *classname = msg-&gt;className(); // returns "cMessage"
</pre>
<p>
<br><P class="subheading">Name attribute</P>

<p>
An object can be assigned a name (a character string). The name
string is the first argument to the constructor of every class,
and it defaults to NULL (no name string). If you supply a name
string, the object will make its own copy (<tt>strdup()</tt>). As an example,
you can create a message object like this:

<pre>
cMessage *mymsg = new cMessage("mymsg");
</pre>
<p>

<p>You can also set the name after the object has been created:

<pre>
mymsg-&gt;setName("mymsg");
</pre>
<p>
You can get a pointer to the internally stored copy of the name
string like this:

<pre>
const char *name = mymsg-&gt;name(); // --&gt; returns ptr to internal copy
                                  // of "mymsg"
</pre>
<p>

<p>For convenience and efficiency reasons, the empty string ``''
and NULL are treated as equivalent by library objects: ``''
is stored as NULL (so that it does not consume heap), but it
is returned as ``'' (so that it is easier to print
out etc). Thus, if you create a message object with either NULL
or ``'' as name, it will be stored as NULL and <tt>name()</tt>
will return a pointer to ``'', a static string:

<pre>
cMessage *msg = new cMessage(NULL, &lt;additional args&gt;);
const char *str = msg-&gt;name(); // --&gt; returns ptr to  ""
</pre>
<p>

<p><br><P class="subheading">fullName() and fullPath()</P>

<p>
Objects have two more member functions which return other sort
of names based on the name attribute: <tt>fullName()</tt> and <tt>fullPath()</tt>.

<p>Suppose we have a module in the network university_lan, compound
module fddi_ring, simple module station[10]. If you call the functions
on the simple module object (<tt>cSimpleModule</tt> inherits from
<tt>cObject</tt>, too), the functions will return these values:

<pre>
ev &lt;&lt; module-&gt;name(); // --&gt; "station"
ev &lt;&lt; module-&gt;fullName(); // --&gt; "station[10]"
ev &lt;&lt; module-&gt;fullPath(); // --&gt; "university_lan.fddi_ring.station[10]"
</pre>
<p>

<p>
These functions work for any object. For example, a local object
inside the module would produce results like this:

<p>
<pre>
void FDDIStation::activity()
{
    cQueue buffer("buffer");
    ev &lt;&lt; buffer-&gt;fullPath(); // --&gt; "university_lan.fddi_ring.
                              // station[10].buffer"
}
</pre>

<p>

<p><tt>fullName()</tt> and <tt>fullPath()</tt>, together with
<tt>className()</tt> can be used for example to generate informative
error messages.

<p>Be aware that <tt>fullName()</tt> and <tt>fullPath()</tt> return
pointers to static buffers. Each call will overwrite the previous
content of the buffer, so for example you shouldn't put two calls in a
single <tt>printf()</tt> statement:

<pre>
ev.printf("object1 is '%s', object2 is '%s'\n",
          object1-&gt;fullPath(),
          object2-&gt;fullPath()
         ); // WRONG! Same string is printed twice!!!
</pre>
<p>

<p><br><P class="subheading">Copying and duplicating objects</P>

<p>
The <tt>dup()</tt> member function creates an exact copy of the
object, duplicating
contained objects also if necessary. This is especially useful in the
case of message objects. <tt>dup()</tt> returns a pointer of type
<tt>cObject*</tt>, so it needs to be cast to the proper type:

<pre>
cMessage *copyMsg = (cMessage *) msg-&gt;dup();
</pre>
<p>

<p><tt>dup()</tt> works through calling the copy constructor, which in
turn relies on the assignment operator between objects.
<tt>operator=()</tt> can be used to copy contents of an object into
another object of the same type. The copying is done properly; object
contained in the object will also be duplicated if necessary. For
various reasons, <tt>operator=()</tt> does not copy the name string;
the copy constructor does it.

<p>
<br><P class="subheading">Iterators</P>

<p>
There are several container classes in the library (<tt>cQueue</tt>,
<tt>cArray</tt> etc.) For many of them, there is a corresponding
iterator class that you can use to loop through the objects stored in
the container.

<p>For example:

<pre>
cQueue queue;

//..
for (cQueue::Iterator queueIter(queue); !queueIter.end(); queueIter++)
{
    cObject *containedObject = queueIter();
}
</pre>
<p>

<p><br><P class="subheading">Ownership control</P>

<p>
By default, if a container object is destroyed, it destroys the
contained objects too. If you call <tt>dup()</tt>, the contained
objects are duplicated too for the new container. This is done so
because contained objects are owned by the container; ownership is
defined as the right/duty of deallocation. However, there is a
fine-grain ownership control mechanism built
in which allows you to specify on per-object basis whether you want
objects to be owned by the container or not; by calling the
<tt>takeOwnership()</tt> member function with false, you tell the
container that you don't want it to become the owner of objects that
will be inserted in the future.

<p>The ownership mechanism is discussed in detail in section
<a href="#sec:ch-sim-lib:ownership-management">[click]</a>

<p>
<hr><H2><A NAME="sec237"/>7.2. Utilities</H2>

<p><br><P class="subheading">Tracing</P>

<p>
The tracing feature will be used extensively in the code examples,
so it is shortly introduced here. It will be covered in detail
in a later section.

<p>The <tt>ev</tt> object represents the user interface of the
simulation.  You can send debugging output to <tt>ev</tt> with the C++-style
output operators:

<pre>
ev &lt;&lt; "packet received, sequence number is "
   &lt;&lt; seq_num &lt;&lt; endl;
</pre>
<p>
An alternative solution is <tt>ev.printf()</tt>:

<pre>
ev.printf("packet received, sequence number is %d\n", seq_num);
</pre>
<p>
<br><P class="subheading">Simulation time conversion</P>

<p>
There are utility functions which convert simulation
time (<tt>simtime_t</tt>) to a printable string
(like <tt>"3s 130ms 230us"</tt>) and vica versa.

<p>
The <tt>simtimeToStr()</tt> function converts a <tt>simtime_t</tt>
(passed in the first arg) to textual form. The result is placed into
the buffer pointed to by the second arg. If the second arg is omitted
or it is NULL, <tt>simtimeToStr()</tt> will place the result into a
static buffer which is overwritten with each call:

<pre>
char buf[32];
ev.printf("t1=%s, t2=%s\n", simtimeToStr(t1), simTimeToStr(t2,buf));
</pre>
<p>

<p>The <tt>strToSimtime()</tt> function parses a time specification passed
in a string, and returns a <tt>simtime_t</tt>. If the string cannot
be entirely interpreted, -1 is returned.

<pre>
simtime_t t = strToSimtime("30s 152ms");
</pre>
<p>
Another variant, <tt>strToSimtime0()</tt> can be used if the time
string is a substring in a larger string. Instead of taking a char*,
it takes a reference to char* (char*&amp;) as the first argument.  The
function sets the pointer to the first character that could not be
interpreted as part of the time string, and returns the value. It
never returns -1; if nothing at the beginning of the string looked
like simulation time, it returns 0.

<pre>
const char *s = "30s 152ms and some rubbish";

simtime_t t = strToSimtime0(s); // now s points to "and some rubbish"
</pre>
<p>
<br><P class="subheading">Utility <SAMP>&lt;string.h&gt;</SAMP> functions</P>

<p><p>
The <tt>opp_strdup()</tt>, <tt>opp_strcpy()</tt>, <tt>opp_strcmp()</tt>
functions are the same as their <SAMP>&lt;string.h&gt;</SAMP> equivalents,
except that they treat NULL and the empty string (<tt>""</tt>) as identical,
and <tt>opp_strdup()</tt> uses operator new instead of <tt>malloc()</tt>.
</p>

<p>The <tt>opp_concat()</tt> function might also be useful, for example
in constructing object names. It takes up to four <tt>const char *</tt>
pointers, concatenates them in a static buffer and returns a pointer
to the result. The result's length shouldn't exceed 255 characters.

<p>

<p><hr><H2><A NAME="sec238"/>7.3. Generating random numbers</H2>

<p>Random numbers in simulation are never random. Rather, they are
produced using deteministic algorithms. Algorithms take a <EM>seed</EM> value
and perform some deterministic calculations on them to produce
a ``random'' number and the next seed. Such algorithms and their
implementations are called <EM>random number generators</EM> or RNGs,
or sometimes pseudo random number generators or PRNGs to highlight
their deterministic nature.
  <br><ul><font size=-1>[There exist real random numbers too, see e.g.
  http://www.random.org/, http://www.comscire.com, or the Linux
  /dev/random device.]</font></ul>

<p>Starting from the same seed, RNGs always produce the same sequence
of random numbers. This is a useful property and of great importance,
because it makes simulation runs repeatable.

<p>RNGs produce uniformly distributed integers in some range,
usually between 0 or 1 and $2^32$ or so. Matematical transformations
are used to produce random variates from them that correspond to
specific distributions.

<p><H3><A NAME="sec239"/>7.3.1. Random number generators</H3>

<p><br><P class="subheading">The current RNG</P>

<p>The currently used random number generator in OMNeT++ is
a linear congruential generator
(LCG) with a cycle length of $2^31-2$.
The startup code of OMNeT++ contains code that checks if the random number
generator works OK, so you do not have to worry about this if you port
the simulator to a new architecture or use a different compiler.

<p>The random number generator was taken from [<a href="#bib-Jain91">Jain91</a>], pp. 441-444,455.
It has the following properties:
<UL>
   <li><strong></strong>Range: ... 2^31-2$
   <li><strong></strong>Period length: ^31-2$
   <li><strong></strong>Method: $x := (x * 7^5) mod (2^31-1)$
   <li><strong>Verification: if $x[0]</strong> = 1$ then $x[10000] = 1,043,618,065$ 
   <li><strong></strong>Required hardware: exactly 32-bit integer arithmetics
</UL>

<p>The concrete implementation:

<pre>
long intrand()
{
  const long int a=16807, q=127773, r=2836;
  seed=a*(seed%q) - r*(seed/q);
  if (seed&lt;=0) seed+=INTRAND_MAX;
  return seed;
}
</pre>
<p>

<p><br><P class="subheading">Caution!</P>

<p>The above ``minimal standard'' RNG is only suitable for small-scale
simulation studies. As shown by Karl Entacher et al. in [<a href="#bib-Entacher02">Entacher02</a>],
the cycle length of about $2^31$ is too small (on todays
fast computers it is easy to exhaust all random numbers), and
the structure of the generated ``random'' points is too regular.
The [<a href="#bib-Hellekalek98">Hellekalek98</a>] paper gives you a broader overview of issues
associated with RNGs used for simulation, and it's well worth reading.
It also gives you useful links and references to further reading
on the topic.

<p>Work is underway to create a flexible and extensible
random number architecture in future versions of OMNeT++,
and to integrate modern RNGs such as L'Ecuyer's CMRG [<a href="#bib-LEcuyer02">LEcuyer02</a>]
with a period of about $2^191$ and/or
Mersenne Twister [<a href="#bib-Matsumoto98">Matsumoto98</a>].

<p>
<br><P class="subheading">Multiple RNGs</P>

<p>If a simulation program uses random numbers for more than one purpose,
the numbers should come from different random number generators.
OMNeT++ provides several independent random number generators (by
default 32; this number is #defined as
<tt>NUM_RANDOM_GENERATORS</tt> in <tt>utils.h</tt>).

<p>To avoid unwanted correlation, it is also important that different
simulation runs and different random number sources within one
simulation run use non-overlapping series of random numbers,
so the generators should be started with seeds well apart. For
selecting good seeds, the seedtool program can be used (it is
documented later).

<p>
<br><P class="subheading">Accessing RNGs</P>

<p>Integers can be generated via the <tt>intrand()</tt> function:

<pre>
long rnd = intrand();   // in the range 1..INTRAND_MAX-1
</pre>
<p>
The random number seed can be specified in the ini file
(<tt>random-seed=</tt>) or set directly from within
simple modules with the <tt>randseed()</tt>
function:

<pre>
randseed( 10 );         // set seed to 10
long seed = randseed(); // current seed value
</pre>
<p>
Zero is not allowed as a seed.

<p>The <tt>intrand()</tt> and <tt>randseed()</tt> functions use generator 0. They have
another variant which uses a specified generator:

<pre>
long rnd = genk_intrand(6); // like intrand(), using generator 6
genk_randseed( k, 167 );    // set seed of generator k to 167
</pre>
<p>

<p>The <tt>intrand(n)</tt> and <tt>dblrand()</tt> functions are based on <tt>intrand()</tt>:

<pre>
int dice = 1 + intrand(6); // result of intrand(6) is in the range 0..5
                           // (it is calculated as intrand()%6)

double prob = dblrand();   // dblrand() produces numbers in [0,1)
                           // calculated as
                           // intrand()/(double)INTRAND_MAX
</pre>
<p>

<p>They also have their counterparts that use generator <EM>k</EM>:

<pre>
int dice = 1 + genk_intrand(k,6); // uses generator k
double prob = genk_dblrand(k);    // ""
</pre>
<p>

<p>

<p><H3><A NAME="sec240"/>7.3.2. Random variates</H3>

<p>The following functions are based on <tt>dblrand()</tt> and return
random variables of different distributions:

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNeT++. By default this is generator 0, but you can specify
which one to be used.

<p>OMNeT++ has the following predefined distributions:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <EM>rng=0</tt>)</EM> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <EM>rng=0</tt>)</EM> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <EM>rng=0</tt>)</EM> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <EM>rng=0</tt>)</EM> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left> 
</table>

<p>
They are the same functions that can be used in NED files.
<tt>intuniform()</tt> generates integers including both the lower and
upper limit, so for example the outcome of tossing a coin could be
written as intuniform(1,2).  <tt>truncnormal()</tt> is the normal
distribution truncated to nonnegative values; its implementation
generates a number with normal distribution and if the result is
negative, it keeps generating other numbers until the outcome is
nonnegative.

<p>If the above distributions do not suffice, you can write your own
functions. If you register your functions
with the <tt>Register_Function()</tt> macro, you can use them in NED
files and ini files too.

<p>
<H3><A NAME="sec241"/>7.3.3. Random numbers from histograms</H3>

<p>You can also specify your distribution as a
histogram. The
<tt>cLongHistogram</tt>, <tt>cDoubleHistogram</tt>,
<tt>cVarHistogram</tt>, <tt>cKSplit</tt> or <tt>cPSquare</tt> classes
are there to generate random numbers from equidistant-cell or
equiprobable-cell histograms.  This feature is documented later, with
the statistical classes.

<p>

<p>

<p><hr><H2><A NAME="sec242"/>7.4. Container classes</H2>

<p><H3><A NAME="sec243"/>7.4.1. Queue class: cQueue</H3>

<p><br><P class="subheading">Basic usage</P>

<p>
<tt>cQueue</tt> is a container class that acts as a queue.
<tt>cQueue</tt> can hold objects of type derived from <tt>cObject</tt>
(almost all classes from the OMNeT++ library), such as
<tt>cMessage</tt>, <tt>cPar</tt>, etc. Internally, <tt>cQueue</tt>
uses a double-linked list to store the elements.

<p>A queue object has a head and a tail. Normally, new elements
are inserted at its head and elements are removed at its tail.

<p>

<p>  <DIV ALIGN=center>
    <img src="figures/usmanFig10.gif">
    <center><i>Figure: What is what with cQueue</i></center>
    <a name="fig:ch-sim-lib:cqueue"></a>
  </DIV>

<p>
The basic <tt>cQueue</tt> member functions dealing with insertion and removal
are <tt>insert()</tt> and <tt>pop()</tt>. They are used
like this:

<pre>
cQueue queue("my-queue");
cMessage *msg;

// insert messages
for (int i=0; i&lt;10; i++)
{
  msg = new cMessage;
  queue.insert( msg );
}

// remove messages
while( ! queue.empty() )
{
  msg = (cMessage *)queue.pop();
  delete msg;
}
</pre>
<p>

<p>The <tt>length()</tt> member function returns the number of items in the
queue, and <tt>empty()</tt> tells whether there's anything in the queue.

<p>There are other functions dealing with insertion and removal.  The
<tt>insertBefore()</tt> and <tt>insertAfter()</tt> functions insert a
new item exactly before and after a specified one, regardless of the
ordering function.

<p>The <tt>tail()</tt> and <tt>head()</tt> functions return pointers to the objects
at the tail and head of the queue, without affecting queue contents.

<p>

<p>The <tt>pop()</tt> function can be used to remove items from the
tail of the queue, and the <tt>remove()</tt> function can be
used to remove any item known by its pointer from the queue:

<p>
<tt>queue.remove( msg );</tt>

<p>

<p><br><P class="subheading">Priority queue</P>

<p>
By default, <tt>cQueue</tt> implements a FIFO, but it can also act as
a priority queue, that is, it can keep the inserted objects
ordered.  If you want to use this feature, you have
to provide a function that takes two <tt>cObject</tt> pointers,
compares the two objects and returns -1, 0 or 1 as the result (see the
reference for details).  An example of setting up an ordered
<tt>cQueue</tt>:

<pre>
cQueue sortedqueue("sortedqueue", cObject::cmpbyname, true );
                        // sorted by object name, ascending
</pre>
<p>

<p>If the queue object is set up as an ordered queue, the <tt>insert()</tt>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there.

<p>
<br><P class="subheading">Iterators</P>

<p>
Normally, you can only access the objects at the head or tail of the
queue. However, if you use an iterator class, <tt>cQueue::Iterator</tt>,
you can examine each object in the queue.

<p>The <tt>cQueue::Iterator</tt> constructor takes two arguments, the first
is the queue object and the second one specifies the initial position
of the iterator: 0=tail, 1=head. Otherwise it acts as any other
OMNeT++ iterator class: you can use the ++ and - operators to advance
it, the () operator to get a pointer to the current item, and the
<tt>end()</tt> member function to examine if you're at the end (or the
beginning) of the queue.

<p>
An example:

<pre>
for( cQueue::Iterator iter(queue,1); !iter.end(), iter++)
{
  cMessage *msg = (cMessage *) iter();
  //...
}
</pre>
<p>

<p>

<p><H3><A NAME="sec244"/>7.4.2. Expandable array: cArray</H3>

<p><br><P class="subheading">Basic usage</P>

<p>
<tt>cArray</tt> is a container class that holds objects derived from
<tt>cObject</tt>. <tt>cArray</tt> stores the pointers of the objects
inserted instead of making copies. <tt>cArray</tt> works as an array,
but if it gets full, it grows automatically. Internally,
<tt>cArray</tt> is implemented with an array of pointers; if the array
gets full, it is reallocated.

<p><tt>cArray</tt> objects are used in OMNeT++ to store parameters
attached to messages, and internally, for storing module parameters
and gates.

<p>
Creating an array:

<pre>
cArray array("array");
</pre>
<p>
Adding an object at the first free index:

<pre>
cPar *p = new cPar("par");
int index = array.add( p );
</pre>
<p>

<p>Adding an object at a given index (if the index is occupied,
you'll get an error message):

<pre>
cPar *p = new cPar("par");
int index = array.addAt(5,p);
</pre>
<p>

<p>Finding an object in the array:

<pre>
int index = array.find(p);
</pre>
<p>
Getting a pointer to an object at a given index:

<pre>
cPar *p = (cPar *) array[index];
</pre>
<p>
You can also search the array or get a pointer to an object by
the object's name:

<pre>
int index = array.find("par");
Par *p = (cPar *) array["par"];
</pre>
<p>

<p>You can remove an object from the array by calling <tt>remove()</tt>
with the object name, the index position or the object pointer:

<pre>
array.remove("par");
array.remove(index);
array.remove( p );
</pre>
<p>

<p>The <tt>remove()</tt> function doesn't deallocate the object, but it
returns the object pointer. If you also want to deallocate it, you can
write:

<pre>
delete array.remove( index );
</pre>
<p>
<br><P class="subheading">Iteration</P>

<p>
<tt>cArray</tt> has no iterator, but it's easy to loop through all the
indices with an integer variable. The <tt>items()</tt> member function
returns the largest index plus one.

<pre>
for (int i=0; i&lt;array.items(); i++)
{
  if (array[i]) // is this position used?
  {
    cObject *obj = array[i];
    ev &lt;&lt; obj-&gt;name() &lt;&lt; endl;
  }
}
</pre>
<p>

<p>

<p><hr><H2><A NAME="sec245"/>7.5. Non-object container classes</H2>

<p>There are two container classes to store non-object
items: <tt>cLinkedList</tt> and
<tt>cBag</tt>.  The first one parallels with <tt>cQueue</tt>, the
second one with <tt>cArray</tt>. They can be useful if you have to
deal with C structs or objects that are not derived from
<tt>cObject</tt>.

<p>See the class library reference for more info about them.

<p>

<p>

<p><hr><H2><A NAME="sec246"/>7.6. The parameter class: cPar</H2>

<p><H3><A NAME="sec247"/>7.6.1. Basic usage</H3>

<p><tt>cPar</tt> is a class that is designed to hold a value. The value
is numeric (long or double) in the first place, but string, pointer
and other types are also supported.

<p>cPar is used in OMNeT++ in the following places:

<p><UL>
  <li><strong></strong>as module parameters
  <li><strong></strong>as message parameters
</UL>

<p>There are many ways to set a <tt>cPar</tt>'s value. One is the set...Value()
member functions:

<pre>
cPar pp("pp");
pp.setDoubleValue(1.0);
</pre>
<p>

<p>or by using overloaded operators:

<pre>
cPar pp("pp");
pp = 1.0;
</pre>
<p>

<p>For reading its value, it is best to use overloaded type cast
operators:

<pre>
double d1 = (double)pp;
// or simply:
double d2 = pp;
</pre>
<p>
Long integers:

<pre>
pp = 89363L; // or:
pp.setLongValue( 89363L );
</pre>
<p>
Character string:

<pre>
pp = "hi there"; // or:
pp.setStringValue( "hi there" );
</pre>
<p>

<p>The <tt>cPar</tt> object makes its own copy of the string, so the
original one does not need to be preserved. Short strings (less than
<IT>~</IT>20 chars) are handled more efficiently because they
are stored in the object's memory space (and are not dynamically
allocated).

<p>There are several other types <tt>cPar</tt> can store: such as boolean,
void* pointer; cObject* pointer,  function with constant args;
they will be mentioned in the next section.

<p>For numeric and string types, an input flag can be
set. In this case, when the object's value is first used, the
parameter value will be searched for in the configuration (ini)
file; if it is not found there, the user will be given
a chance to enter the value interactively.

<p>
Examples:

<pre>
cPar inp("inp");
inp.setPrompt("Enter my value:");
inp.setInput( true );   // make it an input parameter
double a = (double)inp; // the user will be prompted HERE
</pre>
<p>

<p>

<p><H3><A NAME="sec248"/>7.6.2. Random number generation through cPar</H3>

<p>Setting <tt>cPar</tt> to call a function with constant arguments can
be used to make <tt>cPar</tt> return random variables of different distributions:

<pre>
cPar rnd("rnd");
rnd.setDoubleValue(intuniform, -10.0, 10.0);// uniform distr.
rnd.setDoubleValue(normal, 100.0, 5.0); // normal distr. (mean,dev)
rnd.setDoubleValue(exponential, 10.0); // exponential distr. (mean)
</pre>
<p>
<tt>intuniform()</tt>, <tt>normal()</tt> etc. are ordinary C functions
taking double arguments and returning double. Each time you read the
value of a <tt>cPar</tt> containing a function like above, the
function will be called with the given constant arguments (e.g.
normal(100.0,5.0)) and its return value used.

<p>
The above functions use number 0 from the several random number
generators. To use another generator, use the genk_xxx versions
of the random functions:

<pre>
rnd.setDoubleValue(genk\_normal, 3, 100.0, 5.0); // uses generator 3
</pre>
<p>
A <tt>cPar</tt> object can also be set to return a random variable from
a distribution collected by a statistical data collection object:

<pre>
cDoubleHistogram hist =....; // the distribution
cPar rnd2("rnd2");
rnd2.setDoubleValue(hist);
</pre>
<p>

<p>

<p><H3><A NAME="sec249"/>7.6.3. Storing object and non-object pointers in cPar</H3>

<p><tt>cPar</tt> can store pointers to OMNeT++ objects. You can use both
assignment and the <tt>setObjectValue()</tt> member function:

<pre>
cQueue *queue = new cQueue("queue"); // just an example
cPar par1, par2;
par1 = (cObject *) queue;
par2.setObjectValue( queue );
</pre>
<p>
To get the store pointer back, you can use typecast or the <tt>objectValue()</tt>
member function:

<pre>
cQueue *q1 = (cQueue *)(cObject *)par1;
cQueue *q2 = (cQueue *)par2.objectValue();
</pre>
<p>

<p>Whether the <tt>cPar</tt> object will own the other object or not is
controlled by the <tt>takeOwnership()</tt> member
function, just as with container classes. This is documented in detail
in the class library reference.  By default, <tt>cPar</tt> will own
the object.

<p><tt>cPar</tt> can be used to store non-object
pointers (for example C structs) or
non-OMNeT++ object types in the parameter object.  It works very
similarly to the above mechanism. An example:

<pre>
double *mem = new double[15];
cPar par1, par2;
par1 = (void *) mem;
par2.setPointerValue( (void *)mem );
...
double *m1 = (double *)(void *)par1;
double *m2 = (double *)par2.pointerValue();
</pre>
<p>

<p>Memory management can be specified by
<tt>cPar</tt>'s <tt>configPointer()</tt> member function. It takes
three arguments: a pointer to a user-supplied deallocation
function, a pointer to a user-supplied duplication function and
an item size. If all three are 0 (NULL), no memory management is done,
that is, the pointer is treated as a mere pointer. This is the default
behaviour. If you supply only the item size (and both function
pointers are NULL), <tt>cPar</tt> will use the delete operator to
deallocate the memory area when the <tt>cPar</tt> object is
destructed, and it will use new char[size] followed by a
<tt>memcpy()</tt> to duplicate the memory area whenever the
<tt>cPar</tt> object is duplicated. If you need more sophisticated
memory management, you can supply your own deallocation and
duplication functions.

<p>An example for simple memory management:

<pre>
double *mem = new double[15];
cPar par;
par.setPointerValue((void *) mem);
par.configPointer(NULL, NULL, 15*sizeof(double));
// -&gt; now if par goes out of scope, it will delete the 15-double array.
</pre>
<p>
The <tt>configPointer()</tt> setting only affects what happens when the
<tt>cPar</tt> is deleted, duplicated or copied, but does <EM>not</EM>
apply to assigning new pointers. That is, if <EM>you</EM> assign a new
void* to the <tt>cPar</tt>, you simply overwrite the pointer - the
block denoted by the old pointer is <EM>not</EM> deleted. This fact
can be used to extract some dynamically allocated block out of the
<tt>cPar</tt>: carrying on the previous example, you would extract the
array of 15 doubles from the <tt>cPar</tt> like this:

<pre>
double *mem2 = (double *)par.pointerValue();
par.setValue( (void *)0 );
// -&gt; now par has nothing to do with the double[15] array
</pre>
<p>

<p>
However, if you assign some non-pointer value
to the <tt>cPar</tt>, beware: this <EM>will</EM> activate the memory
management for the block. If you temporarily use the same
<tt>cPar</tt> object to store other than void* ('P') values, the
<tt>configPointer()</tt> setting is lost.

<p>

<p><H3><A NAME="sec250"/>7.6.4. Reverse Polish expressions</H3>

<p>This feature is rarely needed by the user, it is more used internally.
A <tt>cPar</tt> object can also store
expressions. In this case, the expression must
be given in reversed Polish form. An
example:

<pre>
cPar::XElem *expression = new cPar::XElem[5];
expression[0] = &par("count"); // pointer to
module parameter
expression[1] = 1;
expression[2] = '+';
expression[3] = 2;
expression[4] = '/';

cPar expr("expr");
expr.setDoubleValue(expression,5);
</pre>
<p>

<p>The <tt>cPar</tt> object created above contains the $(count+1)/2$
expression where <EM>count</EM> is a module parameter. Each time the
<tt>cPar</tt> is evaluated, it recalculates the expression, using the
current value of count. Note the &amp; sign in front of
<SAMP>par(''count'')</SAMP> expression: if it was not there, the parameter
would be taken by value, evaluated once and
then the resulting constant would be used.

<p>Another example is a distribution with mean and
standard deviation given by module parameters:

<pre>
cPar::XElem *expression = new cPar::XElem[3];
expression[0] = &par("mean");
expression[1] = &par("stddev");
expression[2] = normal; // pointer to the normal(double,double) func.

cPar expr("expr");
expr.setDoubleValue(expression,3);
</pre>
<p>

<p>For more information, see the reference and the code NEDC generates
for parameter expressions.

<p>

<p><H3><A NAME="sec251"/>7.6.5. Using redirection</H3>

<p>A <tt>cPar</tt> object can be set to stand for a value actually stored
in another <tt>cPar</tt> object. This is called <EM>indirect</EM> or
<EM>redirected</EM> value. When using redirection,
every operation on the value (i.e.  reading or changing it) will be
actually done to the other <tt>cPar</tt> object:

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig11.gif">
    <center><i>Figure: cPar redirection</i></center>
    <a name="fig:ch-sim-lib:cPar-redirection"></a>
  </DIV>

<p>
Redirection is how module parameters taken by
reference are implemented.  The
redirection does not include name strings. That is, if you say
A-<SAMP>&gt;</SAMP>setName(''newname'') in the above example, A's name will
be changed as the name member is not redirected. (This is natural if
you consider parameters taken by reference: a parameter should/can
have different name than the value it refers to.)

<p>
You create a redirection with the <tt>setRedirection()</tt> function:

<pre>
cPar *bb = new cPar("bb"); // background value
bb = 10L;
cPar a("a"); // we'll redirect this object

a.setRedirection(bb); // create redirection
</pre>
<p>

<p>Now every operation you do on a's value will be done to bb:

<pre>
long x = a; // returns bb's value, 10L
a = 5;      // bb's value changes to 5
</pre>
<p>

<p>The only way to determine whether a is really holding the value or it
is redirected to another <tt>cPar</tt> is to use the
<tt>isRedirected()</tt> member function which returns a bool, or
<tt>redirection()</tt> which returns the pointer to the background
object, or NULL if there's no redirection:

<pre>
cPar *redir = a.redirection(); // returns bb's pointer
if (redir != NULL)
  ev &lt;&lt; "a is redirected to " &lt;&lt; redir-&gt;name() &lt;&lt; endl;
</pre>
<p>

<p>To break the link between the two objects, use the
<tt>cancelRedirection()</tt> member function. (No other method will
work, including assigning a the value of another <tt>cPar</tt>
object.) The <tt>cancelRedirection()</tt> function gives the <SAMP>(long)0</SAMP>
value to the redirected object (the other will be unaffected). If you
want to cancel the indirection but keep the old value, you can do
something like this:

<pre>
cPar *value = a.redirection();  // bb's pointer
a.cancelRedirection();          // break the link; value of a is now 0
a = *value;                     // copy the contents of bb into a
</pre>
<p>

<p>

<p><H3><A NAME="sec252"/>7.6.6. Type characters</H3>

<p>Internally, <tt>cPar</tt> objects identify the types of the stored values
by type characters. The type character is returned by the <tt>type()</tt>
member function:

<pre>
cPar par = 10L;
char typechar = par.type(); // returns 'L'
</pre>
<p>
The full table of type characters is presented in the <EM>Summary</EM>
section below.

<p>The <tt>isNumeric()</tt> function tells whether the object
stores one of the numeric types, so that e.g. <tt>asDoubleValue()</tt>
can be invoked on it.

<p>

<p>
<H3><A NAME="sec253"/>7.6.7. Summary</H3>

<p>The various <tt>cPar</tt> types and the member functions used to manipulate them are summarized
in the following table:

<p><table border>
<TR> <TD align=left>

<STRONG>Type<br>
char</STRONG> </TD> <TD align=left>
<STRONG>Type <br>
name</STRONG> </TD> <TD align=left>
<STRONG>Member functions</STRONG> </TD> <TD align=left>
<STRONG>Description</STRONG></TD></TR>
<TR> <TD align=left>
S </TD> <TD align=left>  string </TD> <TD align=left>
<tt>setStringValue( <br>
  const char *); <br>
const char * <br>
 <tt>stringValue()</tt>; <br>
op const char *(); <br>
op=(const char *);</tt> </TD> <TD align=left>

string value. Short strings (len<SAMP>&lt;</SAMP>=27) are stored inside
<tt>cPar</tt> object, without using heap allocation.</TD></TR>
<TR> <TD align=left> B </TD> <TD align=left>  boolean </TD> <TD align=left>
<tt>setBoolValue(bool); <br>
bool <tt>boolValue()</tt>; <br>
op <tt>bool()</tt>; <br>
op=(bool);</tt> </TD> <TD align=left>
boolean value. Can also be retrieved from the object as long  (0 or 1).</TD></TR>
<TR> <TD align=left> L </TD> <TD align=left> long int </TD> <TD align=left>
<tt>setLongValue(long); <br>
long <tt>longValue()</tt>; <br>
op <tt>long()</tt>; <br>
op=(long);</tt> </TD> <TD align=left>
signed long integer value. Can also be retrieved from the object
as double.</TD></TR>
<TR> <TD align=left> D </TD> <TD align=left> double </TD> <TD align=left>
<tt>setDoubleValue(double); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
op=(double);</tt> </TD> <TD align=left>
double-precision floating point value.</TD></TR>
<TR> <TD align=left> F </TD> <TD align=left> function </TD> <TD align=left>
<tt>setDoubleValue( <br>
 MathFunc, <br>
 [double], <br>
 [double], <br>
 [double]); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
Mathematical function with constant arguments. The function
is given by its pointer; it must take 0,1,2 or 3 doubles and
return a double. This type is mainly used to generate random
numbers: e.g. the function takes mean and standard deviation
and returns random variable of a certain distribution.</TD></TR>
<TR> <TD align=left> X </TD> <TD align=left> expr. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 cPar::XElem*,int); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>;</tt>
</TD> <TD align=left>
Reverse Polish expression. Expression can contain constants,
<tt>cPar</tt> objects, refer to other <tt>cPars</tt> (e.g. module parameters),
can use many math operators (+-*/^% etc), function calls
(function must take 0,1,2 or 3 doubles and return a double).
The expression must be given is in an cPar::XElem array (see later).</TD></TR>
<TR> <TD align=left> T </TD> <TD align=left> distrib. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 <tt>cStatistic</tt>*); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
random variable generated from a distribution collected by a
statistical data collection object (derived from <tt>cStatistic</tt>).</TD></TR>
<TR> <TD align=left> P </TD> <TD align=left> void* pointer </TD> <TD align=left>
<tt>setPointerValue(void*); <br>
void *<tt>pointerValue()</tt>; <br>
op void *(); <br>
op=(void *);</tt> </TD> <TD align=left>
pointer to a non-<tt>cObject</tt> item (C struct, non-<tt>cObject</tt> object
etc.) Memory management can be controlled through the <tt>configPointer()</tt>
member function.</TD></TR>
<TR> <TD align=left> O </TD> <TD align=left> object pointer </TD> <TD align=left>
<tt>setObjectValue(cObject*); <br>
cObject *<tt>objectValue()</tt>; <br>
op cObject *(); <br>
op=(cObject *);</tt>
</TD> <TD align=left>
 pointer to an object derived from <tt>cObject</tt>.
Ownership management is done through <tt>takeOwnership()</tt>.</TD></TR>
<TR> <TD align=left> I </TD> <TD align=left> indirect value </TD> <TD align=left>
<tt>setRedirection(cPar*); <br>
bool <tt>isRedirected()</tt>; <br>
cPar *<tt>redirection()</tt>; <br>
<tt>cancelRedirection()</tt>;</tt>
</TD> <TD align=left>
 value is redirected to another <tt>cPar</tt> object. All value setting
and reading operates on the other <tt>cPar</tt>; even the <tt>type()</tt> function
will return the type in the other <tt>cPar</tt> (so you'll never get 'I'
as the type). This redirection can only be broken with the <tt>cancelRedirection()</tt>
member function. Module parameters taken by REF use this mechanism.</TD></TR>
</table>

<p>

<p>

<p><hr><H2><A NAME="sec254"/>7.7. Routing support: cTopology</H2>

<p><H3><A NAME="sec255"/>7.7.1. Overview</H3>

<p>The <tt>cTopology</tt> class was designed primarily to support
routing in telecommunication or multiprocessor
networks.

<p>A <tt>cTopology</tt> object stores an abstract representation of the
network in graph form:
<UL>
  <li><strong></strong>each <tt>cTopology</tt> node corresponds to a <EM>module</EM>
    (simple or compound), and
  <li><strong></strong>each <tt>cTopology</tt> edge corresponds to a <EM>link</EM> or
    <EM>series of connecting links</EM>.
</UL>

<p>You can specify which modules (either simple or compound) you want to
include in the graph. The graph will include all connections among the
selected modules. In the graph, all nodes are at the same level,
there's no submodule nesting.  Connections which span across compound
module boundaries are also represented as one graph edge. Graph edges
are directed, just as module gates are.

<p>
If you're writing a router or switch model, the <tt>cTopology</tt>
graph can help you determine what nodes are available through which
gate and also to find optimal routes. The
<tt>cTopology</tt> object can calculate shortest paths between nodes for you.

<p>The mapping between the graph (nodes, edges) and network model
(modules, gates, connections) is preserved: you can easily find
the corresponding module for a <tt>cTopology</tt> node and vica versa.

<p>

<p>

<p><H3><A NAME="sec256"/>7.7.2. Basic usage</H3>

<p>You can extract the network topology into a <tt>cTopology</tt>
object by a single function call. You have several ways to select
which modules you want to include in the topology:
<UL>
  <li><strong></strong>by module type
  <li><strong></strong>by a parameter's presence and its value
  <li><strong></strong>with a user-supplied boolean function
</UL>

<p>First, you can specify which node types you want to include. The
following code extracts all modules of type Router or User. (Router
and User can be both simple and compound module types.)

<pre>
cTopology topo;
topo.extractByModuleType( "Router", "User", NULL );
</pre>
<p>

<p>Any number of module types (up to 32) can be supplied; the list
must be terminated by NULL.

<p>Second, you can extract all modules which have a certain parameter:

<pre>
topo.extractByParameter( "ip_address" );
</pre>
<p>

<p>You can also specify that the parameter must have a certain value
for the module to be included in the graph:

<pre>
cPar yes = "yes";
topo.extractByParameter( "include_in_topo", &yes );
</pre>
<p>
The third form allows you to pass a function which can determine for
each module whether it should or should not be included.  You can have
<tt>cTopology</tt> pass supplemental data to the function through a
void* pointer. An example which selects all top-level modules (and
does not use the void* pointer):

<pre>
int select_function(cModule *mod, void *)
{
  return mod-&gt;parentModule() == simulation.systemModule();
}

topo.extractFromNetwork( select_function, NULL );
</pre>
<p>

A <tt>cTopology</tt> object uses two types: <tt>sTopoNode</tt> for
nodes and <tt>sTopoLink</tt> for edges. (<tt>sTopoLinkIn</tt> and
<tt>sTopoLinkOut</tt> are `aliases' for <tt>sTopoLink</tt>; we'll
talk about them later.)

<p>Once you have the topology extracted, you can start exploring
it. Consider the following code (we'll explain it shortly):

<pre>
for (int i=0; i&lt;topo.nodes(); i++)
{
  sTopoNode *node = topo.node(i);
  ev &lt;&lt; "Node i=" &lt;&lt; i &lt;&lt; " is " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
  ev &lt;&lt; " It has " &lt;&lt; node-&gt;outLinks() &lt;&lt; " conns to other nodes\n";
  ev &lt;&lt; " and " &lt;&lt; node-&gt;inLinks() &lt;&lt; " conns from other nodes\n";

  ev &lt;&lt; " Connections to other modules are:\n";
  for (int j=0; j&lt;node-&gt;outLinks(); j++)
  {
    sTopoNode *neighbour = node-&gt;out(j)-&gt;remoteNode();
    cGate *gate = node-&gt;out(j)-&gt;localGate();
    ev &lt;&lt; " " &lt;&lt; neighbour-&gt;module()-&gt;fullPath()
       &lt;&lt; " through gate " &lt;&lt; gate-&gt;fullName() &lt;&lt; endl;
  }
}
</pre>
<p>
The <tt>nodes()</tt> member function (1st line) returns the number of
nodes in the graph, and node(i) returns a pointer to the <EM>i</EM>th
node, an <tt>sTopoNode</tt> structure.

<p>
The correspondence between a graph node and a module can be obtained
by:

<pre>
sTopoNode *node = topo.nodeFor( module );
cModule *module = node-&gt;module();
</pre>
<p>

<p>The <tt>nodeFor()</tt> member function returns a pointer to the graph
node for a given module. (If the module is not in the graph, it
returns NULL). <tt>nodeFor()</tt> uses binary search within the
<tt>cTopology</tt> object so it is fast enough.

<p>
<tt>sTopoNode</tt>'s other member functions let you determine the
connections of this node: <tt>inLinks()</tt>, <tt>outLinks()</tt> return
the number of connections, <tt>in(i)</tt> and
<tt>out(i)</tt> return pointers to graph edge objects.

<p>
By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <tt>remoteNode()</tt>
function returns the other end of the connection, and
<tt>localGate()</tt>, <tt>remoteGate()</tt>, <tt>localGateId()</tt> and
<tt>remoteGateId()</tt> return the gate pointers and ids of the gates
involved. (Actually, the implementation is a bit tricky here: the same
graph edge object <tt>sTopoLink</tt> is returned either as
<tt>sTopoLinkIn</tt> or as <tt>sTopoLinkOut</tt> so that ``remote''
and ``local'' can be correctly interpreted for edges of both
directions.)

<p>

<p>

<p><H3><A NAME="sec257"/>7.7.3. Shortest paths</H3>

<p>The real power of <tt>cTopology</tt> is in finding shortest
paths in the network to support optimal
routing. <tt>cTopology</tt> finds shortest paths
from <EM>all</EM> nodes <EM>to</EM> a target node. The algorithm is
computationally inexpensive. In the simplest case, all edges are
assumed to have the same weight.

<p>A real-life example when we have the target module pointer, finding
the shortest path looks like this:

<pre>
cModule *targetmodulep =...;
sTopoNode *targetnode = topo.nodeFor( targetmodulep );
topo.unweightedSingleShortestPathsTo( targetnode );
</pre>
<p>

<p>This performs the Dijkstra algorithm and
stores the result in the <tt>cTopology</tt> object. The result can
then be extracted using <tt>cTopology</tt> and
<tt>sTopoNode</tt> methods.  Naturally, each call to
<tt>unweightedSingleShortestPathsTo()</tt> overwrites the results of
the previous call.

<p>Walking along the path from our module to the target node:

<pre>
sTopoNode *node = topo.nodeFor( this );

if (node == NULL)
{
  ev &lt; "We (" &lt;&lt; fullPath() &lt;&lt; ") are not included in the topology.\n";
}
else if (node-&gt;paths()==0)
{
  ev &lt;&lt; "No path to destination.\n";
}
else
{
  while (node != topo.targetNode())
  {
    ev &lt;&lt; "We are in " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
    ev &lt;&lt; node-&gt;distanceToTarget() &lt;&lt; " hops to go\n";
    ev &lt;&lt; "There are " &lt;&lt; node-&gt;paths()
       &lt;&lt; " equally good directions, taking the first one\n";
    sTopoLinkOut *path = node-&gt;path(0);
    ev &lt;&lt; "Taking gate " &lt;&lt; path-&gt;localGate()-&gt;fullName()
       &lt;&lt; " we arrive in " &lt;&lt; path-&gt;remoteNode()-&gt;module()-&gt;fullPath()
       &lt;&lt; " on its gate " &lt;&lt; path-&gt;remoteGate()-&gt;fullName() &lt;&lt; endl;
    node = path-&gt;remoteNode();
  }
}
</pre>
<p>

<p>The purpose of the <tt>distanceToTarget()</tt> member function of a
node is self-explanatory. In the unweighted case, it returns the
number of hops. The <tt>paths()</tt> member function returns the number
of edges which are part of a shortest path, and
<tt>path(i)</tt> returns the <EM>i</EM>th edge of them as
<tt>sTopoLinkOut</tt>. If the shortest paths were created by the
<tt>...SingleShortestPaths()</tt> function,
<tt>paths()</tt> will always return 1 (or 0 if the target is not
reachable), that is, only one of the several possible shortest paths
are found.  The
<tt>...MultiShortestPathsTo()</tt> functions
find all paths, at increased run-time cost. The <tt>cTopology</tt>'s
<tt>targetNode()</tt> function returns the target node of the last
shortest path search.

<p>You can enable/disable nodes or edges in the graph. This is done by
calling their <tt>enable()</tt> or <tt>disable()</tt> member functions.
Disabled nodes or edges are ignored by the shortest paths calculation
algorithm. The <tt>enabled()</tt> member function returns the state of
a node or edge in the topology graph.

<p>One usage of <tt>disable()</tt> is when you want to determine in how many
hops the target node can be reached from our node <EM>through
a particular output gate</EM>. To calculate this, you calculate the
shortest paths to the target <EM>from the neighbor node</EM>, but
you must disable the current node to prevent the shortest paths
from going through it:

<pre>
sTopoNode *thisnode = topo.nodeFor( this );
thisnode-&gt;disable();
topo.unweightedSingleShortestPathsTo( targetnode );
thisnode-&gt;enable();

for (int j=0; j&lt;thisnode-&gt;outLinks(); j++)
{
  sTopoLinkOut *link = thisnode-&gt;out(i);
  ev &lt;&lt; "Through gate " &lt;&lt; link-&gt;localGate()-&gt;fullName() &lt;&lt; " : "
     &lt;&lt; 1 + link-&gt;remoteNode()-&gt;distanceToTarget() &lt;&lt; " hops" &lt;&lt; endl;
}
</pre>
<p>
In the future, other shortest path algorithms will also be implemented:

<pre>
unweightedMultiShortestPathsTo(sTopoNode *target);
weightedSingleShortestPathsTo(sTopoNode *target);
weightedMultiShortestPathsTo(sTopoNode *target);
</pre>
<p>

<p>

<p>

<p><hr><H2><A NAME="sec258"/>7.8. Statistics and distribution estimation</H2>

<p><H3><A NAME="sec259"/>7.8.1. cStatistic and descendants</H3>

<p>There are several statistic and result collection classes:
<tt>cStdDev</tt>, <tt>cWeightedStdDev</tt>, <tt>LongHistogram</tt>,
<tt>cDoubleHistogram</tt>, <tt>cVarHistogram</tt>, <tt>cPSquare</tt> and
<tt>cKSplit</tt>. They are all derived from the abstract base class
<tt>cStatistic</tt>.

<p><UL>
  <li><strong></strong><tt>cStdDev</tt> keeps number of samples, mean, standard
    deviation, minimum and maximum value etc.
  <li><strong></strong><tt>cWeightedStdDev</tt> is similar to <tt>cStdDev</tt>, but
    accepts weighted observations. <tt>cWeightedStdDev</tt> can be used
    for example to calculate time average. It is the only weighted
    statistics class.
  <li><strong></strong><tt>cLongHistogram</tt> and <tt>cDoubleHistogram</tt> are
    descendants of <tt>cStdDev</tt> and also keep an approximation of
    the distribution of the observations using equidistant
    (equal-sized) cell histograms.
  <li><strong></strong><tt>cVarHistogram</tt> implements a histogram where cells do not
    need to be the same size. You can manually add the cell (bin)
    boundaries, or alternatively, automatically have a partitioning
    created where each bin has the same number of observations (or as
    close to that as possible).
  <li><strong></strong><tt>cPSquare</tt> is a class that uses the $P^2$ algorithm
    described in [<a href="#bib-JCh85">JCh85</a>]. The algorithm calculates quantiles without
    storing the observations; one can also think of it as a histogram
    with equiprobable cells.
  <li><strong></strong><tt>cKSplit</tt> uses a novel, experimental method, based on an
    adaptive histogram-like algorithm.
</UL>

<p><br><P class="subheading">Basic usage</P>

<p>One can insert an observation into a statistic object with the
<tt>collect()</tt> function or the <SAMP>+=</SAMP> operator (they are
equivalent).  <tt>cStdDev</tt> has the following methods for getting
statistics out of the object: <tt>samples()</tt>, <tt>min()</tt>,
<tt>max()</tt>, <tt>mean()</tt>, <tt>stddev()</tt>, <tt>variance()</tt>,
<tt>sum()</tt>, <tt>sqrSum()</tt> with the obvious meanings. An example
usage for <tt>cStdDev</tt>:

<pre>
cStdDev stat("stat");

for (int i=0; i&lt;10; i++)
  stat.collect( normal(0,1) );

long numSamples = stat.samples();
double smallest = stat.min(),
       largest = stat.max();
double mean = stat.mean(),
       standardDeviation = stat.stddev(),
       variance = stat.variance();
</pre>
<p>

<p>

<p>
<H3><A NAME="sec260"/>7.8.2. Distribution estimation</H3>

<p><br><P class="subheading">Initialization and usage</P>

<p>
The distribution estimation classes (the histogram classes,
<tt>cPSquare</tt> and <tt>cKSplit</tt>) are derived from
<tt>cDensityEstBase</tt>. Distribution estimation classes (except for
<tt>cPSquare</tt>) assume that the observations are within a range.
You may specify the range explicitly (based on some a-priori info
about the distribution) or you may let the object collect the first
few observations and determine the range from them. Methods which let
you specify range settings are part of <tt>cDensityEstBase</tt>.

<p>The following member functions exist for setting up the range
and to specify how many observations should be used for
automatically determining the range.

<pre>
setRange(lower,upper);
setRangeAuto(num_firstvals, range_ext_factor);
setRangeAutoLower(upper, num_firstvals, range_ext_factor);
setRangeAutoUpper(lower, num, range_ext_factor);
</pre>
<p>
<pre>
setNumFirstVals(num_firstvals);
</pre>

<p>The following example creates a histogram with 20 cells and automatic
range estimation:

<pre>
cDoubleHistogram histogram("histogram", 20);
histogram.setRangeAuto(100,1.5);
</pre>
<p>

<p>Here, 20 is the number of cells (not including the underflow/overflow
cells, see later), and 100 is the number of observations to be
collected before setting up the cells. 1.5 is the range extension
factor. It means that the actual range of the initial observations
will be expanded 1.5 times and this expanded range will be used to lay
out the cells. This method increases the chance that further
observations fall in one of the cells and not outside the histogram
range.

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig12.gif">
    <center><i>Figure: Setting up a histogram's range</i></center>
  </DIV>

<p>
After the cells have been set up, collecting can go on.

<p>The <tt>transformed()</tt> function returns <EM>true</EM> when the cells have
already been set up. You can force range estimation and setting
up the cells by calling the <tt>transform()</tt> function.

<p>The observations that fall outside the histogram range will be counted
as underflows and overflows. The number of underflows and overflows
are returned by the <tt>underflowCell()</tt> and <tt>overflowCell()</tt>
member functions.

<p>
<DIV ALIGN=center>
  <img src="figures/usmanFig13.gif">
  <center><i>Figure: Histogram structure after setting up the cells</i></center>
</DIV>

<p>
You create a $P^2$ object by specifying the number of cells:

<pre>
cPSquare psquare("interarrival-times", 20);
</pre>
<p>
Afterwards, a <tt>cPSquare</tt> can be used with the same member functions
as a histogram.

<p>
<br><P class="subheading">Getting histogram data</P>

<p>
There are three member functions to explicitly return cell boundaries
and the number of observations is each cell. <tt>cells()</tt> returns
the number of cells, <tt>basepoint(int k)</tt> returns the
<EM>k</EM>th base point, <tt>cell(int k)</tt> returns the
number of observations in cell <EM>k</EM>, and
<tt>cellPDF(int k)</tt> returns the PDF value in the cell
(i.e. between <tt>basepoint(k)</tt> and
<tt>basepoint(k+1)</tt>).  These functions work for all
histogram types, plus <tt>cPSquare</tt> and <tt>cKSplit</tt>.

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig14.gif">
    <center><i>Figure: base points and cells</i></center>
  </DIV>

<p>
An example:

<pre>
long n = histogram.samples();
for (int i=0; i&lt;histogram.cells(); i++)
{
  double cellWidth = histogram.basepoint(i+1)-histogram.basepoint(i);
  int count = histogram.cell(i);
  double pdf = histogram.cellPDF(i);
  //...
}
</pre>
<p>

<p>The <tt>pdf(x)</tt> and <tt>cdf(x)</tt> member functions
return the value of the probability density function and the cumulated
density function at a given <EM>x</EM>, respectively.

<p>
<br><P class="subheading">Random number generation from distributions</P>

<p>
The <tt>random()</tt> member function generates random
numbers from the distribution stored by the
object:

<pre>
double rnd = histogram.random();
</pre>
<p>

<p><tt>cStdDev</tt> assumes normal distribution.

<p>You can also wrap the distribution object in a <tt>cPar</tt>:

<pre>
cPar rnd_par("rnd_par");
rnd_par.setDoubleValue(&histogram);
</pre>
<p>

<p>The <tt>cPar</tt> object stores the pointer to the histogram (or $P^2$ object),
and whenever it is asked for the value, calls the histogram object's <tt>random()</tt>
function:

<pre>
double rnd = (double)rnd_par; // random number from the cPSquare
</pre>
<p>
<br><P class="subheading">Storing/loading distributions</P>

<p>
The statistic classes have <tt>loadFromFile()</tt> member functions
that read the histogram data from a text file. If you need a custom
distribution that cannot be written (or it
is inefficient) as a C function, you can describe it in histogram form
stored in a text file, and use a histogram object with
<tt>loadFromFile()</tt>.

<p>You can also use <tt>saveToFile()</tt>that writes out the distribution
collected by the histogram object:

<pre>
FILE *f = fopen("histogram.dat","w");
histogram.saveToFile( f ); // save the distribution
fclose( f );

FILE *f2 = fopen("histogram.dat","r");}
cDoubleHistogram hist2("Hist-from-file");
hist2.loadFromFile( f2 ); // load stored distribution
fclose( f2 );
</pre>
<p>

<p><br><P class="subheading">Histogram with custom cells</P>

<p>
The <tt>cVarHistogram</tt> class can be used to create
histograms with arbitrary (non-equidistant) cells.
It can operate in two modes:

<p><UL>
  <li><strong></strong> <EM>manual</EM>, where you specify cell boundaries explicitly
     before starting collecting
  <li><strong></strong> <EM>automatic</EM>, where <tt>transform()</tt> will set up the cells
     after collecting a certain number of initial observations. The cells
     will be set up so that as far as possible, an equal number of observations
     fall into each cell (equi-probable cells).
</UL>

<p>Modes are selected with a <EM>transform-type</EM> parameter:
<UL>
  <li><strong></strong><tt>HIST_TR_NO_TRANSFORM</tt>: no transformation; uses bin boundaries
    previously defined by <tt>addBinBound()</tt>
  <li><strong></strong><tt>HIST_TR_AUTO_EPC_DBL</tt>: automatically creates equiprobable cells
  <li><strong></strong><tt>HIST_TR_AUTO_EPC_INT</tt>: like the above, but for integers
</UL>

<p>Creating an object:

<pre>
cVarHistogram(const char *s=NULL,
              int numcells=11,
              int transformtype=HIST_TR_AUTO_EPC_DBL);
</pre>
<p>
Manually adding a cell boundary:

<pre>
void addBinBound(double x);
</pre>
<p>
Rangemin and rangemax is chosen after collecting the
<SAMP>num_firstvals</SAMP> initial observations. One cannot add cell
boundaries when the histogram has already been transformed.

<p>

<p>

<p><H3><A NAME="sec261"/>7.8.3. The k-split algorithm</H3>

<p><br><P class="subheading">Purpose</P>

<p>
The <EM>k</EM>-split algorithm is an on-line distribution
estimation method.  It was
designed for on-line result collection in simulation programs.  The
method was proposed by Varga and Fakhamzadeh in 1997. The primary
advantage of <EM>k</EM>-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size. The
<EM>k</EM>-split algorithm can be extended to multi-dimensional
distributions, but here we deal
with the one-dimensional version only.

<p>
<br><P class="subheading">The algorithm</P>

<p>
The <EM>k-split</EM> algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out with
a histogram range $[x_lo, x_hi)$ with $k$ equal-sized histogram
cells with observation counts $n_1,n_2, .. n_k$.  Each collected
observation increments the corresponding observation count. When an
observation count $n_i$ reaches a <EM>split threshold</EM>, the cell
is split into $k$ smaller, equal-sized cells with observation counts
$n_i,1, n_i,2, .. n_i,k$ initialized to zero. The $n_i$
observation count is remembered and is called the <EM>mother
  observation count</EM> to the newly created cells. Further observations
may cause cells to be split further (e.g. $n_i,1,1,...n_i,1,k$
etc.), thus creating a $k$-order tree of observation counts where
leaves contain live counters that are actually incremented by new
observations, and intermediate nodes contain mother observation counts
for their children. If an observation falls outside the histogram
range, the range is extended in a natural manner by inserting new
level(s) at the top of the tree. The fundamental parameter to the
algorithm is the split factor $k$. Low values of $k$, $k=2$ and $k=3$
are to be considered. In this paper we examine only the $k=2$ case.

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig15.gif">
    <center><i>Figure: Illustration of the k-split algorithm, $k=2$. The
      numbers in boxes represent the observation count values</i></center>
  </DIV>

<p>

<p>For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.

<p>
Let $n_...,i$ be the (mother) observation count for a cell,
$s_...,i$ be the total observation count in a cell $n_...,i$ plus
the observation counts in all its sub-, sub-sub-, etc. cells), and
$m_...,i$ the mother observations propagated to the cell. We are
interested in the $&ntilde;_...,i = n_...,i + m_...,i$
estimated amount of observations in the tree nodes, especially in the
leaves. In other words, if we have $&ntilde;_...,i$ estimated
observation amount in a cell, how to divide it to obtain $m_...,i,1,
m_...,i,2 .. m_...,i,k$ that can be propagated to child cells.
Naturally, $m_...,i,1 + m_...,i,2 + .. + m_...,i,k =
&ntilde;_...,i$.

<p>
Two natural distribution methods are even
distribution\indexdistribution!even (when $m_...,i,1 = m_...,i,2
= .. = m_...,i,k$) and proportional
distribution\indexdistribution!proportional (when $m_...,i,1 :
m_...,i,2 : .. : m_...,i,k = s_...,i,1 : s_...,i,2 :
.. : s_...,i,k$). Even distribution is optimal when the
$s_...,i,j$ values are very small, and proportional distribution is
good when the $s_...,i,j$ values are large compared to
$m_...,i,j$. In practice, a linear combination of them seems
appropriate, where $lambda=0$ means even and $lambda=1$ means
proportional distribution:

<p>
<blockquote>
m_..,i,j=(1-lambda )<fontmaroon><em> Unknown LaTeX command </em> \frac </font>&ntilde;_..,i<fontmaroon><em>  </em>  </font>k + lambda &ntilde;_..,i <fontmaroon><em> Unknown LaTeX command </em> \frac </font>s_...,i,j<fontmaroon><em>  </em>  </font>s_..,i, lambda\in[0,1]
</blockquote>

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig16.gif">
    <center><i>Figure: Density estimation from the k-split cell tree. We
      assume $lambda=0$, i.e. we distribute mother observations
      evenly.</i></center>
  </DIV>

<p>
Note that while $n_...,i$ are integers, $m_...,i$ and thus
$&ntilde;_...,i$ are typically real numbers. The histogram estimate
calculated from <EM>k</EM>-split is not exact, because the frequency
counts calculated in the above manner contain a degree of estimation
themselves. This introduces a certain <EM>cell division error</EM>;
the lambda parameter should be selected so that it minimizes that
error. It has been shown that the cell division error can
be reduced to a more-than-acceptable small value.<br>
Strictly speaking, the <EM>k</EM>-split algorithm is semi-online,
because its needs some observations to set up the initial histogram
range.  However, because of the range extension and cell split
capabilities, the algorithm is not very sensitive to the choice of the
initial range, so very few observations are enough for range
estimation (say $N_pre=10$). Thus we can regard <EM>k</EM>-split as
an on-line method.

<p><EM>K</EM>-split can also be used in semi-online mode, when the
algorithm is only used to create an optimal partition from a larger
number of $N_pre$ observations. When the partition has been created,
the observation counts are cleared and the $N_pre$ observations are
fed into <EM>k</EM>-split once again. This way all mother (non-leaf)
observation counts will be zero and the cell division error is
eliminated. It has been shown that the partition created by
<EM>k</EM>-split can be better than both the equi-distant and the
equal-frequency partition.

<p>
OMNeT++ contains an experimental implementation of the <EM>k</EM>-split
algorithm, the <tt>cKSplit</tt> class. Research on <EM>k</EM>-split is
still under way.

<p>
<br><P class="subheading">The cKSplit class</P>

<p>The <tt>cKSplit</tt> class is an implementation of the <EM>k-split</EM> method.
Member functions:


<pre>
void setCritFunc(KSplitCritFunc _critfunc, double *_critdata);
void setDivFunc(KSplitDivFunc \_divfunc, double *\_divdata);
void rangeExtension( bool enabled );
</pre>
<p>

<pre>
int treeDepth();
int treeDepth(sGrid& grid);
</pre>
<p>
<pre>
double realCellValue(sGrid& grid, int cell);
void printGrids();
</pre>

<pre>
sGrid& grid(int k);
sGrid& rootGrid();
</pre>
<p>
<pre>
struct sGrid
{
  int parent;   // index of parent grid
  int reldepth; // depth = (reldepth - rootgrid's reldepth)
  long total;   // sum of cells & all subgrids (includes `mother')
  int mother;   // observations `inherited' from mother cell
  int cells[K]; // cell values
};
</pre>

<p>

<p><H3><A NAME="sec262"/>7.8.4. Transient detection and result accuracy</H3>

<p>In many simulations, only the steady state performance (i.e.
the performance after the system has reached a stable state)
is of interest. The initial part of the simulation is called
the transient period. After the model has entered steady state,
simulation must proceed until enough statistical data have been
collected to compute result with the required accuracy.

<p>
Detection of the end of the transient period and a certain result
accuracy is supported by OMNeT++. The user can attach transient
detection and result accuracy objects to a result object (<tt>cStatistic</tt>'s
descendants). The transient detection and result accuracy objects will
do the specific algorithms on the data fed into the result object and
tell if the transient period is over or the result accuracy has been
reached.

<p>The base classes for classes implementing specific transient
detection and result accuracy detection algorithms are:
<UL>
<li><strong></strong><tt>cTransientDetection</tt>: base class for transient detection
<li><strong></strong><tt>cAccuracyDetection</tt>: base class for result accuracy detection
</UL>

<p>
<br><P class="subheading">Basic usage</P>


Attaching detection objects to a <tt>cStatistic</tt> and getting pointers
to the attached objects:

<pre>
addTransientDetection(cTransientDetection *object);
addAccuracyDetection(cAccuracyDetection *object);
cTransientDetection *transientDetectionObject();
cAccuracyDetection *accuracyDetectionObject();
</pre>
<p>

<p>Detecting the end of the period:
<UL>
<li><strong></strong>polling the <tt>detect()</tt> function of the object
<li><strong></strong>installing a post-detect function
</UL>

<p>
<br><P class="subheading">Transient detection</P>

<p>
Currently one transient detection algorithm
is implemented, i.e.  there's one class derived from
<tt>cTransientDetection</tt>. The <tt>cTDExpandingWindows</tt> class
uses the sliding window approach with two windows, and checks the
difference of the two averages to see if the transient period is over.

<pre>
void setParameters(int reps=3,
                   int minw=4,
                   double wind=1.3,
                   double acc=0.3);
</pre>
<p>
<br><P class="subheading">Accuracy detection</P>

<p>
Currently one accuracy detection algorithm
is implemented, i.e.  there's one class derived from
<tt>cAccuracyDetection</tt>. The algorithm implemented in the
<tt>cADByStddev</tt> class is: divide the standard deviation by the
square of the number of values and check if this is small enough.

<pre>
void setParameters(double acc=0.1,
                   int reps=3);
</pre>
<p>

<p>

<p><hr><H2><A NAME="sec263"/>7.9. Recording simulation results</H2>

<p><H3><A NAME="sec264"/>7.9.1. Output vectors: cOutVector</H3>
<a name="sec:ch-sim-lib:cOutVector"></a>

<p>Objects of type <tt>cOutVector</tt> are responsible for writing time series
data (referred to as <EM>output vectors</EM>) to a file. The <tt>record()</tt>
member is used to output a value (or a value pair) with a timestamp.

<p>It can be used like this:

<pre>
cOutVector resp_v("response time");

while (...)
{
  double response_time;
  //...
  resp_v.record( response_time );
  //...
}
</pre>
<p>

<p>All <tt>cOutVector</tt> objects write to the same, common file. The
file is textual; each <tt>record()</tt> call generates a line in the
file. The output file can be processed using Plove, but otherwise its
simple format allows it to be easily processed with <tt>sed</tt>,
<tt>awk</tt>, <tt>grep</tt> and the like, and it can be imported by
spreadsheet programs.  The file format is described later in this
manual (in the section about simulation execution).

<p>You can disable the output vector or specify a
simulation time interval for recording either from the ini file or
directly from program code:

<pre>
cOutVector v("v");
simtime_t t =...;

v.enable();
v.disable();
v.setStartTime( t );
v.setStopTime( t+100.0 );
</pre>
<p>

<p>If the output vector object is disabled or the simulation time is
outside the specified interval, <tt>record()</tt> doesn't write
anything to the output file. However, if you have a Tkenv inspector
window open for the output vector object,
the values will be displayed there, regardless of the state of the
output vector object.

<p>

<p>

<p><H3><A NAME="sec265"/>7.9.2. Output scalars</H3>

<p>While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars are supposed to record a single
value per simulation run. You can use outputs scalars
<UL>
<li><strong></strong>to record summary data at the end of the simulation run
<li><strong></strong>to do several runs with different parameter settings/random seed
    and determine the dependence of some measures on the parameter
    settings. For example, multiple runs and output scalars are the
    way to produce <EM>Throughput vs. Offered Load</EM> plots.
</UL>

<p>Output scalars are recorded with the <tt>recordScalar()</tt> member
function.  It is overloaded, you can use it to write doubles and
strings (const char *):

<pre>
double avg_throughput = total_bits / simTime();
recordScalar("Average throughput", avg_throughput);
</pre>
<p>
You can record whole statistics objects by calling <tt>recordStats()</tt>:

<pre>
cStdDev *eedstats = new cStdDev;
...
recordStats("End-to-end Statistics", eedstats);
</pre>
<p>
Calls to <tt>recordScalar()</tt> and <tt>recordStats()</tt> are usually
placed in the redefined <tt>finish()</tt> member function of a
simple module.

<p>The above calls write into the (textual) output scalar file.  The
output scalar file is preserved across simulation runs (unlike the
output vector file is, scalar files are not deleted at the beginning
of each run). Data are always appended at the end of the file, and
output from different simulation runs are separated by special lines.

<p>

<p>
<hr><H2><A NAME="sec266"/>7.10. Tracing and debugging aids</H2>

<p><H3><A NAME="sec267"/>7.10.1. Displaying information about module activity</H3>

<p>You can have simple modules print textual output for
debugging purposes.

<p>The global object called <tt>ev</tt> represents the user interface of the
simulation program. You can send data to <tt>ev</tt> using the
C++-style I/O operator (<tt>&lt;</tt><tt>&lt;</tt>).

<pre>
ev &lt;&lt; "started\n";
ev &lt;&lt; "about to send message #" &lt;&lt;  i &lt;&lt; endl;
ev &lt;&lt; "queue full, discarding packet\n";
</pre>
<p>
The more traditional-looking but functionally equivalent
<tt>ev.printf()</tt> form also exists.

<pre>
ev.printf("%d packets dropped out of %d\n", drops, total);
</pre>
<p>
The exact way messages are displayed to the user depends on the user
interface. In the command-line user interface (Cmdenv),
it is simply dumped to the standard output. (This output can also be
disabled from the ini file so that it doesn't slow down simulation
when it is not needed.) In windowing user interfaces
(Tkenv), each simple module can have
a separate text output window.

<p>The above means that you should <EM>not</EM> use <tt>printf()</tt>,
<tt>cout</tt> <tt>&lt;&lt;</tt> and the like because with Tkenv, their output
would appear in the terminal window behind the graphical window of the
simulation application.

<p>
<H3><A NAME="sec268"/>7.10.2. Watches</H3>

<p>You may want some of your int, long, double, char, etc. variables to
be inspect-able in Tkenv and to be output into the snapshot
file. In this case, you can create
<tt>cWatch</tt> objects for them with the <tt>WATCH()</tt> macro:

<pre>
int i; WATCH(i);
char c; WATCH(c);
</pre>
<p>
When you open an inspector for the simple module in Tkenv and click
the Objects/Watches tab in it, you'll see your WATCHed variables
and their values there. Tkenv also lets you change the value of a
WATCHed variable.

<p>The <tt>WATCH()</tt> macro expands to a dynamically created <tt>cWatch</tt>
object.  The object remembers the address and type of your variable.
The macro expands to something like:

<pre>
new cWatch("i",i);
</pre>
<p>

<p>You can also make a <SAMP>WATCH</SAMP> for pointers of type <tt>char*</tt> or
<tt>cObject*</tt>, but this may cause a segmentation fault if
the pointer does not point to a valid location when Tkenv or
<tt>snapshot()</tt> wants to use it.

<p>You can also set watches for variables that are members of the
module class or for structure fields:

<pre>
WATCH( lapbconfig.timeout );
</pre>
<p>

<p><br><P class="subheading">Placement of WATCHes</P>

<p>
Be careful not to execute a <tt>WATCH()</tt> statement more than once,
as each call would create a new <tt>cWatch</tt> object! If you use
<tt>activity()</tt>, the best place for WATCHes is the top of the
<tt>activity()</tt> function.  If you use <tt>handleMessage()</tt>,
place the <tt>WATCH()</tt> statement into <tt>initialize()</tt>.
<tt>WATCH()</tt> creates a dynamic <tt>cWatch</tt> object, and we do
not want to create a new object each time <tt>handleMessage()</tt> is
called.

<p>

<p><H3><A NAME="sec269"/>7.10.3. Snapshots</H3>
<a name="sec:ch-sim-lib:snapshots"></a>

<p>The <tt>snapshot()</tt> function outputs textual information about all
or selected objects of the simulation (including the objects created
in module functions by the user) into the snapshot file.

<pre>
bool snapshot(cObject *obj = &simulation, const char *label = NULL);
</pre>
<p>

<p>The function can be called from module functions, like this:

<pre>
snapshot();     // dump the whole network
snapshot(this); // dump this simple module and all its objects
snapshot(&simulation.msgQueue); // dump future events
</pre>
<p>
This will append snapshot information to the end of the snapshot file.
(The snapshot file name has an extension of <tt>.sna</tt>, default is
<tt>omnetpp.sna</tt>. Actual file name can be set in the
config file.)

<p>
The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <tt>snapshot()</tt>, one can trace
how the values of variables, objects changed over the simulation.
The arguments: label is a string that will appear in the output
file; obj is the object whose inside is of interest. By default,
the whole simulation (all modules etc) will be written out.

<p>If you run the simulation with Tkenv, you can also create a snapshot
from the menu.

<p>
An example of a snapshot file:

<p><pre>
================================================
|| SNAPSHOT ||
================================================
| Of object:    `simulation'
| Label:        `three-station token ring'
| Sim. time:    0.0576872457 ( 57ms)
| Network:      `token'
| Run no.       1
| Started at:   Mar 13, 1997, 14:23:38
| Time:         Mar 13, 1997, 14:27:10
| Elapsed:      5 sec
| Initiated by: operator
================================================

<p>
(cSimulation) `simulation' begin
  Modules in the network:
    `token' #1 (TokenRing)
      `comp[0]' #2 (Computer)
        `mac' #3 (TokenRingMAC)
        `gen' #4 (Generator)
        `sink' #5 (Sink)
      `comp[1]' #6 (Computer)
        `mac' #7 (TokenRingMAC)
        `gen' #8 (Generator)
        `sink' #9 (Sink)
      `comp[2]' #10 (Computer)
        `mac' #11 (TokenRingMAC)
        `gen' #12 (Generator)
        `sink' #13 (Sink)
end

<p>(cCompoundModule) `token' begin
  #1 params     (cArray) (n=6)
  #1 gates      (cArray) (empty)
  comp[0]          (cCompoundModule,#2)
  comp[1]          (cCompoundModule,#6)
  comp[2]          (cCompoundModule,#10)
end

<p>(cArray) `token.parameters' begin
  num_stations (cModulePar) 3 (L)
  num_messages (cModulePar) 10000 (L)
  ia_time      (cModulePar) truncnormal(0.005,0.003) (F)
  THT          (cModulePar) 0.01 (D)
  data_rate    (cModulePar) 4000000 (L)
  cable_delay  (cModulePar) 1e-06 (D)
end

<p>(cModulePar) `token.num_stations' begin
  Type: L
  Value: 3
end

<p><EM>[...token.num_messages omitted...]</EM>

<p>(cModulePar) `token.ia_time' begin
  Type:  F
  Value: truncnormal(0.005,0.003)
end

<p><EM>[...rest of parameters &amp; gates stuff deleted from here...]</EM>

<p>(cCompoundModule) `token.comp[0]' begin
  parameters    (cArray) (empty)
  gates         (cArray) (n=2)
  mac           (TokenRingMAC,#3)
  gen           (Generator,#4)
  sink          (Sink,#5)
end

<p>(cArray) `token.comp[0].parameters' begin
end

<p>(cArray) `token.comp[0].gates' begin
  in            (cGate)  &lt;- comp[2].out
  out           (cGate)  -&gt; D -&gt; comp[1].in
end

<p>(cGate) `token.comp[0].in' begin
  type:  input
  inside connection:  token.comp[0].mac.phy_in
  outside connection: token.comp[2].out
  delay: -
  error: -
  data rate: -
end

<p>(cGate) `token.comp[0].out' begin
  type: output
  inside connection: token.comp[0].mac.phy_out
  outside connection: token.comp[1].in
  delay: (cPar) 1e-06 (D)
  error: -
  data rate: -
end

<p>(TokenRingMAC) `token.comp[0].mac' begin
  parameters    (cArray) (n=2)
  gates         (cArray) (n=4)
  local-objects (cHead)
  class-data-members (cHead)
end

<p><EM>[...comp[0].mac parameters stuff deleted from here...]</EM>

<p>(cArray) `token.comp[0].mac.gates' begin
  phy_in        (cGate)  &lt;- &lt;parent&gt;.in
  from_gen      (cGate)  &lt;- gen.out
  phy_out       (cGate)  -&gt; &lt;parent&gt;.out
  to_sink       (cGate)  -&gt; sink.in
end

<p><EM>[...detailed gate list deleted from here...]</EM>

<p>(cHead) `token.comp[0].mac.local-objects' begin
  sendqueue-length (cOutVector) (single)
  send-queue   (cQueue) (n=11)
end

<p>(cOutVector) `token.comp[0].mac.local-objects.sendqueue-length' begin
end

<p>(cQueue) `token.comp[0].mac.local-objects.send-queue' begin
  0-&gt;1         (cMessage) Tarr=0.0158105774 ( 15ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0163553310 ( 16ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0205628236 ( 20ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0242203591 ( 24ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0300994268 ( 30ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0364005251 ( 36ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0370745702 ( 37ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0387984129 ( 38ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0457462493 ( 45ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0487308918 ( 48ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0514466766 ( 51ms) Src=#4 Dest=#3
end

<p>(cMessage) `token.comp[0].mac.local-objects.send-queue.0-&gt;1' begin
  #4 -&gt; #3
  sent:         0.0158105774 ( 15ms)
  arrived:      0.0158105774 ( 15ms)
  length:       33536
  kind:         0
  priority:     0
  error:        FALSE
  time stamp:   0.0000000 ( 0.00s)
  parameter list:
    dest        (cPar) 1 (L)
    source      (cPar) 0 (L)
    gentime     (cPar) 0.0158106 (D)
end

<p>(cArray) `token.comp[0].mac.local-objects.send-queue.0-&gt;1.par-vector' begin
  dest          (cPar) 1 (L)
  source        (cPar) 0 (L)
  gentime       (cPar) 0.0158106 (D)
end

<p><EM>[...message parameters and the other messages' stuff deleted...]</EM>

<p>(cHead) `token.comp[0].mac.class-data-members' begin
end

<p><EM>[...comp[0].gen and comp[0].sink stuff deleted from here...]</EM>
<EM>[...whole comp[1] and comp[2] stuff deleted from here...]</EM>

<p>(cMessageHeap) `simulation.message-queue' begin
  1-&gt;0         (cMessage) Tarr=0.0576872457 ( 57ms) Src=#8 Dest=#7
                (cMessage) Tarr=0.0577201630 ( 57ms) Mod=#8 (selfmsg)
                (cMessage) Tarr=0.0585677054 ( 58ms) Mod=#4 (selfmsg)
                (cMessage) Tarr=0.0594939072 ( 59ms) Mod=#12 (selfmsg)
                (cMessage) Tarr=0.0601010000 ( 60ms) Mod=#7 (selfmsg)
  1-&gt;2         (cMessage) Tarr=0.0601020000 ( 60ms) Src=#11 Dest=#13
end

<p><EM>[...detailed list of message queue contents deleted from here...]</EM>
</pre>

<p>

<p>

<p><H3><A NAME="sec270"/>7.10.4. Breakpoints</H3>

<p><STRONG>With activity() only!</STRONG> In those user interfaces which support
debugging, breakpoints stop execution and the state of the simulation
can be examined.

<p>You can set a breakpoint inserting a
<tt>breakpoint()</tt> call into the source:

<pre>
for(;;)
{
  cMessage *msg = receive();
  breakpoint("before-processing");
  breakpoint("before-send");
  send( reply_msg, "out" );
  //..
}
</pre>
<p>

<p>In user interfaces that do not support debugging, <tt>breakpoint()</tt>
calls are simply ignored.

<p>

<p>

<p><H3><A NAME="sec271"/>7.10.5. Disabling warnings</H3>

<p>Some container classes and functions suspend the simulation and issue
warning messages in potentially bogus/dangerous situations, for
example when an object is not found and NULL pointer/reference is
about to be returned. Very often this is useful, but sometimes it is
more trouble. You can turn warnings on/off from the ini file
(warnings=yes/no).

<p>
It is a good practice to leave warnings enabled, and
temporarily disable warnings in places where OMNeT++ would normally
issue warnings but you know the code is correct. This is done in the
following way:

<pre>
bool w = simulation.warnings();
simulation.setWarnings( false );
...
... // critical code
...
simulation.setWarnings( w );
</pre>
<p>

<p>

<p>
<H3><A NAME="sec272"/>7.10.6. Getting coroutine stack usage</H3>

<p>It is important to choose the correct stack size for
modules.  If the stack is
too large, it unnecessarily consumes memory; if it is too small, stack
violation occurs.

<p>From the Feb99 release, OMNeT++ contains a mechanism that detects stack
overflows. It checks the intactness of a
predefined byte pattern (<SAMP>0xdeadbeef</SAMP>) at the stack boundary,
and reports ``stack violation'' if it was
overwritten. The mechanism usually works fine, but occasionally it can
be fooled by large - and not fully used - local variables (e.g. char
buffer[256]): if the byte pattern happens to fall in the middle of
such a local variable, it may be preserved intact and OMNeT++ does not
detect the stack violation.

<p>To be able to make a good guess about stack size, you can use
the <tt>stackUsage()</tt> call which tells you how much stack the module
actually uses. It is most conveniently called from <tt>finish()</tt>:

<pre>
void FooModule::finish()
{
  ev &lt;&lt; stackUsage() &lt;&lt;  "bytes of stack used\n";
}
</pre>
<p>

<p>The value includes the extra stack added by the user interface library
(see <EM>extraStackforEnvir</EM> in
envir/omnetapp.h), which is currently 8K for Cmdenv and at least 16K
for Tkenv.
  <br><ul><font size=-1>[The actual value is dependent on the operating
  system, e.g. SUN Solaris needs more space.]</font></ul>

<p><tt>stackUsage()</tt>also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the above
effect with local variables.

<p>
<hr><H2><A NAME="sec273"/>7.11. Changing the network graphics at run-time</H2>

<p><H3><A NAME="sec274"/>7.11.1. Setting display strings</H3>

<p>Sometimes it is useful to change the appearance or position of
some components in the network graphics, such as the color of the
modules, color/width of connection arrows,
position of a submodule, etc.

<p>The appearance of nodes and connections is determined by the display
strings. Display strings (e.g. <tt>"p=100,10;i=pc"</tt>)
are initially taken from the NED description.
You can change the display string of a module or connection arrow
at run-time by calling methods named <tt>setDisplayString()</tt>.
The <tt>cDisplayStringParser</tt> class (discussed in the following sections)
might be useful for manipulating the display string.

<p>Setting the module's appearance when it is displayed as a component
within a compound module:

<pre>
setDisplayString("p=100,100;b=60,30,rect;o=red,black,3", true);
</pre>
<p>
Setting appearance of a compound module when it's displayed as a
bounding box for its submodules:

<pre>
parentModule()-&gt;setDisplayStringAsParent("p=100.....", true);
</pre>
<p>
The display string of a connection arrow
is stored in its source gate, so you'll need to write something
like this:

<pre>
gate("out")-&gt;setDisplayString("o=yellow,3");
</pre>
<p>
The <tt>setDisplayString()</tt> methods additionally take a bool
argument called <tt>immediate</tt>. It specifies whether the display
string change should take effect immediately, or only after processing
the current event (the default is <EM>immediate=true</EM>). If several
display string changes are going to be done within one event, then
<EM>immediate=false</EM> is useful because it reduces the number of
necessary redraws. <EM>Immediate=false</EM> also uses less stack.  But
its drawback is that a <tt>setDisplayString()</tt> followed by a
<tt>send()</tt> would actually be displayed in reverse order (message
animation first), because message animations are performed immediately
(actually within the <tt>send()</tt> call).

<p>
<H3><A NAME="sec275"/>7.11.2. The cDisplayStringParser class</H3>

<p>The <tt>cDisplayStringParser</tt> utility class lets you parse and
manipulate display strings.

<p>As far as <tt>cDisplayStringParser</tt> is concerned, a display string
(e.g. <tt>"p=100,125;i=cloud"</tt>) is a string that consist of several
<EM>tags</EM> separated by semicolons, and each tag has a <EM>name</EM>
and after an equal sign, zero or more <EM>arguments</EM> separated by commas.

<p>The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags,
removing tags or replacing arguments. The internal storage method allows
very fast operation; it will generally be faster than direct string manipulation.
The class doesn't try to interpret the display string in any way, nor does
it know the meaning of the different tags; it merely parses the string
as data elements separated by semicolons, equal signs and commas.

<p>An example:

<p><pre>
cDisplayStringParser dispstr("a=1,2;p=alpha,,3");
dispstr.insertTag("x");
dispstr.setTagArg("x",0,"joe");
dispstr.setTagArg("x",2,"jim");
dispstr.setTagArg("p",0,"beta");
ev &lt;&lt; dispstr.getString();  // result: "x=joe,,jim;a=1,2;p=beta,,3"
</pre>

<p>

<p>

<p><hr><H2><A NAME="sec276"/>7.12. Deriving new classes</H2>
<a name="sec:ch-sim-lib:deriving-new-classes"></a>

<p><H3><A NAME="sec277"/>7.12.1. cObject or not?</H3>

<p>If you plan to implement a completely new class (as opposed to
subclassing something already present in OMNeT++), you have
to ask yourself whether you want the new class to be based
on <tt>cObject</tt> or not.
Note that we're <EM>not</EM> saying you should always
subclass from <tt>cObject</tt>.
Both solutions have advantages and disadvantages which you
have to consider individually for each class.

<p><tt>cObject</tt> already carries (or provides framework for)
significant functionality that are either important for
your particular purpose or not. Subclassing <tt>cObject</tt>
generally means you have more code to write (as you <EM>have to</EM>
redefine certain virtual functions and adopt to conventions)
and your class will be a bit more heavy-weight.
In turn, it will integrate into OMNeT++ better, for example
it will be more visible in Tkenv and can be automatically
garbage-collected (this will be discussed later). If you
need to store your objects in OMNeT++ objects like <tt>cQueue</tt>,
or you'll want to store OMNeT++ classes in your object,
then you <EM>must</EM> subclass from <tt>cObject</tt>.
  <br><ul><font size=-1>[For simplicity, in the these sections ``OMNeT++ object''
  should be understood as ``object of a class subclassed from
  <tt>cObject</tt>'']</font></ul>

<p>The most significant features <tt>cObject</tt> has is
the name string (which has to be stored somewhere, so it has
its overhead) and ownership management (see section
<a href="#sec:ch-sim-lib:ownership-management">[click]</a>) which
also has the advantages but also some costs.

<p>As a general rule, small <tt>struct</tt>-like classes like <tt>IPAddress</tt>,
<tt>MACAddress</tt>, <tt>RoutingTableEntry</tt>, <tt>TCPConnectionDescriptor</tt>, etc.
are better <EM>not</EM> sublassed from <tt>cObject</tt>.
On the other hand, if you want to store your objects in OMNeT++ objects
like <tt>cQueue</tt>, or you'll want to store OMNeT++ classes in your object,
then you <EM>must</EM> subclass from <tt>cObject</tt>.
If your class fits neither category, you'll need to
see if <tt>cObject</tt> brings any benefit for you, and
decide accordingly.

<p>
<H3><A NAME="sec278"/>7.12.2. cObject virtual methods</H3>

<p>Most classes in the simulation class library are descendants of
<tt>cObject</tt>. If you want to derive a new class from
<tt>cObject</tt> or a <tt>cObject</tt> descendant, you must redefine
some member functions so that objects of the new type can fully
co-operate with other parts of the simulation system. A more or less
complete list of these functions is presented here. Do not be
embarrassed at the length of the list: most functions are not
absolutely necessary to implement. For example, you do not need to
redefine <tt>forEach()</tt> unless your class is a container class.

<p>The following methods <STRONG>must</STRONG> be implemented:

<p><UL>
  <li><strong></strong><EM>Constructor</EM>. At least two constructors should be provided:
        one that takes the object name string as <tt>const char *</tt>
        (recommended by convention), and another one with no arguments
        (must be present). The two are usually implemented as a single
        method, with <tt>NULL</tt> as default name string.
  <li><strong></strong><EM>Copy constructor</EM>, which must have the following signature
        for a class <tt>X</tt>: <tt>X(const X&amp;)</tt>. The copy constructor is used
        whenever an object is duplicated. The usual implementation of
        the copy constructor is to initialize the base class with the
        name (<tt>name()</tt>) of the other object it receives, then call the
        assignment operator (see below).
  <li><strong></strong><EM>Destructor</EM>. Any good-tempered class has a destructor.
  <li><strong></strong><EM>Duplication function,</EM> <tt>cObject *dup() const</tt>.
        It should create and return an exact duplicate of the object.
        It is usually a one-line function, implemented with the help
        of the <tt>new</tt> operator and the copy constructor.
  <li><strong></strong><EM>Assigment operator</EM>, that is, <tt>X&amp; operator=(const X&amp;)</tt>
        for a class <tt>X</tt>. It should copy the contents of the other
        object into this one, except the name string. See later what to do
        if the object contains pointers to other objects.
</UL>

<p>The following function <STRONG>should</STRONG> be implemented if your class contains
via pointers or as data member) other object subclassed from <tt>cObject</tt>.

<p><UL>
  <li><strong></strong><EM>Iteration function,</EM> <tt>void forEach(ForeachFunc f)</tt>.
        The implementation should call the function passed
        for each object it contains via pointer or
        as data member; see the API Reference on <tt>cObject</tt> on how to
        implement <tt>foreach()</tt>. <tt>foreach()</tt> is used by Tkenv and
        <tt>snapshot()</tt> to navigate, search or display the object tree.
</UL>

<p>The following methods are <STRONG>recommended</STRONG> to implement:

<p><UL>
  <li><strong></strong><EM>Object info,</EM> <tt>void info(char *)</tt>. The <tt>info()</tt> function
        should print a one-line info about object contents into the given
        buffer - usually the class name, the object name, important state variables, etc.
        This is used when Tkenv displays list of objects (in the object tree
        or in listboxes). The length of the info should not exceed 500 chars.
  <li><strong></strong><EM>Detailed object info,</EM> <tt>void writeContents(ostream&amp;)</tt>.
        It should write a detailed multi-line report about the object contents
        into the stream provided. This is currently only used by <tt>snapshot()</tt>.
</UL>



<p>
<H3><A NAME="sec279"/>7.12.3. Class registration</H3>

<p>You should also use the <tt>Register_Class()</tt> macro to register the
new class. It is used by the <tt>createOne()</tt> function.

<p>

<p><H3><A NAME="sec280"/>7.12.4. Details</H3>

<p>We'll go through the details using an example. We create a new
class <tt>NewClass</tt>, redefine all above mentioned <tt>cObject</tt>
member functions, and explain the conventions, rules and tips
associated with them.
To demonstrate as much as possible, the class will contain
an <tt>int</tt> data member, dynamically allocated non-<tt>cObject</tt> data
(an array of <tt>double</tt>s),
an OMNeT++ object as data member (a <tt>cQueue</tt>), and
a dynamically allocated OMNeT++ object (a <tt>cMessage</tt>).

<p>The class declaration is the following. It contains the declarations
of all methods discussed in the previous section.

<pre>
//
// file: newclass.h
//
#include &lt;omnetpp.h&gt;

class NewClass : public cObject
{
  protected:
    int data;
    double *array;
    cQueue queue;
    cMessage *msg;
    ...
  public:
    NewClass(const char *name=NULL, int d=0);
    NewClass(const NewClass& other);
    virtual ~NewClass();
    virtual cObject *dup() const;
    NewClass& operator=(const NewClass& other);

    virtual void foreach(ForeachFunc f);

    virtual void info(char *buf);
    virtual void writeContents(ostream& os);
    ...
};
</pre>
<p>
We'll discuss the implementation method by method.
Here's the top of the <tt>.cc</tt> file:

<pre>
//
// file: newclass.cc
//
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include "newclass.h"

Register_Class( NewClass );


NewClass::NewClass(const char *name, int d) : cObject(name)
{
    data = d;
    array = new double[10];
    take(&queue);
    msg = NULL;
}
</pre>
<p>
The constructor (above) calls the base class constructor with
the name of the object, then initializes its own data members.
You need to call <tt>take()</tt> for <tt>cObject</tt>-based data members.

<p>
<pre>
NewClass::NewClass(const NewClass& other) : cObject(other.name())
{
    array = new double[10];
    msg = NULL;
    take(&queue);
    operator=(other);
}
</pre>

<p>The copy constructor relies on the assignment operator. Because
by convention the assignment operator does not copy the
name member, it is passed here to the base class constructor.
(Alternatively, we could have written <tt>setName(other.name())</tt>
into the function body.)

<p>Note that pointer members have to be initialized (to <tt>NULL</tt> or to an
allocated object/memory) before calling the assignment operator,
to avoid crashes.

<p>You need to call <tt>take()</tt> for <tt>cObject</tt>-based data members.

<pre>
NewClass::~NewClass()
{
    delete [] array;
    if (msg-&gt;owner()==this)
        delete msg;
}
</pre>
<p>
The destructor should delete all data structures the object allocated.
<tt>cObject</tt>-based objects should <EM>only</EM> be deleted if they
are owned by the object - details will be covered in section
<a href="#sec:ch-sim-lib:ownership-management">[click]</a>.

<pre>
cObject *NewClass::dup() const
{
    return new NewClass(*this);
}
</pre>
<p>
The <tt>dup()</tt> functions is usually just one line, like the one above.

<pre>
NewClass& NewClass::operator=(const NewClass& other)
{
    if (&other==this)
        return *this;
    cObject::operator=(other);

    data = other.data;

    for (int i=0; i&lt;10; i++)
        array[i] = other.array[i];

    queue = other.queue;
    queue.setName(other.queue.name());

    if (msg && msg-&gt;owner()==this)
        delete msg;
    if (other.msg && other.msg-&gt;owner()==const_cast&lt;cMessage*&gt;(&other))
        take(msg = (cMessage *)other.msg-&gt;dup());
    else
        msg = other.msg;
    return *this;
}
</pre>
<p>
Complexity associated with copying and duplicating the object
is centralized in the assignment operator, so it is usually
the one that requires the most work from you of all methods
required by <tt>cObject</tt>.

<p>If you do not want to implement object copying and duplication,
you should implement the assigment operator to call
<tt>copyNotSupported()</tt> - it'll throw an exception that
stops the simulation with an error message if this function
is called.

<p>The assignment operator copies contents of the <tt>other</tt> object
to this one, except the name string. It should always return
<tt>*this</tt>.

<p>First, we should make sure we're not trying to copy the object
to itself, because it might be disastrous. If so (that is,
<tt>&amp;other==this</tt>), we return immediately without doing anything.

<p>The base class part is copied via invoking the assignment operator of
the base class.

<p>New data members are copied in the normal C++ way. If the class
contains pointers, you'll most probably want to make a deep copy of
the data where they point, and not just copy the pointer values.

<p>If the class contains pointers to OMNeT++ objects, you need
to take ownership into account. If the contained object is <EM>not owned</EM>
then we assume it is a pointer to an ``external'' object, consequently
we only copy the pointer. If it is <EM>owned</EM>, we duplicate
it and become the owner of the new object. Details of ownership
management will be covered in section <a href="#sec:ch-sim-lib:ownership-management">[click]</a>.

<p>
<pre>
void NewClass::forEach(ForeachFunc f)
{
    if (f(this,true))
    {
        queue-&gt;forEach(f);
        if (msg)
            msg-&gt;forEach(f);
    }
    f(this,false);
}
</pre>

<p>The <tt>foreach()</tt> function should be called for each OMNeT++
member of the class. See the API Reference for more information
of <tt>foreach()</tt>.

<pre>
void NewClass::info(char *buf)
{
    cObject::info(buf);
    sprintf(buf+strlen(buf), " data=%d, array[0]=%g, %s",
            data, array[0], (msg ? "has msg" : "no msg"));
}
</pre>
<p>
Here you should produce a concise, one-line info about the object.
You should try not to exceed 40-80 characters, since the
string will be shown in tooltips and listboxes. The length
of the buffer is 500 bytes, so in any case you should not
exceed that length. You can make use of <tt>cObject</tt>'s
<tt>info()</tt> method that produces the class name and the object name.

<pre>
void NewClass::writeContents(ostream& os)
{
    os &lt;&lt; " data: " &lt;&lt; data &lt;&lt; endl;
    os &lt;&lt; " array: "
    for (int i=0; i&lt;10; i++)
        os &lt;&lt; array[i] &lt;&lt; " ";
    os &lt;&lt; endl;
}
</pre>
<p>
<tt>writecontents()</tt> is expected to write values of all
data members to the stream.  You do not need to include anything
about contained <tt>cObject</tt>-based objects, because they
will be included via <tt>foreach()</tt>.

<p>
See the virtual functions of <tt>cObject</tt> in the class library reference
for more information. The sources of the Sim library (<tt>include/</tt>,
<tt>src/sim/</tt>) can serve as further examples.

<p>

<p>
<hr><H2><A NAME="sec281"/>7.13. Object ownership management</H2>
<a name="sec:ch-sim-lib:ownership-management"></a>

<p>OMNeT++ has a built-in ownership management mechanism which
is used for garbage collection, sanity checks, and as
part of the infrastructure supporting Tkenv inspectors.
It usually works transparently, but it is useful to know
what it does exactly so that it doesn't interfere
with the cleanup code and destructors you write.

<p>If you plan to program small simple modules only, you can probably
safely skip this section. But if your simple module code
is getting more complex and you're getting memory leaks or seemingly
unexplicable segmentation faults because of double deletion of objects,
it is probably time to read the following discussion.

<p>
<H3><A NAME="sec282"/>7.13.1. Ownership tree</H3>

<p>Any <tt>cObject</tt>-based object can be both <EM>owner</EM> of other
objects and can at the same time be <EM>owned</EM> by another object.
For example, a message object (<tt>cMessage</tt>) may reside
in a queue (<tt>cQueue</tt>) and be owned by that queue, while it
may own attached <tt>cPar</tt> objects or another message
(added to it via <tt>encapsulate()</tt>).

<p>From an object you can navigate to its owner by calling the <tt>owner()</tt>
method, defined in <tt>cObject</tt>. The other direction, enumerating the
objects owned can be done via <tt>foreach()</tt> that loops through all
contained objects and checking the owner of each object.

<p>
<H3><A NAME="sec283"/>7.13.2. Purpose</H3>

<p>The purpose of maintaining the ownership tree is threefold:

<p><UL>
    <li><strong></strong>to provide a certain degree of garbage collection (that is,
    automatic deletion of objects that are no longer needed)

<p>    <li><strong></strong>to prevent a certain types of programming errors, namely,
    those associated with wrong ownership handling.

<p>    <li><strong></strong>it provides some ``reflection'' (in the Java sense), which
    enables Tkenv to display which objects are present (and where)
    in the simulation, to find ``lost'' (leaked) objects, etc.
</UL>

<p>Some examples of programming errors that can be caught
by the ownership facility:

<p><UL>
    <li><strong></strong>attempts to send a message while it's still in a queue,
    encapsulated in another message, etc.

<p>    <li><strong></strong>attempts to send/schedule a message while it's still owned
    by the simulation kernel (i.e. scheduled as a future event)

<p>    <li><strong></strong>attempts to send the very same message object to multiple
    destinations at the same time (ie. to all connected modules)
</UL>

<p>The above errors are easy to make in the code, and if not
detected automatically, they could cause random crashes
which are usually very difficult to track down.

<p>Of course, some errors of the same kind still cannot be detected
automatically, like calling member functions of a message object
which has been sent to (and so currently kept by) another module.

<p>
<H3><A NAME="sec284"/>7.13.3. Objects are deleted by their owners</H3>

<p>The concept of <tt>ownership</tt> is that <EM>the owner has the
exclusive right and duty to delete the objects it owns</EM>.

<p>As an example, this means if you delete a message, its encapsulated
message (see <tt>encapsulate()</tt> method) and attached
<tt>cPar</tt> objects are also deleted. If you delete a queue,
all messages it contains and also owns will also be deleted.
  <br><ul><font size=-1>[Note that it's not necessary for a container object like
  a queue to actually own all inserted objects. This behavior
  can be controlled via the <EM>takeownership</EM> flag,
  as explained later.]</font></ul>

<p>If you create a new class, you should implement it so that
it deletes the <EM>owned</EM> objects in the destructor -
that is, you have to check <tt>owner()</tt> of each object
before you delete it.

<p>
<H3><A NAME="sec285"/>7.13.4. Ownership is managed transparently</H3>

<p><br><P class="subheading">Automatic transfer of ownership</P>

<p>Ownership is usually established and managed automatically.
It is not hard to guess that objects (i.e. messages) inserted
into a <tt>cQueue</tt> or a <tt>cArray</tt> will be owned by that object
(by default - this can be changed, as described later).
Messages encapsulated into other messages (by <tt>cMessages</tt>'s
<tt>encapsulate()</tt> method), and <tt>cPar</tt>'s added to a message
will also become owned by the message object (again, this can be
changed), and they are deallocated automatically when the
message object is deleted.

<p><br><P class="subheading">The <EM>local objects</EM> list</P>

<p>But objects which, not being stored in another object, appear not to
have owners usually have one as well. If you just create a
message object inside a simple module (e.g. from <tt>activity()</tt>,
<tt>handleMessage()</tt> or any function called from them), it will
be <EM>owned by simple module</EM>, or more precisely, by
its <EM>``local objects list''</EM> (a member of <tt>cSimpleModule</tt>).

<p>So the following line:

<pre>
cMessage *msg = new cMessage("HELLO");
</pre>
<p>
actually creates the message object and automatically adds it
to the module's local objects list.
  <br><ul><font size=-1>[More precisely: to the <EM>currently executing</EM> module's
  local object list, because that's the best guess a <tt>cMessage</tt>
  constructor can do.]</font></ul>

<p>The local objects list also plays a role when an object is
removed from a container object (e.g. when a message is removed
from a queue).
In that case, the container object ``drops'' the ownership of the
object, and the object will ``join'' its default owner,
the local objects list of the simple module (again, to the
<EM>currently active</EM> simple module's list).
Thus, an innocent-looking

<pre>
cMessage *msg = queue.pop();
</pre>
<p>
statement actually involves a transfer of ownership of the message
object from the queue to the simple module.
The same thing happens when a message is decapsulated from another message,
when <tt>cPar</tt>'s are removed from a <tt>cArray</tt>, and in many more cases.

<p>
<br><P class="subheading">Sanity checks</P>

<p>The <tt>send()</tt> and <tt>scheduleAt()</tt> functions make use
of the ownership mechanism to do some sanity check:
the message being sent/scheduled <EM>must</EM> be owned
by module's local objects list.
If it is not, then it's an error, because then the message is
probably with another module (i.e. already sent), or
currently scheduled, or inside a queue, a message or some
other object - in either case, you do not have any authority
to send it. When you get this error message (<tt>"not owner of object"</tt>),
you might feel tempted to forcibly take ownership of the message object
by means of <tt>setOwner()</tt>. Note that it would be
entirely wrong, and would probably lead to crash further on in
your program. <EM>Do not use</EM> <tt>setOwner()</tt>! Instead,
you need to carefully examine who
has the ownership of the message, why's that, and then
probably you'll need to fix the logic somewhere
in your program.

<p><br><P class="subheading">The <EM>class members</EM> list</P>

<p>For completeness, it should also be mentioned that class
members of a simple module are collected on a <EM>``class members list''</EM>.
The reason for the existence of this list is not so much garbage collection
or sanity checks, but rather assisting Tkenv in displaying
the class members list in simple module inspectors.

<p>

<p>
<H3><A NAME="sec286"/>7.13.5. Garbage collection</H3>
<a name="sec:ch-sim-lib:garbage-collection"></a>

<p><br><P class="subheading">How it's done</P>

<p>The local objects list is also the reason why you rarely need to
put delete statements in your simple module destructors.

<p>When you restart the simulation in Tkenv or begin a new run in Cmdenv,
OMNeT++ has to clean up the previously running simulation.
This involves (a) deleting all modules in the network, and
(b) deleting all messages in the Future Events Set.
Modules (both simple and compound) can also be dynamically deleted
during simulation (deleting a compound module just consists
of recursively deleting all submodules). At that time,
one expects all dynamically allocated objects to be properly
destructed and memory released, which is not trivial since the
simulation kernel does not know what objects have been created
by simple modules. Here's how it is done in the simulation kernel.

<p>When a simple module gets deleted, the local objects list is also
deleted in addition to the module's gates and parameters.
This means that all objects on the module's local objects list
(i.e. objects you allocated and need to be garbage collected)
will also be deleted, and this is exactly what we need as garbage
collection.

<p>The result is that as long as you only have dynamically allocated
memory as (or within) <tt>cObject</tt>-based objects,
you don't have to worry about writing module destructors:
everything is taken care of automatically.

<p><br><P class="subheading">Garbage collection and your module destructors</P>

<p>Note that this garbage collection can nicely co-exist with module destructors
you write. If you delete an object explicitly, it is redundant
but does no harm: its destructor will also remove it from the
owner's list (which might be the module's local object list),
so double deletion will not occur.

<pre>
class MyModule : public cSimpleModule
{
    ...
    cMessage *timeoutmsg;
    ...
};

MyModule::~MyModule()
{
    delete timeoutmsg;   // redundant but does no harm
}
</pre>
<p>
Other allocated memory (e.g. C++ arrays of integers, doubles, structs
or pointers) or objects which have nothing to do with <tt>cObject</tt>
(e.g. STL objects or your non-<tt>cObject</tt> rooted classes)
are invisible to the ownership mechanism discussed here,
and must be deleted in the destructor in the conventional way.

<pre>
class MyModule : public cSimpleModule
{
    ...
    double *distances; // array allocated via new double []
    ...
};

MyModule::~MyModule()
{
    delete [] distances; // OMNeT++ knows nothing about this vector,
                         // so we need to clean up it manually
}
</pre>
<p>
It is similar when you have arrays of <tt>cMessage</tt> pointers
(or in general any other non-OMNeT++ data structure which holds pointers to
<tt>cObject</tt>-rooted objects). Then it is enough if you delete
the array or the data structure, the objects will be cleaned up
via the garbage collection mechanism.

<pre>
class MyModule : public cSimpleModule
{
    ...
    cMessage **events; // array allocated via new cMessage *[]
    ...
};

MyModule::~MyModule()
{
    delete [] events; // we need to delete only the pointer array itself,
                      // deleting the message objects can be left to
                      // the garbage collection mechanism
}
</pre>
<p>
In any case, remember <EM>not</EM> to put any destructor-like
code inside the module's <tt>finish()</tt> function. The main reason
is that whenever your simulation stops with an error (or
you just stop it within Tkenv), the <tt>finish()</tt> functions
will not be called and thus, memory will be leaked.

<p><br><P class="subheading">Can it crash?</P>

<p>A potential crash scenario is when the object ownership
mechanism deletes objects before your code does, and <EM>your code,
not aware of the ownership mechanism and not knowing that the objects
have already been deleted, tries to delete them again</EM>.
Note that <EM>this cannot happen</EM> as long as objects stay within the module,
because the garbage collection mechanism is embedded deeply
in the base class of your simple module, thus it is guaranteed
by C++ language rules to take place after
all your destructor-related code (your simple module class's destructor
and the destructors of data members you added to the simple module class)
have executed.

<p>However, if some of your objects have been sent to other modules
(e.g. inside a message)
while their ownership stayed with the original module (which is a
situation one should not allow to happen), the above order of destruction
is not guaranteed and crash is possible. To produce the above crash, however,
one must work hard to add a nonstandard way of storing objects in a message.
This situation will be discussed later in more detail, after we've discussed
how containers like <tt>cQueue</tt> and <tt>cArray</tt> work.

<p><br><P class="subheading">Garbage collection of activity() simple modules</P>

<p>Another interesting aspect is what happens when an <tt>activity()</tt>
simple module is deleted. Objects that were local variables
of <tt>activity()</tt> are just left on the coroutine stack.
They themselves need not (and must not) be deleted using the
<tt>delete</tt> operator, but they need to be properly destructed
(their destructors called) so that the memory <EM>they</EM> allocated
can be released. As of OMNeT++ version 2.3, this is done by actually
calling the method named <tt>discard()</tt> in the <tt>cObject</tt> destructor
instead of the directly the <tt>delete</tt> operator. <tt>discard()</tt>
invokes either the <tt>delete</tt> operator (if the object was allocated
dynamically) or directly the object's destructor (if the object was
a local variable in <tt>activity()</tt> or a function called from
<tt>activity()</tt>). In future releases, the implementation might
be changed to rely on C++ exceptions (stack unwinding) for proper
cleanup.

<p>
<H3><A NAME="sec287"/>7.13.6. What cQueue and cArray do</H3>

<p>How can the ownership mechanism operate transparently?
It is useful to look inside <tt>cQueue</tt> and <tt>cArray</tt>,
because they might give you a hint what behavior you need
to implement when you want to use non-OMNeT++ container classes
to store messages or other <tt>cObject</tt>-based objects.

<p><br><P class="subheading">Insertion</P>

<p><tt>cArray</tt> and <tt>cQueue</tt> have internal data structures
(array and linked list) to store the objects which are inserted
into them. However, they do <EM>not</EM> necessarily own all of these
objects.  (Whether they own an object or not can be determined
from that object's <tt>owner()</tt> pointer.)

<p>The default behaviour of <tt>cQueue</tt> and <tt>cArray</tt> is
to take ownership of the objects inserted.
This behavior can be changed via the <EM>takeOwnership</EM> flag.
The flag is part of <tt>cObject</tt> so that every container object
can make use of it, and can be get/set via the
<tt>takeOwnership()</tt> and <tt>setTakeOwnership()</tt> methods.

<p>Here's what the <EM>insert</EM> operation of <tt>cQueue</tt> (or <tt>cArray</tt>) does:
<UL>
    <li><strong></strong>insert the object into the internal array/list data structure

<p>    <li><strong></strong>if the <EM>takeOwnership</EM> flag is true, take ownership
    of the object, otherwise just leave it with its original owner
</UL>

<p>The corresponding source code:

<pre>
void cQueue::insert(cObject *obj)
{
    // insert into queue data structure (linked list)
    ...

    // take ownership if needed
    if (takeOwnership())
        take(obj);

}
</pre>
<p>

<p><br><P class="subheading">Removal</P>

<p>Here's what the <EM>remove</EM> family of operations in <tt>cQueue</tt>
(or <tt>cArray</tt>) does:

<p><UL>
    <li><strong></strong>remove the object from the internal array/list data structure

<p>    <li><strong></strong>if the object is actually owned by this <tt>cQueue</tt>/<tt>cArray</tt>,
    release ownership of the object, otherwise just leave it with
    its current owner
</UL>

<p>After the object was removed from a <tt>cQueue</tt>/<tt>cArray</tt>,
you may further use it, or if it's not needed any more, you can delete it.

<p>The <EM>release ownership</EM> phrase requires further explanation.
When you remove and object from a queue or array, the ownership
is expected to be transferred to the simple module's local objects list.
This is acomplished by the <tt>drop()</tt> function, which transfers the
ownership to the object's default owner.
<tt>defaultOwner()</tt> is a virtual method returning <tt>cObject*</tt>
defined in <tt>cObject</tt>, and its implementation returns
the currently executing simple module's local object list.

<p>As an example, the <tt>remove()</tt> method of <tt>cQueue</tt> is
implemented like this:
  <br><ul><font size=-1>[Actual code in <SAMP>src/sim</SAMP> is structured somewhat
  differently, but the meaning is the same.]</font></ul>

<pre>
cObject *cQueue::remove(cObject *obj)
{
    // remove object from queue data structure (linked list)
    ...

    // release ownership if needed
    if (obj-&gt;owner()==this)
        drop(obj);

    return obj;
}
</pre>
<p>

<p><br><P class="subheading">Destructor</P>

<p>The destructor should delete all data structures the object allocated.
From the contained objects, only the owned ones are deleted - that is,
where <tt>obj-&gt;owner()==this</tt>.

<p>
<br><P class="subheading">Object copying</P>

<p>The ownership mechanism also has to be taken into consideration
when a <tt>cArray</tt> or <tt>cQueue</tt> object is duplicated.
The duplicate is supposed to have the same content as the
original, however the question is whether the contained objects
should also be duplicated or just their pointers taken over
to the duplicate <tt>cArray</tt> or <tt>cQueue</tt>.

<p>The convention followed by <tt>cArray</tt>/<tt>cQueue</tt> is that
only owned objects are copied, and the contained but not owned ones
will have their pointers taken over and their original owners
left unchanged.

<p>In fact, the same question arises at three places:
the assignment operator <tt>operator=()</tt>, the copy constructor
and the <tt>dup()</tt> method.
In OMNeT++, the convention is that copying is implemented
in the assignment operator, and the other two just rely on it.
(The copy constructor just constructs an empty object and
invokes assigment, while <tt>dup()</tt>
is implemented as <tt>new cArray(*this)</tt>).


<H3><A NAME="sec288"/>7.13.7. Change of implementation</H3>

<p>In the current release (version 2.3), the data structure
used to maintain the ownership tree is in <tt>cObject</tt>.
The ownership principle is also enforced in <tt>cObject</tt>,
so it is the <tt>cObject</tt> destructor that deletes all owned objects.
  <br><ul><font size=-1>[This is also the reason why there are currently so few
  <tt>delete</tt> calls in the simulation kernel sources:
  container classes like <tt>cArray</tt> or <tt>cQueue</tt>
  leave the task of deleting the contained objects they own to the
  <tt>cObject</tt> destructor.]</font></ul>

<p>This behaviour will probably be changed in the next major release,
and every class will be made responsible for deleting its own owned
objects. This will be closer to the usual C++ practice and will
make the OMNeT++ simulation library easier to understand. Also, it
will be more efficient with both memory and execution time, without
losing significant functionality.

<p>The change will be transparent to simulations, unless you implemented
a container class which relies on <tt>cObject</tt>'s destructor
to destroy owned objects.

<p>
As of the 2.3 release, <tt>cObject</tt> contains 4 pointers.
<EM>ownerp</EM> points to the owner, <EM>firstchildp</EM>
points to the first owned object,
while <EM>prevp</EM>, <EM>nextp</EM> are used to build a doubly linked list
of objects held by the same owner. These pointers are private data
members, they cannot be accessed directly, only via certain
member functions. Changing the owner of an object
(<tt>setOwner()</tt> method in <tt>cObject</tt>)
involves about 8-9 pointer assignments (i.e., <EM>ownerp</EM>,
<EM>prevp</EM>, <EM>nextp</EM> and <EM>firstchildp</EM> in the object,
in its owner and siblings).

<p>This data structure is likely to change: <EM>firstchildp</EM>,
<EM>prevp</EM> and <EM>nextp</EM> will be removed from <tt>cObject</tt>,
and only <EM>ownerp</EM> will remain. The <tt>setOwner()</tt> method
will probably be removed entirely.

<p><hr><H2><A NAME="sec289"/>7.14. Tips for speeding up the simulation</H2>

<p>Here are a few tips that can help you make the simulation faster:
<UL>
  <li><strong></strong>Use message subclassing instead of adding <tt>cPar</tt>'s to messages.
  <li><strong></strong>Try to minimize message creations and deletions. Reuse
    messages if possible.
  <li><strong></strong>Turn off the display of screen messages when you run the
    simulation.  You can do this in the ini file. Alternatively, you
    can place #ifdefs around your <SAMP>ev&lt;&lt;</SAMP> and
     calls and turn off the define when compiling
    the simulation for speed.
  <li><strong></strong>Store the module parameters in local variables to avoid
    calling <tt>cPar</tt> member functions every time.
</UL>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec290"/>8. Building Simulation Programs</H1>
<a name="cha:building-simulation-programs"></a>

<p>

<p>
<hr><H2><A NAME="sec291"/>8.1. Overview</H2>

<p>As it was already mentioned, an OMNeT++ model physically consists of
the following parts:
<UL>
  <li><strong></strong>NED language topology description(s). These
      are files with the <tt>.ned</tt> suffix.
  <li><strong></strong>Messsage definitions, in files
      with <tt>.msg</tt> suffix.
  <li><strong></strong>Simple modules implementations and other C++ code, in <tt>.cc</tt>
        files (or <tt>.cpp</tt>, on Windows)
</UL>

<p>
To build an executable simulation program,
first you need to translate the NED files
and the message files into C++, using the NED compiler
(<tt>nedc</tt>) and the message compiler (<tt>opp_msgc</tt>).
After this step, the process is the same as building any C/C++
program from source: all C++ sources need to be compiled into object files
(<tt>.o</tt> files on Unix/Linux, and <tt>.obj</tt> on Windows),
and all object files need to be linked with the necessary libraries to get
an executable.


File names for libraries differ for Unix/Linux and for Windows,
and it's also different for static and shared libraries.
Suppose you have a library called Tkenv.
On a Unix/Linux system, the file name for the static library
would be something like <tt>libtkenv.a</tt> (or <tt>libtkenv.a.</tt><EM>&lt;version&gt;</EM>),
and the shared library would be called <tt>libtkenv.so</tt>
(or <tt>libtkenv.so.</tt><EM>&lt;version&gt;</EM>).
The Windows version of the static library would be <tt>tkenv.lib</tt>,
and the DLL (which is the Windows equivalent of shared libraries)
would be a file named <tt>tkenv.dll</tt>.

<p>You'll need to link with the following libraries:

<p><UL>
  <li><strong></strong>The simulation kernel and class library,
    called <EM>sim_std</EM> (file <tt>libsim_std.a</tt>, <tt>sim_std.lib</tt>, etc).
  <li><strong></strong>User interfaces. The common part of all user interfaces is
    the <EM>envir</EM> library (file <SAMP>libenvir.a</SAMP>, etc),
    and the specific user interfaces are <EM>tkenv</EM> and <EM>cmdenv</EM>
    (<tt>libtkenv.a</tt>, <tt>libcmdenv.a</tt>, etc). You have to link
    with <EM>envir</EM>, plus either <EM>tkenv</EM> or <EM>cmdenv</EM>.
</UL>

<p>Luckily, you do not have to worry about the above details, because
automatic tools like <tt>opp_makemake</tt> will take care of the hard
part for you.

<p>The following figure gives an overview of the process of building
and running simulation programs.

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig17.gif">
    <center><i>Figure: Building and running simulation</i></center>
  </DIV>

<p>

<p>This section discusses how to use the simulation system on the
following platforms:
<UL>
  <li><strong></strong>Unix with gcc (also Windows with Cygwin or MinGW)
  <li><strong></strong>MSVC 6.0 on Windows
</UL>

<p>

<p>
<hr><H2><A NAME="sec292"/>8.2. Using Unix and gcc</H2>

<p>This section applies to using OMNeT++ on Linux, Solaris, FreeBSD and
other Unix derivatives, and also more or less to Cygwin and MinGW
on Windows.

<p>Here in the manual we can give you a rough overview only.
The <tt>doc/</tt> directory of your OMNeT++ installation contains
<tt>Readme.</tt><EM>&lt;platform&gt;</EM> files that provide
up-to-date, more detailed and more precise instructions.

<p>
<H3><A NAME="sec293"/>8.2.1. Installation</H3>

<p>The installation process depends on what distribution you take
(source, precompiled RPM, etc.) and it may change from release
to release, so it is better to refer to the readme files.
If you compile from source, you can expect the usual GNU
procedure: <tt>./configure</tt> followed by <tt>make</tt>.

<p>
<H3><A NAME="sec294"/>8.2.2. Building simulation models</H3>

<p>The <tt>opp_makemake</tt> script can automatically generate the
<SAMP>Makefile</SAMP> for your simulation program, based on the source files
in the current directory. (It can also handle large models
which are spread across several directories; this is covered later in
this section.)

<p><tt>opp_makemake</tt> has several options, with the <tt>-h</tt>
option it displays a summary.

<pre>
% opp_makemake -h
</pre>
<p>
Once you have the source files (<tt>*.ned</tt>, <tt>*.msg</tt>, <tt>*.cc</tt>,
<tt>*.h</tt>) in a directory, <tt>cd</tt> there then type:

<pre>
% opp_makemake
</pre>
<p>
This will create a file named <SAMP>Makefile</SAMP>. Thus if you
simply type <tt>make</tt>, your simulation program should build. The name of
the executable will be the same as the name of the directory
containing the files.

<p>
The freshly generated <SAMP>Makefile</SAMP> doesn't contain
dependencies, it is advisable to add them
by typing <tt>make depend</tt>. The warnings during the
dependency generation process can be safely ignored.

<p>In addition to the simulation executable, the <SAMP>Makefile</SAMP>
contains other targets, too. Here is a list of important ones:

<p><table border>
<TR> <TD align=left>

<p><b>Target</b> </TD> <TD align=left> <b>Action</b></TD></TR>
<TR> <TD align=left>  </TD> <TD align=left> The default target is to build the simulation executable</TD></TR>
<TR> <TD align=left> depend </TD> <TD align=left> Adds (or refreshes) dependencies in the <SAMP>Makefile</SAMP></TD></TR>
<TR> <TD align=left> clean </TD> <TD align=left>  Deletes all files that were produced by the make process</TD></TR>
<TR> <TD align=left> neddoc.html </TD> <TD align=left> Generates documentation for all NED files. The resulting file is named <SAMP>neddoc.html</SAMP></TD></TR>
<TR> <TD align=left> htmldoc </TD> <TD align=left> Generates code documentation using doxygen. The documentation will be placed into the directory <SAMP>htmldoc</SAMP></TD></TR>
<TR> <TD align=left> doc </TD> <TD align=left> Convenience target that calls neddoc.html and htmldoc</TD></TR>
<TR> <TD align=left> re-makemake </TD> <TD align=left> Regenerates the <SAMP>Makefile</SAMP> using <tt>opp_makemake</tt> (this is useful if e.g.  after upgrading OMNeT++, if <tt>opp_makemake</tt> has changed)</TD></TR>
<TR> <TD align=left> re-makemake-m </TD> <TD align=left> Similar to <tt>make re-makemake</tt>, but it regenerates the <SAMP>Makefile.in</SAMP> instead</TD></TR>
</table>

<p>If you already had a <SAMP>Makefile</SAMP> in that directory, <tt>opp_makemake</tt>
will refuse overwriting it. You can force overwriting the old <SAMP>Makefile</SAMP>
with the -f option:

<pre>
% opp_makemake -f
</pre>
<p>
If you have problems, check the path definitions (locations of include
files and libraries etc.) in the configure script and correct them if necessary. Then re-run configure to
commit the changes to all makefiles, the <tt>opp_makemake</tt> script
etc.

<p>
You can specify the user interface (Cmdenv/Tkenv) with the -u option
(with no -u, Tkenv is the default):

<pre>
% opp_makemake -u Tkenv
</pre>
<p>
Or:

<pre>
% opp_makemake -u Cmdenv
</pre>
<p>
The name of the output file is set with the -o
option (the default is the name of the directory):

<pre>
% opp_makemake -o fddi-net
</pre>
<p>
If some of your source files are generated from other files (for
example, you use machine-generated NED files), write your make rules
into a file called <tt>makefrag</tt>. When you run <tt>opp_makemake</tt>, it
will automatically insert <tt>makefrag</tt> into the resulting <SAMP>makefile</SAMP>.
With the -i option, you can also name other files to be included into
<SAMP>Makefile</SAMP>.

<p>
If you want better portability for your models, you can generate
<SAMP>Makefile.in</SAMP> instead of <SAMP>Makefile</SAMP> with <tt>opp_makemake</tt>'s
-m option. You can then use <tt>autoconf</tt>-like configure scripts to generate
the <SAMP>Makefile</SAMP>.

<p>

<p>
<H3><A NAME="sec295"/>8.2.3. Multi-directory models</H3>

<p>In the case of a large project, your source files may be spread across
several directories. You have to decide whether you want to use static
linking, shared or run-time loaded (shared)
libraries. Here we discuss static linking.

<p>
In each subdirectory (say <tt>app/</tt> and <tt>routing/</tt>), run

<pre>
opp_makemake -n
</pre>
<p>
The -n option means no linking is necessary, only compiling has
to be done.

<p>In your toplevel source directory, run

<pre>
opp_makemake app/ routing/
</pre>
<p>
This results in recursive makefiles: when you build the simulation, make
will descend into <tt>app/</tt> and <tt>routing/</tt>, run make in both, then
it will link an executable with the object files in the two directories.

<p>
You may need to use the -I option if you include files from other
directories. The -I option is for both C++ and NED
files. In our example, you could run

<pre>
opp_makemake -n -I../routing
</pre>
<p>
in the <tt>app/</tt> directory, and vice versa.

<p>If you're willing to play with shared and run-time loaded libraries,
several <tt>opp_makemake</tt> options and the
<SAMP>[General]/load-libs=</SAMP> ini file option leave you enough room to
do so.

<p>

<p>

<p><H3><A NAME="sec296"/>8.2.4. Static vs shared OMNeT++ system libraries</H3>

<p>Default linking uses the shared libraries. One
reason you would want static linking is that
debugging\indexdebugging the OMNeT++ class library is more trouble
with shared libraries. Another reason might be that you want to run
the executable on another machine without having to worry about
setting the <tt>LD_LIBRARY_PATH</tt> variable (which should contain the name
of the directory where the OMNeT++ shared libraries are).

<p>If you want static linking, find the

<pre>
build_shared_libs=yes
</pre>
<p>

<p>line in the <SAMP>configure.user</SAMP> script and change it to

<pre>
build_shared_libs=no
</pre>
<p>
Then you have to re-run the configure script and rebuild everything:

<pre>
./configure
make clean
make
</pre>
<p>

<p>
<hr><H2><A NAME="sec297"/>8.3. Using Windows and Microsoft Visual C++</H2>

<p>This is only a rough overview. Up-to-date, more detailed and more
precise instructions can be found in the <tt>doc/</tt> directory
of your OMNeT++ installation, in the file <tt>Readme.MSVC</tt>.

<p>
<H3><A NAME="sec298"/>8.3.1. Installation</H3>

<p>It is easiest to start with the binary, installer version.
It contains all necessary software except MSVC,
and you can get a working system up and running very fast.

<p>Later you'll probably want to download and build the source
distribution too. Reasons for that might be to compile the libraries
with different flags, to debug into them, or to recompile
with support for additional packages (e.g. Akaroa, MPI).
Compilation should be painless (it takes a single
<tt>nmake -f Makefile.vc</tt> command) after you get the different
component directories right in <tt>configuser.vc</tt>.
Additional software needed for the compilation is also described
in <tt>doc/</tt>.

<p>
<H3><A NAME="sec299"/>8.3.2. Building simulation models on the command line</H3>

<p>OMNeT++ has an automatic MSVC makefile creator named <tt>opp_nmakemake</tt>
which is probably the easier way to go. Its usage is very similar
to the similarly named tool for Unix.

<p>If you run <tt>opp_nmakemake</tt> in a directory of model sources, it
collects all the names of all source files in the directory,
and creates a makefile from them. The resulting makefile is
called <tt>Makefile.vc</tt>.

<p>To use <tt>opp_nmakemake</tt>, open a command window (<EM>Start menu</EM>
-&gt; <EM>Run...</EM> -&gt; type <tt>cmd</tt>), then <tt>cd</tt> to the directory
of your model and type:

<pre>
opp_nmakemake
</pre>
<p>
<tt>opp_nmakemake</tt> has several command-line options, mostly the
same as the Unix version.

<p>Then you can build the program by typing:

<pre>
nmake -f Makefile.vc
</pre>
<p>
The most common problem is that <tt>nmake</tt> (which is is part of MSVC)
cannot be found because it is not in the path. You can fix
this by running <tt>vcvars32.bat</tt>, which can be found in the
MSVC <tt>bin</tt> directory (usually
<tt>C:\Program Files\Microsoft
Visual Studio\VC98\Bin</tt>).

<p>
<H3><A NAME="sec300"/>8.3.3. Building simulation models from the MSVC IDE</H3>

<p>You can also use the MSVC IDE for development.
There is an MSVC wizard which will create project files for you,
or you can start by copying one of the sample simulations.
There is also an <tt>AddNEDFileToProject</tt> macro that can, well, add
NED files to your project with the necessary custom build step
(invoke nedc, etc.)

<p>Some caveats (please read <tt>doc/Readme.MSVC</tt> for more!):

<p><UL>
 <li><strong></strong> <b>how to get the graphical environment</b>. By default,
   the sample simulations link with Cmdenv if you rebuild them
   from the IDE. To change to Tkenv, choose Build|Set
   active configuration from the menu, select ``Debug-Tkenv''
   or ``Release-Tkenv'', then re-link the executable.

<p> <li><strong></strong> <b>can't find a usable init.tcl</b>. If you get this message,
   Tcl/Tk is missing the <tt>TCL_LIBRARY</tt> environment variable
   which is normally set by the installer. If you see this message,
   you need to set this variable yourself to the Tcl <tt>lib/</tt> directory.

<p> <li><strong></strong> <b>changed compiler settings</b>. Changes since OMNeT++ 2.2:
   You'll need exception handling and RTTI turned ON, and
   stack size set to as low as 64K.
   See the readme file for rationale and more hints.

<p> <li><strong></strong> <b>adding NED files</b>. After you added a <SAMP>.ned</SAMP> file
   to the project, you also have to add a <tt>_n.cpp</tt> file, and set a
   <EM>Custom Build Step</EM> for them:

<pre>
Description: NED Compiling $(InputPath)
Command: nedc -s _n.cpp $(InputPath)
Outputs: $(InputName)_n.cpp
</pre>
<p>
   For msg files you need an analogous procedure.

<p> <li><strong></strong> <b>file name extension</b>: as a gesture toward the free software
   community, MSVC refuses to treat <SAMP>.cc</SAMP> files as C++ sources,
   so first you have to rename them to <SAMP>.cpp</SAMP>.
   For the sample simulations this is done by <tt>samples/cc2cpp.bat</tt>.

<p></UL>

<p>





<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec301"/>9. Documenting NED and Messages</H1>
<a name="cha:neddoc"></a>

<p><hr><H2><A NAME="sec302"/>9.1. Overview</H2>

<p>Like Javadoc and Doxygen... opp_neddoc

<p>
<hr><H2><A NAME="sec303"/>9.2. Writing the documentation</H2>

<p>
<H3><A NAME="sec304"/>9.2.1. Documentation comments</H3>

<p>Documentation is embedded in normal comments. All <SAMP>//</SAMP> comments
that are in the ``right place'' (from the documentation tool's 
point of view) will be included in the generated documentation.
  <br><ul><font size=-1>[In contrast, Javadoc and Doxygen use special comments (those 
     beginning with <SAMP>/**</SAMP>, <SAMP>///</SAMP>, <SAMP>//&lt;</SAMP> or a similar 
     marker) to distinguish documentation from ``normal'' comments in the 
     source code. In OMNeT++ there's no need for that: NED and the message 
     syntax so compact that practically all comments one would want to write 
     in them can serve documentation purposes. Still, there is a way to write
     comments that <EM>don't</EM> make it into the documentation - by starting
     them with <SAMP>//#</SAMP>.]</font></ul>

<p>Example:

<pre>
//
// An ad-hoc traffic generator to test the Ethernet models.
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
</pre>
<p>
You can also place comments above parameters and gates. This is useful
if they need long explanations. Example:

<pre>
//
// Deletes packets and optionally keeps statistics.
//
simple Sink
    parameters:
        // You can turn statistics generation on and off. This is
        // a very long comment because it has to be described what
        // statistics are collected (or not).
        statistics: bool;
    gates:
        in: in;
endsimple
</pre>
<p>
If you want a comment line <EM>not</EM> to appear in the documentation,
begin it with <SAMP>//#</SAMP>. Those lines will be ignored by the
documentation generation, and can be used to comment out
unused NED code or to make ``private'' comments like <SAMP>FIXME</SAMP> or
<SAMP>TBD</SAMP>.

<pre>
//
// An ad-hoc traffic generator to test the Ethernet models.
//# FIXME above description needs to be refined
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        //# burstiness: numeric;  -- not yet supported
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
</pre>
<p>

<p><H3><A NAME="sec305"/>9.2.2. Text layout and formatting</H3>

<p>If you write longer descriptions, you'll need text formatting capabilities.
Text formatting works like in Javadoc or Doxygen - you can break up the
text into paragraphs and create bulleted/numbered lists without
special commands, and use HTML for more fancy formatting.

<p>Paragraphs are separated by empty lines, like in LaTeX or Doxygen. 
Lines beginning with `<tt>-</tt>' will be turned into bulleted lists, 
and lines beginning with `<tt>-#</tt>' into numbered lists.

<p>Example:

<pre>
// Ethernet MAC layer. MAC performs transmission and reception of frames.
//
// Processing of frames received from higher layers:
// - sends out frame to the network
// - no encapsulation of frames -- this is done by higher layers.
// - can send PAUSE message if requested by higher layers (PAUSE protocol,
//   used in switches). PAUSE is not implemented yet.
//
// Supported frame types:
// -# IEEE 802.3
// -# Ethernet-II
//
</pre>
<p>
<H3><A NAME="sec306"/>9.2.3. Additional text formatting using HTML</H3>

<p>Common HTML tags are understood as formatting commands.
The most useful of these tags are: <tt>&lt;i&gt;..&lt;/i&gt;</tt> (italic),
<tt>&lt;b&gt;..&lt;/b&gt;</tt> (bold), <tt>&lt;tt&gt;..&lt;/tt&gt;</tt> (typewriter font),
<tt>&lt;sub&gt;..&lt;/sub&gt;</tt> (subscript), <tt>&lt;sup&gt;..&lt;/sup&gt;</tt> (superscript),
<tt>&lt;br&gt;</tt> (line break), <tt>&lt;h3&gt;</tt> (heading),
<tt>&lt;pre&gt;..&lt;/pre&gt;</tt> (preformatted text) and <tt>&lt;a href=..&gt;..&lt;/a&gt;</tt> (link),
as well as a few other tags used for table creation (see below).
For example, <SAMP>&lt;i&gt;Hello&lt;/i&gt;</SAMP> will be rendered as ``<EM>Hello</EM>''
(using an italic font).

<p>The complete list of HTML tags interpreted by <tt>opp_neddoc</tt> are:
<SAMP>&lt;a&gt;</SAMP>, <SAMP>&lt;b&gt;</SAMP>, <SAMP>&lt;body&gt;</SAMP>, <SAMP>&lt;br&gt;</SAMP>, <SAMP>&lt;center&gt;</SAMP>,
<SAMP>&lt;caption&gt;</SAMP>, <SAMP>&lt;code&gt;</SAMP>, <SAMP>&lt;dd&gt;</SAMP>, <SAMP>&lt;dfn&gt;</SAMP>, <SAMP>&lt;dl&gt;</SAMP>,
<SAMP>&lt;dt&gt;</SAMP>, <SAMP>&lt;em&gt;</SAMP>, <SAMP>&lt;form&gt;</SAMP>, <SAMP>&lt;font&gt;</SAMP>, <SAMP>&lt;hr&gt;</SAMP>,
<SAMP>&lt;h1&gt;</SAMP>, <SAMP>&lt;h2&gt;</SAMP>, <SAMP>&lt;h3&gt;</SAMP>, <SAMP>&lt;i&gt;</SAMP>, <SAMP>&lt;input&gt;</SAMP>, <SAMP>&lt;img&gt;</SAMP>,
<SAMP>&lt;li&gt;</SAMP>, <SAMP>&lt;meta&gt;</SAMP>, <SAMP>&lt;multicol&gt;</SAMP>, <SAMP>&lt;ol&gt;</SAMP>, <SAMP>&lt;p&gt;</SAMP>, <SAMP>&lt;small&gt;</SAMP>,
<SAMP>&lt;span&gt;</SAMP>, <SAMP>&lt;strong&gt;</SAMP>,
<SAMP>&lt;sub&gt;</SAMP>, <SAMP>&lt;sup&gt;</SAMP>, <SAMP>&lt;table&gt;</SAMP>, <SAMP>&lt;td&gt;</SAMP>, <SAMP>&lt;th&gt;</SAMP>, <SAMP>&lt;tr&gt;</SAMP>,
<SAMP>&lt;tt&gt;</SAMP>, <SAMP>&lt;kbd&gt;</SAMP>, <SAMP>&lt;ul&gt;</SAMP>, <SAMP>&lt;var&gt;</SAMP>.

<p>Any tags not in the above list will not be interpreted as formatting commands
but will be printed verbatim - for example, <SAMP>&lt;what&gt;bar&lt;/what&gt;</SAMP>
will be rendered literally as ``&lt;what&gt;bar&lt;/what&gt;'' (unlike HTML where
unknown tags are simply ignored, i.e. HTML would display ``bar'').

<p>If you insert links to external pages (web sites), its useful to add
the <tt>target="_blank"</tt> attribute to ensure pages come up in a new
browser window and not just in the current frame which looks awkward.
(Alternatively, you can use the <tt>target="_top"</tt> attribute
which replaces all frames in the current browser).

<p>Examples:

<pre>
//
// For more info on Ethernet and other LAN standards, see the
// &lt;a href="http://www.ieee802.org/" target="_blank"&gt;IEEE 802
// Committee's site&lt;/a&gt;.
//
</pre>
<p>
You can also use the <tt>&lt;a href=..&gt;</tt> tag to create links within the page:

<pre>
//
// See the &lt;a href="#resources"&gt;resources&lt;/a&gt; in this page.
// ...
// &lt;a name="resources"&gt;&lt;b&gt;Resources&lt;/b&gt;&lt;/a&gt;
// ...
//
</pre>
<p>
You can use the <SAMP>&lt;pre&gt;..&lt;/pre&gt;</SAMP> HTML tag to insert souce code examples
into the documentation. Line breaks and indentation will be preserved,
but HTML tags continue to be interpreted (or you can turn them off
with <SAMP>&lt;nohtml&gt;</SAMP>, see later).

<p>Example:

<pre>
// &lt;pre&gt;
// // my preferred way of indentation in C/C++ is this:
// &lt;b&gt;for&lt;/b&gt; (&lt;b&gt;int&lt;/b&gt; i=0; i&lt;10; i++)
// {
//     printf(&lt;i&gt;"%d\n"&lt;/i&gt;, i);
// }
// &lt;/pre&gt;
</pre>
<p>
will be rendered as

<p><pre>
// my preferred way of indentation in C/C++ is this:
<STRONG>for</STRONG> (<STRONG>int</STRONG> i=0; i&lt;10; i++)
{
    printf(<EM>"%d\n"</EM>, i);
}
</pre>

<p>HTML is also the way to create tables. The example below

<pre>
//
// &lt;table border="1"&gt;
//   &lt;tr&gt;  &lt;th&gt;#&lt;/th&gt; &lt;th&gt;number&lt;/th&gt; &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;1&lt;/td&gt; &lt;td&gt;one&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;2&lt;/td&gt; &lt;td&gt;two&lt;/td&gt;    &lt;/tr&gt;
//   &lt;tr&gt;  &lt;td&gt;3&lt;/td&gt; &lt;td&gt;three&lt;/td&gt;  &lt;/tr&gt;
// &lt;/table&gt;
//
</pre>
<p>
will be rendered approximately as:

<p><table border>
<TR> <TD align=left>

<p><b>#</b> </TD> <TD align=left> <b>number</b> </TD></TR>
<TR> <TD align=left> 1 </TD> <TD align=left> one </TD></TR>
<TR> <TD align=left> 2 </TD> <TD align=left> two </TD></TR>
<TR> <TD align=left> 3 </TD> <TD align=left> three </TD></TR>
</table>

<p>
<H3><A NAME="sec307"/>9.2.4. Turning off HTML</H3>

<p>You may temporarily turn off interpreting <tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt>, etc.
as HTML formatting commands. This is useful if you have to put literal
<tt>&lt;i&gt;</tt>, <tt>&lt;b&gt;</tt> text in the documentation. To turn off interpreting
HTML, surround the text with <tt>&lt;nohtml&gt;</tt>...<tt>&lt;/nohtml&gt;</tt> tags.
For example,

<pre>
// Use the &lt;nohtml&gt;&lt;i&gt;&lt;/nohtml&gt; tag (like &lt;tt&gt;&lt;nohtml&gt;&lt;i&gt;this&lt;/i&gt;&lt;/nohtml&gt;&lt;tt&gt;)
// to write in &lt;i&gt;italic&lt;/i&gt;.
</pre>
<p>
will be rendered as ``Use the &lt;i&gt; tag (like <SAMP>&lt;i&gt;this&lt;/i&gt;</SAMP>) to write
in <EM>italic</EM>.''

<p>

<p><H3><A NAME="sec308"/>9.2.5. Where to put comments</H3>

<p>You have to put the comments where nedtool will find them.
This is a) above the documented item, or b) after the
documented item, on the same line.

<p>If you put it above, make sure there's no blank line left
between the comment and the documented item. Blank lines
detach the comment from the documented item.

<p>Example:
<pre>
// This is wrong! Because of the blank line, this comment is not
// associated with the following simple module!

simple Gen
    parameters:
    ...
endsimple
</pre>

<p>Do not try to comment groups of parameters together. The result
will be awkward.

<p>
<H3><A NAME="sec309"/>9.2.6. Customizing the title page</H3>

<p>The title page is the one that appears in the main frame after 
opening the documentation in the browser. By default it contains
a boilerplate text with the generic title <EM>``OMNeT++ Model Documentation''</EM>.
You probably want to customize that, and at least change the title
to the name of the documented simulation model.
 
<p>You can supply your own version of the title page adding a <tt>@titlepage</tt>
directive to a file-level comment (a comment that appears at the top of
a NED file, but is separated from the first <tt>import</tt>, <tt>channel</tt>, 
<tt>module</tt>, etc. definition by at least one blank line).
In theory you can place your title page definition into 
any NED or MSG file, but it is probably a good idea to create
a separate <tt>index.ned</tt> file for it.   

<p>The lines you write after the <tt>@titlepage</tt> line up to the next 
<tt>@page</tt> line (see later) or the end of the comment will be used 
as the title page.
You probably want to begin with a title because the documentation
tool doesn't add one (it lets you have full control over the
page contents). You can use the <tt>&lt;h1&gt;..&lt;/h1&gt;</tt> HTML tag 
to define a title. 

<p>Example:

<pre>
//
// @titlepage
// &lt;h1&gt;Ethernet Model Documentation&lt;/h1&gt;
//
// This documents the Ethernet model created by David Wu and refined by Andras
// Varga at CTIE, Monash University, Melbourne, Australia.
//
</pre>
<p>

<p><H3><A NAME="sec310"/>9.2.7. Adding extra pages</H3>

<p>You can add new pages to the documentation in a similar way as customizing
the title page. The directive to be used is <tt>@page</tt>, and it can 
appear in any file-level comment (see above).

<p>The syntax of the <tt>@page</tt> directive is the following:

<pre>
// @page filename.html, Title of the Page
</pre>
<p>  
Please choose a file name that doesn't collide with the files generated
by the documentation tool (such as <tt>index.html</tt>). 
The page title you supply will appear on the top of the page as well as
in the page index.

<p>The lines after the <tt>@page</tt> line up to the next <tt>@page</tt> line
or the end of the comment will be used as the page body.
You don't need to add a title because the documentation tool
automatically adds one.

<p>Example:
<pre>
//
// @page structure.html, Directory Structure
//
// The model core model files and the examples have been placed 
// into different directories. The &lt;tt&gt;examples/&lt;/tt&gt; directory...
//
//
// @page examples.html, Examples
// ...
//
</pre>

<p>You can create links to the generated pages in the normal HTML way,
using the <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag. All HTML files are 
placed in a single directory, so you don't have to worry about 
specifying directories.

<p>Example:
<pre>
//
// @titlepage
// ...
// The structure of the model is described &lt;a href="structure.html"&gt;here&lt;/a&gt;.
//
</pre>

<p>
<H3><A NAME="sec311"/>9.2.8. Incorporating externally created pages</H3>

<p>You may want to create pages outside the documentation tool 
(e.g. using a HTML editor) and include them in the documentation. 
This is possible, all you have to do is declare such pages with 
the <tt>@externalpage</tt> directive in any of the NED files, and 
they will be added to the page index. The pages can then be linked to
from other pages using the HTML <tt>&lt;a href="..."&gt;...&lt;/a&gt;</tt> tag. 

<p>The <tt>@externalpage</tt> directive is similar in syntax
<tt>@page</tt>:  

<pre>
// @externalpage filename.html, Title of the Page
</pre>
<p>
The documentation tool does not check if the page exists 
or not. It is your responsibility to copy them manually into 
the directory of the generated documentation and then to make
sure the hyperlinks work. 

<p>

<p><hr><H2><A NAME="sec312"/>9.3. Generating HTML</H2>

<p><tt>opp_neddoc</tt> generates HTML documentation from NED and MSG files.

<p>FIXME describe.

<p>Usage: opp_neddoc [-o &lt;dir&gt;] [-n] [-a] file1 file2 ...

<p>It accepts the following options:
 -o &lt;dir&gt;      output directory, defaults to ./html
 -n, -nofig   do not generate screenshots
 -a, -all     process all *.ned and *.msg files recursively
 -h, -help    this help text

<p>

<p><H3><A NAME="sec313"/>9.3.1. Multiple projects</H3>

<p>The generated <tt>tags.xml</tt> can be used to generate other documentation
that refers to pages in this documentation via HTML links.

<p>
<hr><H2><A NAME="sec314"/>9.4. How does opp_neddoc work?</H2>

<p><tt>*.ned</tt> and <tt>*.msg</tt> files are collected (e.g. via the <tt>find</tt>
command if you used the <tt>-a</tt> option on Unix) and processed
with <tt>nedtool</tt>. <tt>nedtool</tt> parses them and outputs the resulting syntax
tree in XML - a single large XML file wich contains all files.

<p>The <tt>*.ned</tt> files are processed with the <tt>-c</tt> (export-diagrams-and-exit)
option of <tt>gned</tt>. This causes <tt>gned</tt> to export diagrams for the
compound modules in Postscript. Postscript files are then converted
to GIFs using <tt>convert</tt> (part of the ImageMagick package).
<tt>gned</tt> also exports an <tt>images.xml</tt> file which describes which
image was generated from which compound module, and also contains
additional info (coordinates of submodule rectangles and icons in the image)
for creating clickable image maps.

<p>The XML file containing parsed NED and message files is then processed
with an XSLT stylesheet to generate HTML. XSLT is a very powerful way
of converting an XML document into another XML (or HTML, or text) document.
Additionally, the stylesheet reads <tt>images.xml</tt> and uses its contents
to make the compound module images clickable.
The stylesheet also outputs a <tt>tags.xml</tt> file which describes what is documented
in which .html file, so that external documentation can link to this one.

<p>As a final step, the comments in the generated HTML file are processed
with a perl script. The perl script also performs syntax hightlighting
of the source listings in the HTML, and puts hyperlinks on module,
channel, message, etc. names. (It uses the info in the <tt>tags.xml</tt> file
for the latter task.) This last step, comment formatting and source code
coloring whould have been very difficult to achieve from XSLT, which
(at least in its 1.0 version of the standard) completely lacks powerful
string manipulation functions. (Not even simple find/replace
is supported in strings, let alone regular expressions. Perhaps the
2.0 version of XSLT will improve on this.)

<p>The whole process is controlled by the <tt>opp_neddoc</tt> shell script
(or on Windows, the <tt>opp_neddoc.cmd</tt> batch file.)

<p>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb  2 2004</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jan 30 2004</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec315"/>10. Running The Simulation</H1>
<a name="cha:running-the-simulation"></a>

<p><hr><H2><A NAME="sec316"/>10.1. User interfaces</H2>

<p>OMNeT++ simulations can be run under different user interfaces.
Currenly, two user interfaces are supported:

<p><UL>
  <li><strong></strong> Tkenv: Tcl/Tk-based graphical, windowing user interface
  <li><strong></strong> Cmdenv: command-line user interface for batch execution
</UL>

<p>
You would typically test and debug your simulation under Tkenv,
then run actual simulation experiments from the command line or
shell script, using Cmdenv. Tkenv is also better suited for educational or
demonstration purposes.

<p>Both Tkenv and Cmdenv are provided in the form of a library, and
you choose between them by linking one or the other into your
simulation executable. (Creating the executable was described in
chapter <a href="#cha:building-simulation-programs">[click]</a>). Both user interfaces
are supported on Unix and Windows platforms.

<p>Common functionality in Tkenv and Cmdenv has been collected and
placed into the Envir library, which can be thought of as the
``common base class'' for the two user interfaces.

<p>The user interface is separated from the
simulation kernel, and the two parts interact through a well-defined
interface. This also means that, if needed, you can write your
own user interface or embed an OMNeT++ simulation into your application
without any change to models or the simulation library.

<p>Configuration and input data for the simulation are described in
a configuration file usually called <tt>omnetpp.ini</tt>.
Some entries in this file apply to Tkenv or Cmdenv only, other
settings are in effect regardless of the user interface.
Both user interfaces accept command-line arguments, too.

<p>
The following sections explain <tt>omnetpp.ini</tt> and the common part of
the user interfaces, describe Cmdenv and Tkenv in detail, then
go on to specific problems.

<p>
<hr><H2><A NAME="sec317"/>10.2. The configuration file: omnetpp.ini</H2>

<p><H3><A NAME="sec318"/>10.2.1. An example</H3>

<p>For a start, let us see a simple <tt>omnetpp.ini</tt> file which
can be used to run the Fifo1 sample simulation under Cmdenv.

<pre>
[General]
network = fifonet1
sim-time-limit = 500000s
output-vector-file = fifo1.vec

[Cmdenv]
express-mode = yes

[Parameters]
# generate a large number of jobs of length 5..10 according to Poisson
fifonet1.gen.num_messages = 10000000
fifonet1.gen.ia_time = exponential(1)
fifonet1.gen.msg_length = intuniform(5,10)
# processing speeed of queue server
fifonet1.fifo.bits_per_sec = 10
</pre>
<p>
The file is grouped into <EM>sections</EM> named <tt>[General]</tt>, <tt>[Cmdenv]</tt>
and <tt>[Parameters]</tt>, each one containing several <EM>entries</EM>.
The <tt>[General]</tt> section applies to both Tkenv and Cmdenv, and the entries
in this case specify that the network named <tt>fifonet1</tt> should be simulated and run
for 500,000 simulated seconds, and vector results should be written into the
<tt>fifo1.vec</tt> file. The entry in the <tt>[Cmdenv]</tt> section tells
Cmdenv to run the simulation at full speed and print periodic updates
about the progress of the simulation. The <tt>[Parameters]</tt> section assigns
values to parameters that did not get a value (or got <tt>input</tt> value)
inside the NED files.

<p>Lines that start with ``#'' or ``;'' are comments.

<p>When you build the Fifo1 sample with Cmdenv and you run it by typing <tt>fifo1</tt>
(or on Unix, <tt>./fifo1</tt>) on the command prompt, you should see
something like this.

<pre>
OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Preparing for Run #1...
Setting up network `fifonet1'...
Running simulation...
** Event #0        T=0.0000000  ( 0.00s)   Elapsed: 0m  0s   ev/sec=0
** Event #100000   T=25321.99 ( 7h  2m)    Elapsed: 0m  1s   ev/sec=0
** Event #200000   T=50275.694 (13h 57m)   Elapsed: 0m  3s   ev/sec=60168.5
** Event #300000   T=75217.597 (20h 53m)   Elapsed: 0m  5s   ev/sec=59808.6
** Event #400000   T=100125.76 ( 1d  3h)   Elapsed: 0m  6s   ev/sec=59772.9
** Event #500000   T=125239.67 ( 1d 10h)   Elapsed: 0m  8s   ev/sec=60168.5
...
** Event #1700000  T=424529.21 ( 4d 21h)   Elapsed: 0m 28s   ev/sec=58754.4
** Event #1800000  T=449573.47 ( 5d  4h)   Elapsed: 0m 30s   ev/sec=59066.7
** Event #1900000  T=474429.06 ( 5d 11h)   Elapsed: 0m 32s   ev/sec=59453
** Event #2000000  T=499417.66 ( 5d 18h)   Elapsed: 0m 34s   ev/sec=58719.9
&lt;!&gt; Simulation time limit reached -- simulation stopped.

Calling finish() at end of Run #1...
*** Module: fifonet1.sink***
Total jobs processed: 9818
Avg queueing time:    1.8523
Max queueing time:    10.5473
Standard deviation:   1.3826

End run of OMNeT++
</pre>
<p>
As Cmdenv runs the simulation, periodically it prints the sequence number
of the current event, the simulation time, the elapsed (real) time,
and the performance of the simulation (how many events are processed per
second; the first two values are 0 because there wasn't enough data
for it to calculate yet). At the end of the simulation, the <tt>finish()</tt>
methods of the simple modules are run, and the output from them are displayed.
On my machine this run took 34 seconds. This Cmdenv output can be
customized via <tt>omnetpp.ini</tt> entries. The output file <tt>fifo1.vec</tt>
contains vector data recorded during simulation (here, queueing times),
and it can be processed using Plove or other tools.

<p><H3><A NAME="sec319"/>10.2.2. The concept of simulation runs</H3>

<p>OMNeT++ can execute several simulation runs automatically one after
another. If multiple runs are
selected, option settings and parameter values can be given either
individually for each run, or together for all runs, depending in
which section the option or parameter appears.

<p><H3><A NAME="sec320"/>10.2.3. File syntax</H3>

<p>The ini file is a text file consisting of entries grouped into different sections.
The order of the sections doesn't matter. Also, if you have two sections
with the same name (e.g. <tt>[General]</tt> occurs twice in the file),
they will be merged.

<p>Lines that start with "#" or ";" are comments, and will be ignored during
processing.

<p>Long lines can be broken up using the backslash notation: if the last character
of a line is "\", it will be merged with the next line.

<p>The size of the ini file (the number of sections and entries) is not limited.
Currently there is a 1024-character limit on the line length,
which <EM>cannot</EM> be increased by breaking up the line using backslashes.
This limit might be lifted in future releases.

<p>Example:

<pre>
[General]
# this is a comment
foo="this is a single value \
for the foo parameter"

[General]  # duplicate sections are merged
bar="belongs to the same section as foo"
</pre>
<p>
<H3><A NAME="sec321"/>10.2.4. File inclusion</H3>

<p>OMNeT++ supports including an ini file in another,
via the <tt>include</tt> keyword. This feature allows you to partition large ini
files into logical units, fixed and varying part etc.

<p>An example:

<pre>
# omnetpp.ini
...
include parameters.ini
include per-run-pars.ini
...
</pre>
<p>

<p><H3><A NAME="sec322"/>10.2.5. Sections</H3>

<p>The following sections can exist:

<p><table border>
<TR> <TD align=left>

<p><b>Section</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left> <tt>[General]</tt> </TD> <TD align=left> Contains general settings that apply to all simulation runs
and all user interfaces. For details, see section <a href="#sec:ch-run-sim:general-section">[click]</a>.
</TD></TR>
<TR> <TD align=left> <tt>[Run 1]</tt>, <tt>[Run 2]</tt>, ...  </TD> <TD align=left> Contains per-run settings.
These sections may contain any entries that are accepted in other
sections.
</TD></TR>
<TR> <TD align=left> <tt>[Cmdenv]</tt> </TD> <TD align=left> Contains Cmdenv-specific settings.
For details, see section <a href="#sec:ch-run-sim:cmdenv-section">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Tkenv]</tt> </TD> <TD align=left> Contains Tkenv-specific settings.
For details, see section <a href="#sec:ch-run-sim:tkenv-section">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Parameters]</tt> </TD> <TD align=left> Contains values for module parameters that did not
get a value (or got <tt>input</tt> value) inside the NED files.
For details, see section <a href="#sec:ch-run-sim:parameter-settings">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[OutVectors]</tt> </TD> <TD align=left> Configures recording of output vectors. You can specify
filtering by vector names and by simulation time (start/stop recording).
For details, see section <a href="#sec:ch-run-sim:outvectors-section">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[DisplayStrings]</tt> </TD> <TD align=left> Module display strings for Tkenv.
For details, see section <a href="#sec:ch-run-sim:displaystrings-section">[click]</a>
</TD></TR>
<TR> <TD align=left> </table>

<p>

<p><H3><A NAME="sec323"/>10.2.6. The [General] section</H3>
<a name="sec:ch-run-sim:general-section"></a>

<p>The most important options of the <SAMP>[General]</SAMP> section are the
following.
<UL>
  <li><strong></strong>The <tt>ini-warnings</tt> option can be used for ``debugging'' ini
    files: if enabled, it lists which options were searched for but
    not found.
  <li><strong></strong>The <tt>network</tt> option selects the model to be set up and run.
  <li><strong></strong>The length of the simulation can be set with the
    <tt>sim-time-limit</tt> and the <tt>cpu-time-limit</tt> options (the
    usual time units such as ms, s, m, h, etc. can be used).
  <li><strong></strong>The output file names can be set with the following options:
    <tt>output-vector-file</tt>, <tt>output-scalar-file</tt> and <tt>snapshot-file</tt>.
</UL>

<p>The full list of supported options follows. Almost every one these options
can also be put into the <tt>[Run <EM>n</EM>]</tt> sections. Per-run settings
have priority over globally set ones.

<p>
<table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>[General]</b> </TD></TR>
<TR> <TD align=left> <tt>ini-warnings</tt> = yes </TD> <TD align=left> Helps debugging of the ini file. If turned
on, OMNeT++ prints out the name of the entries it that it wanted to
read but they were not in the ini file.</TD></TR>
<TR> <TD align=left> <tt>network</tt> = </TD> <TD align=left> The name of the network to be simulated. </TD></TR>
<TR> <TD align=left> <tt>snapshot-file</tt> = omnetpp.sna </TD> <TD align=left> Name of the snapshot file. The result of
each <tt>snapshot()</tt> call will be appended to this file. </TD></TR>
<TR> <TD align=left> <tt>output-vector-file</tt> = omnetpp.vec </TD> <TD align=left> Name of output vector file. </TD></TR>
<TR> <TD align=left> <tt>output-scalar-file</tt> = omnetpp.sca </TD> <TD align=left> Name of output scalar file. </TD></TR>
<TR> <TD align=left> <tt>pause-in-sendmsg</tt> = no </TD> <TD align=left> Only makes sense with step-by-step execution.
If enabled, OMNeT++ will split <tt>send()</tt> calls to two steps.</TD></TR>
<TR> <TD align=left> <tt>sim-time-limit</tt> = </TD> <TD align=left> Duration of the simulation in simulation time.</TD></TR>
<TR> <TD align=left> <tt>cpu-time-limit</tt> = </TD> <TD align=left> Duration of the simulation in real time.</TD></TR>
<TR> <TD align=left> <tt>random-seed</tt> = </TD> <TD align=left> Random number seed for generator 0. Should be nonzero.</TD></TR>
<TR> <TD align=left> <tt>gen0-seed</tt> =  <br>
<tt>gen1-seed</tt> =  <br>
... </TD> <TD align=left> Seeds for the given random number generator. They should be
nonzero. <tt>gen0-seed</tt> is equivalent to <tt>random-seed</tt>.</TD></TR>
<TR> <TD align=left> <tt>total-stack-kb</tt> = </TD> <TD align=left> Specifies the total stack size (sum of all coroutine stacks)
in kilobytes. You need to increase this value if you get the
``Cannot allocate coroutine stack...'' error.</TD></TR>
<TR> <TD align=left> <tt>load-libs</tt> = </TD> <TD align=left>  Name of shared libraries (.so files) to load after startup.
You can use it to load simple module code etc. Example:

<p><tt>load-libs</tt> = <tt>../x25/x25.so ../lapb/lapb.so</tt></TD></TR>
<TR> <TD align=left> <tt>netif-check-freq</tt> = </TD> <TD align=left> Used with parallel execution.</TD></TR>
<TR> <TD align=left> <tt>outputvectormanager-class</tt> = <br>
<tt>cFileOutputVectorManager</tt>
</TD> <TD align=left>
Part of the Envir plugin mechanism: defines the name of
the output vector manager class to be used to record data from output
vectors.  The class has to implement the
<tt>cOutputVectorManager</tt> interface defined in <tt>envirext.h</tt>.</TD></TR>
<TR> <TD align=left> <tt>outputscalarmanager-class</tt> = <br>
<tt>cFileOutputScalarManager</tt>
</TD> <TD align=left>
Part of the Envir plugin mechanism: defines the name of the output
scalar manager class to be used to record data passed to
<tt>recordScalar()</tt>. The class has to implement the
<tt>cOutputScalarManager</tt> interface defined in <tt>envirext.h</tt>.
</TD></TR>
<TR> <TD align=left> <tt>snapshotmanager-class</tt> = <br>
<tt>cFileSnapshotManager</tt>
</TD> <TD align=left>
Part of the Envir plugin mechanism: defines the name of the class to
handle streams to which <tt>snapshot()</tt> writes its output.  The
class has to implement the <tt>cSnapshotManager</tt> interface defined
in <tt>envirext.h</tt>.</TD></TR>
<TR> <TD align=left> 
</table>

<p><hr><H2><A NAME="sec324"/>10.3. Cmdenv: the command-line interface</H2>

<p>The command line user interface is
a small, portable and fast user interface that compiles and runs on
all platforms. Cmdenv is designed primarily for batch execution.

<p>Cmdenv uses simply executes some or all simulation runs that are described
in the configuration file. If one run stops with an error message,
subsequent ones will still be executed. The runs to be executed can be
passed via command-line argument or in the ini file.

<p><H3><A NAME="sec325"/>10.3.1. Command-line switches</H3>

<p>A simulation program built with Cmdenv accepts the following command line
switches:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left> 
  <tt>-f</tt> <SAMP>&lt;</SAMP><EM>fileName<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <SAMP>omnetpp.ini</SAMP>.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left> 
  <tt>-l</tt> <SAMP>&lt;</SAMP><EM>fileName<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  Load a shared object (<SAMP>.so</SAMP> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <SAMP>.so</SAMP> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<SAMP>_n.o</SAMP> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <SAMP>gcc -shared...</SAMP>)</TD></TR>
<TR> <TD align=left> 
  <tt>-r</tt> <SAMP>&lt;</SAMP><EM>runs<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  It specifies which runs should be executed (e.g. <tt>-r 2,4,6-8</tt>).
  This option overrides the <SAMP>runs-to-execute=</SAMP> option
  in the <SAMP>[Cmdenv]</SAMP> section of the ini file
  (see later).</TD></TR>
</table>

<p>All other options are read from the configuration file.

<p>An example of running an OMNeT++ executable with the -h flag:

<pre>

% ./fddi -h

OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Command line switches:
  -h            print this help and exit.
  -f &lt;inifile&gt;  use the given ini file instead of omnetpp.ini.
  -r &lt;runs&gt;     execute the specified runs in the ini file.
                &lt;runs&gt; is a comma-separated list of run numbers or
                run number ranges, for example 1,2,5-10.
  -l &lt;library&gt;  load the specified shared library on startup.
                The library can contain modules, networks, etc.

Available networks:
  FDDI1
  NRing
  TUBw
  TUBs

Available modules:
  FDDI_MAC
  FDDI_MAC4Ring
  ...

Available channels:


End run of OMNeT++
</pre>
<p>

<p><H3><A NAME="sec326"/>10.3.2. Cmdenv ini file options</H3>
<a name="sec:ch-run-sim:cmdenv-section"></a>

<p>Cmdenv can be executed in two modes, selected by the <tt>express-mode</tt> ini file entry:

<p><UL>
    <li><strong></strong> <b>Normal</b> (non-express) mode is for debugging: detailed information
        will be written to the standard output (event banners, module output,
        etc).
    <li><strong></strong> <b>Express</b> mode can be used for long simulation runs: only
        periodical status update is displayed about the progress of the
        simulation.
</UL>

<p>The full list of ini file options recognized by Cmdenv:

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left colspan=2><b>[Cmdenv]</b></TD></TR>
<TR> <TD align=left> <tt>runs-to-execute</tt> = </TD> <TD align=left> Specifies which simulation runs should be executed.
It accepts a comma-separated list of run numbers or run number ranges, e.g.
<tt>1,3-4,7-9</tt>. If the value is missing, Cmdenv executes all runs that have
ini file sections; if no runs are specified in the ini file, Cmdenv does one run.
The -r command line option overrides this ini file setting. </TD></TR>
<TR> <TD align=left> <tt>express-mode</tt>=yes/no (default: no) </TD> <TD align=left> Selects ``normal'' (debug/trace) or ``express'' mode.
</TD></TR>
<TR> <TD align=left> <tt>module-messages</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing module ev&lt;&lt; output on/off </TD></TR>
<TR> <TD align=left> <tt>event-banners</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing event banners on/off </TD></TR>
<TR> <TD align=left> <tt>message-trace</tt>=yes/no (default: no) </TD> <TD align=left> In normal mode only: print a line
about each message sending (by <tt>send()</tt>,<tt>scheduleAt()</tt>, etc)
and delivery on the standard output </TD></TR>
<TR> <TD align=left> <tt>autoflush</tt>=yes/no (default: no) </TD> <TD align=left>  Call <tt>fflush(stdout)</tt> after each
event banner or status update; affects both express and normal mode. Turning on
autoflush can be useful with printf-style debugging for tracking down
program crashes. </TD></TR>
<TR> <TD align=left> <tt>status-frequency</tt>=&lt;integer&gt; (default: 50000) </TD> <TD align=left> In express mode only:
print status update every n events (on today's computers, and
for a typical model, this will produce an update every few seconds,
perhaps a few times per second) </TD></TR>
<TR> <TD align=left> <tt>performance-display</tt>=yes/no (default: yes) </TD> <TD align=left> In express mode only:
print detailed performance information. Turning it on results in a 3-line
entry printed on each update, containing ev/sec, simsec/sec, ev/simsec,
number of messages created/still present/currently scheduled in FES.
</TD></TR>
<TR> <TD align=left> <tt>extra-stack</tt> = 16384 </TD> <TD align=left> Specifies the extra amount of stack
(bytes) that is reserved for each <tt>activity()</tt>
simple module when the simulation is linked with Cmdenv. </TD></TR>
</table>

<p><H3><A NAME="sec327"/>10.3.3. Interpreting Cmdenv output</H3>
<a name="sec:ch-run-sim:interpreting-cmdenv-output"></a>

<p>When the simulation is running in ``express'' mode with detailed
performance display enabled, Cmdenv periodically outputs a three-line
status info about the progress of the simulation.
The output looks like this:

<pre>
...
** Event #250000   T=123.74354 ( 2m  3s)    Elapsed: 0m 12s
     Speed:     ev/sec=19731.6   simsec/sec=9.80713   ev/simsec=2011.97
     Messages:  created: 55532   present: 6553   in FES: 8
** Event #300000   T=148.55496 ( 2m 28s)    Elapsed: 0m 15s
     Speed:     ev/sec=19584.8   simsec/sec=9.64698   ev/simsec=2030.15
     Messages:  created: 66605   present: 7815   in FES: 7
...
</pre>
<p>
The first line of the status display (beginning with <tt>**</tt>)
contains:

<p><UL>
   <li><strong></strong>how many events have been processed so far
   <li><strong></strong>the current simulation time (T), and
   <li><strong></strong>the elapsed time (wall clock time) since the beginning of the simulation run.
</UL>

<p>The second line displays info about simulation performance:

<p><UL>
   <li><strong></strong><tt>ev/sec</tt> indicates <EM>performance</EM>: how many events are processed
     in one real-time second.  On one hand it depends on your hardware
     (faster CPUs process more events per second), and on the other hand
     it depends on the complexity (amount of calculations) associated
     with processing one event. For example, protocol simulations tend to require
     more processing per event than e.g. queueing networks, thus
     the latter produce higher ev/sec values.
     In any case, this value is independent of the size (number of modules) in your model.
   <li><strong></strong><tt>simsec/sec</tt> shows <EM>relative speed</EM> of the simulation, that is,
     how fast the simulation is progressing compared to real time, how many
     simulated seconds can be done in one real second. This value virtuall depends
     on everything: on the hardware, on the size of the simulation model,
     on the complexity of events, and the average simulation time between events as well.
   <li><strong></strong><tt>ev/simsec</tt> is the <EM>event density</EM>: how many events are
     there per simulated second. Event density only depends on the simulation model,
     regardless of the hardware used to simulate it: in a cell-level ATM simulation
     you'll have very hight values ($10^9$), while in a bank teller simulation
     this value is probably well under 1. It also depends on the size of your
     model: if you double the number of modules in your model, you can expect
     the event density double, too.
</UL>

<p>The third line displays the number of messages, and it is important
because it may indicate the `health' of your simulation.

<p><UL>
   <li><strong></strong><tt>Created</tt>: total number of message objects created since the
     beginning of the simulation run. This does not mean that this many message
     object actually exist, because some (many) of them may have been deleted
     since then. It also does not mean that <EM>you</EM> created all those
     messages - the simulation kernel also creates messages for its own use
     (e.g. to implement <tt>wait()</tt> in an <tt>activity()</tt> simple module).
   <li><strong></strong><tt>Present</tt>: the number of message objects currently present
     in the simulation model, that is, the number of messages created (see above)
     minus the number of messages already deleted. This number includes
     the messages in the FES.
   <li><strong></strong><tt>In FES</tt>: the number of messages currently scheduled in the
     Future Event Set.
</UL>

<p>
The second value, the number of messages present is more useful than
perhaps one would initially think. It can indicator of the `health' of the simulation:
if it is growing steadily, then either you have a memory leak and losing
messages (which indicates a programming error), or the network you simulate is
overloaded and queues are steadily filling up (which might indicate wrong input
parameters).

<p>Of course, if the number of messages does not increase, it does not mean
that you do <EM>not</EM> have a memory leak (other memory leaks are also
possible). Nevertheless the value is still useful, because by far the
most common way of leaking memory in a simulation is by not deleting messages.

<p>

<p><hr><H2><A NAME="sec328"/>10.4. Tkenv: the graphical user interface</H2>

<p><br><P class="subheading">Features</P>

<p>Tkenv is a portable graphical windowing user interface.
Tkenv supports interactive execution of the simulation, tracing and
debugging. Tkenv is recommended in the
development stage of a simulation or for presentation and educational
purposes, since it allows one to get a detailed picture of the state
of simulation at any point of execution and to follow what happens
inside the network. The most important feaures are:
<UL>
  <li><strong></strong>message flow animation
  <li><strong></strong>graphical display of statistics (histograms etc.) and output
    vectors during simulation execution
  <li><strong></strong>separate window for each module's text output
  <li><strong></strong>scheduled messages can be watched in a window as simulation
    progresses
  <li><strong></strong>event-by-event, normal and fast execution
  <li><strong></strong>labeled breakpoints
  <li><strong></strong>inspector windows to examine and alter objects and variables
    in the model
  <li><strong></strong>simulation can be restarted
  <li><strong></strong>snapshots (detailed report about the model: objects, variables
    etc.)
</UL>

<p>
Tkenv makes it possible to view simulation results (output vectors
etc.) during execution. Results can be displayed as histograms and
time-series diagrams. This can speed up the process of verifying the
correct operation of the simulation program and provides a good
environment for experimenting with the model during execution.  When
used together with <tt>gdb</tt> or <tt>xxgdb</tt>, Tkenv can speed up
debugging a lot.

<p>Tkenv is built with Tcl/Tk, and it work on all platforms where
Tcl/Tk has been ported to: Unix/X, Windows, Macintosh.
You can get more information about Tcl/Tk on the Web pages listed
in the Reference.

<p><H3><A NAME="sec329"/>10.4.1. Command-line switches</H3>

<p>A simulation program built with Tkenv accepts the following command line
switches:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left> 
  <tt>-f </tt><EM>&lt;fileName&gt;</EM>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <SAMP>omnetpp.ini</SAMP>.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left> 
  <tt>-l </tt><EM>&lt;fileName&gt;</EM>
  </TD> <TD align=left>
  Load a shared object (<SAMP>.so</SAMP> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <SAMP>.so</SAMP> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<SAMP>_n.o</SAMP> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <SAMP>gcc -shared...</SAMP>)</TD></TR>
</table>

<p><H3><A NAME="sec330"/>10.4.2. Tkenv ini file settings</H3>
<a name="sec:ch-run-sim:tkenv-section"></a>

<p>Tkenv accepts several settings in the <tt>[Tkenv]</tt> section of the ini file.
These settings can also be set within the graphical environment too,
via menu items and dialogs.

<p>
<table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>[Tkenv]</b></TD></TR>
<TR> <TD align=left> <tt>default-run</tt> = 1 </TD> <TD align=left> Specifies which run Tkenv should set up
automatically after startup. If there's no default-run= entry or the
value is 0, Tkenv will ask which run to set up. </TD></TR>
<TR> <TD align=left> <tt>use-mainwindow</tt> = yes </TD> <TD align=left> Enables/disables writing <EM>ev</EM> output to the Tkenv main window. </TD></TR>
<TR> <TD align=left> <tt>print-banners</tt> = yes </TD> <TD align=left> Enables/disables printing banners for
each event.</TD></TR>
<TR> <TD align=left> <tt>breakpoints-enabled</tt> = yes </TD> <TD align=left> Specifies whether the simulation
should be stopped at each <tt>breakpoint()</tt> call in the
simple modules. </TD></TR>
<TR> <TD align=left> <tt>update-freq-fast</tt> = 10 </TD> <TD align=left> Number of events executed between two
display updates when in <EM>Fast</EM> execution mode. </TD></TR>
<TR> <TD align=left> <tt>update-freq-express</tt> = 500 </TD> <TD align=left> Number of events executed between
two display updates when in <EM>Express</EM> execution mode. </TD></TR>
<TR> <TD align=left> <tt>animation-delay</tt> = 0.3s </TD> <TD align=left> Delay between steps when you slow-execute the simulation. </TD></TR>
<TR> <TD align=left> <tt>animation-enabled</tt> = yes </TD> <TD align=left> Enables/disables message flow animation. </TD></TR>
<TR> <TD align=left> <tt>animation-msgnames</tt> = yes </TD> <TD align=left> Enables/disables displaying message names during message flow
animation. </TD></TR>
<TR> <TD align=left> <tt>animation-msgcolors</tt> = yes </TD> <TD align=left> Enables/disables using different colors
for each message kind during message flow animation. </TD></TR>
<TR> <TD align=left> <tt>animation-speed</tt> = 1.0 </TD> <TD align=left> Specifies the speed of message flow animation. </TD></TR>
<TR> <TD align=left> <tt>extra-stack</tt> = 32768 </TD> <TD align=left> Specifies the extra amount of stack
(bytes) that is reserved for each <EM><tt>activity()</tt></EM>
simple module when the simulation is linked with
Tkenv. </TD></TR>
</table>

<p>
<H3><A NAME="sec331"/>10.4.3. Using the graphical environment</H3>

<p><br><P class="subheading">Simulation running modes in Tkenv</P>

<p>
Tkenv has the following modes for running the simulation :

<p><UL>
   <li><strong></strong>Step
   <li><strong></strong>Run
   <li><strong></strong>Fast run
   <li><strong></strong>Express run
</UL>

<p>
The running modes have their corresponding buttons on Tkenv's
toolbar.

<p>
In <b>Step</b> mode, you can execute the simulation event-by-event.

<p>In <b>Run</b> mode, the simulation runs with all tracing aids on.
Message animation is active and inspector windows are updated
after each event. Output messages are displayed in the main window
and module output windows. You can stop the simulation with the
Stop button on the toolbar. You can fully interact with the user
interface while the simulation is running: you can open inspectors
etc.

<p>In <b>Fast</b> mode, animation is turned off. The inspectors and
the message output windows are updated after each 10 events (the
actual number can be set in Options|Simulation options and
also in the ini file). Fast mode is several times faster than
the Run mode; the speedup can get close to 10 (or the configured
event count).

<p>In <b>Express</b> mode, the simulation runs at about the same speed
as with Cmdenv, all tracing disabled. Module output is not recorded
in the output windows any more. You can interact with the simulation
only once in a while (1000 events is the default as I recall),
thus the run-time overhead of the user interface is minimal.
You have to explicitly push the Update inspectors button if you
want an update.

<p>Tkenv has a status bar which is regularly updated while the simulation
is running. The gauges displayed are similar to those in Cmdenv,
described in section <a href="#sec:ch-run-sim:interpreting-cmdenv-output">[click]</a>.

<p>
<br><P class="subheading">Inspectors</P>

<p>
In Tkenv, objects can be viewed through inspectors. To start, choose
Inspect|Network from the menu. Usage should be obvious; just
use double-clicks and popup menus that are brought up by
right-clicking. In Step, Run and Fast Run modes, inspectors are
updated automatically as the simulation progresses. To make ordinary
variables (int, double, char etc.) appear in Tkenv, use the
<tt>WATCH()</tt> macro in the C++ code.

<p>Tkenv inspectors also display the object pointer, and can also copy
the pointer value to the clipboard. This can be invaluable for debugging:
when the simulation is running under a debugger like gdb or the MSVC IDE,
you can paste the object pointer into the debugger and have closer look
at the data structures.

<p>
<br><P class="subheading">Configuring Tkenv</P>

<p>
In case of nonstandard installation, it may be necessary to set the
<tt>OMNETPP_TKENV_DIR</tt> environment variable so that Tkenv can find
its parts written in Tcl script.

<p><p>
The default path from where the icons are loaded can be changed with
the <tt>OMNETPP_BITMAP_PATH</tt> variable, which is a
semicolon-separated list of directories and defaults to
``<EM>omnetpp-dir</EM>/bitmaps;.;./bitmaps''.
</p>

<p><br><P class="subheading">Embedding Tcl code into the executable</P>

<p>A significant part of Tkenv is written in Tcl, in several
<SAMP>.tcl</SAMP> script files. The default location of the scripts is
passed compile-time to <SAMP>tkapp.cc</SAMP>, and it can be overridden at
run-time by the <tt>OMNETPP_TKENV_DIR</tt> environment variable. The
existence of a separate script library can be inconvenient if you want
to carry standalone simulation executables to different machines. To
solve the problem, there is a possibility to compile the script parts
into Tkenv.

<p>The details: the <tt>tcl2c</tt> program (its C source is there in the
Tkenv directory) is used to translate the <SAMP>.tcl</SAMP> files into C
code (<SAMP>tclcode.cc</SAMP>), which gets included into
<SAMP>tkapp.cc</SAMP>. This possibility is built into the makefiles
and can be optionally enabled.

<p><H3><A NAME="sec332"/>10.4.4. In Memoriam... </H3>

<p>There used to be other windowing user interfaces which have been removed
from the distribution:

<p><UL>
  <li><strong></strong> <b>TVEnv</b>. A Turbo Vision-based user interface, the first
    interactive UI for OMNeT++. Turbo Vision was an excellent
    character-graphical windowing environment, originally shipped with
    Borland C++ 3.1.
  <li><strong></strong> <b>XEnv</b>. A GUI written in pure X/Motif. It was an
    experiment, written before I stumbled into Tcl/Tk and discovered
    its immense productivity in GUI building. XEnv never got too far
    because it was really very-very slow to program in Motif...
</UL>

<p>
<hr><H2><A NAME="sec333"/>10.5. More about omnetpp.ini</H2>

<p>
<H3><A NAME="sec334"/>10.5.1. Module parameters in the configuration file</H3>
<a name="sec:ch-run-sim:parameter-settings"></a>


<p>Values for module parameters go into the <SAMP>[Parameters]</SAMP> or the
<SAMP>[Run 1]</SAMP>, <SAMP>[Run 2]</SAMP> etc. sections of the ini file. The
run-specific settings take precedence over the overall settings.
Parameters that were assigned a (non-input) value in the NED file are
not influenced by ini file settings.

<p>Wildcards (*,?) can be used to supply values
to several model parameters at a time. Filename-style (glob) and not
regex-style pattern matching is used. Character ranges use curly
braces instead of square brackets to avoid interference with the
notation of module vectors: {a-zA-Z}. If a parameter name matches
several wildcards-patterns, the first matching occurrence is used.

<p>
An example ini file:

<p><pre>
# omnetpp.ini

<p><b>[Parameters]</b>
token.num_stations = 3
token.num_messages = 10000

<p><b>[Run 1]</b>
token.stations[*].wait_time = 10ms

<p><b>[Run 2]</b>
token.stations[0].wait_time = 5ms
token.stations[*].wait_time = 1000ms
</pre>

<p>
<H3><A NAME="sec335"/>10.5.2. Configuring output vectors</H3>
<a name="sec:ch-run-sim:outvectors-section"></a>

<p>As a simulation program is evolving, it is becoming capable of
collecting more and more statistics. The size of output vector
files can easily reach a magnitude of
several ten or hundred megabytes, but very often, only some of the
recorded statistics are interesting to the analyst.

<p>
In OMNeT++, you can control how <tt>cOutVector</tt> objects record data
to disk. You can turn output vectors on/off or you can assign a result
collection interval. Output vector configuration is given in the
<SAMP>[OutVectors]</SAMP> section of the ini file, or in the <SAMP>[Run
  1]</SAMP>, <SAMP>[Run 2]</SAMP> etc sections individually for each run. By
default, all output vectors are turned on.

<p>
Entries configuring output vectors can be like that:

<p><pre>
<EM>module-pathname</EM>.<EM>objectname</EM>.enabled = yes/no
<EM>module-pathname</EM>.<EM>objectname</EM>.interval = <EM>start</EM>..<EM>stop</EM>
<EM>module-pathname</EM>.<EM>objectname</EM>.interval = ..<EM>stop</EM>
<EM>module-pathname</EM>.<EM>objectname</EM>.interval = <EM>start</EM>..
</pre>

<p>The object name is the string passed to <tt>cOutVector</tt> in its constructor
or with the <tt>setName()</tt> member function.

<pre>
cOutVector eed("End-to-End Delay",1);
</pre>
<p>
Start and stop values can be any time specification accepted
in NED and config files (e.g. <EM>10h 30m 45.2s</EM>).

<p>
As with parameter names, wildcards are allowed in the object
names and module path names.

<p>An example:

<pre>
#
# omnetpp.ini
#

[OutVectors]
*.interval = 1s..60s
*.End-to-End Delay.enabled = yes
*.Router2.*.enabled = yes
*.enabled = no
</pre>
<p>

<p>The above configuration limits collection of all output vectors
to the 1s..60s interval, and disables collection of output vectors
except all end-to-end delays and the ones in any module called Router2.



<p><H3><A NAME="sec336"/>10.5.3. Display strings</H3>
<a name="sec:ch-run-sim:displaystrings-section"></a>

<p>Display strings control the modules' graphical
appearance in the Tkenv user interface. Display strings can be
assigned to modules, submodules and gates (a connection's display
string is stored in its ``from'' gate). Display strings can be
hardcoded into the NED file or specified in the configuration file.
(Hardcoded display strings take precedence over the ones given in ini
files.) Format of display string are documented in section
<a href="#sec:ch-ned-lang:display-strings">[click]</a>).

<p>Display strings can appear in the <SAMP>[DisplayStrings]</SAMP> section of
the ini file. They are expected as entries in one of the following
forms:

<pre>
moduletype = "..."
moduletype.submodulename = "..."

moduletype.inputgatename = "..."
moduletype.submodulename.outputgatename = "..."
</pre>
<p>
As with parameter names, wildcards
are allowed in module types, submodule and gate names.

<p>
<H3><A NAME="sec337"/>10.5.4. Specifying seed values</H3>

<p>As is was pointed out earlier, it is of great importance that
different simulation runs and different random number sources
within one simulation run use non-overlapping sequences of random
numbers.

<p>
In OMNeT++, you have three choices:
<OL>
  <li><strong></strong>Automatic seed selection.
  <li><strong></strong>Specify seeds in the ini file (with the help of the seedtool
    program, see later)
  <li><strong></strong>Manually set the seed from within the program.
</OL>

<p>If you decide for automatic seed selection,
do not specify any seed value in the ini file. For the
random number generators, OMNeT++ will automatically select seeds that
are 1,000,000 values apart in the sequence. If you have several runs,
each run is started with a fresh set of seeds that are 1,000,000
values apart from the seeds used for previous runs. Since the
generation of new seed values is costly, OMNeT++ has a table of
pre-calculated seeds (256 values); if they are all used up, OMNeT++
starts from the beginning of the table again.

<p><STRONG>Warning!</STRONG> Be aware that each time the simulation program
is started, OMNeT++ starts assigning seeds from the beginning
of the table. That is, if you execute Run 1, Run 2, Run 3 one
at a time (e.g. from a shell script, using the Cmdenv -r command-line
flag), all your runs will be executed using the <EM>same</EM> seeds!
This behavior is almost surely not what you want, and it will be
fixed in future versions of OMNeT++. Until then, it is a good
idea to stick to manually generating seeds and explicitly adding them
to the ini file.

<p>
Automatic seed selection may not be appropriate for you for several
reasons. First, you may need more than 256 seeds values; or, if you
use variance reduction techniques, you may want to use the same seeds
for several simulation runs. In this case, there is a standalone
program to generate appropriate seed values (<tt>seedtool</tt> will be
discussed in Section <a href="#sec:ch-run-sim:choosing-good-seed">[click]</a>), and you
can specify the seeds explicitly in the ini file.

<p>
The following ini file explicitly initializes two of the random
number generators, and uses different seed values for each run:

<pre>
[Run 1]
gen0-seed = 1768507984
gen1-seed = 33648008

[Run 2]
gen0-seed = 1082809519
gen1-seed = 703931312
...
</pre>
<p>

<p>If you want the same seed values for all runs, you will write
something like this:

<pre>
[General]
gen0-seed = 1768507984
gen1-seed = 33648008
</pre>
<p>

<p>All other random number generators (2,3,...) will have their seeds
automatically assigned.  As a third way, you can also set the seed
values from the code of a simple module using
<tt>genk_randseed()</tt>, but I see no reason why you would want to do
so.

<p>
<hr><H2><A NAME="sec338"/>10.6. Choosing good seed values: the seedtool utility</H2>
<a name="sec:ch-run-sim:choosing-good-seed"></a>

<p>For selecting good seeds, the <tt>seedtool</tt> program can be used (it
is in the utils directory). When started without command-line
arguments, the program prints out the following help:

<pre>
seedtool - part of OMNeT++, (c) 1992-2001 Andras Varga, TU Budapest
See the license for distribution terms and warranty disclaimer.

A tool to help select good random number generator seed values.
Usage:
  seedtool i seed         - index of `seed' in cycle
  seedtool s index        - seed at index `index' in cycle
  seedtool d seed1 seed2  - distance of `seed1' and `seed2' in cycle
  seedtool g seed0 dist   - generate seed `dist' away from `seed0'
  seedtool g seed0 dist n - generate `n' seeds `dist' apart, starting
                            at `seed0'
  seedtool t              - generate hashtable
  seedtool p              - print out hashtable
</pre>
<p>

<p>The last two options, p and t were used internally to generate
a hash table of pre-computed seeds that greatly speeds up the
tool. For practical use, the g option is the most important.
Suppose you have 4 simulation runs that need two independent
random number generators each and you want to start their seeds
at least 10,000,000 values apart. The first seed value can be
simply 1. You would type the following command:

<pre>
C:\OMNETPP\UTILS&gt; seedtool g 1 10000000 8
</pre>
<p>

<p>The program outputs 8 numbers that can be used as random number
seeds:

<pre>
1768507984
33648008
1082809519
703931312
1856610745
784675296
426676692
1100642647
</pre>
<p>

<p>You would specify these seed values in the ini file.

<p>

<p><hr><H2><A NAME="sec339"/>10.7. Repeating or iterating simulation runs</H2>

<p>Once your model works reliably, you'll usually want to run several
simulations. You may want to run the model with various
parameter settings, or you may want <EM>(should want?)</EM> to
run the same model with the same parameter settings but with
different random number generator seeds, to achieve statistically
more reliable results.

<p>Running a simulation several times by hand can easily become tedious,
and then a good solution is to write a control script that
takes care of the task automatically. Unix shell is
a natural language choice to write the control script in,
but other languages like Perl, Matlab/Octave, Tcl, Ruby might also have
justification for this purpose.

<p>The next sections are only for Unix users. We'll use the
Unix `Bourne' shell (<tt>sh</tt>, <tt>bash</tt>) to write the control script.
If you'd prefer Matlab/Octave, the <tt>contrib/octave/</tt> directory
contains example scripts (contributed by Richard Lyon).

<p>
<H3><A NAME="sec340"/>10.7.1. Executing several runs</H3>

<p>In simple cases, you may define all simulation runs needed in the
<tt>[Run 1]</tt>, <tt>[Run 2]</tt>, etc. sections of <tt>omnetpp.ini</tt>,
and invoke your simulation with the -r flag each time.
The -f flag lets you use a file name different from <tt>omnetpp.ini</tt>.

<p>The following script executes a simulation named <tt>wireless</tt>
several times, with parameters for the different runs
given in the <tt>runs.ini</tt> file.

<pre>
#! /bin/sh
./wireless -f runs.ini -r 1
./wireless -f runs.ini -r 2
./wireless -f runs.ini -r 3
./wireless -f runs.ini -r 4
...
./wireless -f runs.ini -r 10
</pre>
<p>
To run the above script, type it in a text file called e.g. <tt>run</tt>,
give it <tt>x</tt> (executable) permission using <tt>chmod</tt>,
then you can execute it by typing <tt>./run</tt>:

<pre>
% chmod +x run
% ./run
</pre>
<p>
You can simplify the above script by using a <EM>for</EM> loop.
In the example below, the variable <tt>i</tt> iterates through
the values of list given after the <tt>in</tt> keyword.
It is very practical, since you can leave out or add runs,
or change the order of runs by simply editing the list -
to demonstrate this, we skip run 6, and include run 15 instead.

<pre>
#! /bin/sh
for i in 3 2 1 4 5 7 15 8 9 10; do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>
If you have many runs, you can use a C-style loop:

<pre>
#! /bin/sh
for ((i=1; $i&lt;50; i++)); do
   ./wireless -f runs.ini -r $i
done
</pre>
<p>

<p><H3><A NAME="sec341"/>10.7.2. Variations over parameter values</H3>

<p>It may not be practical to hand-write descriptions of all runs
in an ini file, especially if there are many parameter
settings to try, or you want to try all possible
combinations of two or more parameters.
The solution might be to generate only a small fraction
of the ini file with the variable parameters, and
use it via ini file inclusion. For example, you might
write your <tt>omnetpp.ini</tt> like this:

<pre>
[General]
network = Wireless

[Parameters]
Wireless.n = 10
...   # other fixed parameters
include params.ini  # include variable part
</pre>
<p>
And have the following as control script. It uses two nested loops to explore
all possible combinations of the <EM>alpha</EM> and <EM>beta</EM> parameters.
Note that <tt>params.ini</tt> is created by redirecting the <tt>echo</tt>
output into file, using the <tt>&gt;</tt> and <tt>&gt;&gt;</tt> operators.

<pre>
#! /bin/sh
for alpha in 1 2 5 10 20 50; do
   for beta in 0.1 0.2 0.3 0.4 0.5; do
       echo "Wireless.alpha=$alpha" &gt; params.ini
       echo "Wireless.beta=$beta" &gt;&gt; params.ini
       ./wireless
   done
done
</pre>
<p>

<p>As a heavy-weight example, here's the ``runall'' script of
Joel Sherrill's <EM>File System Simulator</EM>. It also demonstrates
that loops can iterate over string values too, not just numbers.
(<SAMP>omnetpp.ini</SAMP> includes the generated <SAMP>algorithms.ini</SAMP>.)

<p>Note that instead of redirecting every <tt>echo</tt> command to file,
they are grouped using parentheses, and redirected together.
The net effect is the same, but you can spare some typing this way.

<pre>
#! /bin/bash
#
# This script runs multiple variations of the file system simulator.
#
all_cache_managers="NoCache FIFOCache LRUCache PriorityLRUCache..."
all_schedulers="FIFOScheduler SSTFScheduler CScanScheduler..."

for c in ${all_cache_managers}; do
  for s in ${all_schedulers}; do
  (
    echo "[Parameters]"
    echo "filesystem.generator_type = \"GenerateFromFile\""
    echo "filesystem.iolibrary_type = \"PassThroughIOLibrary\""
    echo "filesystem.syscalliface_type = \"PassThroughSysCallIface\""
    echo "filesystem.filesystem_type = \"PassThroughFileSystem\""
    echo "filesystem.cache_type = \"${c}\""
    echo "filesystem.blocktranslator_type = \"NoTranslation\""
    echo "filesystem.diskscheduler_type = \"${s}\""
    echo "filesystem.accessmanager_type = \"MutexAccessManager\""
    echo "filesystem.physicaldisk_type = \"HP97560Disk\""
  ) &gt;algorithms.ini

  ./filesystem
  done
done
</pre>
<p>

<p>
<H3><A NAME="sec342"/>10.7.3. Variations over seed value (multiple independent runs)</H3>

<p>The same kind of control script can be used if you want to execute
several runs with different random seeds.
The following code does 500 runs with independent seeds.
(<SAMP>omnetpp.ini</SAMP> should include <tt>parameters.ini</tt>.)

<p>The seeds are 10 million numbers apart in the sequence (<tt>seedtool</tt>
parameter), so one run should not use more random numbers than this,
otherwise there will be overlaps in the sequences and the runs
will not be independent.

<pre>
#! /bin/sh
seedtool g 1 10000000 500 &gt; seeds.txt
for seed in `cat seeds.txt`; do
   (
     echo "[General]"
     echo "random-seed = ${seed}"
     echo "output-vector-file = xcube-${seed}.vec"
   ) &gt; parameters.ini
   ./xcube
done
</pre>
<p>

<p>

<p>
<hr><H2><A NAME="sec343"/>10.8. Akaroa support: Multiple Replications in Parallel</H2>

<p><H3><A NAME="sec344"/>10.8.1. Introduction</H3>

<p>Typical simulations are Monte-Carlo simulations: they use
(pseudo-)random numbers to drive the simulation model.
For the simulation to produce statistically reliable results,
one has to carefully consider the following:

<p><UL>
  <li><strong></strong>When is the initial transient over, when can we start
    collecting data? We usually do not want to include the
    initial transient when the simulation is still ``warming up.''
  <li><strong></strong>When can we stop the simulation? We want to wait long enough
    so that the statistics we are collecting can ``stabilize'',
    can reach the required sample size to be statistically trustable.
</UL>

<p>Neither questions are trivial to answer. One might just suggest
to wait ``very long'' or ``long enough''. However, this is neither
simple (how do you know what is ``long enough''?) nor practical
(even with today's high speed processors simulations of modest complexity
can take hours, and one may not afford multiplying runtimes by,
say, 10, ``just to be safe.'') If you need further convincing,
please read [<a href="#bib-Pawlikowsky02">Pawlikowsky02</a>] and be horrified.

<p>A possible solution is to look at the statistics while the simulation
is running, and decide at runtime when enough data have been
collected for the results to have reached the required accuracy.
One possible criterion is given by the confidence level,
more precisely, by its width relative to the mean.
But ex ante it is unknown how many observations have to be collected
to achieve this level - it must be determined runtime.

<p>
<H3><A NAME="sec345"/>10.8.2. What is Akaroa</H3>

<p>Akaroa [<a href="#bib-Akaroa99">Akaroa99</a>] addresses the above problem.
According to its authors, Akaroa (Akaroa2) is a ``fully automated
simulation tool designed for running distributed stochastic simulations
in MRIP scenario'' in a cluster computing environment.

<p>MRIP stands for <EM>Multiple Replications in Parallel</EM>.
In MRIP, the computers of the cluster run independent replications
of the whole simulation process (i.e. with the same parameters but
different seed for the RNGs (random number generators)),
generating statistically equivalent streams of simulation output data.
These data streams are fed to a global data analyser responsible for
analysis of the final results and for stopping the simulation
when the results reach a satisfactory accuracy.

<p>The independent simulation processes run independently of one another
and continuously send their observations to the central analyser
and control process. This process <EM>combines</EM> the independent data streams,
and calculates from these observations an overall estimate of the mean value
of each parameter.
Akaroa2 decides by a given confidence level and precision
whether it has enough observations or not. When it judges that is
has enough observations it halts the simulation.

<p>If <EM>n</EM> processors are used, the needed simulation execution time
is usually <EM>n</EM> times smaller compared to a one-processor
simulation (the required number of observations are produced sooner).
Thus, the simulation would be sped up approximately in proportion
to the number of processors used and sometimes even more.

<p>Akaroa was designed at the University of Canterbury in Christchurch, New Zealand
and can be used free of charge for teaching and non-profit research activities.

<p>
<H3><A NAME="sec346"/>10.8.3. Using Akaroa with OMNeT++</H3>

<p><br><P class="subheading">Akaroa</P>

<p>Before the simulation can be run in parallel under Akaroa, you have to
start up the system:

<p><UL>
  <li><strong></strong>Start <tt>akmaster</tt> running in the background on some host.
  <li><strong></strong>On each host where you want to run a simulation engine,
     start <tt>akslave</tt> in the background.
</UL>

<p>Each <tt>akslave</tt> establishes a connection with the <tt>akmaster</tt>.

<p>Then you use <tt>akrun</tt> to start a simulation. <tt>akrun</tt> waits
for the simulation to complete, and writes a report of the results
to the standard output. The basic usage of the <tt>akrun</tt> command is:

<pre>
akrun -n num_hosts command [argument..]
</pre>
<p>
where <EM>command</EM> is the name of the simulation you want to start.
Parameters for Akaroa are read from the file named <tt>Akaroa</tt> in
the working directory. Collected data from the processes are
sent to the <tt>akmaster</tt> process, and when the required precision
has been reached, <tt>akmaster</tt> tells the simulation processes to
terminate. The results are written to the standard output.

<p>The above description is of course not detailed enough help you
set up and successfully use Akaroa - for that you need to read the
Akaroa manual. The purpose was rather to give you the ``flavour''
of using it.

<p><br><P class="subheading">Configuring OMNeT++ for Akaroa</P>

<p>First of all, you have to compile OMNeT++ with Akaroa support enabled.

<p>The OMNeT++ simulation must be configured in <tt>omnetpp.ini</tt>
so that it passes the observations to Akaroa. The simulation model itself does
not need to be changed (except for RNGs, see later) - it continues to write
the observations into output vectors (<tt>cOutVector</tt> objects,
see chapter <a href="#cha:the-simulation-library">[click]</a>). You can place some of
the output vectors under Akaroa control.

<p>You need to add the following to <tt>omnetpp.ini</tt>:

<pre>
[General]
outputvectormanager-class="cAkOutputVectorManager"
</pre>
<p>
The above line replaces the normal output vector handler
by its Akaroa-enabled version, using the Envir plugin interface.

<p>Also, you have to specify which output vectors you want to
be under Akaroa control. By default, all output vectors are under Akaroa
control; the

<pre>
&lt;modulename&gt;.&lt;vectorname&gt;.akaroa=false
</pre>
<p>
setting can be used to make Akaroa ignore specific vectors.
If you only want a few vectors be placed under Akaroa,
you can use the following ``trick'':

<pre>
&lt;modulename&gt;.&lt;vectorname1&gt;.akaroa=true
&lt;modulename&gt;.&lt;vectorname2&gt;.akaroa=true
...
*.*.akaroa=false
</pre>
<p>

<p><br><P class="subheading">Using shared file systems</P>

<p>It is usually practical to have the same physical disk mounted (e.g. via NFS or Samba)
on all computers in the cluster. However, because all OMNeT++ simulation
processes run with the same settings, they would overwrite each other's
output files. Your can prevent this from happening using the
<tt>fname-append-host</tt> ini file entry:

<pre>
[General]
fname-append-host=yes
</pre>
<p>
When turned on, it appends the host name to the names of the output
files (output vector, output scalar, snapshot files).

<p>
<br><P class="subheading">Random number generation</P>

<p>Another important point is that you cannot use the random number
generators provided by OMNeT++, but rather you have to obtain
random numbers from Akaroa.

<p>Unfortunately, OMNeT++'s RNGs do not (yet) know anything about Akaroa.
Remember, all simulation processes are run with exactly the same
configuration - including the same RNG seeds.
That is, if you'd use OMNeT++'s own RNGs,
all simulation processes would use <EM>identical</EM> random number streams,
thus executing <EM>exactly the same sequence of events!</EM>
This is clearly not what you want or what Akaroa expects.

<p>Akaroa provides the following random number functions. The underlying
RNG is a Combined Multiple Recursive pseudorandom
number generator (CMRG) with a period of approximately $2^191$
random numbers, and provides a unique stream of random numbers
for every simulation engine.

<p>Future versions of OMNeT++ will wrap the random number functions
of Akaroa, thus requiring no modifications to simulation programs.

<p>
<pre>
#include &lt;akaroa/distribution.H&gt;

real Uniform(real a, real b);
long UniformInt(long n0, long n1);
long Binomial(long n, real p);
real Exponential(real m);
real Erlang(real m, real s);
real HyperExponential(real m, real s);
real Normal(real m, real s);
real LogNormal(real m, real s);
long Geometric(real m);
real HyperGeometric(real m, real s);
long Poisson(real m);
real Weibull(real alpha, real beta);
</pre>

<p>

<p>

<p><hr><H2><A NAME="sec347"/>10.9. Typical problems</H2>

<p><H3><A NAME="sec348"/>10.9.1. Stack problems</H3>

<p><br><P class="subheading">``Stack violation (<EM>FooModule</EM> stack too small?) in module <EM>bar.foo</EM>''</P>


<p>OMNeT++ detected that the module has used more stack space than it has
allocated. You should increase the stack for that module type. You can call
the <tt>stackUsage()</tt> from <tt>finish()</tt> to find out actually
how much stack the module used.

<p>
<br><P class="subheading">``Error: Cannot allocate <EM>nn</EM> bytes stack for module <EM>foo.bar''</EM></P>

<p>The resolution depends on whether you are using OMNeT++ on Unix or on Windows.

<p><STRONG>Unix.</STRONG>
If you get the above message, you have to increase the total stack
size (the sum of all coroutine stacks). You can do
so in <SAMP>omnetpp.ini</SAMP>:

<pre>
[General]
total-stack-kb = 2048 # 2MB
</pre>
<p>
There is no penalty if you set <tt>total-stack-kb</tt> too high. I
recommend to set it to a few K less than the maximum process stack
size allowed by the operating system (<tt>ulimit -s</tt>; see
next section).

<p>
<STRONG>Windows.</STRONG>
You need to set a <EM>low</EM> (!) ``reserved stack size''
in the linker options, for example 64K (/stack:65536 linker flag) will do.
The ``reserved stack size'' is an attribute in the Windows exe
files' internal header. It can be set from the linker, or with
the <tt>editbin</tt> Microsoft utility. You can use the <tt>opp_stacktool</tt>
program (which relies on another Microsoft utility called <tt>dumpbin</tt>)
to display reserved stack size for executables.

<p>You need a low reserved stack size because the Win32 Fiber API
which is the mechanism underlying <tt>activity()</tt> uses
this number as coroutine stack size, and with 1MB being the default,
it is easy to run out of the 2GB possible address space (2GB/1MB=2048).

<p>A more detailed explanation follows.
Each fiber has its own stack, by default 1MB (this is the ``reserved''
stack space - i.e. reserved in the address space, but not the full
1MB is actually ``committed'', i.e. has physical memory assigned to it).
This means that a 2GB address space will run out after 2048 fibers,
which is way too few. (In practice, you won't even be able to create
this many fibers, because physical memory is also a limiting factor).
Therefore, the 1MB reserved stack size (RSS) must be set to a smaller
value: the coroutine stack size requested for the module, plus
extra-stack-for-envir, the sum of the two typically around 32K.
Unfortunately, the CreateFiber() Win32 API doesn't allow the RSS to be
specified. The more advanced CreateFiberEx() API which accepts RSS as
parameter is unfortunately only available from Windows XP.

<p>The alternative is the stacksize parameter stored in the EXE header,
which can be set
via the STACKSIZE .def file parameter, via the /stack linker option,
or on an existing executable using the editbin /stack utility.
This parameter specifies a common RSS for the main program stack,
fiber and thread stacks. 64K should be enough. This is the way
simulation executable should be created: linked with the /stack:65536
option, or the /stack:65536 parameter applied using editbin later.
For example, after applying the editbin /stacksize:65536 command to
dyna.exe, I was able to successfully run the Dyna sample with 8000
Client modules on my Win2K PC with 256M RAM (that means about 12000
modules at runtime, including about 4000 dynamically created modules.)

<p>
<br><P class="subheading">``Segmentation fault''</P>

<p>On Unix, if you set the total stack size higher, you may get a
segmentation fault during network setup (or
during execution if you use dynamically created modules) for exceeding
the operating system limit for maximum stack size. For example, in
Linux 2.4.x, the default stack limit is 8192K (that is, 8MB). The
<tt>ulimit</tt> shell command can be used to modify the
resource limits, and you can raise the allowed maximum stack size
up to 64M.

<pre>
$ ulimit -s 65500
$ ulimit -s
65500
</pre>
<p>
Further increase is only possible if you're root.
Resource limits are inherited by child processes.
The following sequence can be used under Linux to get a shell with
256M stack limit:

<pre>
$ su root
Password:
# ulimit -s 262144
# su andras
$ ulimit -s
262144
</pre>
<p>
If you do not want to go through the above process at each login, you
can change the limit in the PAM configuration files. In Redhat Linux
(maybe other systems too), add the following line to
<tt>/etc/pam.d/login</tt>:

<pre>
session    required    /lib/security/pam_limits.so
</pre>
<p>
and the following line to <tt>/etc/security/limits.conf</tt>:

<pre>
*    hard    stack    65536
</pre>
<p>
<p>
A more drastic solution is to recompile the kernel with a larger stack
limit. Edit <tt>/usr/src/linux/include/linux/sched.h</tt> and increase
<tt>_STK_LIM</tt> from <tt>(8*1024*1024)</tt> to <tt>(64*1024*1024)</tt>.
</p>

<p>Finally, it you're tight with memory, you can switch to Cmdenv. Tkenv
increases the stack size of each module by about 32K so that user interface code that is called from a
simple module's context can be safely executed.
Cmdenv does not need that much extra stack.

<p>
<br><P class="subheading">Eventually...</P>

<p>Once you get to the point where you have to adjust the total stack size
to get your program running,
you should probably consider transforming (some of) your <tt>activity()</tt>
simple modules to <tt>handleMessage()</tt>. <tt>activity()</tt> does not
scale well for large simulations.

<p>

<p><H3><A NAME="sec349"/>10.9.2. Memory leaks and crashes</H3>

<p>The most common problems in C++ are associated with memory allocation
(usage of <tt>new</tt> and <tt>delete</tt>):

<p><UL>
   <li><strong></strong><EM>memory leaks,</EM> that is, forgetting to delete objects
     or memory blocks no longer used;
   <li><strong></strong><EM>crashes,</EM> usually due to referring to an already deleted
     object or memory block, or trying to delete one for a second time;
   <li><strong></strong><EM>heap corruption</EM> (enventually leading to crash) due to
     overrunning allocated blocks, i.e. writing past the end of an allocated
     array.
</UL>

<p>By far the most common ways leaking memory in simulation programs
is by not deleting messages (<tt>cMessage</tt> objects or subclasses).
Both Tkenv and Cmdenv are able to display the number of messages
currently in the simulation,
see e.g. section <a href="#sec:ch-run-sim:interpreting-cmdenv-output">[click]</a>.
If you find that the number of messages is steadily increasing,
you need to find where the message objects are. You can do so
by selecting <EM>Inspect|From list of all objects...</EM> from
the Tkenv menu, and reviewing the list in the dialog that pops up.
(If the model is large, it may take a while for the dialog to appear.)

<p>If the number of messages is stable, it's still possible
you're leaking other <tt>cObject</tt>-based objects. You can
also find them using Tkenv's <EM>Inspect|From list of all objects...</EM>
function.

<p>If you're leaking non-<tt>cObject</tt>-based objects or just
memory blocks (<tt>struct</tt>s, <tt>int</tt>/<tt>double</tt>/<tt>struct</tt> arrays,
etc, allocated by <tt>new</tt>), you cannot find them via Tkenv.
You'll probably need a specialized memory debugging tool like
the ones described below.

<p><br><P class="subheading">Memory debugging tools</P>

<p>If you suspect that you may have memory allocation problems
(crashes associated with double-deletion or accessing already
deleted block, or memory leaks), you can use specialized tools
to track them down.
  <br><ul><font size=-1>[Alternatively, you can go through the full code,
  review it looking for bugs. In my experience, the latter one
  has proved to be far more efficient than using any kind
  of memory debugger.]</font></ul>

<p>The number one of these tools is <EM>Purify</EM> from Rational Software.
This is a commercial tool. Not particularly cheap, but it has
very good reputation and proved its usefulness many times.

<p>There are several open source tools you can try. The best seems
to be <EM>Valgrind</EM> used by the KDE people.
Other good ones are <EM>NJAMD</EM>, <EM>MemProf</EM>, <EM>MPatrol</EM>
and <EM>dmalloc</EM>, while <EM>ElectricFence</EM> seems
to be included in most Linux distributions.
Most of the above tools support tracking down memory leaks as well as
detecting double deletion, writing past the end of an allocated block, etc.

<p>
<br><P class="subheading">Poor man's memory leak debugger</P>

<p>However, if you don't have such tools, you can use the basic
heap debugging code in Cmdenv. It is disabled by default;
to turn it on, you have to uncomment the <tt>#defines</tt>
in <tt>src/envir/cmdenv/heap.cc</tt>:

<p><table>
<TR> <TD align=left> <tt>HEAPCHECK</tt> </TD> <TD align=left> checks heap on new/delete</TD></TR>
<TR> <TD align=left> <tt>COUNTBLOCKS</tt> </TD> <TD align=left> counts blocks on heap and tells it if none left</TD></TR>
<TR> <TD align=left> <tt>ALLOCTABLE</tt> </TD> <TD align=left> remembers pointers and reports heap contents if only LASTN
blocks remained</TD></TR>
<TR> <TD align=left> <tt>DISPLAYALL</tt> </TD> <TD align=left> reports every new/delete</TD></TR>
<TR> <TD align=left> <tt>DISPSTRAYS</tt> </TD> <TD align=left> reports deleting of pointers that were not registered
by operator new or that were deleted since then</TD></TR>
<TR> <TD align=left> <tt>BKPT</tt> </TD> <TD align=left>  calls a function at a specified new/delete; you can set a
breakpoint to that function</TD></TR>
</table>

<p>
If <tt>COUNTBLOCKS</tt> is turned on, you should see the
<SAMP>[heap.cc-DEBUG:ALL BLOCKS FREED OK]</SAMP> message at the end of the
simulation. If you do not see it, it means that some blocks have not
been freed up properly, that is, your simulation program is likely to
have memory leaks.

<p>


<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Nov  5 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec350"/>11. Analyzing Simulation Results</H1>
<a name="cha:analyzing-simulation-results"></a>

<p>
<hr><H2><A NAME="sec351"/>11.1. Output vectors</H2>

<p>Output vectors are time series data: values with timestamps.
You can use output vectors to record end-to-end delays or
round trip times of packets, queue lengths, queueing times,
link utilization, the number of dopped packets, etc. -
anything that's useful to get a full picture of what happened
in the model during the simulation run.

<p>Output vectors are recorded from simple modules, by <tt>cOutVector</tt> objects
(see section <a href="#sec:ch-sim-lib:cOutVector">[click]</a>). Since output vectors usually
record a large amount of data, in <tt>omnetpp.ini</tt> you can disable vectors
or specify a simulation time interval for recording
(see section <a href="#sec:ch-run-sim:outvectors-section">[click]</a>).

<p>All <tt>cOutVector</tt> objects write to the same, common file.
The following sections describe the format of the file, and
how you can process them.

<p>
<hr><H2><A NAME="sec352"/>11.2. Plotting output vectors with Plove</H2>

<p><H3><A NAME="sec353"/>11.2.1. Plove features</H3>

<p>Typically, you'll get output vector files as a result of a simulation.
Data written to <tt>cOutVector</tt> objects from
simple modules go to output vector
files. Normally, you use Plove to look
into output vector files and plot vectors in it.

<p>Plove\indexPlove is a handy tool for plotting OMNeT++ output vectors.
It uses Gnuplot to do the actual work. You can specify
the drawing style (lines, dots etc) for each vector as well as set the
most frequent drawing options like axis bounds, scaling, titles and
labels etc. You can save the gnuplot graphs to files (postscript,
latex, pbm etc) with a click. Plove can also generate standalone shell
scripts that plot output vectors in much the same way Plove does
itself. These scripts can be used for batch processing or to debug
filters (see later). Plove does not take away any of gnuplot's
flexibility - you can embed your own gnuplot commands to customize
the output.

<p>
Filtering the results before plotting is
possible. Filters can do averaging, truncation of extreme values,
smoothing, they can do density estimation by
calculating histograms etc. Some filters are built
in, and you can easily create new filters or modify the existing ones.
Filters can be incorporated in one of three ways: as <tt>awk</tt> expressions,
as <tt>awk</tt> programs and as external filter programs. Filters can be
parameterized. Multiple filters for the same vector is not currently
supported; also, you cannot currently feed several vectors into a
single filter.

<p>Plove does not create temporary files, so you don't need to worry
about disk space: if the output vector is there, Plove can plot
it for you. Moreover, it can also work with gzipped vector files
without extracting them - just make sure you have zcat.

<p>
Plove never modifies the output vector files themselves.

<p>On startup, Plove automatically reads the <SAMP>.ploverc</SAMP> file in
your home directory. The file contains general gnuplot settings, the
filter configuration etc. (that is, the stuff from the Options menu).

<p>

<p>
<H3><A NAME="sec354"/>11.2.2. Usage</H3>

<p>First, you load an output vector file (<SAMP>.vec</SAMP>) into the left
pane.  You can also load gzipped vector files (<SAMP>.vec.gz</SAMP>)
without having to decompress them. You can copy vectors from the left
pane to the right pane by clicking the right arrow icon in the middle.
The large PLOT button will plot the <EM>selected</EM> vectors in the
right pane. Selection works as in Windows: dragging and shift+left
click selects a range, and ctrl+left click selects/deselects
individual items. To adjust drawing style, change vector title or add
filter, push the Options... button. This works for several selected
vectors too. Plove accepts nc/mc-like keystrokes: F3, F4, F5, F6, F8,
grey '+' and grey '*'.

<p>
The left pane works as a general storage for vectors you're working
with. You can load several vector files, delete vectors you don't
want to deal with, rename them etc. All this will not affect
the vector files on disk. In the right pane, you can duplicate
vectors if you want to filter the vector and also keep the original.
If you set the right options for a vector but temporarily do
not want it to hang around in the right pane, you can put it
back into the left pane for storage.

<p>

<p>

<p><H3><A NAME="sec355"/>11.2.3. Writing filters</H3>

<p>Filters get an output vector on their standard input (as plain
text, with the timestamp being the second and the value being
the third field on each line), do some processing to it and write
the result to the standard output.

<p>
Filters can be incorporated in one of three ways: as <tt>awk</tt>
expressions, as <tt>awk</tt> programs or as external programs. An `awk
expression' filter means assembling and launching a command like this:

<p><pre>
cat foobar.vec | awk '{$3 = <EM>&lt;expression&gt;</EM>; print}' | ...
</pre>

An <tt>awk</tt> program filter means running the following command:

<p><pre>
cat foobar.vec | awk '{<EM>&lt;program&gt;</EM>}' | ...
</pre>

<p>The third type of filters is used like this:

<p><pre>
cat foobar.vec | <EM>&lt;program&gt; &lt;parameters&gt;</EM> | ...
</pre>

<p>Before the filter pipeline is launched, the following substitutions
are performed on the <tt>awk</tt> scripts:

<p><UL>
  <li><strong></strong> <b>t</b> gets substituted to \, which is the simulation time
  (the second column in the output vector file)
  <li><strong></strong> <b>x</b> gets substituted to \, the actual value (the third column)
</UL>

<p>The parameters of the form <tt>$(paramname)</tt> are also replaced with
their actual value.

<p>For example, if you want to add 1 to all values, you can use the <tt>awk</tt>
expression filter <tt>x+1</tt>. It will turn into the following awk script:

<pre>
awk '{$3 = $3+1}; print'
</pre>
<p>

<p>When you want to shift the vector by a used-defined DT time,
you can create the following <tt>awk</tt> program filter:

<pre>
{t += $(DT); print}
</pre>
<p>
To plot the mean on <EM>(0,t)</EM>, you'd write

<pre>
{sum+=x; x=sum/++n; print}
</pre>
<p>
Do not forget the print statement, or your filter will not output
anything and the gnuplot graph will be empty.

<p>Filters are automatically saved into and loaded from the <tt>~/.ploverc</tt>
file.



<p>

<p><hr><H2><A NAME="sec356"/>11.3. Format of output vector files</H2>

<p>An output vector file contains several
series of data produced during simulation. The file is textual, it
looks like this:

<p><pre>
<STRONG>mysim.vec:</STRONG>
vector 1   "subnet[4].term[12]"  "response time"  1
1  12.895  2355.66666666
1  14.126  4577.66664666
vector 2   "subnet[4].srvr"  "queue length"  1
2  16.960  2.00000000000.63663666
1  23.086  2355.66666666
2  24.026  8.00000000000.44766536
</pre>

<p>
There are label lines (beginning with vector) and data lines.

<p>A vector line introduces a new vector. Its columns are: vector ID,
module of creation, name of <tt>cOutVector</tt> object, multiplicity
of data (single numbers or pairs will be written).

<p>Lines beginning with numbers are data lines. The columns: vector
ID, current simulation time, and one or two double values.

<p>

<p>

<p><hr><H2><A NAME="sec357"/>11.4. Working without Plove</H2>

<p><H3><A NAME="sec358"/>11.4.1. Extracting vectors from the file</H3>

<p>You can use the Unix <tt>grep</tt> tool to extract a particular vector
from the file. As the first step, you must find out the ID of the
vector. You can find the appropriate vector line with a text editor or
you can use <tt>grep</tt> for this purpose:

<pre>
% grep "queue length" vector.vec
</pre>
<p>
Or, you can get the list of all vectors in the file by typing:

<pre>
% grep ^vector vector.vec
</pre>
<p>
This will output the appropriate vector line:

<pre>
vector 6  "subnet[4].srvr"  "queue length"  1
</pre>
<p>
Pick the vector ID, which is 6 in this case, and grep the file
for the vector's data lines:

<pre>
grep ^6 vector.vec &gt; vector6.vec
</pre>
<p>

<p>Now, <SAMP>vector6.vec</SAMP> contains the appropriate vector. The only
potential problem is that the vector ID is there at the beginning of
each line and this may be hard to explain to some programs that you
use for post-processing and/or visualization. This problem is
eliminated by the OMNeT++ <tt>splitvec</tt> utility (written in
<tt>awk</tt>), to be discussed in the next section.

<p>

<p>
<H3><A NAME="sec359"/>11.4.2. Using splitvec</H3>

<p>The <tt>splitvec</tt> script (part of OMNeT++) breaks the vector file
into several files which contain one vector each:

<pre>
% splitvec mysim.vec
</pre>
<p>

<p>creates several files: mysim1.vec, mysim2.vec etc.

<p><pre>
<STRONG>mysim1.vec:</STRONG>
# vector 1  "subnet[4].term[12]"  "response time"  1
12.895  2355.66666666
14.126  4577.66664666
23.086  2355.66666666

<p><STRONG>mysim2.vec:</STRONG>
# vector 2  "subnet[4].srvr"  "queue length"  1
16.960  2.00000000000.63663666
24.026  8.00000000000.44766536
</pre>

<p>
As you can see, the vector ID is gone.

<p>The files can be further processed with math packages, or read
by analysis or spreadsheet programs which provide numerous ways
to display data as diagrams, do calculations on them etc. One
could use for example Matlab/Octave, Excel, or one of the programs
described in the next section.

<p>

<p>
<hr><H2><A NAME="sec360"/>11.5. Visualization tools</H2>

<p>There are a couple of open-source programs you can use for plotting
the results. <EM>Gnuplot</EM> is the most commonly used one
(also supported by OMNeT++ Plove); other, more powerful ones
include <EM>Grace</EM> and <EM>ROOT</EM>.

<p>These programs can eat files produced by <tt>splitvec</tt>, and
can produce output in various forms (on the screen, as PostScript,
in various image formats, etc.)

<p>On Windows, the easiest way to include a picture in a document
is to copy the picture to the clipboard from the Gnuplot
window's system menu.

<p>
<H3><A NAME="sec361"/>11.5.1. Grace</H3>

<p><EM>Grace</EM> (also known as <EM>xmgrace</EM>, a successor of <EM>ACE/gr</EM> or
<EM>Xmgr</EM>) is a GPL-ed powerful data visualization program
with a WYSIWIG point-and-click graphical user interface. It has been
written for Unix, but has a Windows version, too.

<p>You load the appropriate file by selecting from a dialog box.
The icon bar and menu commands can be used to customize
the graph.

<p>As of June 2003, Grace 1.5.12 can export graphics to (E)PS, PDF, MIF, SVG,
PNM, JPEG and PNG formats. It has many useful features like built-in statistics
and analysis functions (e.g. correlation, histogram), fitting, splines, etc.,
and it also sports a built-in programming language.

<p>
<H3><A NAME="sec362"/>11.5.2. ROOT</H3>

<p><EM>ROOT</EM> is a powerful object-oriented data analysis framework,
with strong support for plotting and graphics in general.
ROOT has been developed at CERN, and it is distributed under a BSD-like license.

<p>An interesting thing is ROOT is based on <EM>CINT</EM>, a ``C/C++ interpreter''
aimed at processing C/C++ scripts. It is probably harder to get started
using ROOT than with either Gnuplot or Grace, but if you are serious
about analysing simulation results, you will find that ROOT gives you
as much power and flexibility that is unthinkable in the other two programs.

<p>Curt Brune's page at Stanford (http://www.slac.stanford.edu/~curt/omnet++/)
shows examples what you can achieve using using ROOT with OMNeT++.

<p>
<H3><A NAME="sec363"/>11.5.3. Using Gnuplot</H3>

<p>Gnuplot has an interactive command interface. To get the vectors in
<SAMP>mysim1.vec</SAMP> and <SAMP>mysim4.vec</SAMP> plotted in the same graph,
you can type:

<pre>
plot "mysim1.vec" with lines, "mysim4.vec" with lines
</pre>
<p>
To adjust the $y$ range, you would type:

<pre>
set yrange [0:1.2]
replot
</pre>
<p>

<p>There are several commands to adjust ranges, plotting style, labels,
scaling etc. Gnuplot can also plot 3D graphs. Gnuplot
is also available for Windows and other platforms. Gnuplot also
has a simple graphical interactive user interface called PlotMTV.
However, we recommend that you use OMNeT++'s Plove tool, described in
an earlier section.

<p>

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 18 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec364"/>12. Parallel Execution</H1>
<a name="cha:parallel-execution"></a>

<p><hr><H2><A NAME="sec365"/>12.1. OMNeT++ support for parallel execution</H2>

<p><H3><A NAME="sec366"/>12.1.1. Introduction to Parallel Discrete Event Simulation</H3>

<p>OMNeT++ supports parallel execution of large
simulations. The following paragraphs provide a brief picture
of the problems and methods of parallel
discrete event simulation (PDES). Interested readers are
strongly encouraged to look into the literature.

<p>For parallel execution, the model is to be partitioned to several
LPs that will be simulated independently on different hosts or
processors. Each LP will have its own local Future Event Set,
thus they will maintain local simulation times. The main issue with
parallel simulations is keeping LPs synchronized in order to
avoid violating causality of events. Without synchronization, a
message sent by one LP could arrive in another LP when the
simulation time in the receiving LP has already passed the
timestamp (arrival time) of the message. This would break
causality of events in the receiving LP.

<p>There are two broad categories of parallel simulation algorithms
that differ in the way they solve the causality problem outlined
above:

<p><OL>
  <li><strong></strong><STRONG>Conservative algorithms</STRONG>
    prevents incausalities from happening. The Null Message Algorithm
    exploits knowledge about when LPs send messages to other LPs,
    and uses `null' messages to propagate this info to other LPs.
    If a LP knows it won't receive any messages from other
    LPs until $t+delta t$ simulation time, it may advance until
    $t+delta t$ without the need for external synchronization.
    Conservative simulation tends to converge to sequential simulation
    (slowed down by communication between LPs) if there's not
    enough parallelism in the model, or parallelism is not exploited
    by sending enough `null' messages.

<p>  <li><strong></strong><STRONG>Optimistic synchronization</STRONG>
    allows incausalities to occur, but detects and
    repairs them. Repairing involves rollbacks to a previous state,
    sending out anti-messages to cancel messages sent out during the
    period that is being rolled back, etc.  Optimistic synchronization
    is extremely difficult to implement, because it requires periodic
    state saving and the ability to restore previous states. In any
    case, implementing optimistic synchronization in OMNeT++ would
    require - in addition to a more complicated simulation kernel -
    writing significantly more complex simple
    module code from the user.  Optimistic synchronization may be slow
    in cases of excessive rollbacks.
</OL>

<p>
<H3><A NAME="sec367"/>12.1.2. In work</H3>

<p>Parallel simulation support in OMNeT++ has recently been reimplemented.
The new code is currently being refined and tested, and it will be
available in the following releases.

<p>


<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec368"/>13. Customization and Embedding</H1>
<a name="cha:the-design-of-omnet"></a>

<p><hr><H2><A NAME="sec369"/>13.1. Architecture</H2>

<p>OMNeT++ has a modular architecture. The following diagram shows the
high-level architecture of OMNeT++ simulations:

<p>
  <DIV ALIGN=center>
    <img src="figures/usmanFig18.gif">
    <center><i>Figure: Architecture of OMNeT++ simulation programs</i></center>
  </DIV>

<p>
The rectangles in the picture represent functional blocks:

<p><UL>
  <li><strong></strong><STRONG>Sim</STRONG> is the simulation kernel and class
    library. Sim exists as a library you link
    your simulation program with.
       <br><ul><font size=-1>[Use of dynamic (shared) libraries is also possible, but
       for simplicity we'll use the word <EM>linking</EM> here.]</font></ul>
    
  <li><strong></strong><STRONG>Envir</STRONG> is another library which contains all code
    that is common for all user interfaces. <tt>main()</tt> is also in Envir.
    Envir provides services like ini file handling for specific user interface
    implementations. Envir presents itself towards Sim and the executing model
    via the <tt>ev</tt> facade object, hiding all other user interface internals.
    Some aspects of Envir can be customized via plugin
    interfaces. Embedding OMNeT++ into applications can
    be achieved implementing a new user interface in addition to Cmdenv and Tkev,
    or by replacing Envir with another implementation of <tt>ev</tt>
    (see sections <a href="#sec:ch-opp-design:customization">[click]</a> and
    <a href="#sec:ch-opp-design:embedding">[click]</a>.)
  <li><strong></strong><STRONG>Cmdenv and Tkenv</STRONG> are specific user interface
    implementations. A concrete simulation is linked with
    either Cmdenv or Tkenv.
  <li><strong></strong>The <STRONG>Model Component Library</STRONG> is the simple module definitions and
    their C++ implementations, compound module types, channels, networks,
    message types and in general everything that belong to models and
    has been linked into the simulation program. A simulation program is
    able to run any model that has all necessary components linked in.
  <li><strong></strong>The <STRONG>Executing Model</STRONG> is the model that has been set up
    for simulation. It contains objects (modules, channels, etc.) that
    are all instances of components in the model component library.
</UL>

<p>The arrows in the figure show how functional blocks interact with
each other:

<p><UL>
  <li><strong></strong><STRONG>Executing Model vs Sim</STRONG>. The simulation kernel
    manages the future events and invokes modules in the executing model
    as events occur. The modules of the executing model are stored
    in the main object of Sim, <tt>simulation</tt> (of class <tt>cSimulation</tt>).
    In turn, the executing model calls functions in the
    simulation kernel and uses classes in the Sim library.
  <li><strong></strong><STRONG>Sim vs Model Component Library</STRONG>. The simulation kernel
    instantiates simple modules and other components when the simulation model
    is set up at the beginning of the simulation run. It also refers
    to the component library when dynamic module creation is used.
    The machinery for registering and looking up components in the model
    component library is implemented as part of Sim.
  <li><strong></strong><STRONG>Executing Model vs Envir</STRONG>. The <tt>ev</tt> object, logically
    part of Envir, is the facade of the user interface towards the executing model.
    The model uses <tt>ev</tt> for writing debug logs (<tt>ev&lt;&lt;</tt>, <tt>ev.printf()</tt>).
  <li><strong></strong><STRONG>Sim vs Envir</STRONG>. Envir is in full command of what
    happens in the simulation program. Envir contains the <tt>main()</tt> function
    where execution begins. Envir determines which models should be set up
    for simulation, and instructs Sim to do so. Envir contains the main
    simulation loop (<EM>determine-next-event</EM>, <EM>execute-event</EM>
    sequence) and invokes the simulation kernel for the necessary
    functionality (event scheduling and event execution are implemented in Sim).
    Envir catches and handles errors and exceptions that occur
    in the simulation kernel or in the library
    classes during execution. Envir presents a single facade object (<tt>ev</tt>)
    that represents the environment (user interface) toward Sim - no Envir
    internals are visible to Sim or the executing model.
    During simulation model setup, Envir supplies parameter values for
    Sim when Sim asks for them. Sim writes output vectors via Envir,
    so one can redefine the output vector storing mechanism by changing Envir.
    Sim and its classes use Envir to print debug information.
  <li><strong></strong><STRONG>Envir vs Tkenv and Cmdenv</STRONG>. Envir defines <tt>TOmnetApp</tt>
    as a base class for user interfaces, and Tkenv and Cmdenv both subclass
    from <tt>TOmnetApp</tt>. The <tt>main()</tt> function provided as part of Envir
    determines the appropriate user interface class (subclassed from
    <tt>TOmnetApp</tt>), creates an instance and runs it - whatever
    happens next (opening a GUI window or running as a command-line program)
    is decided in the <tt>run()</tt> method of the appropriate <tt>TOmnetApp</tt>
    subclass. Sim's or the model's calls on the <tt>ev</tt> object are
    simply forwarded to the <tt>TOmnetApp</tt> instance. Envir presents
    a framework and base functionality to Tkenv and Cmdenv via the methods of
     <tt>TOmnetApp</tt> and some other classes.)
</UL>

<p>
<hr><H2><A NAME="sec370"/>13.2. Embedding OMNeT++</H2>
<a name="sec:ch-opp-design:embedding"></a>

<p>Embedding is a special issue. You probably
do not want to keep the appearance of the simulation program, so you
do not want Cmdenv and Tkenv. You may or may not want to keep Envir.

<p>What you'll absolutely need for a simulation to run is the Sim
library. You can keep Envir if its philosophy and the infrastructure
it provides (<tt>omnetpp.ini</tt>, certain command-line options etc.)
fit into your design. Then your application, the embedding program
will take the place of Cmdenv and Tkenv.

<p>If Envir does not fit your needs (for example, you want the model
parameters to come from a database not from <tt>omnetpp.ini</tt>), then you
have to replace it. Your Envir replacement (the embedding application,
practically) must implement the <tt>cEnvir</tt> member functions from
<tt>envir/cenvir.h</tt>, but you have full control over the simulation.

<p>Normally, code that sets up a network or builds the internals of a
compound module comes from compiled NED source.  You may not like the
restriction that your simulation program can only simulate networks
whose setup code is linked in. No problem; your program can contain
pieces of code like what is generated by nedc and then it can build
any network whose components (primarily the simple modules) are linked
in. Moreover, it is possible to write an integrated environment where
you can put together a network using a graphical editor and right
after that you can run it, without intervening NED compilation and
linkage.

<p>

<p>

<p><hr><H2><A NAME="sec371"/>13.3. Sim: the simulation kernel and class library</H2>

<p>There is little to say about Sim here, since chapters
<a href="#cha:simple-modules">[click]</a> and <a href="#cha:the-simulation-library">[click]</a>,
and part of chapter <a href="#cha:messages">[click]</a> are all on
this topic. Classes covered in those chapters are documented
in more detail in the API Reference generated by Doxygen.
What we can do here is documenting some internals
that were not appropriate to be treated in the general
chapters.

<p>The source code for the simulation kernel
and class library reside in the <tt>src/sim/</tt> subdirectory.

<p>
<H3><A NAME="sec372"/>13.3.1. The global simulation object</H3>

<p>The global <tt>simulation</tt> object is an instance of <tt>cSimulation</tt>.
It stores the model, and encapsulated much of the functionality
of setting up and running a simulation model.

<p><tt>simulation</tt> has two basic roles:

<p><UL>
  <li><strong></strong>stores modules of the executing model
  <li><strong></strong>holds the future event set (FES) object
</UL>

<p>

<p><H3><A NAME="sec373"/>13.3.2. The coroutine package</H3>

<p>The coroutine package is in fact two coroutine
packages:

<p><UL>
  <li><strong></strong> Portable coroutine package creates all coroutine stacks
     inside the main stack. It is based on Kofoed's solution[<a href="#bib-Kofoed95">Kofoed95</a>].
     It allocates stack by deep-deep recursions and then plays with
     <tt>setjmp()</tt> and <tt>longjmp()</tt> to switch from one another.

<p>  <li><strong></strong> On Windows, the Fiber functions (<tt>CreateFiber()</tt>,
     <tt>SwitchToFiber()</tt>, etc) are used, which are part of
     the standard Win32 API.
</UL>

<p>The coroutines are represented by the <tt>cCoroutine</tt>
class. <tt>cSimpleModule</tt> has <tt>cCoroutine</tt> as one a
base class.

<p>

<p><hr><H2><A NAME="sec374"/>13.4. The Model Component Library</H2>

<p>All model components (simple module definitions and their C++
implementations, compound module types, channels, networks,
message types, etc.) that you compile and link into a simulation
program are registered in the Model Component Library.
Any model that has all its necessary components in the
component library of simulation program can be run by that
simulation program.

<p>If your simulation program is linked with Cmdenv or Tkenv,
you can have the contents of its component library printed,
using the -h switch.

<pre>
% ./fddi -h

OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
...
Available networks:
  FDDI1
  NRing
  TUBw
  TUBs

Available modules:
  FDDI_MAC
  FDDI_MAC4Ring
  ...

Available channels:
  ...
End run of OMNeT++
</pre>
<p>
Information on components are kept on registration lists.
There are macros for registering components (that is, for adding
them to the registeration lists):
<tt><tt>Define_Module()</tt></tt>, <tt><tt>Define_Module_Like()</tt></tt>,
<tt><tt>Define_Network()</tt></tt>, <tt><tt>Define_Function()</tt></tt>,
<tt>Register_Class()</tt>, and a few others. For components defined
in NED files, the macro calls are generated by the NED compiler;
in other cases you have to write them in your C++ source.

<p>The machinery for managing the registrations lists are part
of the Sim library. Registration lists are implemented
as global objects.

<p>The registration lists are:

<p><table border>
<TR> <TD align=left>

<STRONG>List object</STRONG>
</TD> <TD align=left>
<STRONG>Macro that creates a member;</STRONG><br>
<STRONG>Class of members</STRONG>
</TD> <TD align=left>
<STRONG>Function</STRONG> </TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt>  <br>
<tt> networks;</tt>
</TD> <TD align=left>
<tt><tt>Define_Network()</tt></tt> <br>
<br>
<tt><tt>cNetworkType</tt></tt>
</TD> <TD align=left>
 List of available networks.
A <tt>cNetworkType</tt> object holds a pointer to a function that can
build up the network.
<tt>Define_Network()</tt> macros occur in the code generated by the NEDC
compiler.</TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt> <br>
<tt> modtypes;</tt>
</TD> <TD align=left>
<tt><tt>Define_Module()</tt>,</tt> <br>
<tt><tt>Define_Module_Like()</tt>,</tt>  <br>
<br>
<tt><tt>cModuleType</tt></tt>
</TD> <TD align=left>
 List of available module types.
A <tt>cModuleType</tt> object knows how to create a module of a specific
type. If it is compound, it holds a pointer to a function that can
build up the inside.
Usually, <tt>Define_Module()</tt> macros for compound modules occur in
the code generated by the NEDC compiler; for simple modules,
the <tt>Define_Module()</tt> lines are added by the user.</TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt> <br>
<tt> classes;</tt>
</TD> <TD align=left>
<tt>Register_Class()</tt> <br>
<br>
<tt>cClassRegister</tt>
</TD> <TD align=left>
 List of available classes of which the user can create
an instance.
A <tt>cClassRegister</tt> object knows how to create an (empty) object
of a specific class. The list is used by the <tt>createOne()</tt> function
that can create an object of any (registered) type from a string
containing the class name.
(E.g. <tt>ptr = createOne("cArray")</tt> creates an empty <tt>cArray</tt>.)
<tt>Register_Class()</tt> macros are present in the simulation source
files for existing classes; has to be written by the user for new
classes.</TD></TR>
<TR> <TD align=left> <tt>cHead</tt> <br>
<tt> functions;</tt>
</TD> <TD align=left>
<tt><tt>Define_Function()</tt></tt> <br>
<br>
<tt><tt>cFunctionType</tt></tt>
</TD> <TD align=left>
 List of functions taking <tt>double</tt>s and returning a <tt>double</tt>
(see type <tt>MathFuncNoArg</tt>...<tt>MathFunc3Args</tt>).
A <tt>cFunctionType</tt> object holds a pointer to the function and knows
how many arguments it takes.</TD></TR>
<TR> <TD align=left> <tt>cHead</tt> <br>
<tt> linktypes;</tt>
</TD> <TD align=left>
<tt>Define_Link()</tt> <br>
<br>
<tt>cLinkType</tt>
</TD> <TD align=left>
 List of link types.
A <tt>cLinkType</tt> object knows how to create <tt>cPar</tt> objects representing
the delay, error and datarate attributes for a channel.
<tt>Define_Link()</tt> macros occur in the code generated by the NEDC
compiler, one for each channel definition. </TD></TR>
</table>

<p>

<p>

<p><hr><H2><A NAME="sec375"/>13.5. Envir, Tkenv and Cmdenv</H2>

<p>The source code for the user interface of OMNeT++ resides in the
<SAMP>src/envir/</SAMP> directory (common part) and in the <SAMP>src/cmdenv/</SAMP>,
<SAMP>src/tkenv/</SAMP> directories.

<p>The classes in the user interface are <EM>not</EM> derived from <tt>cObject</tt>,
they are completely separated from the simulation kernel.

<p>

<p><H3><A NAME="sec376"/>13.5.1. The main() function</H3>

<p>The <tt>main()</tt> function of OMNeT++ simply sets up the user
interface and runs it. Actual simulation is done in
<tt>cEnvir::run()</tt> (see later).

<p>

<p><H3><A NAME="sec377"/>13.5.2. The cEnvir interface</H3>

<p>The <tt>cEnvir</tt> class has only one instance, a global object
called <tt>ev</tt>:

<pre>
cEnvir ev;
</pre>
<p>
<tt>cEnvir</tt> basically a facade, its member functions
contain little code. <tt>cEnvir</tt> maintains a pointer to a
dynamically allocated simulation application object (derived from
<tt>TOmnetApp</tt>, see later) which does all actual work.

<p>
<tt>cEnvir</tt> member functions deal with four basic tasks:
<UL>
  <li><strong></strong>I/O for module activities; actual implementation is different
    for each user interface (e.g. stdin/stdout for Cmdenv, windowing
    in Tkenv)
  <li><strong></strong>setting up and running the simulation application
  <li><strong></strong>provides functions called by simulation kernel objects to
    get information (for example, get module parameter settings
    from the configuration file)
  <li><strong></strong>provides functions called by simulation kernel objects to
    notify the user interface of some events. This is especially
    important for windowing user interfaces (Tkenv), because the
    events are like this: an object was deleted so its inspector
    window should be closed; a message was sent so it can be
    displayed; a breakpoint was hit.
</UL>

<p>
<H3><A NAME="sec378"/>13.5.3. Customizing Envir</H3>
<a name="sec:ch-opp-design:customization"></a>

<p>Certain aspects of Envir can be customized via plugin interfaces.
Plugin interfaces are presented in the form of C++ abstract classes
that you have to implement, register via the <tt>Register_Class()</tt>
macro, and finally tell Envir to use them via <tt>omnetpp.ini</tt> entries.

<p>The following plugin interfaces are supported:

<p><UL>
   <li><strong></strong><tt>cOutputScalarManager</tt>. It handles recording the scalar output data,
     output via the cModule::recordScalar() family of functions.
     The default output scalar manager is <tt>cFileOutputScalarManager</tt>,
     defined in the Envir library.
   <li><strong></strong><tt>cOutputVectorManager</tt>. It handles recording the output
     for <tt>cOutVector</tt> objects.
     The default output vector manager is <tt>cFileOutputVectorManager</tt>,
     defined in the Envir library.
   <li><strong></strong><tt>cSnapshotManager</tt>. It provides an output stream to which
     snapshots are written (see section <a href="#sec:ch-sim-lib:snapshots">[click]</a>).
     The default snapshot manager is <tt>cFileSnapshotManager</tt>,
     defined in the Envir library.
</UL>

<p>The above interfaces are documented in the API Reference, generated by Doxygen.

<p>The corresponding ini file entries that allow you to select your
plugin classes are <tt>outputvectormanager-class</tt>,
<tt>outputscalarmanager-class</tt> and <tt>snapshotmanager-class</tt>,
documented in section <a href="#sec:ch-run-sim:general-section">[click]</a>.

<p>

<p><H3><A NAME="sec379"/>13.5.4. Implementation of the user interface: simulation applications</H3>

<p>The base class for simulation application is <tt>TOmnetApp</tt>.
Specific user interfaces such as <tt>TCmdenv</tt>,
<tt>TOmnetTkApp</tt> are derived from <tt>TOmnetApp</tt>.

<p><tt>TOmnetApp</tt>'s member functions are almost all virtual.
<UL>
  <li><strong></strong>Some of them implement the <tt>cEnvir</tt> functions
    (described in the previous section)
  <li><strong></strong>Others implement the common part of all user interfaces (for
    example: reading options from the configuration files; making the
    options effective within the simulation kernel)
  <li><strong></strong>The <tt>run()</tt> function is pure virtual (it is different
    for each user interface).
</UL>

<p><tt>TOmnetApp</tt>'s data members:
<UL>
  <li><strong></strong>a pointer to the object holding configuration file contents
    (type <tt>cInifile</tt>);
  <li><strong></strong>the options and switches that can be set from the
    configuration file (these members begin with <tt>opt_</tt>)
</UL>

<p>Concrete simulation applications:
<UL>
  <li><strong></strong>add new configuration options
  <li><strong></strong>provide a <tt>run()</tt> function
  
<p>  <li><strong></strong>implement functions left empty in <tt>TOmnetApp</tt> (like
    <tt>breakpointHit()</tt>, <tt>objectDeleted()</tt>).
</UL>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><H1><A NAME="sec380"/>14. NED Language Grammar</H1>
<a name="cha:ned-language-grammar"></a>

<p>The NED language, the network topology description language of
OMNeT++ will be given using the extended BNF notation.

<p>Space, horizontal tab and new line characters counts as delimiters,
so one or more of them is required between two elements of the
description which would otherwise be unseparable. '//' (two slashes)
may be used to write comments that last to the end of the line.
The language only distinguishes between lower and upper case
letters in names, but not in keywords.

<p>
In this description, the {xxx...} notation stands for one or
more xxx's separated with spaces, tabs or new line characters,
and {xxx,,,} stands for one or more xxx's, separated with a
comma and (optionally) spaces, tabs or new line characters.

<p>
For ease of reading, in some cases we use textual definitions.
The <EM>networkdescription</EM> symbol is the sentence symbol of the
grammar.

<p>
<pre>
        <STRONG>notation    meaning</STRONG>
        [a]         0 or 1 time a
        {a}         a
        {a,,,}      1 or more times a, separated by commas
        {a...}      1 or more times a, separated by spaces
        a|b         a or b
        `a'         the character a
        <STRONG>bold</STRONG>        keyword
        <EM>italic</EM>      identifier

<p>
networkdescription ::=
    { definition... }

<p>definition    ::=
      include
    | channeldefinition
    | simpledefinition
    | moduledefinition
    | networkdefinition

<p>include ::=
    <STRONG>INCLUDE</STRONG> { fileName ,,, } ;

<p>channeldefinition ::=
    <STRONG>CHANNEL</STRONG> <EM>channeltype</EM>
     [ <STRONG>DELAY</STRONG> numericvalue ]
     [ <STRONG>ERROR</STRONG> numericvalue ]
     [ <STRONG>DATARATE</STRONG> numericvalue ] <sup>******</sup>
    <STRONG>ENDCHANNEL</STRONG>

<p>simpledefinition ::=
    <STRONG>SIMPLE</STRONG> <EM>simplemoduletype</EM>
     [ machineblock ]
     [ paramblock ]
     [ gateblock ]
    <STRONG>ENDSIMPLE</STRONG> [ <EM>simplemoduletype</EM> ]

<p>moduledefinition ::=
    <STRONG>MODULE</STRONG> <EM>compoundmoduletype</EM>
     [ machineblock<sup>*</sup> ]
     [ paramblock ]
     [ gateblock ]
     [ submodblock ]
     [ connblock ]
    <STRONG>ENDMODULE</STRONG> [ <EM>compoundmoduletype</EM> ]

<p>moduletype ::=
    <EM>simplemoduletype</EM> | <EM>compoundmoduletype</EM>

<p>machineblock ::=
    <STRONG>MACHINES:</STRONG> { <EM>machine</EM> ,,, } ;

<p>paramblock ::=
    <STRONG>PARAMETERS:</STRONG> { parameter ,,, } ;

<p>parameter ::=
    <EM>parametername</EM>
    | <EM>parametername</EM> : <STRONG>CONST</STRONG> [ <STRONG>NUMERIC</STRONG> ]
    | <EM>parametername</EM> <STRONG>: STRING</STRONG>
    | <EM>parametername</EM> <STRONG>: BOOL</STRONG>
    | <EM>parametername</EM> <STRONG>: CHAR</STRONG>
    | <EM>parametername</EM> <STRONG>: ANYTYPE</STRONG>

<p>gateblock ::=
    <STRONG>GATES:</STRONG>
     [ <STRONG>IN:</STRONG> { gate ,,, } ; ]
     [ <STRONG>OUT:</STRONG> { gate ,,, } ; ]
gate ::=
    <EM>gatename</EM> [ '[]' ]

<p>submodblock ::=
    <STRONG>SUBMODULES:</STRONG> { submodule... }

<p>submodule ::=
    { <EM>submodulename</EM> : <EM>moduletype</EM> [ vector ]
     [ on_block<sup>*</sup>... ]
     [ substparamblock... ]
     [ gatesizeblock... ] }
  | { <EM>submodulename</EM> : <EM>parametername</EM> [ vector ] <STRONG>LIKE</STRONG> <EM>moduletype</EM>
     [ on_block<sup>*</sup>... ]
     [ substparamblock... ]
     [ gatesizeblock... ] }

<p>on_block<sup>*</sup> ::=
    <STRONG>ON</STRONG> [ <STRONG>IF</STRONG> expression ]<STRONG>:</STRONG> { <EM>on_machine</EM> ,,, } ;

<p>substparamblock    ::=
    <STRONG>PARAMETERS</STRONG> [ <STRONG>IF</STRONG> expression ]<STRONG>:</STRONG>
      { <EM>substparamname</EM> = substparamvalue,,, } ;

<p>substparamvalue ::=
    ( [ <STRONG>ANCESTOR</STRONG> ] [ <STRONG>REF</STRONG> ] <EM>name</EM> )
    | parexpression

<p>gatesizeblock ::=
    <STRONG>GATESIZES</STRONG> [ <STRONG>IF</STRONG> expression ]<STRONG>:</STRONG>
      { <EM>gatename</EM> vector ,,, } ;

<p>connblock ::=
    <STRONG>CONNECTIONS</STRONG> [ <STRONG>NOCHECK</STRONG> ]<STRONG>:</STRONG> { connection ,,, } ;

<p>connection ::=
     normalconnection | loopconnection

<p>loopconnection ::=
    <STRONG>FOR</STRONG> { index... } <STRONG>DO</STRONG>
      { normalconnection ,,, } ;
    <STRONG>ENDFOR</STRONG>

<p>index ::=
    <EM>indexvariable</EM> '=' expression ``...'' expression

<p>normalconnection ::=
     { gate { -&gt; | &lt;- } gate [ <STRONG>IF</STRONG> expression ]}
   | {gate -&gt; channel -&gt; gate [ <STRONG>IF</STRONG> expression ]}
   | {gate &lt;- channel &lt;- gate [ <STRONG>IF</STRONG> expression ]}

<p>channel ::=
     <EM>channeltype</EM>
    | [ <STRONG>DELAY</STRONG> expression ] [ <STRONG>ERROR</STRONG> expression ] [ <STRONG>DATARATE</STRONG> expression ]
        <sup>******</sup>

<p>gate ::=
    [ <EM>modulename</EM> [vector]. ] <EM>gatename</EM> [vector]

<p>networkdefinition ::=
    <STRONG>NETWORK</STRONG> <EM>networkname</EM> : <EM>moduletype</EM>
     [ on_block ]
     [ substparamblock ]
    <STRONG>ENDNETWORK</STRONG>

<p>vector ::=    '[' expression ']'

<p>parexpression ::=
    expression | otherconstvalue

<p>expression    ::=
      expression + expression
    | expression - expression
    | expression * expression
    | expression / expression
    | expression % expression
    | expression ^ expression
    | expression == expression
    | expression != expression
    | expression <SAMP>&lt;</SAMP> expression
    | expression <SAMP>&lt;</SAMP>= expression
    | expression <SAMP>&gt;</SAMP> expression
    | expression <SAMP>&gt;</SAMP>= expression
    | expression ? expression : expression
    | expression <STRONG>AND</STRONG> expression
    | expression <STRONG>OR</STRONG> expression
    | <STRONG>NOT</STRONG> expression
    | '(' expression ')'
    | <EM>functionname</EM> '(' [ expression ,,, ] ')' <sup>***</sup>
    | - expression
    | numconstvalue
    | inputvalue
    | [ <STRONG>ANCESTOR</STRONG> ] [ <STRONG>REF</STRONG> ] <EM>parametername</EM>
    | <STRONG>SIZEOF</STRONG><sup>****</sup> '(' <EM>gatename</EM> ')'
    | <STRONG>INDEX</STRONG><sup>*****</sup>

<p>numconstvalue ::=
    <EM>integerconstant</EM> | <EM>realconstant</EM> | <EM>timeconstant</EM>

<p>otherconstvalue ::=
      '<EM>characterconstant'</EM>
    | "<EM>stringconstant</EM>"
    | <STRONG>TRUE</STRONG>
    | <STRONG>FALSE</STRONG>

<p>inputvalue ::=
    <STRONG>INPUT</STRONG> '(' default , "<EM>prompt-string</EM>" ')'

<p>default ::=
    expression | otherconstvalue
</pre>

<p>
<sup>*</sup> used with distributed execution

<p>
<sup>**</sup> used with the statistical synchronization method<br>
<sup>***</sup> max. three arguments. The function name must be declared
in the C++ sources with the Define_Function macro.<br>
<sup>****</sup> Size of a vector gate.<br>
<sup>*****</sup> Index in submodule vector.<br>
<sup>******</sup> Can appear in any order.

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>May  1 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<H1><A NAME="sec381"/>15. References</H1>

<p><a name="bib-Entacher02"></a>[EHW02]&nbsp;&nbsp;
K. Entacher, B. Hechenleitner, and S. Wegenkittl.
 A simple OMNeT++ queuing experiment using parallel streams.
  PARALLEL NUMERICS'02 - Theory and Applications, pages 89-105,
  2002.
 Editors: R. Trobec, P. Zinterhof, M. Vajtersic and A. Uhl.

<p><a name="bib-Akaroa99"></a>[EPM99]&nbsp;&nbsp;
G. Ewing, K. Pawlikowski, and D. McNickle.
 Akaroa2: Exploiting network computing by distributing stochastic
  simulation.
 In  Proceedings of the European Simulation Multiconference
  ESM'99, Warsaw, June 1999, pages 175-181. International Society for
  Computer Simulation, 1999.

<p><a name="bib-Goldberg91what"></a>[Gol91]&nbsp;&nbsp;
David Goldberg.
 What every computer scientist should know about floating-point
  arithmetic.
  ACM Computing Surveys, 23(1):5-48, 1991.

<p><a name="bib-Hellekalek98"></a>[Hel98]&nbsp;&nbsp;
P. Hellekalek.
 Don't trust parallel Monte Carlo.
  ACM SIGSIM Simulation Digest, 28(1):82-89, jul 1998.
 Author's page is a great source of information, see
  http://random.mat.sbg.ac.at/.

<p><a name="bib-JAR"></a>[HPvdL95]&nbsp;&nbsp;
Jan Heijmans, Alex Paalvast, and Robert van~der Leij.
 Network simulation using the JAR compiler for the OMNeT++
  simulation system.
 Technical report, Technical University of Budapest, Dept. of
  Telecommunications, 1995.

<p><a name="bib-Jain91"></a>[Jai91]&nbsp;&nbsp;
Raj Jain.
  The Art of Computer Systems Performance Analysis.
 Wiley, New York, 1991.

<p><a name="bib-JCh85"></a>[JC85]&nbsp;&nbsp;
Raj Jain and Imrich Chlamtac.
 The $P^2$ algorithm for dynamic calculation of quantiles and
  histograms without storing observations.
  Communications of the ACM, 28(10):1076-1085, 1985.

<p><a name="bib-Kofoed95"></a>[Kof95]&nbsp;&nbsp;
Stig Kofoed.
 Portable multitasking in C++.
  Dr. Dobb's Journal, November 1995.
 Download sorce from http://www.ddj.com/ftp/1995/1995.11/mtask.zip/.

<p><a name="bib-LGThesis"></a>[Len94]&nbsp;&nbsp;
G&aacute;bor Lencse.
 Graphical network editor for OMNeT++.
 Master's thesis, Technical University of Budapest, 1994.
 In Hungarian.

<p><a name="bib-LEcuyer02"></a>[LSCK02]&nbsp;&nbsp;
P. L'Ecuyer, R. Simard, E. J. Chen, and W. D. Kelton.
 An objected-oriented random-number package with many long streams and
  substreams.
  Operations Research, 50(6):1073-1075, 2002.
 Source code can be downloaded from
  http://www.iro.umontreal.ca/~lecuyer/papers.html.

<p><a name="bib-Matsumoto98"></a>[MN98]&nbsp;&nbsp;
M. Matsumoto and T. Nishimura.
 Mersenne Twister: A 623-dimensionally equidistributed uniform
  pseudorandom number generator.
  ACM Trans. on Modeling and Computer Simulation, 8(1):3-30,
  1998.
 Source code can be downloaded from
  http://www.math.keio.ac.jp/~matumoto/emt.html.

<p><a name="bib-OMNeTExamples"></a>[MvMvdW95]&nbsp;&nbsp;
Andr&eacute; Maurits, George van Montfort, and Gerard van~de Weerd.
 OMNeT++ extensions and examples.
 Technical report, Technical University of Budapest, Dept. of
  Telecommunications, 1995.

<p><a name="bib-BFS86"></a>[PFS86]&nbsp;&nbsp;
Bratley P., B. L. Fox, and L. E. Schrage.
  A Guide to Simulation.
 Springer-Verlag, New York, 1986.

<p><a name="bib-Pawlikowsky02"></a>[PJL02]&nbsp;&nbsp;
K. Pawlikowski, H. Jeong, and J. Lee.
 On credibility of simulation studies of telecommunication networks.
  IEEE Communications Magazine, pages 132-139, jan 2002.

<p><a name="bib-PongorOmnet"></a>[Pon91]&nbsp;&nbsp;
Gy&ouml;rgy Pongor.
 OMNET: An object-oriented network simulator.
 Technical report, Technical University of Budapest, Dept. of
  Telecommunications, 1991.

<p><a name="bib-PongorSSM92"></a>[Pon92]&nbsp;&nbsp;
Gy&ouml;rgy Pongor.
 Statistical Synchronization: A different approach of parallel
  discrete event simulation.
 Technical report, University of Technology, Data Communications
  Laboratory, Lappeenranta, Finland, 1992.

<p><a name="bib-PongorSSM93"></a>[Pon93]&nbsp;&nbsp;
Gy&ouml;rgy Pongor.
 On the efficiency of the Statistical Synchronization Method.
 In  Proceedings of the European Simulation Symposium (ESS'93),
  Delft, The Netherlands, Oct. 25-28, 1993. International Society for Computer
  Simulation, 1993.

<p><a name="bib-AVTDK"></a>[Var92]&nbsp;&nbsp;
Andr&aacute;s Varga.
 OMNeT++ - portable simulation environment in C++.
 In  Proceedings of the Annual Students' Scientific Conference
  (TDK), 1992. Technical University of Budapest, 1992.
 In Hungarian.

<p><a name="bib-AVThesis"></a>[Var94]&nbsp;&nbsp;
Andr&aacute;s Varga.
 Portable user interface for the OMNeT++ simulation system.
 Master's thesis, Technical University of Budapest, 1994.
 In Hungarian.

<p><a name="bib-KSplit98"></a>[Var98a]&nbsp;&nbsp;
Andr&aacute;s Varga.
 K-split - on-line density estimation for simulation result
  collection.
 In  Proceedings of the European Simulation Symposium (ESS'98),
  Nottingham, UK, October 26-28. International Society for Computer
  Simulation, 1998.

<p><a name="bib-Paramtop98"></a>[Var98b]&nbsp;&nbsp;
Andr&aacute;s Varga.
 Parameterized topologies for simulation programs.
 In  Proceedings of the Western Multiconference on Simulation
  (WMC'98) / Communication Networks and Distributed Systems (CNDS'98), San
  Diego, CA, January 11-14. International Society for Computer Simulation,
  1998.

<p><a name="bib-Edu99"></a>[Var99]&nbsp;&nbsp;
Andr&aacute;s Varga.
 Using the OMNeT++ discrete event simulation system in education.
  IEEE Transactions on Education, 42(4):372, November 1999.
 on CD-ROM issue; journal contains abstract.

<p><a name="bib-VZThesis"></a>[Vas96]&nbsp;&nbsp;
Zolt&aacute;n Vass.
 PVM extension of OMNeT++ to support Statistical
  Synchronization.
 Master's thesis, Technical University of Budapest, 1996.
 In Hungarian.

<p><a name="bib-KSplit97"></a>[VF97]&nbsp;&nbsp;
Andr&aacute;s Varga and Babak Fakhamzadeh.
 The K-Split algorithm for the PDF approximation of
  multi-dimensional empirical distributions without storing observations.
 In  Proceedings of the 9th European Simulation Symposium
  (ESS'97), Passau, Germany, October 19-22, 1997, pages 94-98. International
  Society for Computer Simulation, 1997.

<p><a name="bib-Flex97"></a>[VP97]&nbsp;&nbsp;
Andr&aacute;s Varga and Gy&ouml;rgy Pongor.
 Flexible topology description language for simulation programs.
 In  Proceedings of the 9th European Simulation Symposium
  (ESS'97), Passau, Germany, October 19-22, 1997, pages 225-229, 1997.

<p><a name="bib-WelchBook"></a>[Wel95]&nbsp;&nbsp;
Brent Welch.
  Practical Programming in Tcl and Tk.
 Prentice-Hall, 1995.

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Dec  7 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Jun 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>


</BODY>
</HTML>
