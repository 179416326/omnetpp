<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>OMNeT++ - Manual</TITLE>
   <META NAME="Author" CONTENT="Andras Varga">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFE8" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<P><FONT COLOR="#FF0000"><B><FONT SIZE=+4>OMNeT++ </FONT></B>
<I><FONT SIZE=+1>Discrete Event Simulation System</FONT></I></FONT></P>

<H1><B>User Manual</B></H1><H3>OMNeT++ version 2.3b1</H3><H1>Chapters</H1>
<B><A HREF="#toc_1.">1. <FONTgreen>Introduction</FONT></A></B><BR>
<B><A HREF="#toc_2.">2. <FONTgreen>Overview</FONT></A></B><BR>
<B><A HREF="#toc_3.">3. <FONTgreen>An Example: The Nim Game</FONT></A></B><BR>
<B><A HREF="#toc_4.">4. <FONTgreen>The NED Language</FONT></A></B><BR>
<B><A HREF="#toc_5.">5. <FONTgreen>Simple Modules</FONT></A></B><BR>
<B><A HREF="#toc_6.">6. <FONTgreen>The Simulation Library</FONT></A></B><BR>
<B><A HREF="#toc_7.">7. <FONTgreen>Message Definitions</FONT></A></B><BR>
<B><A HREF="#toc_8.">8. <FONTgreen>Building Simulation Programs</FONT></A></B><BR>
<B><A HREF="#toc_9.">9. <FONTgreen>Running The Simulation</FONT></A></B><BR>
<B><A HREF="#toc_10.">10. <FONTgreen>Analyzing Simulation Results</FONT></A></B><BR>
<B><A HREF="#toc_11.">11. <FONTgreen>Parallel Execution</FONT></A></B><BR>
<B><A HREF="#toc_12.">12. <FONTgreen>The Design of OMNeT++</FONT></A></B><BR>
<B><A HREF="#toc_13.">13. <FONTgreen>OPNET and OMNeT++</FONT></A></B><BR>
<B><A HREF="#toc_14.">14. <FONTgreen>PARSEC and OMNeT++</FONT></A></B><BR>
<B><A HREF="#toc_15.">15. <FONTgreen>NED Language Grammar</FONT></A></B><BR>
<B><A HREF="#toc_16.">16. <FONTgreen>References</FONT></A></B><BR>
<HR><H1>Table of Contents</H1>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_1."></A><A HREF="#sec100">1. <FONTgreen>Introduction</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.1."></A><A HREF="#sec101">1.1. <FONTblue>What is OMNeT++?</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.2."></A><A HREF="#sec102">1.2. <FONTblue>Where is OMNeT++ in the world of simulation tools?</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.3."></A><A HREF="#sec103">1.3. <FONTblue>Organization of this manual</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.4."></A><A HREF="#sec104">1.4. <FONTblue>History</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_1.5."></A><A HREF="#sec105">1.5. <FONTblue>Authors</FONT></A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_2."></A><A HREF="#sec106">2. <FONTgreen>Overview</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1."></A><A HREF="#sec107">2.1. <FONTblue>Modeling concepts</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.1."></A><A HREF="#sec108">2.1.1. <FONTteal>Hierarchical modules</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.2."></A><A HREF="#sec109">2.1.2. <FONTteal>Module types</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.3."></A><A HREF="#sec110">2.1.3. <FONTteal>Messages, gates, links</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.4."></A><A HREF="#sec111">2.1.4. <FONTteal>Link characteristics</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.5."></A><A HREF="#sec112">2.1.5. <FONTteal>Parameters</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.1.6."></A><A HREF="#sec113">2.1.6. <FONTteal>Topology description method</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2."></A><A HREF="#sec114">2.2. <FONTblue>Programming the algorithms</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.1."></A><A HREF="#sec115">2.2.1. <FONTteal>Creating simple modules</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.2."></A><A HREF="#sec116">2.2.2. <FONTteal>Object mechanisms</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.3."></A><A HREF="#sec117">2.2.3. <FONTteal>Derive new classes</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.2.4."></A><A HREF="#sec118">2.2.4. <FONTteal>Self-describing objects to ease debugging</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3."></A><A HREF="#sec119">2.3. <FONTblue>Using OMNeT++</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.1."></A><A HREF="#sec120">2.3.1. <FONTteal>Building and running simulations</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_2.3.2."></A><A HREF="#sec121">2.3.2. <FONTteal>What is what in the directories</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_3."></A><A HREF="#sec122">3. <FONTgreen>An Example: The Nim Game</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.1."></A><A HREF="#sec123">3.1. <FONTblue>Topology</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.2."></A><A HREF="#sec124">3.2. <FONTblue>Simple modules</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.3."></A><A HREF="#sec125">3.3. <FONTblue>Running the simulation</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_3.4."></A><A HREF="#sec126">3.4. <FONTblue>Other examples</FONT></A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_4."></A><A HREF="#sec127">4. <FONTgreen>The NED Language</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1."></A><A HREF="#sec128">4.1. <FONTblue>NED overview</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.1."></A><A HREF="#sec129">4.1.1. <FONTteal>Components of a NED description</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.2."></A><A HREF="#sec130">4.1.2. <FONTteal>Reserved words</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.1.3."></A><A HREF="#sec131">4.1.3. <FONTteal>Case sensitivity</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.2."></A><A HREF="#sec132">4.2. <FONTblue>The import statement</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.3."></A><A HREF="#sec133">4.3. <FONTblue>Channel definitions</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4."></A><A HREF="#sec134">4.4. <FONTblue>Simple module definitions</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.1."></A><A HREF="#sec135">4.4.1. <FONTteal>Simple module parameters</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.4.2."></A><A HREF="#sec136">4.4.2. <FONTteal>Simple module gates</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5."></A><A HREF="#sec137">4.5. <FONTblue>Compound module definitions</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.1."></A><A HREF="#sec138">4.5.1. <FONTteal>Compound module parameters</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.2."></A><A HREF="#sec139">4.5.2. <FONTteal>Compound module gates</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.3."></A><A HREF="#sec140">4.5.3. <FONTteal>Submodules</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.5.4."></A><A HREF="#sec141">4.5.4. <FONTteal>Connections</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6."></A><A HREF="#sec142">4.6. <FONTblue>Parameterized compound modules</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.1."></A><A HREF="#sec143">4.6.1. <FONTteal>Examples</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.2."></A><A HREF="#sec144">4.6.2. <FONTteal>Using const with parameterized topologies</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.3."></A><A HREF="#sec145">4.6.3. <FONTteal>Design patterns for compound modules</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.6.4."></A><A HREF="#sec146">4.6.4. <FONTteal>Topology templates</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.7."></A><A HREF="#sec147">4.7. <FONTblue>Network definition</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8."></A><A HREF="#sec148">4.8. <FONTblue>Support for parallel execution</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.1."></A><A HREF="#sec149">4.8.1. <FONTteal>Extensions to the compound module and system definitions</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.8.2."></A><A HREF="#sec150">4.8.2. <FONTteal>Conditional 'on' sections</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9."></A><A HREF="#sec151">4.9. <FONTblue>Expressions</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.1."></A><A HREF="#sec152">4.9.1. <FONTteal>Referencing other parameters</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.2."></A><A HREF="#sec153">4.9.2. <FONTteal>Operators</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.3."></A><A HREF="#sec154">4.9.3. <FONTteal>The <tt>sizeof()</tt> and <tt>index</tt> operators</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.4."></A><A HREF="#sec155">4.9.4. <FONTteal>Prompt text and default value</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.5."></A><A HREF="#sec156">4.9.5. <FONTteal>Time constants</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.6."></A><A HREF="#sec157">4.9.6. <FONTteal>Functions</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.7."></A><A HREF="#sec158">4.9.7. <FONTteal>Random values</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.9.8."></A><A HREF="#sec159">4.9.8. <FONTteal>Defining new functions</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.10."></A><A HREF="#sec160">4.10. <FONTblue>Display strings</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_4.11."></A><A HREF="#sec161">4.11. <FONTblue>GNED - Graphical NED Editor</FONT></A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_5."></A><A HREF="#sec162">5. <FONTgreen>Simple Modules</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1."></A><A HREF="#sec163">5.1. <FONTblue>Simulation concepts</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.1."></A><A HREF="#sec164">5.1.1. <FONTteal>Discrete Event Simulation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.2."></A><A HREF="#sec165">5.1.2. <FONTteal>The event loop</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.3."></A><A HREF="#sec166">5.1.3. <FONTteal>Simple modules in OMNeT++</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.4."></A><A HREF="#sec167">5.1.4. <FONTteal>Events in OMNeT++</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.1.5."></A><A HREF="#sec168">5.1.5. <FONTteal>FES implementation</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2."></A><A HREF="#sec169">5.2. <FONTblue>Defining simple module types</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.1."></A><A HREF="#sec170">5.2.1. <FONTteal>Overview</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.2."></A><A HREF="#sec171">5.2.2. <FONTteal>The module declaration</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.3."></A><A HREF="#sec172">5.2.3. <FONTteal>Several modules, single NED interface</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.4."></A><A HREF="#sec173">5.2.4. <FONTteal>The class declaration</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.2.5."></A><A HREF="#sec174">5.2.5. <FONTteal>Decomposing activity()/handleMessage() and inheritance</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3."></A><A HREF="#sec175">5.3. <FONTblue>Adding functionality to cSimpleModule</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.1."></A><A HREF="#sec176">5.3.1. <FONTteal>activity()</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.2."></A><A HREF="#sec177">5.3.2. <FONTteal>handleMessage()</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.3.3."></A><A HREF="#sec178">5.3.3. <FONTteal>initialize() and finish()</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.4."></A><A HREF="#sec179">5.4. <FONTblue>Finite State Machines in OMNeT++</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.5."></A><A HREF="#sec180">5.5. <FONTblue>Message transmission modeling</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.6."></A><A HREF="#sec181">5.6. <FONTblue>Coding conventions</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.7."></A><A HREF="#sec182">5.7. <FONTblue>Component libraries</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.7.1."></A><A HREF="#sec183">5.7.1. <FONTteal>Simple module libraries</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.7.2."></A><A HREF="#sec184">5.7.2. <FONTteal>Compound module NED source libraries</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.7.3."></A><A HREF="#sec185">5.7.3. <FONTteal>Precompiled compound module libraries</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8."></A><A HREF="#sec186">5.8. <FONTblue>Some simulation techniques</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.1."></A><A HREF="#sec187">5.8.1. <FONTteal>Modeling computer networks</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.2."></A><A HREF="#sec188">5.8.2. <FONTteal>Modeling multiprocessor systems</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.3."></A><A HREF="#sec189">5.8.3. <FONTteal>Parameter tuning</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.4."></A><A HREF="#sec190">5.8.4. <FONTteal>Multiple experiments within one simulation run</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_5.8.5."></A><A HREF="#sec191">5.8.5. <FONTteal>Dynamic topology optimization</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_6."></A><A HREF="#sec192">6. <FONTgreen>The Simulation Library</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.1."></A><A HREF="#sec193">6.1. <FONTblue>Class library conventions</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.2."></A><A HREF="#sec194">6.2. <FONTblue>Utilities</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3."></A><A HREF="#sec195">6.3. <FONTblue>Messages and packets</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3.1."></A><A HREF="#sec196">6.3.1. <FONTteal>The cMessage class</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3.2."></A><A HREF="#sec197">6.3.2. <FONTteal>Message encapsulation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3.3."></A><A HREF="#sec198">6.3.3. <FONTteal>Information about the last sending</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3.4."></A><A HREF="#sec199">6.3.4. <FONTteal>Context pointer</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3.5."></A><A HREF="#sec200">6.3.5. <FONTteal>The cPacket class</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.3.6."></A><A HREF="#sec201">6.3.6. <FONTteal>Attaching parameters and objects</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4."></A><A HREF="#sec202">6.4. <FONTblue>Sending and receiving messages</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.1."></A><A HREF="#sec203">6.4.1. <FONTteal>Sending messages</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.2."></A><A HREF="#sec204">6.4.2. <FONTteal>Delayed sending</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.3."></A><A HREF="#sec205">6.4.3. <FONTteal>Direct message sending</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.4."></A><A HREF="#sec206">6.4.4. <FONTteal>Receiving messages</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.5."></A><A HREF="#sec207">6.4.5. <FONTteal>The wait() function</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.6."></A><A HREF="#sec208">6.4.6. <FONTteal>Self-messages</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.7."></A><A HREF="#sec209">6.4.7. <FONTteal>Querying the state of an output gate</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.4.8."></A><A HREF="#sec210">6.4.8. <FONTteal>Stopping the simulation</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5."></A><A HREF="#sec211">6.5. <FONTblue>Accessing module parameters and gates</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5.1."></A><A HREF="#sec212">6.5.1. <FONTteal>Module parameters</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.5.2."></A><A HREF="#sec213">6.5.2. <FONTteal>Gates and links</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.6."></A><A HREF="#sec214">6.6. <FONTblue>Walking the module hierarchy</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.7."></A><A HREF="#sec215">6.7. <FONTblue>Dynamic module creation</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8."></A><A HREF="#sec216">6.8. <FONTblue>Routing support: cTopology</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.1."></A><A HREF="#sec217">6.8.1. <FONTteal>Overview</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.2."></A><A HREF="#sec218">6.8.2. <FONTteal>Basic usage</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.8.3."></A><A HREF="#sec219">6.8.3. <FONTteal>Shortest paths</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9."></A><A HREF="#sec220">6.9. <FONTblue>Generating random numbers</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.1."></A><A HREF="#sec221">6.9.1. <FONTteal>Random number generators</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.2."></A><A HREF="#sec222">6.9.2. <FONTteal>Random variates</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.9.3."></A><A HREF="#sec223">6.9.3. <FONTteal>Random numbers from histograms</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10."></A><A HREF="#sec224">6.10. <FONTblue>Container classes</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.1."></A><A HREF="#sec225">6.10.1. <FONTteal>Queue class: cQueue</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.10.2."></A><A HREF="#sec226">6.10.2. <FONTteal>Expandable array: cArray</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.11."></A><A HREF="#sec227">6.11. <FONTblue>Non-object container classes</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12."></A><A HREF="#sec228">6.12. <FONTblue>The parameter class: cPar</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.1."></A><A HREF="#sec229">6.12.1. <FONTteal>Basic usage</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.2."></A><A HREF="#sec230">6.12.2. <FONTteal>Random number generation through cPar</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.3."></A><A HREF="#sec231">6.12.3. <FONTteal>Storing object and non-object pointers in cPar</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.4."></A><A HREF="#sec232">6.12.4. <FONTteal>Reverse Polish expressions</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.5."></A><A HREF="#sec233">6.12.5. <FONTteal>Using redirection</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.6."></A><A HREF="#sec234">6.12.6. <FONTteal>Type characters</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.12.7."></A><A HREF="#sec235">6.12.7. <FONTteal>Summary</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.13."></A><A HREF="#sec236">6.13. <FONTblue>Statistics and distribution estimation</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.13.1."></A><A HREF="#sec237">6.13.1. <FONTteal>
cStatistic and descendants</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.13.2."></A><A HREF="#sec238">6.13.2. <FONTteal>Distribution estimation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.13.3."></A><A HREF="#sec239">6.13.3. <FONTteal>The k-split algorithm</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.13.4."></A><A HREF="#sec240">6.13.4. <FONTteal>Transient detection and result accuracy</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.14."></A><A HREF="#sec241">6.14. <FONTblue>Recording simulation results</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.14.1."></A><A HREF="#sec242">6.14.1. <FONTteal>Output vectors: cOutVector</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.14.2."></A><A HREF="#sec243">6.14.2. <FONTteal>Output scalars</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.15."></A><A HREF="#sec244">6.15. <FONTblue>Deriving new classes</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.16."></A><A HREF="#sec245">6.16. <FONTblue>Tracing and debugging aids</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.16.1."></A><A HREF="#sec246">6.16.1. <FONTteal>Displaying information about module activity</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.16.2."></A><A HREF="#sec247">6.16.2. <FONTteal>Watches</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.16.3."></A><A HREF="#sec248">6.16.3. <FONTteal>Snapshots</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.16.4."></A><A HREF="#sec249">6.16.4. <FONTteal>Breakpoints</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.16.5."></A><A HREF="#sec250">6.16.5. <FONTteal>Disabling warnings</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.16.6."></A><A HREF="#sec251">6.16.6. <FONTteal>Getting coroutine stack usage</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.17."></A><A HREF="#sec252">6.17. <FONTblue>Changing the network graphics at run-time</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.17.1."></A><A HREF="#sec253">6.17.1. <FONTteal>Setting display strings</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.17.2."></A><A HREF="#sec254">6.17.2. <FONTteal>The cDisplayStringParser class</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.18."></A><A HREF="#sec255">6.18. <FONTblue>Tips for speeding up the simulation</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.18.1."></A><A HREF="#sec256">6.18.1. <FONTteal>Using shared objects</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.19."></A><A HREF="#sec257">6.19. <FONTblue>Building large networks</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.19.1."></A><A HREF="#sec258">6.19.1. <FONTteal>Generating NED files</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_6.19.2."></A><A HREF="#sec259">6.19.2. <FONTteal>Building the network from C++ code</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_7."></A><A HREF="#sec260">7. <FONTgreen>Message Definitions</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.1."></A><A HREF="#sec261">7.1. <FONTblue>Motivation</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.2."></A><A HREF="#sec262">7.2. <FONTblue>The first message class</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3."></A><A HREF="#sec263">7.3. <FONTblue>Features</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.1."></A><A HREF="#sec264">7.3.1. <FONTteal>Declaring enums</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.2."></A><A HREF="#sec265">7.3.2. <FONTteal>Message declarations</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.3."></A><A HREF="#sec266">7.3.3. <FONTteal>Inheritance, composition</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.4."></A><A HREF="#sec267">7.3.4. <FONTteal>Using existing C++ types</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.3.5."></A><A HREF="#sec268">7.3.5. <FONTteal>Customizing the generated class</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.4."></A><A HREF="#sec269">7.4. <FONTblue>Summary</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_7.5."></A><A HREF="#sec270">7.5. <FONTblue>Example</FONT></A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_8."></A><A HREF="#sec271">8. <FONTgreen>Building Simulation Programs</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.1."></A><A HREF="#sec272">8.1. <FONTblue>Overview</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2."></A><A HREF="#sec273">8.2. <FONTblue>Using Unix and gcc</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.1."></A><A HREF="#sec274">8.2.1. <FONTteal>Installation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.2."></A><A HREF="#sec275">8.2.2. <FONTteal>Building simulation models</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.3."></A><A HREF="#sec276">8.2.3. <FONTteal>Multi-directory models</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.2.4."></A><A HREF="#sec277">8.2.4. <FONTteal>Static vs shared OMNeT++ system libraries</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3."></A><A HREF="#sec278">8.3. <FONTblue>Using Windows and Microsoft Visual C++</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3.1."></A><A HREF="#sec279">8.3.1. <FONTteal>Installation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_8.3.2."></A><A HREF="#sec280">8.3.2. <FONTteal>Building simulation models</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_9."></A><A HREF="#sec281">9. <FONTgreen>Running The Simulation</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.1."></A><A HREF="#sec282">9.1. <FONTblue>User interfaces</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2."></A><A HREF="#sec283">9.2. <FONTblue>The configuration file: omnetpp.ini</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.1."></A><A HREF="#sec284">9.2.1. <FONTteal>An example</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.2."></A><A HREF="#sec285">9.2.2. <FONTteal>The concept of simulation runs</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.3."></A><A HREF="#sec286">9.2.3. <FONTteal>Sections and entries</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.4."></A><A HREF="#sec287">9.2.4. <FONTteal>File inclusion</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.2.5."></A><A HREF="#sec288">9.2.5. <FONTteal>The [General] section</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3."></A><A HREF="#sec289">9.3. <FONTblue>Cmdenv: the command-line interface</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.1."></A><A HREF="#sec290">9.3.1. <FONTteal>Command-line switches</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.3.2."></A><A HREF="#sec291">9.3.2. <FONTteal>Cmdenv ini file options</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4."></A><A HREF="#sec292">9.4. <FONTblue>Tkenv: the graphical user interface</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4.1."></A><A HREF="#sec293">9.4.1. <FONTteal>Command-line switches</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4.2."></A><A HREF="#sec294">9.4.2. <FONTteal>Tkenv ini file settings</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4.3."></A><A HREF="#sec295">9.4.3. <FONTteal>Using the graphical environment</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.4.4."></A><A HREF="#sec296">9.4.4. <FONTteal>In Memoriam... </FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5."></A><A HREF="#sec297">9.5. <FONTblue>More about omnetpp.ini</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.1."></A><A HREF="#sec298">9.5.1. <FONTteal>The [Slaves] section</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.2."></A><A HREF="#sec299">9.5.2. <FONTteal>Module parameters in the configuration file</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.3."></A><A HREF="#sec300">9.5.3. <FONTteal>Configuring output vectors</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.4."></A><A HREF="#sec301">9.5.4. <FONTteal>Display strings</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.5.5."></A><A HREF="#sec302">9.5.5. <FONTteal>Specifying seed values</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.6."></A><A HREF="#sec303">9.6. <FONTblue>Choosing good seed values: the seedtool utility</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.7."></A><A HREF="#sec304">9.7. <FONTblue>Repeating or iterating simulation runs</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.8."></A><A HREF="#sec305">9.8. <FONTblue>Typical problems</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.8.1."></A><A HREF="#sec306">9.8.1. <FONTteal>Stack problems</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_9.8.2."></A><A HREF="#sec307">9.8.2. <FONTteal>Memory allocation problems</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_10."></A><A HREF="#sec308">10. <FONTgreen>Analyzing Simulation Results</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1."></A><A HREF="#sec309">10.1. <FONTblue>Plotting output vectors with Plove</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.1."></A><A HREF="#sec310">10.1.1. <FONTteal>Plove features</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.2."></A><A HREF="#sec311">10.1.2. <FONTteal>Usage</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.1.3."></A><A HREF="#sec312">10.1.3. <FONTteal>Writing filters</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.2."></A><A HREF="#sec313">10.2. <FONTblue>Format of output vector files</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3."></A><A HREF="#sec314">10.3. <FONTblue>Working without Plove</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.1."></A><A HREF="#sec315">10.3.1. <FONTteal>Extracting vectors from the file</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.2."></A><A HREF="#sec316">10.3.2. <FONTteal>Using splitvec</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_10.3.3."></A><A HREF="#sec317">10.3.3. <FONTteal>Visualization under Unix</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_11."></A><A HREF="#sec318">11. <FONTgreen>Parallel Execution</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.1."></A><A HREF="#sec319">11.1. <FONTblue>OMNeT++ support for parallel execution</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.1.1."></A><A HREF="#sec320">11.1.1. <FONTteal>Introduction to Parallel Discrete Event Simulation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.1.2."></A><A HREF="#sec321">11.1.2. <FONTteal>OMNeT++ support for parallel simulation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.1.3."></A><A HREF="#sec322">11.1.3. <FONTteal>Syncpoints</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2."></A><A HREF="#sec323">11.2. <FONTblue>Configuring a simulation for parallel execution</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.1."></A><A HREF="#sec324">11.2.1. <FONTteal>Configuring OMNeT++</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.1.1."></A><A HREF="#sec325">11.2.1.1. <FONTteal>Choosing between MPI and PVM</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.1.2."></A><A HREF="#sec326">11.2.1.2. <FONTteal>Mapping logical machines to physical ones</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.1.3."></A><A HREF="#sec327">11.2.1.3. <FONTteal>Configuration of the slaves</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.2."></A><A HREF="#sec328">11.2.2. <FONTteal>Setting up PVM</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.2.1."></A><A HREF="#sec329">11.2.2.1. <FONTteal>The PVM virtual machine</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.2.2."></A><A HREF="#sec330">11.2.2.2. <FONTteal>Configuration and running</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.2.3."></A><A HREF="#sec331">11.2.2.3. <FONTteal>If there are problems...</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.2.3."></A><A HREF="#sec332">11.2.3. <FONTteal>Setting up MPI</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3."></A><A HREF="#sec333">11.3. <FONTblue>Statistical synchronization</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3.1."></A><A HREF="#sec334">11.3.1. <FONTteal>The description of the Statistical Synchronization Method (SSM)</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_11.3.2."></A><A HREF="#sec335">11.3.2. <FONTteal>Using SSM in OMNeT++</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_12."></A><A HREF="#sec336">12. <FONTgreen>The Design of OMNeT++</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.1."></A><A HREF="#sec337">12.1. <FONTblue>Structure of an OMNeT++ executable</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.2."></A><A HREF="#sec338">12.2. <FONTblue>Embedding OMNeT++</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3."></A><A HREF="#sec339">12.3. <FONTblue>The simulation kernel</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.1."></A><A HREF="#sec340">12.3.1. <FONTteal>The central object: cSimulation simulation</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.2."></A><A HREF="#sec341">12.3.2. <FONTteal>Module classes</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.3."></A><A HREF="#sec342">12.3.3. <FONTteal>Global registration lists</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.4."></A><A HREF="#sec343">12.3.4. <FONTteal>The coroutine package</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.3.5."></A><A HREF="#sec344">12.3.5. <FONTteal>Object ownership/contains relationships</FONT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.4."></A><A HREF="#sec345">12.4. <FONTblue>The user interface</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.4.1."></A><A HREF="#sec346">12.4.1. <FONTteal>The main() function</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.4.2."></A><A HREF="#sec347">12.4.2. <FONTteal>The cEnvir interface</FONT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_12.4.3."></A><A HREF="#sec348">12.4.3. <FONTteal>Implementation of the user interface: simulation applications</FONT></A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_13."></A><A HREF="#sec349">13. <FONTgreen>OPNET and OMNeT++</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.1."></A><A HREF="#sec350">13.1. <FONTblue>Comparison of OPNET and OMNeT++</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_13.2."></A><A HREF="#sec351">13.2. <FONTblue>Quick reference for OPNET users</FONT></A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_14."></A><A HREF="#sec352">14. <FONTgreen>PARSEC and OMNeT++</FONT></A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.1."></A><A HREF="#sec353">14.1. <FONTblue>What is PARSEC?</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.2."></A><A HREF="#sec354">14.2. <FONTblue>What is inside the PARSEC package?</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.3."></A><A HREF="#sec355">14.3. <FONTblue>PARSEC vs. the OMNeT++ simulation kernel</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.4."></A><A HREF="#sec356">14.4. <FONTblue>Feature summary</FONT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="toc_14.5."></A><A HREF="#sec357">14.5. <FONTblue>Correspondence between PARSEC and OMNeT++</FONT></A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_15."></A><A HREF="#sec358">15. <FONTgreen>NED Language Grammar</FONT></A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="toc_16."></A><A HREF="#sec359">16. <FONTgreen>References</FONT></A></B></FONT><BR>
 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><b>Document History</b>

<p>
<table border>
<TR> <TD align=left>

<p><b>Date</b> </TD> <TD align=left> <b>Author</b> </TD> <TD align=left> <b>Change</b></TD></TR>
<TR> <TD align=left> 2003/01 </TD> <TD align=left> AV </TD> <TD align=left> Added chapter about message subclassing; revised chapter about
running the simulation and incorporated new Cmdenv options; added new 
distributions and clarified many details in NED expr. handling section</TD></TR>
<TR> <TD align=left> Summer 2002 </TD> <TD align=left> Ulrich Kaage </TD> <TD align=left> Converted from Word to LaTeX</TD></TR>
<TR> <TD align=left> 2002/03/18 </TD> <TD align=left> AV </TD> <TD align=left> Documented new ini file options about Envir plugins</TD></TR>
<TR> <TD align=left> 2002/01/24 </TD> <TD align=left> AV </TD> <TD align=left> Refinements on the Parsec chapter</TD></TR>
<TR> <TD align=left> 2001/10/23 </TD> <TD align=left> AV </TD> <TD align=left> Updated to reflect changes since 2.1 release (see include/ChangeLog)</TD></TR>
<TR> <TD align=left> </table>

<p>

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb  3 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec100"/>1. <FONTgreen>Introduction</FONT></H1></font></hr>
<a name="cha:introduction"/>

<p>
<hr><font color="#006f00"><H2><A NAME="sec101"/>1.1. <FONTblue>What is OMNeT++?</FONT></H2></font></hr>

<p>OMNeT++ is an object-oriented modular discrete event simulator.
The name itself stands for Objective Modular Network Testbed
in C++. OMNeT++ has its distant roots in OMNeT, a simulator written
in Object Pascal by dr. Gy\"orgy Pongor.

<p>The simulator can be used for modeling:
<UL>
  <li><strong></strong>communication protocols
  <li><strong></strong>computer networks and traffic modeling
  <li><strong></strong>multi-processor and distributed systems
  <li><strong></strong>administrative systems
  <li><strong></strong>... any other system where the discrete event approach is
    suitable.
</UL>

<p>
An OMNeT++ model consists of hierarchically nested modules. The
depth of module nesting is not limited, which allows the user
to reflect the logical structure of the actual system in the
model structure. Modules communicate with message passing. Messages
can contain arbitrarily complex data structures. Modules can
send messages either directly to their destination or along a
predefined path, through gates and connections.

<p>
Modules can have parameters which are used for three main purposes:
to customize module behaviour; to create flexible model topologies
(where parameters can specify the number of modules, connection
structure etc); and for module communication, as shared variables.

<p>Modules at the lowest level of the module hierarchy are to be
provided by the user, and they contain the algorithms in the
model. During simulation execution, simple modules appear to
run in parallel, since they are implemented as coroutines (sometimes
termed lightweight processes). To write simple modules, the user
does not need to learn a new programming language, but he/she
is assumed to have some knowledge of C++ programming.

<p>OMNeT++ simulations can feature different user interfaces for
different purposes: debugging, demonstration and batch execution.
Advanced user interfaces make the inside of the model visible
to the user, allow him/her to start/stop simulation execution
and to intervene by changing variables/objects inside the model.
This is very important in the development/debugging phase
of the simulation project. User interfaces also facilitate demonstration
of how a model works.

<p>The simulator as well as user interfaces and tools are portable:
they are known to work on Windows and on several Unix flavours,
using various C++ compilers.

<p>OMNeT++ has been extended to execute the simulation in parallel.
Any kind of synchronization mechanism can be used. One suitable
synchronization mechanism is the statistical synchronization,
for which OMNeT++ provides explicit support.

<p>
OMNeT++ Home Page on the Web:

<p>
<a href="http://www.hit.bme.hu/phd/vargaa/omnetpp.htm">http://www.hit.bme.hu/phd/vargaa/omnetpp.htm</a>

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec102"/>1.2. <FONTblue>Where is OMNeT++ in the world of simulation tools?</FONT></H2></font></hr>

<p>There are numerous network simulation tools on the market today,
both commercial and non-commercial. In this section I will try
to give an overview by picking some of the most important or
most representative ones in both categories and comparing them
to OMNeT++: PARSEC, SMURPH, NS, Ptolemy, NetSim++, C++SIM, CLASS
as non-commercial, and OPNET, COMNET III as commercial tools.
(The OMNeT++ Home Page contains a list of Web sites with collections
of references to network simulation tools where the reader can
get a more complete list.) In the commercial category, OPNET
is widely held to be the state of the art in network simulation.
OMNeT++ is targeted at roughly the same segment of network simulation
as OPNET.&nbsp;

<p>
Seven issues are examined to get an overview about the network
simulation tools:

<p>
<STRONG>Detail Level</STRONG>. <EM>Does the simulation tool have the necessary
power to express details in the model?</EM> In other words, can the
user implement arbitrary new building blocks like in OMNeT++
or he is confined to the predefined blocks implemented by the
supplier? Some tools like COMNET III are not programmable by
the user to this extent therefore they cannot be compared to
OMNeT++. Specialized network simulation tools like NS (for IP)
and CLASS (for ATM) also rather fall into this category.

<p>
<STRONG>Available Models.</STRONG> <EM>What protocol models are readily available
for the simulation tool?</EM> On this point, non-commercial simulation
tools cannot compete with some commercial ones (especially OPNET)
which have a large selection of ready-made protocol models. OMNeT++
is no exception.

<p>
<STRONG>Defining Network Topology</STRONG>. <EM>How does the simulation
  tool support defining the network topology?</EM> Is it possible to
create some form of hierarchy (nesting) or only ''flat'' topologies
are supported? Network simulation tools naturally share the property
that a model (network) consists of ''nodes'' (blocks, entities,
modules, etc.) connected by ''links'' (channels, connections, etc.).
Many commercial simulators have graphical editors to define the
network; however, this is only a good solution if there is an
alternative form of topology description (e.g. text file) which allows
one to generate the topology by program. OPNET follows a unique way:
the network topology is stored in a proprietary binary file format
which can be generated (and read) by the graphical editor and C
programs linked against a special library. On the other hand, most
non-commercial simulation tools do not provide explicit support for
topology description: one must program a ''driver entity'' which will
boot the model by creating the necessary nodes and interconnecting
them (PARSEC, SMURPH, NS). Finally, a large part of the tools that do
support explicit topology description supports only flat topologies
(CLASS). OMNeT++ probably uses the most flexible method: it has a
human-readable textual topology description format (the NED language)
which is easy to create with any text-processing tool (<tt>perl</tt>,
<tt>awk</tt>, etc.), and the same format is used by the graphical
editor. It is also possible to create a ''driver entity'' to build a
network at run-time by program. OMNeT++ also supports submodule
nesting.

<p>
<STRONG>Programming Model.</STRONG> <EM>What is the programming model supported
by the simulation environment?</EM> Network simulators typically use
either thread/coroutine-based programming (such as <tt>activity()</tt>
in OMNeT++), or FSMs built upon a <tt>handleMessage()</tt>-like function.
For example, OPNET, SMURPH and NetSim++ use FSMs (with underlying
handleMessage()), PARSEC and C++SIM use threads. OMNeT++ supports
both programming models; the author does not know of another
simulation tool that does so.

<p>
<STRONG>Debugging and Tracing Support.</STRONG> <EM>What debugging or tracing
facilities does the simulation tool offer?</EM> Simulation programs
are infamous for long debugging periods. C++-based simulation
tools rarely offer much more than <tt>printf()</tt>-style debugging; often
the simulation kernel is also capable of dumping selected debug
information on the standard output. Animation is also often supported,
either off-line (record&amp;playback) or in some client-server architecture,
where the simulation program is the ''server'' and
it can be viewed using the ''client''. Off-line animation
naturally lacks interactivity and is therefore little use in
debugging. The client-server solution typically has limited power
because the simulation and the viewer run as independent operating
system processes, and the viewer has limited access to the simulation
program's internals and/or it does not have enough control over
the course of simulation execution. OPNET has a very good support
for command-line debugging and provides both off-line and client-server
style animation. NetSim++ and Ptolemy use the client-server method
of animation. OMNeT++ goes a different way by linking the GUI
library with the debugging/tracing capability into the simulation
executable. This architecture enables the GUI to be very powerful:
every user-created object is visible (and modifiable) in the
GUI via inspector windows and the user has tight control over
the execution. To the author's best knowledge, the tracing feature
OMNeT++ provides is unique among the C++-based simulation tools.

<p>
<STRONG>Performance.</STRONG> <EM>What performance can be expected from the
simulation?</EM> Simulation programs typically run for several hours.
Probably the most important factor is the programming language;
almost all network simulation tools are C/C++-based. Performance
is a particularly interesting issue with OMNeT++ since the GUI
debugging/tracing support involves some extra overhead in the
simulation library. However, in a reported case, an OMNeT++ simulation
was only 1.3 slower than its counterpart implemented in plain
C (i.e. one containing very little administration overhead),
which is a very good showing. A similar result was reported in
a performance comparison with a PARSEC simulation.

<p>
<STRONG>Source Availability.</STRONG> <EM>Is the simulation library available
in source?</EM> This is a trivial question but it immediately becomes
important if one wants to examine or teach the internal workings
of a simulation kernel, or one runs into trouble because some
function in the simulation library has a bug and/or it is not
documented well enough. In general it can be said that non-commercial
tools (like OMNeT++) are open-source and commercial ones are
not. This is also true for OPNET: the source for simulation kernel
is not available (although the ready-made protocol models come
with sources).

<p>
In conclusion, it can be said that OMNeT++ has enough features
to make it a good alternative to most network simulation tools,
and it has a strong potential to become one of the most widely
used network simulation packages in academic and research environments.
The most serious shortcoming is the lack of available protocol
models, but since this is mostly due to the fact that it is a
relatively new simulation tool, with the help of the OMNeT++
user community the situation is likely to become much better
in the future.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec103"/>1.3. <FONTblue>Organization of this manual</FONT></H2></font></hr>

<p>The manual is organized around the following topics:
<UL>
  <li><strong></strong>The Chapters <a href="#cha:introduction">[click]</a>, <a href="#cha:overview">[click]</a> and
    <a href="#cha:the-nim-game">[click]</a> contain introductory material: some
    overview and an example simulation.
  <li><strong></strong>The second group of Chapters, <a href="#cha:the-ned-language">[click]</a>,
    <a href="#cha:simple-modules">[click]</a> and <a href="#cha:the-simulation-library">[click]</a> are
    the programming guide. They present the NED language, the
    simulation concepts and their implementation in OMNeT++, explain
    how to write simple modules and describe the class library.
  <li><strong></strong>The following chapters,
    <a href="#cha:building-simulation-programs">[click]</a>,
    <a href="#cha:running-the-simulation">[click]</a> and
    <a href="#cha:analyzing-simulation-results">[click]</a> deal with practical issues
    like building and running simulations and analyzing results, and
    present the tools OMNeT++ has to support these tasks.
  <li><strong></strong>Chapter <a href="#cha:parallel-execution">[click]</a> is devoted to the support
    for distributed execution.
  <li><strong></strong>Finally, Chapter <a href="#cha:the-design-of-omnet">[click]</a> explains the
    architecture and the internals of OMNeT++. This chapter will be
    useful to those who want to extend the capabilities of the
    simulator or want to embed it into a larger application.
  <li><strong></strong>The first two Appendices, <a href="#cha:opnet-and-omnet">[click]</a> and
    <a href="#cha:parsec-and-omnet">[click]</a>, contain a comparison of OMNeT++ and
    two other important and well-known simulation tools, OPNET and
    PARSEC.
  <li><strong></strong>Appendice <a href="#cha:ned-language-grammar">[click]</a> provides a reference
    of the NED language.
</UL>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec104"/>1.4. <FONTblue>History</FONT></H2></font></hr>

<p>The development of OMNeT++ started as a semester's programming
assignment at the Technical University of Budapest (BME) in 1992.
The assignment (``creation of an object-oriented discrete event
simulation system in C++'') was handed out by Prof. Dr Gy\"orgy
Pongor, and two students signed up: \'Akos Kun and Andr\'as Varga.
The basis for the design was Mr. Pongor's existing simulation
software written in Pascal, named OMNeT.

<p>At that time, we wrote the code under Borland C++ 3.1. The idea
of multiple runtime environments (a significant addition to the
original OMNeT design) was there from the first moment; naturally,
we used Turbo Vision (Borland's then successful character-based
GUI) for the first `graphical' user interface. In 1992, we submitted
a paper about OMNeT++ to the student's annual university conference
(named ``TDK'') and won first prize in the ``Software'' section.
Later we also won 1st prize in the national ``TDK''. Then the
idea came to port OMNeT++ to Unix (first for AIX on an RS/6000
with 16MB (!) RAM, later Linux), until all development was done
in Linux and BC3.1 could no longer be supported.

<p>Well, here's a brief list of events since then - maybe one time
I'll make up my mind to enhance them to a whole story...

<p>1994: XEnv (a GUI in pure MOTIF, superceded by Tkenv by now)
was written as diploma work

<p>1994: used OPNET for several simulation projects. OPNET features
(and flaws) gave lots of ideas how to continue with OMNeT++.

<p>1995: initial version of nedc was written by a group of exchange
students from Delft

<p>1996: initial version of PVM support was programmed by Zoltan
Vass as diploma work

<p>1997: started working on Tkenv

<p>1997 Dec: added GNED

<p>1997 Sept: web site set up, first public release

<p>1997 Feb-1998 Sept: simulation projects for a small company in
Hungary. We used a version of OMNeT++.

<p>1998 March: added Plove

<p>1998 June: animation implemented in GNED

<p>1998 Sept-1999 May: work at MeTechnology (later Brokat) in Leipzig

<p>2000 Jan: MSVC porting

<p>2000 Sept: contributed model repository set up

<p>2000: IP-suite created in Karlsruhe

<p>2001 June: the CVS is hosted in Karlsruhe

<p>...

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec105"/>1.5. <FONTblue>Authors</FONT></H2></font></hr>

<p>OMNeT++ has been developed mostly by Andr\'as Varga at the Technical
University of Budapest, Department of Telecommunications (BME-HIT).

<p>  Andr\'as Varga    BME-HIT, andras@whale.hit.bme.hu

<p>
Since leaving the university in 1998, I've been doing the development
in my free time.

<p>Several people have worked for shorter periods (1..3 months)
on different topics within OMNeT++. Credit for organizing this
goes to Dr. Gy\"orgy Pongor (BME-HIT, <a href="mailto:pongor@hit.bme.hu">pongor@hit.bme.hu</a>), my
advisor at the University. Here is a more-or-less complete list
of people:

<p>Old NED compiler, 1992-93:<br>
  \'Akos Kun    BME

<p>JAR compiler (now called NEDC), sample simulations; summer 1995:<br>
  Jan Heijmans    TU Delft<br>
  Alex Paalvast    TU Delft<br>
  Robert van der Leij  TU Delft

<p>New feaures, testing, new examples; fall 1995:<br>
  Maurits Andr\'e    TU Delft, M.J.A.Andre@twi.tudelft.nl<br>
  George van Montfort  TU Delft, G.P.R.vanMontfort@twi.tudelft.nl<br>
  Gerard van de Weerd  TU Delft, G.vandeweerd@twi.tudelft.nl

<p>JAR (NEDC) support for distributed execution:<br>
  G\'abor Lencse    BME-HIT, lencse@hit.bme.hu

<p>PVM support (as final project), spring 1996:<br>
  Zolt\'an Vass    BME-HIT

<p>P<sup>2</sup>, k-split algorithms and more, from fall 1996:<br>
  Babak Fakhamzadeh  TU Delft

<p>
We have to mention Dr. Leon Rothkranz from the Technical University
of Delft whose work made it possible for the Delft students to
come to Budapest in 1995.

<p>Several bugfixes and valuable suggestions for improvements came
from the user community of OMNeT++. It would be impossible to
mention everyone here, and the list is constantly growing -
instead, the README file contains acknowledgements to those I
can remember.

<p>Since the summer of 2001, the OMNeT++ sources are kept in the
CVS server at the University of Karlsruhe. Credit for setting
up and maintaining the CVS server goes to Ulrich Kaage.

<p>The starting point of this manual was the 1995 report of Jan
Heijmans, Alex Paalvast and Robert van der Leij.

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec106"/>2. <FONTgreen>Overview</FONT></H1></font></hr>
<a name="cha:overview"/>

<p>
<hr><font color="#006f00"><H2><A NAME="sec107"/>2.1. <FONTblue>Modeling concepts</FONT></H2></font></hr>

<p>OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are:
<UL>
<li><strong></strong>hierarchically nested modules
<li><strong></strong>modules are instances of module types
<li><strong></strong>modules communicate with messages through channels
<li><strong></strong>flexible module parameters
<li><strong></strong>topology description language
</UL>

<p><font color="#006f00"><H3><A NAME="sec108"/>2.1.1. <FONTteal>Hierarchical modules</FONT></H3></font>

<p>
An OMNeT++ model consists of hierarchically nested
modules which communicate with messages.
OMNeT++ models are often referred to as <EM>networks</EM>. The top
level module is the <EM>system module</EM>.  The system module
contains <EM>submodules</EM>, which can also contain submodules
themselves (Fig. <a href="#fig:ch-overview:modules">[click]</a>). The depth of module
nesting is not limited; this allows the user to reflect the logical
structure of the actual system in the model structure.

<p>
<DIV ALIGN=center>
<img src="usmanFig2.gif">
<center><i>Figure: Simple and compound modules</i></center>
<a name="fig:ch-overview:modules"/>
</DIV>

<p>

<p>Modules that contain submodules are termed <EM>compound
  modules</EM>, as opposed <EM>simple
  modules</EM> which are at the lowest level of the
module hierarchy. Simple modules contain the algorithms in the model.
The user implements the simple modules in C++, using the OMNeT++
simulation class library.

<p>
<font color="#006f00"><H3><A NAME="sec109"/>2.1.2. <FONTteal>Module types</FONT></H3></font>


<p>Both simple and compound modules are instances of <EM>module
  types</EM>. While describing the model, the user defines module types;
instances of these module types serve as components for more complex
module types. Finally, the user creates the system module as an
instance of a previously defined module type; all modules of the
network are instantiated as submodules and sub-submodules of the
system module.

<p>
When a module type is used as a building block, there is no
distinction whether it is a simple or a compound module. This allows
the user to split a simple module into several
simple modules embedded into a compound module,
or vica versa, aggregate the functionality of a compound module into a
single simple module, without affecting existing users of the module
type.

<p>
Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <EM>component libraries</EM>. This feature
will be discussed later, in Chapter <a href="#cha:running-the-simulation">[click]</a>.

<p>

<p><font color="#006f00"><H3><A NAME="sec110"/>2.1.3. <FONTteal>Messages, gates, links</FONT></H3></font>

<p>Modules communicate by exchanging
<EM>messages</EM>. In an actual simulation,
messages can represent frames or packets in a computer network, jobs
or customers in a queuing network or other types of mobile entities.
Messages can contain arbitrarily complex data structures. Simple
modules can send messages either directly to their destination or
along a predefined path, through gates and connections.

<p>
The ``local simulation time'' of a module advances when the module
receives a message. The message can arrive from another module
or from the same module (<EM>self-messages</EM> are used to implement
timers).

<p>
<EM>Gates</EM>indexgate are the input and output interfaces of
modules; messages are sent out through output gates and arrive through
input gates.

<p>Each <EM>connection</EM> (also called
<EM>link</EM>) is created within a single level of the
module hierarchy: within a compound module, one can connect the
corresponding gates of two submodules, or a gate of one submodule and
a gate of the compound module (Fig.
<a href="#fig:ch-overview:connections">[click]</a>).

<p>
<DIV ALIGN=center>
<img src="usmanFig3.gif">
<center><i>Figure: Connections</i></center>
<a name="fig:ch-overview:connections"/>
</DIV>

<p>
Due to the hierarchical structure of the model, messages typically
travel through a series of connections, to start and arrive in simple
modules. Such series of connections that go from simple module to
simple module are called <EM>routes</EM>.  Compound modules act as
'cardboard boxes' in the model, transparently relaying messages
between their inside and their outside world.

<p>
<font color="#006f00"><H3><A NAME="sec111"/>2.1.4. <FONTteal>Link characteristics</FONT></H3></font>

<p>Connections can be assigned three parameters which facilitate
the modeling of communication networks, but can be useful for
other models too:
<UL>
  <li><strong></strong>propagation delay (sec)
  <li><strong></strong>bit error rate (errors/bit)
  <li><strong></strong>data rate (bits/sec)
</UL>

<p>
Each of these parameters is optional. One can specify link parameters
individually for each connection, or define link types (also
called <EM>channel</EM> <EM>types</EM>) once and use them throughout the
whole model.

<p>The <EM>propagation delay</EM> is the amount of time the arrival of
the message is delayed by when it travels through the channel.
Propagation delay is specified in seconds.

<p>The <EM>bit error rate</EM> has influence on the transmission of messages
through the channel. The bit error rate is the probability that
a bit is incorrectly transmitted. Thus, the probability that
a message of <EM>n</EM> bits length is transferred correctly is:<br>

<p>
$P( <EM>sent message received properly</EM> ) = (1 - <EM>ber</EM>)^<i>n</i>$<br>
where <EM>ber</EM> = bit error rate and <EM>n</EM> = number of bits in message.<br>

<p>
The message has an error flag which is set in case of transmission
errors.

<p>The <EM>data rate</EM> is specified in bits/second, and it is used
for transmission delay calculation. The sending time of the message
normally corresponds to the transmission of the first bit, and
the arrival time of the message corresponds to the reception
of the last bit (Fig. <a href="#fig:ch-overview:message-transm">[click]</a>).

<p>
<DIV ALIGN=center>
<img src="usmanFig4.gif">
<center><i>Figure: Message transmission</i></center>
<a name="fig:ch-overview:message-transm"/>
</DIV>

<p>
The above model is not applicable for modeling some protocols like
Token Ring and FDDI where the stations repeat the bits of a frame that
arrives on the ring immediately, without waiting for the whole frame
to arrive; in other words, frames ''flow through'' the stations, being
delayed only a few bits. If you want to model such networks, the data
rate modeling feature of OMNeT++ cannot be used.

<p>If a message travels along a route, through successive links and
compound modules, the model behaves as if each module waited until the
last bit of the message arrives and only start its transmission then
(Fig. <a href="#fig:ch-overview:msg-multiple-ch">[click]</a>).

<p>
<DIV ALIGN=center>
<img src="usmanFig5.gif">
<center><i>Figure: Message sending over multiple channels</i></center>
<a name="fig:ch-overview:msg-multiple-ch"/>
</DIV>

<p>
Since the above effect is usually not the desired one, typically
you will want to assign data rate to only one connection in the
route.

<p>
<font color="#006f00"><H3><A NAME="sec112"/>2.1.5. <FONTteal>Parameters</FONT></H3></font>



<p>Modules can have parameters. Parameters are used for three purposes:
<OL>
  <li><strong></strong>to parameterize module topology
  <li><strong></strong>to customize simple module behaviour
  <li><strong></strong>for module communication, as shared variables
</OL>

<p>Parameters can take string, numeric or pointer values; numeric
values include expressions using other parameters and calling
C functions, random variables from different distributions, and
values input interactively by the user.

<p>
Numeric-valued parameters can be used to construct topologies in a
flexible way. Within a compound module, parameters can define the
number of submodules, number of gates, and the way the internal
connections are made.

<p>
Compound modules can pass parameters or expressions of parameters
to their submodules. Parameter passing can be done by value or
by reference.

<p>During simulation execution, if a module changes the value of
a parameter taken by reference, the changed value propagates
to other modules. This effect can be used to tune the model or
as a second means of module communication. Pointer-valued parameters
can be used to implement shared memory.

<p>
<font color="#006f00"><H3><A NAME="sec113"/>2.1.6. <FONTteal>Topology description method</FONT></H3></font>

The user defines the structure of the model in NED language descriptions
(Network Description).The NED language will be discussed in detail
in Chapter <a href="#cha:the-ned-language">[click]</a>.

<p>
<hr><font color="#006f00"><H2><A NAME="sec114"/>2.2. <FONTblue>Programming the algorithms</FONT></H2></font></hr>

<p>The simple modules of a model contain the algorithms as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.

<p>
OMNeT++ supports a process-style description method for describing
activities. During simulation execution, simple module functions
appear to run in parallel, because they are implemented as coroutines
(also termed lightweight processes). Coroutines were chosen because
they allow an intuitive description of the algorithm and they
can also serve as a good basis for implementing other description
methods like state-transition diagrams or Petri nets.

<p>OMNeT++ has a consistent object-oriented design. One can freely
use OOP concepts (inheritance, polymorphism etc) to extend the
functionality of the simulator.

<p>Elements of the simulation (messages, modules, queues etc.) are
represented as objects. These classes are part of the simulation
class library:
<UL>
<li><strong></strong>modules, gates, connections etc.
<li><strong></strong>parameters
<li><strong></strong>messages
<li><strong></strong>container classes (e.g. queue, array)
<li><strong></strong>data collection classes
<li><strong></strong>statistic and distribution estimation classes (histograms, $P^2$
algorithm for calculating quantiles etc.)
<li><strong></strong>transient detection and result accuracy detection classes
</UL>

<p>The objects are designed so that they can efficiently work together,
creating a powerful framework for simulation programming.

<p>
<font color="#006f00"><H3><A NAME="sec115"/>2.2.1. <FONTteal>Creating simple modules</FONT></H3></font>


<p>Each simple module type is implemented with a C++ class. Simple
module classes are derived from a simple module base class, by
redefining the virtual function that contains the algorithm.
The user can add other member functions to the class to split
up a complex algorithm; he can also add data members to the class.

<p>It is also possible to derive new simple module classes from
existing ones. For example, if one wants to experiment with retransmission
timeout schemes in a transport protocol, he can implement the
protocol in one class, create a virtual function for the retransmission
algorithm and then derive a family of classes that implement
concrete schemes. This concept is further supported by the fact
that in the network description, actual module types can be parameters.

<p>
<font color="#006f00"><H3><A NAME="sec116"/>2.2.2. <FONTteal>Object mechanisms</FONT></H3></font>

<p>The use of smart container classes allows the user to build
<EM>aggregate data structures</EM>.
For example, one can add any number of objects to a message object as
parameters. Since the added objects can contain further objects,
complex data structures can be built.

<p>There is an efficient <EM>ownership</EM> mechanism
built in. The user can specify an owner for each object; then, the
owner object will have the responsibility of destroying that object.
Most of the time, the ownership mechanism works transparently;
ownership only needs to be explicitly managed when the user wants to
do something non-typical.

<p>
The <EM>forEach</EM> mechanism allows one to
enumerate the objects inside a container object in a uniform way and
do some operation on them. This feature which makes it possible to
handle many objects together. (The forEach feature is extensively used
by the user interfaces with debugging capability and the snapshot
mechanism; see later.)

<p>
<font color="#006f00"><H3><A NAME="sec117"/>2.2.3. <FONTteal>Derive new classes</FONT></H3></font>

<p>It most cases, the functionality offered by the OMNeT++ classes
is enough for the user. But if it is needed, one can derive new
classes from the existing ones or create entirely new classes.
For flexibility, several member functions are declared virtual.
When the user creates new classes, certain rules need to be kept
so that the object can fully work together with other objects.

<p>
<font color="#006f00"><H3><A NAME="sec118"/>2.2.4. <FONTteal>Self-describing objects to ease debugging</FONT></H3></font>


<p>The class library is designed so that objects can give textual
information about themselves. This makes it possible to peek
into a running simulation program: through an appropriate user
interface, one can examine (and modify) the internal data structures
of a running simulation. This feature helps the user to get some
insight what is happening inside the model and get hands-on experience.

<p>
A unique feature called <EM>snapshot</EM> allows the
user to dump the contents of the simulation model or a part of it into
a text file. The file will contain textual reports about every object;
this can be of invaluable help at times of debugging. Ordinary
variables can also be made to appear in the snapshot file. Snapshot
creations can be scheduled from within the simulation program or done
from the user interface.

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec119"/>2.3. <FONTblue>Using OMNeT++</FONT></H2></font></hr>

<p>
<font color="#006f00"><H3><A NAME="sec120"/>2.3.1. <FONTteal>Building and running simulations</FONT></H3></font>



<p>This section gives some idea how to work with OMNeT++ in practice:
issues like model files, compiling and running simulations are
discussed.

<p>An OMNeT++ model consists of the following parts:
<UL>
  <li><strong></strong>NED language topology description(s) which
    describe the module structure with parameters, gates etc. They are
    files with .ned suffix. NED files can be written with any text
    editor or using the GNED graphical editor.
  <li><strong></strong> Simple modules sources. They are C++ files, with <SAMP>.h</SAMP>/<SAMP>.cc</SAMP> suffix.
</UL>

<p>The simulation system provides the following components:
<UL>
  <li><strong></strong>Simulation kernel. This contains the
    code that manages the simulation and the simulation class library.
    It is written in C++, compiled and put together to form a library
    (a file with .a or .lib extension)
  <li><strong></strong>User interfaces
    \indexuser interface|seesimulation interface. OMNeT++ user interfaces
    are used with simulation execution, to facilitate debugging,
    demonstration, or batch execution of simulations. There are
    several user interfaces, written in C++, compiled and put together
    into libraries (<SAMP>.a</SAMP> or <SAMP>.lib</SAMP> files).
</UL>

<p>
Simulation programs are built from the above components. First, the
NED files are compiled into C++ source code, using
the NEDC\indexned!compiler compiler which is part of OMNeT++. Then
all C++ sources are compiled and linked with the simulation kernel and
a user interface to form a simulation executable.

<p>
<STRONG>Running the simulation and analyzing the results</STRONG>

<p>The simulation executable is a standalone program<font size=-1>[as long as
  it is linked statically]</font>; thus, it can be run on other machines
without OMNeT++ or the model files being present. When the program is
started, it reads in a configuration
file (usually called
<SAMP>omnetpp.ini</SAMP>); it contains settings that
control how the simulation is run, values for model parameters, etc.
The configuration file can also prescribe several simulation runs; in
the simplest case, they will be executed by the simulation program one
after another.

<p>The output of the simulation is written into data files: output vector
files, output scalar files
, and possibly the user's own output files.
OMNeT++ provides a GUI tool named Plove to view and plot the contents
of output vector files. But it is not expected that someone will
process the result files using OMNeT++ alone: output files are text
files in a format which (maybe after some preprocessing using
<tt>sed</tt>, <tt>awk</tt> or <tt>perl</tt>) can be read into math
packages like Matlab or its free equivalent Octave, or imported into
spreadsheets like Excel. All these external programs have rich
functionality for statistical analysis and visualization, and OMNeT++
does not try to duplicate their efforts. This manual briefly describes
some data plotting programs and how to use them with OMNeT++.

<p>
<STRONG>User interfaces</STRONG>


<p>The primary purpose of user interfaces is to make the inside
of the model visible to the user, to start/stop simulation execution,
and possibly allow the user intervene by changing variables/objects
inside the model. This is very important in the development/debugging
phase of the simulation project. Just as important, a hands-on
experience allows the user to get a 'feel' about the model's
behaviour. A nice graphical user interface can also be used to
demonstrate how the model works internally.

<p>
The same simulation model can be executed with different user
interfaces, without any change in the model files themselves.
The user would test and debug the simulation with a powerful
graphical user interface, and finally run it with a simple and
fast user interface that supports batch execution.

<p>
<STRONG>Component libraries</STRONG>


<p>Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create component libraries.

<p>
<STRONG>Universal standalone simulation programs</STRONG>

<p>
A simulation executable can store several independent models
that use the same set of simple modules. The user can specify
in the configuration file which model he/she wants to run. This
allows one to build one large executable that contains several
simulation models, and distribute it as a standalone simulation
tool. The flexibility of the topology description language also
supports this approach.

<p>
<font color="#006f00"><H3><A NAME="sec121"/>2.3.2. <FONTteal>What is what in the directories</FONT></H3></font>

<p>To help you navigate among files in the OMNeT++ distribution,
here's a list what you can find in the different directories.

<p>The <SAMP>omnetpp</SAMP> directory contains the following subdirectories.

<p>The simulation system itself:

<p><pre>
  <b>omnetpp/</b>       OMNeT++ root directory
    <b>bin/</b>         OMNeT++ executables (GNED, nedc, etc.)
    <b>include/</b>     header files for simulation models
    <b>lib/</b>         library files
    <b>bitmaps/</b>     icons that can be used in network graphics
    <b>doc/</b>         manual (PDF), readme, license, etc.
      <b>html/</b>      manual in HTML
       <b>api/</b>      API reference in HTML
    <b>src/</b>         OMNeT++ sources
      <b>nedc/</b>      NED compiler
      <b>sim/</b>       simulation kernel
        <b>std/</b>     files for non-distributed execution
        <b>pvm/</b>     files for distributed execution over PVM
        <b>mpi/</b>     files for distributed execution using MPI
      <b>envir/</b>     common code for user interfaces
      <b>cmdenv/</b>    command-line user interface
      <b>tkenv/</b>     Tcl/Tk-based user interface
      <b>gned/</b>      graphical NED editor
      <b>plove/</b>     output vector analyzer and plotting tool
      <b>utils/</b>     makefile-autocreator etc
</pre>

<p>There is a tutorial, contributed by Nick van Foreest

<p><pre>
    <b>tutorial/</b>    the tutorial document
      <b>queues/</b>    sample simulation that supports the tutorial
      <b>doc_src/</b>  the Latex sources for the tutorial doc
</pre>

<p>Sample simulations are within the <SAMP>samples</SAMP> directory. Each of the
sample directories contain a network description (.ned file) and
corresponding simple module code (<SAMP>.h</SAMP>, <SAMP>.cc</SAMP> files).
Makefiles are included.

<p><pre>
    <b>samples/</b>     directories for sample simulations
      <b>nim/</b>       a simple two-player game
      <b>hcube/</b>     hypercube network with deflection routing
      <b>token/</b>     Token-Ring network
      <b>fddi/</b>      an accurate FDDI MAC simulation
      <b>hist/</b>      demo of the histogram classes
      <b>dyna/</b>      dynamic module creation (client-server network)
      <b>fifo1/</b>     single-server queue
      <b>fifo2/</b>     another implementation of a single-server queue
      <b>demo/</b>      several sim. models in a single executable
</pre>

<p>
The <SAMP>contrib</SAMP> directory contains material from the OMNeT++ community.

<p><pre>
    <b>contrib/</b>     directory for contributed material
      <b>octave/</b>    Octave scripts for result processing
      <b>emacs/</b>     NED syntax highlight for Emacs
</pre>

<p>You may also find additional directories like <SAMP>msvc/</SAMP>, which contains
integration components for Microsoft Visual C++, etc.

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb  4 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec122"/>3. <FONTgreen>An Example: The Nim Game</FONT></H1></font></hr>
<a name="cha:the-nim-game"/>

<p>
This chapter contains a full example program that can give you
some basic idea of using the simulator. An enhanced version of
the Nim example can be found among the sample programs.

<p>Nim is an ancient game with two players and a bunch of sticks.
The players take turns, removing 1, 2, 3 or 4 sticks from the
heap of sticks at each turn. The one who takes the last stick
is the loser.

<p>
Of course, building a model of the Nim game is not much of a
simulation project, but it nicely demonstrates the modeling approach
used by OMNeT++.

<p>
Describing the model consists of two phases:
<UL>
<li><strong></strong>topology description
<li><strong></strong>defining the operation of components
</UL>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec123"/>3.1. <FONTblue>Topology</FONT></H2></font></hr>

<p>The game can be modelled in OMNeT++ as a network with three modules:
the ''game'' (a manager module) and two players.
The modules will communicate by exchanging messages. The ''game''
module keeps the current number of tokens and organizes the game;
in each turn, the player modules receives the number of tokens
from the Game module and sends back its move.

<p>
<DIV ALIGN=center>
<img src="usmanFig6.gif">
<center><i>Figure: Module structure for the Nim game.</i></center>
</DIV>

<p>
<SAMP>Player1</SAMP>, <SAMP>Player2</SAMP> and <SAMP>Game</SAMP> are simple
modules (e.g. they have no submodules.) Each module is an instance of
a module type. We'll need a module type to represent the <SAMP>Game</SAMP> module;
let's call it <SAMP>Game</SAMP> too.

<p>We can implement two kinds of players: <SAMP>SmartPlayer</SAMP>, which knows
the winning algorithm, and <SAMP>SimplePlayer</SAMP>, which simply takes a
random number of sticks. In our example, <SAMP>Player1</SAMP> will be a <SAMP>SmartPlayer</SAMP>
and <SAMP>Player2</SAMP> will be a <SAMP>SimplePlayer</SAMP>.

<p>The enclosing module, <SAMP>Nim</SAMP> is a compound module (it has submodules).
It is also defined as a module type of which one instance is
created, the system module.

<p>Modules have input and output gates (the tiny boxes
labeled <SAMP>in</SAMP>, <SAMP>out</SAMP>, <SAMP>from_player1</SAMP>, etc. in the
figure). An input and an output gate can be connected: connections (or
links) are shown as in the figure as arrows.  During the simulation,
modules communicate by sending messages through the connections.

<p>
The user defines the topology of the network in NED files.

<p>
We placed the model description in two files; the first file
defines the simple module types and the second one the system
module.

<p>The first file (NED keywords are typed in boldface):

<p><pre>
//-
// file: nim_mod.ned
// Simple modules in nim.ned
//-

<p>
// Declaration of simple module type Game.

<p><STRONG>simple</STRONG> Game
    <STRONG>parameters</STRONG>:
         num_sticks, // initial number of sticks
         first_move; // 1=Player1, 2=Player2

<p>    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>:
             from_player1, // input and output gates
             from_player2; // for connecting to Player1/Player2
        <STRONG>out</STRONG>:
             to_player1,
             to_player2;
<STRONG>endsimple</STRONG>

<p>
// Now the declarations of the two simple module types.
// Any one of the two types can be Player1 or Player2.

<p>// A player that makes random moves
<STRONG>simple</STRONG> SimplePlayer
    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>: in; // gates for connecting to Game
        <STRONG>out</STRONG>: out;
<STRONG>endsimple</STRONG>

<p>// A player who knows the winning algorithm
<STRONG>simple</STRONG> SmartPlayer
    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>: in; // gates for connecting to Game
        <STRONG>out</STRONG>: out;
<STRONG>endsimple</STRONG>
</pre>

<p>The second file:

<p><pre>
//-
// file: nim.ned
// Nim compound module + system module
//-

<p><STRONG>import</STRONG> "nim_mod";

<p><STRONG>module</STRONG> Nim
    <STRONG>submodules</STRONG>:
        game: Game
            <STRONG>parameters</STRONG>:
                num_sticks = intuniform(21, 31),
                first_move = intuniform(1, 2);
        player1: SmartPlayer;
        player2: SimplePlayer;
    <STRONG>connections</STRONG>:
        player1.out -<SAMP>&gt;</SAMP> game.from_player1,
        player1.in <SAMP>&lt;</SAMP>- game.to_player1,
        player2.out -<SAMP>&gt;</SAMP> game.from_player2,
        player2.in <SAMP>&lt;</SAMP>- game.to_player2;
<STRONG>endmodule</STRONG>

<p>// system module creation
<STRONG>network</STRONG>
    nim: Nim
<STRONG>endnetwork</STRONG>
</pre>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec124"/>3.2. <FONTblue>Simple modules</FONT></H2></font></hr>

<p>The module types <SAMP>SmartPlayer</SAMP>, <SAMP>SimplePlayer</SAMP> and <SAMP>Game</SAMP> are implemented
in C++, using the OMNeT++ library classes and functions.

<p>Each simple module type is derived from the C++
class <tt>cSimpleModule</tt>, with its <tt>activity()</tt> member
function redefined. The <tt>activity()</tt> functions of all
simple modules in the network are executed as
coroutines, so they appear as if they were running in
parallel.  Messages are instances of the class <tt>cMessage</tt>.

<p>We present here the C++ sources of the <SAMP>SmartPlayer</SAMP> and <SAMP>Game</SAMP> module
types.

<p>The <SAMP>SmartPlayer</SAMP> first introduces himself by sending its name
to the <SAMP>Game</SAMP> module. Then it enters an infinite loop; with each
iteration, it receives a message from <SAMP>Game</SAMP> with the number of
sticks left, it calculates its move and sends back a message
containing the move.

<p>Here's the source:

<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

#include &lt;omnetpp.h&gt;

// derive SmartPlayer from cSimpleModule
class SmartPlayer : public cSimpleModule
{
    Module_Class_Members( SmartPlayer, cSimpleModule, 8192)
    // this is a macro; it expands to constructor definition etc.
    // 8192 is the size for the coroutine stack (in bytes)

virtual void activity();
    // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( SmartPlayer );

// define operations of SmartPlayer
void SmartPlayer::activity()
{
    int move;

    // initialization phase: send module type to Game module
    // create a message with the name "SmartPlayer" and send it to Game

    cMessage *msg = new cMessage("SmartPlayer");
    send(msg, "out");

    // infinite loop to process moves;
    // simulation will be terminated by Game

    for (;;)
    {
        // messages have several fields; here, we'll use the message
        // kind member to store the number of sticks
        cMessage *msgin = receive(); // receive message from Game
        int num_sticks = msgin-&gt;kind(); // extract message kind (an int)
                                        // it hold the number of sticks
                                        // still on the stack
        delete msgin;                   // dispose of the message

        move = (num_sticks + 4) % 5; // calculate move
        if (move == 0)                  // we cannot take zero
            move = 1;                   // seems like we going to lose

        ev &lt;&lt; "Taking " &lt;&lt; move         // some debug output. The ev
           &lt;&lt; " out of " &lt;&lt; num\_sticks // object represents the user
           &lt;&lt; " sticks.\n";             // interface of the simulator

        cMessage *msgout = new cMessage;// create empty message
        msgout-&gt;setKind( move );        // use message kind as storage
                                        // for move
        send( msgout, "out"); // send the message to Game
    }
}
</pre>
<p>
The <SAMP>Game</SAMP> module first waits for a message from both players
and extracts the message names that are also the players' names.  Then
it enters a loop, with the <SAMP>player_to_move</SAMP> variable
alternating between 1 and 2. With each iteration, it sends out a
message with the current number of sticks to the corresponding player
and gets back the number of sticks taken by that player. When the
sticks are out, the module announces the winner and ends the
simulation.

<p>The source:

<p>
<pre>
//-------------------------------------------------------------
// file: game.cc
// (part of NIM - an OMNeT++ demo simulation)
//-------------------------------------------------------------

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &lt;omnetpp.h&gt;

// derive Game from cSimpleModule
class Game : public cSimpleModule
{
    Module_Class_Members(Game,cSimpleModule,8192)
      // this is a macro; it expands to constructor definition etc.
      // 8192 is the size for the coroutine stack (in bytes)

    virtual void activity();
      // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( Game );

// operation of Game:
void Game::activity()
{
    // strings to store player names; player[0] is unused
    char player[3][32];

    // read parameter values
    int num_sticks = par("num_sticks");
    int player_to_move = par("first_move");

    // waiting for players to tell their names
    for (int i=0; i&lt;2; i++)
    {
        cMessage *msg = receive();
        if (msg-&gt;arrivedOn("from_player1"))
            strcpy( player[1], msg-&gt;name());
        else
            strcpy( player[2], msg-&gt;name());
        delete msg;
    }

    // ev represents the user interface of the simulator
    ev &lt;&lt; "Let the game begin!\n";
    ev &lt;&lt; "Player 1: " &lt;&lt; player[1] &lt;&lt; "   Player 2: " &lt;&lt; player[2]
       &lt;&lt; "\n\n";

    do
    {
        ev &lt;&lt; "Sticks left: " &lt;&lt; num_sticks &lt;&lt; "\n";
        ev &lt;&lt; "Player " &lt;&lt; player_to_move &lt;&lt; " ("
           &lt;&lt; player[player_to_move] &lt;&lt; ") to move.\n";

        cMessage *msg = new cMessage("", num_sticks);
                        // num\_sticks will be the msg kind

        if (player_to_move == 1)
            send(msg, "to_player1");
        else
            send(msg, "to_player2");

        msg = receive();
        int sticks_taken = msg-&gt;kind();
        delete msg;

        num_sticks -= sticks_taken;

        ev &lt;&lt; "Player " &lt;&lt; player_to_move &lt;&lt; " ("
           &lt;&lt; player[player_to_move] &lt;&lt; ") took "
           &lt;&lt; sticks_taken &lt;&lt; " stick(s).\n";

        player_to_move = 3 - player_to_move;
    }
    while (num_sticks&gt;0);

    ev &lt;&lt; "\nPlayer " &lt;&lt; player_to_move &lt;&lt; " ("
       &lt;&lt; player[player_to_move] &lt;&lt; ") won!\n";

    endSimulation();
}
</pre>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec125"/>3.3. <FONTblue>Running the simulation</FONT></H2></font></hr>

<p>Once the source files are ready, one needs to compile and link
them into a simulation executable. One can specify the user interface
to be linked.

<p>Before running the simulation, one can put parameter values and
all sorts of other settings into an initialization file that
will be read when the simulation program starts:

<p>

<pre>
#
# file: omnetpp.ini
#

[General]
network = nim
random-seed = 3
ini-warnings = false

[Cmdenv]
express-mode = no
</pre>
<p>
Suppose we link the Nim simulation with the command line user
interface. We get the executable nim (nim.exe under Windows).
When we run it, we'll get the following screen output:

<pre>
% ./nim
</pre>
<p>
Or:

<pre>
C:\OMNeT++\samples\nim&gt; nim

OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Preparing for Run #1...
Setting up network `nim'...
Running simulation...

Let the game begin!
Player 1: SmartPlayer Player 2: SimplePlayer

Sticks left: 29
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 2 out of 29 sticks.
Player 2 (SimplePlayer) took 2 stick(s).
Sticks left: 27
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 1 out of 27 sticks.
Player 1 (SmartPlayer) took 1 stick(s).
Sticks left: 26
[...]
Sticks left: 5
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 4 out of 5 sticks.
Player 1 (SmartPlayer) took 4 stick(s).
Sticks left: 1
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 1 out of 1 sticks.
Player 2 (SimplePlayer) took 1 stick(s).

Player 1 (SmartPlayer) won!
&lt;!&gt; Module nim.game: Simulation stopped with endSimulation().

End run of OMNeT++
</pre>
<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec126"/>3.4. <FONTblue>Other examples</FONT></H2></font></hr>

<p>An enhanced version of the Nim example can be found among the sample
programs. It adds a third, interactive player and derives specific
player types from a <SAMP>Player</SAMP> abstract class. It also adds the
possibility that actual types for <SAMP>player1</SAMP> and
<SAMP>player2</SAMP> can be specified in the ini file or interactively
entered by the user at the beginning of the simulation.

<p>Nim does not show very much of how complex algorithms like communication
protocols can be implemented in OMNeT++. To have an idea about
that, look at the Token Ring example. It is also extensively
commented, though you may need to peep into the user manual to
fully understand it. The Dyna simulation models a simple
client-server network and demonstrates dynamic module creation.
The FDDI example is an accurate FDDI MAC simulation
which was written on the basis of the ANSI standard.

<p>
The following table summarizes the sample simulations:

<p><table border>
<TR> <TD align=left>

<p><STRONG>NAME</STRONG> </TD> <TD align=left> <STRONG>TOPIC</STRONG> </TD> <TD align=left> <STRONG>DEMONSTRATES</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>nim</STRONG> </TD> <TD align=left> a simple two-player game
</TD> <TD align=left>
 module inheritance</TD></TR>
<TR> <TD align=left> module type as parameter</TD></TR>
<TR> <TD align=left> <STRONG>hcube</STRONG>
</TD> <TD align=left>
 hypercube network with</TD></TR>
<TR> <TD align=left> deflection routing
</TD> <TD align=left>
 hypercube topology with dimension as parameter</TD></TR>
<TR> <TD align=left> topology templates</TD></TR>
<TR> <TD align=left> output vectors</TD></TR>
<TR> <TD align=left> <STRONG>token</STRONG> </TD> <TD align=left> Token Ring network
</TD> <TD align=left>
 ring topology with the number of nodes as parameter</TD></TR>
<TR> <TD align=left> using <tt>cQueue</tt></TD></TR>
<TR> <TD align=left> <tt>wait()</tt></TD></TR>
<TR> <TD align=left> output vectors</TD></TR>
<TR> <TD align=left> <STRONG>fifo1</STRONG> </TD> <TD align=left> single-server queue
</TD> <TD align=left>
 simple module inheritance</TD></TR>
<TR> <TD align=left> decomposing <tt>activity()</tt> into several functions</TD></TR>
<TR> <TD align=left> using simple statistics and output vectors</TD></TR>
<TR> <TD align=left> printing stack usage info to help optimize memory consumption</TD></TR>
<TR> <TD align=left> using <tt>finish()</tt></TD></TR>
<TR> <TD align=left> <STRONG>fifo2</STRONG> </TD> <TD align=left> another fifo implementation
</TD> <TD align=left>
 using <tt>handleMessage()</tt></TD></TR>
<TR> <TD align=left> decomposing <SAMP>handleMessage()</SAMP> into several functions</TD></TR>
<TR> <TD align=left> the FSM macros</TD></TR>
<TR> <TD align=left> simple module inheritance</TD></TR>
<TR> <TD align=left> using simple statistics and output vectors</TD></TR>
<TR> <TD align=left> using <SAMP>finish()</SAMP></TD></TR>
<TR> <TD align=left> <STRONG>fddi</STRONG> </TD> <TD align=left> FDDI MAC simulation
</TD> <TD align=left>
 using statistics classes</TD></TR>
<TR> <TD align=left> and many other features</TD></TR>
<TR> <TD align=left> <STRONG>hist</STRONG> </TD> <TD align=left> demo of the histogram classes
</TD> <TD align=left>
 collecting observations into statistics objects</TD></TR>
<TR> <TD align=left> saving statistics objects to file and restoring them</TD></TR>
<TR> <TD align=left> using the inspect.lst file in Tkenv</TD></TR>
<TR> <TD align=left> <STRONG>dyna</STRONG> </TD> <TD align=left> a client-server network
</TD> <TD align=left>
 dynamic module creation</TD></TR>
<TR> <TD align=left> using <tt>WATCH()</tt></TD></TR>
<TR> <TD align=left> star topology with the number of modules as parameters</TD></TR>
<TR> <TD align=left> <STRONG>demo</STRONG> </TD> <TD align=left> tour of OMNeT++ samples </TD> <TD align=left> shows how to link several sim. models into one executable</TD></TR>
</table>

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec127"/>4. <FONTgreen>The NED Language</FONT></H1></font></hr>
<a name="cha:the-ned-language"/>

<p>
<hr><font color="#006f00"><H2><A NAME="sec128"/>4.1. <FONTblue>NED overview</FONT></H2></font></hr>

<p>The description of model topology is given in the NED
language. The NED language supports modular
description of a network. This means that a network
description consists of a number of
component descriptions (channels,
simple/compound module
types). The channels, simple modules and compound
modules of one network description can be used in another network
description. As a consequence, the NED language makes it possible for
the user to build his own libraries of network descriptions.

<p>
Files containing network descriptions generally have a <SAMP>.ned</SAMP>
suffix.  Network descriptions are not used directly: they are
translated into C++ code by the NEDC compiler, then compiled by the
C++ compiler and linked into the simulation executable.

<p>
The EBNF description of the language can be found in Appendix
<a href="#cha:ned-language-grammar">[click]</a>.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec129"/>4.1.1. <FONTteal>Components of a NED description</FONT></H3></font>

<p>
A NED description can contain the following components, in arbitrary
number or order:
<UL>
  <li><strong></strong>import statements
  <li><strong></strong>channel definitions
  <li><strong></strong>simple and compound module declarations
  <li><strong></strong>system module declarations
</UL>

<p>The rest of this chapter discusses each of these types in detail.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec130"/>4.1.2. <FONTteal>Reserved words</FONT></H3></font>

<p>

<p>The writer of the network description has to take care that no
reserved words are used for names. The reserved words of the
NED language are:
<pre>
  import include channel endchannel simple endsimple module endmodule
  error delay datarate const parameters gates submodules connections
  gatesizes on if machines for do endfor network endnetwork nocheck
  ref ancestor true false like input numeric string bool char
</pre>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec131"/>4.1.3. <FONTteal>Case sensitivity</FONT></H3></font>

<p>

<p>The network description and all identifiers in it are case sensitive.

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec132"/>4.2. <FONTblue>The import statement</FONT></H2></font></hr>

<p>


<p>Example:

<p>
<pre>
<b>import</b> "tkn_mod", "tkn2_mod";
</pre>

<p>
The <tt>import</tt> statement (the
<tt>include</tt> keyword is also recognized for
backwards compatibility) is used to import declarations from other
network description files. After importing a network description, one
can use the components (channels, simple/compound
module types) defined in it.

<p>
From the imported files, only the declaration information is used, but
<EM>no C++ code is generated</EM>. The consequence is that one has to
compile and link each network description,
not only the top-level ones.

<p>
The user can specify the name of the files with or without the
<SAMP>.ned</SAMP> extension. One can also include a path in the
filenames, or better, use the NEDC compiler's
<tt>-I &lt;path&gt;</tt> command-line option to name the directories where the
imported files reside.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec133"/>4.3. <FONTblue>Channel definitions</FONT></H2></font></hr>

<p>





<p>A channel definition specifies a connection type of given characteristics.
The channel name can be used later in the NED description to
create connections with these parameters.

<p>
Example:

<p><pre>
<b>channel</b> DialUpConnection
    <b>delay</b> normal (0.004, 0.0018)
    <b>error</b> 0.00001
    <b>datarate</b> 14400
<b>endchannel</b>
</pre>

<p>Any of the <tt>delay</tt>, <tt>error</tt> and <tt>datarate</tt> parameters
are optional and they can appear in any order. The values are NED
expressions.  This means that they can be
constants (integer or real), random values from various distributions,
etc.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec134"/>4.4. <FONTblue>Simple module definitions</FONT></H2></font></hr>

<p>
Simple modules are the basic building blocks for other (compound)
modules. A simple module is defined by
declaring its parameters and
gates.

<p>Example:

<p><pre>
<b>simple</b> SomeNameForModule
    <b>parameters</b>:
        //...
    <b>gates</b>:
        //...
<b>endsimple</b>
</pre>

<p>

<p><font color="#006f00"><H3><A NAME="sec135"/>4.4.1. <FONTteal>Simple module parameters</FONT></H3></font>
<a name="sec:ch-ned-lang:simple-module-param"/>

<p>

<p>Parameters are variables that belong to a module. Simple module
parameters can be queried and used by simple module algorithms.
For example, a parameter called <tt>num_of_messages</tt> can be used
by a module called <tt>MsgSource</tt> to determine how many messages it
has to generate.

<p>
Parameters are declared by listing their names in the
parameters: section of a
module description. The parameter type can optionally be specified as
<tt>numeric</tt>, \fpar[ned!keywords!numeric
const]numeric const (or simply <tt>const</tt>),
<tt>bool</tt>, <tt>string</tt>, or
<tt>anytype</tt>.

<p>
Example:

<p><pre>
<b>simple</b> MsgSource
    <b>parameters</b>:
        interarrival_time,
        num_of_messages : <b>const,</b>
        address : <b>string</b>;
    <b>gates</b>: //...
<b>endsimple</b>
</pre>

<p>If the parameter type is omitted, <tt>numeric</tt>
is assumed. Practically, this means that you only need to explicitly
specify the type for string, bool or char-valued parameters.

<p>Note that the actual parameter values are given later, when the module
is used as a building block of a compound module type or as a system
module.

<p>When the user writes the word <tt>const</tt> before
the parameter, it is converted to constant; that is, the parameter's
value is replaced by its evaluation. This can be important when the
original value was a random number or an
expression. One is advised to write out the
<tt>const</tt> keyword for each parameter that
should be constant.

<p>Beware when using <tt>const</tt> and by-reference
parameter passing (<tt>ref</tt> modifier, see later)
at the same time. Converting the parameter to constant can affect
other modules and cause errors that are difficult to discover.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec136"/>4.4.2. <FONTteal>Simple module gates</FONT></H3></font>
<a name="sec:ch-ned-lang:simple-module-gates"/>

<p>


<p>Gates are the connection points of modules. The starting and
ending points of the connections between modules are gates. OMNeT++
supports simplex (one-directional) connections, so there are
two kinds of gates: input and output. Messages are sent through
output gates and received through input gates.

<p>Gates are identified with their names. Gate vectors are supported:
a gate vector contains a number of single gates.

<p>Gates are declared by listing their names in the
<tt>gates:</tt> section of a module description. An
empty bracket pair [] denotes a gate vector.
Elements of the vector are numbered starting with zero.

<p>Examples:

<p><pre>
<b>simple</b> DataLink
    <b>parameters</b>: //..
    <b>gates</b>:
        <b>in</b>:  from_port, from_higher_layer;
        <b>out</b>: to_port, to_higher_layer;
<b>endsimple</b>

<p><b>simple</b> RoutingModule
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>:  output[];
        <b>out</b>: input[];
<b>endsimple</b>
</pre>

<p>The sizes of gate vectors are given later, when the module is used as
a building block of a compound module type. Thus, every instance of
the module can have gate vectors of different sizes.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec137"/>4.5. <FONTblue>Compound module definitions</FONT></H2></font></hr>

<p>
Compound modules are modules that are composed of one or more
submodules. Compound modules, like a
simple modules, can have parameters and
gates, so a compound module
definition looks similar to a
simple module definition, except that it also has
sections to specify the submodules and connections within the module.

<p>
Submodules can either be simple or
compound modules, they are equivalent.

<p>
Example:

<p><pre>
<b>module</b> SomeNameForCompoundModule
    <b>parameters</b>:
        //...
    <b>gates</b>:
        //...
    <b>submodules</b>:
        //...
    <b>connections</b>:
        //...
<b>endmodule</b>
</pre>

<p>Any of the above sections (parameters, gates, submodules, connections)
is optional.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec138"/>4.5.1. <FONTteal>Compound module parameters</FONT></H3></font>

<p>
Parameters are declared in the same
way as with simple modules.  Please refer to
Section <a href="#sec:ch-ned-lang:simple-module-param">[click]</a>, ''Simple module
parameters''.

<p>
Example:

<p><pre>
<b>module</b> Router
    <b>parameters</b>:
        rte_processing_delay, rte_buffersize,
        num_of_ports : <b>const</b>;
    <b>gates</b>: //...
    <b>submodules</b>: //...
    <b>connections</b>://...
<b>endmodule</b>
</pre>

<p>Compound module parameters can be used in two ways:
<UL>
<li><strong></strong>used in expressions for submodule parameter values
<li><strong></strong>used in defining the internal topology of the network
</UL>

<p>For example, a parameter called <tt>num_of_ports</tt> can be used to
construct a router module with the number of ports as a parameter.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec139"/>4.5.2. <FONTteal>Compound module gates</FONT></H3></font>

<p>


<p>
Gates have the same role and are declared in the same way
as with simple modules. Please refer to Section
<a href="#sec:ch-ned-lang:simple-module-gates">[click]</a>, ''Simple module gates''.

<p>
Example:
<pre>
<b>module</b> Router
    <b>parameters</b>: //...
    <b>gates</b>:
        <b>in</b>: input_port[];
        <b>out</b>: output_port[];
    <b>submodules</b>: //...
    <b>connections</b>: //...
<b>endmodule</b>
</pre>

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec140"/>4.5.3. <FONTteal>Submodules</FONT></H3></font>

<p>
Submodules are defined in the
<tt>submodules:</tt> section of a
module description. For each submodule, there are sections to define
the actual values to be passed to its parameters and the sizes of its
gate vectors.

<p>Example:

<p><pre>
<b>module</b> NameForCompoundModule
    <b>parameters</b>: //...
    <b>gates</b>: //...
    <b>submodules</b>:
        SubModuleName: TypeOfSubModule
            <b>parameters</b>:
                //...
            <b>gatesizes</b>:
                //...
        SecondSubModuleName: TypeOfSecondSubModule
            //...
    <b>connections</b>: //...
<b>endmodule</b>
</pre>

<p>In a submodule definition, one has to supply the name of a previously
defined module as the type and a module name. The description of the
module type can occur in the same NED file or an imported NED file.

<p><b>Module vector as submodule</b>

<p>

<p>It is possible to create an array of
submodules (a module
vector).  This is done with an expression between
brackets right behind the module type name. The expression can refer
to module parameters.  A zero value as module count is also allowed.

<p>Example:

<p><pre>
<b>module</b> BigCompound
    <b>parameters</b>:
        num_of_submods: <b>const</b>;
    <b>submodules</b>:
        Submod1: Node[3]
            //...
        Submod2: Node[num_of_submods]
            //...
        Submod3: Node[(num_of_submods+1)/2]
            //...
<b>endmodule</b>
</pre>

<p><b>Module type as parameter</b>

<p>

<p>Instead of supplying a concrete module type, one can leave it as a
parameter. At the same time, to let the NED compiler know what
parameters and gates that module has, the user has to supply the name
of an existing module type. This is done with the
<tt>like</tt> phrase.

<p>Example:

<p>
<pre>
<b>module</b> CompoundModule
    <b>parameters</b>:
        node_type : <b>string</b>;
    <b>gates</b>: //...
    <b>submodules</b>:
        theNode: node_type <b>like</b> GeneralNode
           <b>parameters</b>:
                buffer = 10;
    <b>connections</b>: //...
<b>endmodule</b>
</pre>

<p>The above example means that the type of the submodule theNode is not
known in advance; it will be taken from the <SAMP>node_type</SAMP>
parameter of <SAMP>CompoundModule</SAMP> which must be a string (for
example, ''SwitchingNode''). The module type called
<SAMP>GeneralNode</SAMP> must have appeared earlier in the NED files; its
declaration will be used to check whether <SAMP>theNode</SAMP>'s
parameters and gates exist and are used correctly. The
<SAMP>node_type</SAMP> parameter will probably be given an input value
somewhere higher in the module hierarchy so that the actual module
type can be specified in the ini file or entered interactively.

<p>The GeneralNode module type does not need to be implemented in
C++, because no instance of it is created; it is merely used
to check the correctness of the NED file.

<p>On the other hand, the actual module type that will be substituted
(i.e. SwitchingNode in our case) does not need to be declared
in the NED files.

<p>The <tt>like</tt> phrase enables the user to
create <EM>families</EM> of modules that serve
similar purposes and implement the same interface (they have the same
gates and parameters) and to use them interchangeably in NED files.
This scheme directly parallels with the concept of
<EM>polymorphism</EM> used in object-oriented programming.

<p><b>Submodule parameters</b>

<p>

<p>Right after the declaration, the values for the parameters of
the declared submodules can be specified.

<p>Example:

<p>
<pre>
<b>module</b> ManyParameters
    <b>parameters</b>:
        par1, par2, switch;
    <b>submodules</b>:
        Submod1: Node
            <b>parameters</b>:
                p1 = 10,
                p2 = par1+par2,
                p3 = switch==0 ? par1 : par2;
        //...
<b>endmodule</b>
</pre>

<p>Expressions are mostly C-style, and they can
contain parameters of the compound module being defined. A separate
section is dedicated to expressions. Here, only the modes of parameter
passing are discussed.

<p>The default parameter passing method is by value. However, the
user can write <tt>ref</tt> or
<tt>ancestor</tt> before the parameter name.
Writing <tt>ref</tt> means that the parameter is not
passed by value, but by reference.  This means that instead of the
value of the parameter the address of the parameter is passed.

<p>Writing <tt>ancestor</tt> before the parameter
name means that the parameter will be searched upwards, among the
parameters of all future enclosing modules of the current module. This
reference cannot be resolved or checked by the NEDC compiler; it can
only be done at runtime, when the whole network has been built up. The
parameter which is found first is used; if no such parameter can be
found in any of the enclosing modules, the system will give an error
during runtime.

<p>The <SAMP>ancestor</SAMP> and <SAMP>ref</SAMP> modifiers are independent, they
can be used together.

<p>For example:

<p>
<pre>
<b>simple</b> sub_sub
    <b>parameters</b>:
        s_s_par1, s_s_par2;
<b>endmodule</b> sub_sub

<p>
<b>module</b> sub
    <b>parameters</b>:
        s_par;
    <b>submodules</b>:
        child: sub_sub
            <b>parameters</b>:
                s_s_par1 = <b>ref</b> s_par,
                s_s_par2 = <b>ref</b> <b>ancestor</b> m_par2;
<b>endmodule</b> sub

<p>
<b>module</b> mod
    <b>parameters</b>:
        m_par1, m_par2;
    <b>submodules</b>:
        child: sub
            <b>parameters</b>:
                s_par = m_par1;
<b>endmodule</b> mod
</pre>

<p>
Again, note that the network description compiler can check for the
existence of ordinary parameters but not for ancestor parameters (it
cannot predict in what modules the current module will be embedded in
an actual network description).  Parameters taken by reference can be
used as a second means of module communication, because during
simulation execution, if a module changes the value of a parameter
taken be reference, the changed value propagates to other modules.
<SAMP>ref</SAMP> parameters can also be used to implement shared
memory (see in Chapter <a href="#cha:simple-modules">[click]</a>).

<p><b>Submodule gate sizes</b>

<p>


<p>The sizes of gate vectors are defined with the
<tt>gatesizes:</tt> keyword.  Gate vector sizes
can be given as constants, parameters or expressions.

<p>An example:

<p>
<pre>
<b>simple</b> SimpleType
    <b>gates</b>:
        <b>in</b>: inputs[]; <b>out</b>: outputs[];
<b>endsimple</b>
<b>module SomeCompound
    parameters</b>:
        num: <b>const</b>;
    <b>submodules</b>:
        Submod1: SimpleType
            <b>gatesizes</b>:
                inputs[10], outputs[num];
        //...
<b>endmodule</b>
</pre>

<p>
<b>Conditional parameter and gatesize sections</b>

<p>
Multiple parameters: and
gatesizes: sections can exist in a submodule
definition and each of them can be tagged with
conditions.

<p>For example:

<p><pre>
<b>module</b> Serial
    <b>parameters</b>: count: <b>const</b>;
    <b>submodules</b>:
        node : Node [count]
            <b>parameters</b>:
                position = "middle";
            <b>parameters</b> <b>if</b> index==0:
                position = "beginning";
            <b>parameters</b> <b>if</b> index==count-1:
                position = "end";
            <b>gatesizes</b>:
                in[2], out[2];
            <b>gatesizes</b> <b>if</b> index==0 || index==count-1:
                in[1], in[1];
    <b>connections</b>:
        //...
<b>endmodule</b>
</pre>

<p>
If the conditions are not disjoint and a parameter value or a
gate size is defined twice, the last definition will take effect,
overwriting the former ones. Thus, values intended as defaults
should appear in the first sections.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec141"/>4.5.4. <FONTteal>Connections</FONT></H3></font>

<p>
The compound module definition specifies how the gates of the compound
module and its immediate sub-modules are connected.
The NED language does not permit connections that cross the boundaries
of a compound module without using the gates of that module.
Only point-to-point connections are supported.

<p>
In summary:
<OL>
  <li><strong></strong>The gate of a submodule or enclosing module gate can be connected
    to another submodule or enclosing module gate
  <li><strong></strong>Gate direction must be observed (e.g. you cannot connect two
    submodule output gates)
</OL>

<p>
Connections are specified in the
<tt>connections:</tt> section of a compound
module definition. It lists the connections, separated by semicolons.

<p>Example:

<p>
<pre>
<b>module</b> SomeCompound
    <b>parameters</b>: //...
    <b>gates</b>: //...
    <b>submodules</b>: //...
    <b>connections</b>:
        node1.output -&gt; node2.input;
        node1.input &lt;- node2.output;
        //...
<b>endmodule</b>
</pre>

<p>

<p>Each connection can be:
<UL>
  <li><strong></strong>direct (that is, no delay, bit error rate or data rate), can
    use a named channel, or a channel given with delay, error and
    data rate values;
<li><strong></strong>single or multiple (loop) connection;
<li><strong></strong>conditional or non-conditional.
</UL>

<p>These connection types are described in the following sections.

<p>
<b>Single connections and channels</b>

<p>


<p>The source gate can be an output gate of a submodule or an input
gate of the compound module, and the destination gate can be
an input gate of a submodule or an output gate of the compound
module.

<p>
If the user does not specify a channel, the connection will have
no propagation delay, no transmission delay and no bit errors:
<pre>
    Sender.outgate --&gt; Receiver.ingate;
</pre>

<p>The arrow can point either left-to-right or right-to-left.

<p>The user can also specify a channel by its name:
<pre>
    Sender.outgate --&gt; Dialup14400 --&gt; Receiver.ingate;
</pre>

<p>In this case, the NED sources must contain the definition of
the channel.

<p>One can also specify the channel parameters directly:
<pre>
    Sender.outgate --&gt; error 1e-5 delay 0.001 --&gt; Receiver.ingate;
</pre>

<p>Either of the parameters can be omitted and they can be in any
order.

<p>
<b>Loop connections</b>

<p>
If submodule or gate vectors are used, it is possible to create
more than one connection with one statement. This is termed a <EM>multiple</EM>
or <EM>loop connection</EM>.

<p>A multiple connection is created with the <tt>for</tt>
statement:

<p><pre>
<b>for</b> i=0..4 <b>do</b>
    Sender.outgate[i] -&gt; Receiver[i].ingate
<b>endfor</b>;
</pre>

<p>

<p>The result of the above loop connection can be illustrated as
depicted in Fig. <a href="#fig:ch-ned-lang:loop-connection">[click]</a>.

<p>
<DIV ALIGN=center>
<img src="usmanFig7.gif">
<center><i>Figure: Loop connection</i></center>
<a name="fig:ch-ned-lang:loop-connection"/>
</DIV>

<p>

<p>One can place several connections in the body of the
<tt>for</tt> statement, separated by semicolons.

<p>More than one indices can be specified in a for statement, with their
own lower and upper bounds. This will be interpreted as nested for
statements, the leftmost index being
the outermost and the rightmost index being the innermost loop.

<p>
<pre>
<b>for</b> i=0..4, j=0..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>One can also use an index in the lower and upper bound expressions
of the subsequent indices:

<p><pre>
<b>for</b> i=0..3, j=i+1..4 <b>do</b>
    //...
<b>endfor</b>;
</pre>

<p>
In the above example, the following <EM>(i,j)</EM> pairs will be used
for the connections inside the for statement:

<p>  <EM>(0,1)  (0,2)  (0,3)  (0,4)  (1,2)  (1,3)  (1,4)  (2,3)  (2,4)  (3,4)</EM>

<p>A gate cannot be used in more than one connection and one connection
cannot be made more than once. Consider the following bogus statement:

<p>
<pre>
<b>for</b> i = 0..2, j = 0..2 <b>do</b>
    module1.out [i] -&gt; module2.in [<b><EM>i</EM></b>];
<b>endfor</b>;
</pre>

<p>
It will cause a runtime error: each connection is made twice,
as the index variable <EM>j</EM> is not used in the connection. In
general, every connection inside a loop should use all the index
variables at both sides of the connection.

<p>
<b>Conditional connections</b>

<p>

<p>Connections can be conditional. This is a conditional connection:

<p>

<p><pre>
<b>for</b> i=0..n <b>do</b>
    Sender.outgate[i] -<tt>&gt;</tt> Receiver[i].ingate <b>if</b> i%2==0;
<b>endfor</b>;
</pre>

<p>
This way we connected every second gate.

<p>
<b>The nocheck modifier</b>

<p>

<p>Conditional connections are especially useful with random numbers when
they can create random connections. Here, a
problem can be that by default, the simulation program checks if all
gates are connected. You can turn off this check by using the
<tt>nocheck</tt> modifier
.

<p>This example generates a random subgraph of a full graph:

<p>
<pre>
<b>module</b> Stochastic
    <b>parameters</b>: //..
    <b>gates</b>: //..
    <b>submodules</b>: //..
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..9 <b>do</b>
            Sender.outgate[i] -&gt; Receiver[i].ingate
                                <b>if</b> uniform(0,1)&lt;0.3;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
When using <tt>nocheck</tt>, it is the simple modules' responsibility
not to send messages on gates that are not connected.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec142"/>4.6. <FONTblue>Parameterized compound modules</FONT></H2></font></hr>

<p>

<p>With the help of conditional parameter and gatesize blocks and
conditional connections, one can create complex topologies.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec143"/>4.6.1. <FONTteal>Examples</FONT></H3></font>

<p><b>Example 1: Router</b>

<p>The following example contains a router module with the number of
ports taken as parameter. The compound module is built using three
module types: Application, RoutingModule, DataLink. We assume that
their definition is in a separate NED file which we will import.

<p>
<pre>
<b>import</b> "modules";
<b>module</b> Router
    <b>parameters</b>:
        rte_processing_delay, rte_buffersize,
        num_of_ports: <b>const</b>;
    <b>gates</b>:
        <b>in</b>: input_ports[];
        <b>out</b>: output_ports[];
    <b>submodules</b>:
        local_user: Application;
        routing: RoutingModule
            <b>parameters</b>:
                processing_delay = rte_processing_delay,
                buffersize = rte_buffersize;
            <b>gatesizes</b>:
                input[num_of_ports+1],
                output[num_of_ports+1];
        port_if: DataLink[num_of_ports]
            <b>parameters</b>:
                retry_count = 5,
                window_size = 2;
    <b>connections</b>:
        <b>for</b> i=0..num_of_ports-1 <b>do</b>
            routing.output[i] -&gt; port_if[i].from_higher_layer;
            routing.input[i] &lt;- port_if[i].to_higher_layer;
            port_if[i].to_port -&gt; output_ports[i];
            port_if[i].from_port &lt;- input_ports[i];
        <b>endfor</b>;
        routing.output[num_of_ports] -&gt; local_user.input;
        routing.input[num_of_ports] &lt;- local_user.output;
<b>endmodule</b>
</pre>

<p>
<b>Example 2: Chain</b>

<p>
For example, one can create a chain of modules like this:

<p>
<pre>
<b>module</b> Serial
    <b>parameters</b>: count: <b>const</b>;
    <b>submodules</b>:
        node : Node [count]
            <b>gatesizes</b>:
                in[2], out[2];
            <b>gatesizes</b> <b>if</b> index==0 || index==count-1:
                in[1], out[1];
    <b>connections</b>:
        <b>for</b> i = 0..count-2 <b>do</b>
            node[i].out[i!=0 ? 1 : 0] -&gt; node[i+1].in[0];
            node[i].in[i!=0 ? 1 : 0] &lt;- node[i+1].out[0];
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
<b>Example 3: Binary Tree</b>

<p>
One can use conditional connections to build a binary tree.
The following NED code loops through all possible node pairs, and
creates the connections needed for a binary tree.

<p><pre>
<b>simple</b> BinaryTreeNode
    <b>gates</b>:
        <b>in</b>: fromupper;
        <b>out</b>: downleft;
        <b>out</b>: downright;
<b>endsimple</b>

<p><b>module</b> BinaryTree
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i = 0..2^height-2, j = 0..2^height-2 <b>do</b>
            node[i].downleft -&gt; node[j].fromupper <b>if</b> j==2*i+1;
            node[i].downright -&gt; node[j].fromupper <b>if</b> j==2*i+2;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note that not each gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the <tt>nocheck</tt> modifier.  Consequently, it
is the simple modules' responsibility not to send on a gate which is
not leading anywhere.

<p>An alert reader might notice that there is a better alternative
to the above code. Each node except the ones at the lowest level
of the tree has to be connected to exactly two nodes,
so we can use a single loop to create the connections.

<p><pre>
<b>module</b> BinaryTree2
    <b>parameters</b>:
        height: <b>const</b>;
    <b>submodules</b>:
        node: BinaryTreeNode [ 2^height-1 ];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..2^(height-1)-2 <b>do</b>
            node[i].downleft -&gt; node[2*i+1].fromupper;
            node[i].downright -&gt; node[2*i+2].fromupper;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>

<p><b>Example 4: Random graph</b>

<p>Conditional connections can also be used to generate random
topologies.  The following code generates a
random subgraph of a full graph:

<p>
<pre>
<b>module</b> RandomGraph
    <b>parameters</b>:
        count: <b>const</b>,
        connectedness; // 0.0&lt;x&lt;1.0
    <b>submodules</b>:
        node: Node [count];
            <b>gatesizes</b>: <b>in</b>[count], <b>out</b>[count];
    <b>connections</b> <b>nocheck</b>:
        <b>for</b> i=0..count-1, j=0..count-1 <b>do</b>
            node[i].out[j] -&gt; node[j].in[i]
                <b>if</b> i!=j && uniform(0,1)&lt;connectedness;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>Note the use of the <tt>nocheck</tt> modifier
here too, to turn off error messages given by the network setup code
for unconnected gates.

<p>
<font color="#006f00"><H3><A NAME="sec144"/>4.6.2. <FONTteal>Using const with parameterized topologies</FONT></H3></font>

<p>
Since parameter values can be used in defining the internal topology
of the module, the <tt>const</tt> modifier has a
significant role. Consider the following example:

<p>
<pre>
<b>simple</b> Sender
    <b>parameters</b>:
        num_of_outgates;
    <b>gates</b>:
        <b>out</b>: outgate[num_of_outgates];
<b>endsimple</b> Sender

<p><b>simple</b> Receiver
    <b>gates</b>:
        <b>in</b>: ingate;
<b>endsimple</b> Receiver

<p><b>module</b> Network;
    <b>parameters</b>:
        num_of_mods: <b>const</b>;
    <b>submodules</b>:
        sender: Sender
            <b>parameters</b>:
                num_of_outgates = <EM>num_of_mods</EM>;
        receiver: Receiver [<EM>num_of_mods</EM>]
    <b>connections</b>:
        <b>for</b> i=1..<EM>num_of_mods</EM> <b>do</b>
            sender.outgate[i] -&gt; receiver[i].ingate
        <b>endfor</b>;
<b>endmodule</b>

<p><b>network</b> net: Network
    <b>parameters</b>:
        num_of_mods = normal (5,2);
<b>endnetwork</b>
</pre>

<p>
If parameter num_of_mods wasn't const, the following would happen:<br>
normal(5,2) would be substituted for the num_of_mods. There
are three places where an evaluation of num_of_mods (that is, normal
(5,2)) is done (they are typed in italics in the example). It
is likely that these evaluations would not result in the same
value, and consequently, the gate vector sizes would not match
each other and the end value of the for statement. Thus, the
loop connection would not be created properly.

<p>Using <tt>const</tt> for the parameter num_of_mods
prevents this from happening: an evaluation of normal(5,2) is
substituted for num_of_mods and an equal number of gates are
created.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec145"/>4.6.3. <FONTteal>Design patterns for compound modules</FONT></H3></font>

<p>


<p>Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are
described below.

<p>
<b>'Subgraph of a Full Graph' </b>

<p>
This pattern takes a subset of the connections of a full graph.  A
condition is used to ''carve out'' the necessary interconnection from
the full graph:

<p>
<pre>
for i=0..N-1, j=0..N-1 do
    node[i].out[...] -&gt; node[j].in[...] if condition(i,j);
endfor;
</pre>

<p>

<p>
The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate <EM>condition(i,j)</EM> can be formulated. For example,
when generating a tree structure, the condition
would return whether node <EM>j</EM> is a child of node <EM>i</EM> or
vica versa.

<p>Though this pattern is very general, its usage can be prohibitive if
the <EM>N</EM> number of nodes is high and the graph is sparse (it has
much fewer connections that <EM>N</EM><sup><i>2</i></sup>). The following
two patterns do not suffer from this drawback.

<p>
<b>'Connections of Each Node' </b>

<p>
The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

<p>
<pre>
for i=0..Nnodes, j=0..Nconns(i)-1 do
    node[i].out[j] -&gt; node[rightNodeIndex(i,j)].in[j];
endfor;
</pre>

<p>

<p>The Hypercube compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

<p>The applicability of this pattern depends on how easily the <EM>rightNodeIndex(i,j)</EM>
function can be formulated.

<p>
<b>'Enumerate All Connections' </b>

<p>
A third pattern is to list all connections within a loop:

<p>
<pre>
for i=0..Nconnections-1 do
    node[leftNodeIndex(i)].out[...] -&gt; node[rightNodeIndex(i)].in[...];
endfor;
</pre>

<p>

<p>The pattern can be used if <EM>leftNodeIndex(i)</EM> and <EM>rightNodeIndex(i)</EM>
mapping functions can be sufficiently formulated.

<p>The Serial module is an example of this approach where the mapping
functions are extremely simple: <EM>leftNodeIndex(i)=i</EM> and <EM>rightNodeIndex(i)=i+1</EM>.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

<p>In the case of irregular structures where none of the above patterns
can be employed, the user can resort to specifying constant submodule/gate
vector sizes and explicitly listing all connections, like he/she
would do it in most existing simulators.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec146"/>4.6.4. <FONTteal>Topology templates</FONT></H3></font>
<a name="sec:ch-ned-lang:topology-templates"/>

<p>

<p><b>Overview</b>

<p>
Topology templates are nothing more than compound modules where one or
more submodule types are left as parameters (using the
<tt>like</tt> phrase of the NED language).  You can
write such modules which implement mesh,
hypercube,
butterfly, perfect
shuffle or other topologies, and you
can use them wherever needed in you simulations.  With topology
templates, you can reuse
<EM>interconnection structure</EM>.

<p>

<p><b>An example: hypercube</b>

<p>
The concept is demonstrated on a network with hypercube interconnection.
When building an N-dimension hypercube, we can exploit the fact
that each node is connected to N others which differ from it
only in one bit of the binary representations of the node indices
(see Fig. <a href="#fig:ch-ned-lang:hypercube-topology">[click]</a>).

<p>
  <DIV ALIGN=center>
    <img src="usmanFig8.gif">
    <center><i>Figure: Hypercube topology</i></center>
    <a name="fig:ch-ned-lang:hypercube-topology"/>
  </DIV>

<p>

<p>The hypercube topology template is the
following (it can be placed into a separate file, e.g hypercube.ned):

<p>
<pre>
simple Node
    gates: out: out[]; in: in[];
endsimple

<p><b>module</b> Hypercube
    parameters:
        dim, nodetype;
    submodules:
        node: nodetype[2^dim] like Node
    gatesizes:
        out[dim], in[dim];
    connections:
        for i=0..2^dim-1, j=0..dim-1 do
            node[i].out[j] -&gt; node[i # 2^j].in[j]; // # is bitwise XOR
        endfor;
endmodule
</pre>

<p>

<p>When you create an actual hypercube, you substitute the name
of an existing module type (e.g. Hypercube_PE) for the nodetype
parameter. The module type implements the algorithm the user
wants to simulate and it must have the same gates that the Node
type has. The topology template code can be used through importing
the file:

<p>
<pre>
import "hypercube.ned"

<p>simple Hypercube_PE
    gates: out: out[]; in: in[];
endsimple

<p>network hypercube: Hypercube
    parameters:
        dim = 4,
        nodetype = "Hypercube_PE";
endnetwork
</pre>

<p>

<p>If you put the nodetype parameter to the ini file, you can use the
same simulation model to test e.g. several routing algorithms in a
hypercube, each algorithm implemented with a different
simple module type - you just have to supply
different values to nodetype, such as ''WormholeRoutingNode'',
''DeflectionRoutingNode'', etc.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec147"/>4.7. <FONTblue>Network definition</FONT></H2></font></hr>

<p>

<p>A <EM>network definition</EM> (or <EM>system module
  definition</EM>) specifies the system module. Its syntax is very
similar to a submodule declaration. The system definition starts with
keyword <tt>network</tt> and ends with
<tt>endnetwork</tt>.

<p>
An example:

<p>
<pre>
<b>network</b> modelledNetwork: SomeModule
    <b>parameters</b>:
        par1=10,
        par2=normal(100,20);
<b>endnetwork</b>
</pre>

<p>
Here, SomeModule is the name of a compound or a simple module type.

<p>
There can be several system definitions in a network description,
each one defines a different network. The simulation program
built with such a network description is able to run any of them;
the desired one can be specified in the config file (see later).

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec148"/>4.8. <FONTblue>Support for parallel execution</FONT></H2></font></hr>

<p>OMNeT++ simulations can be executed in parallel. This means that different parts of the model execute on
different hosts or processors.  (We'll use the term ''host'' or
''machine'' in this sense.) The unit of granularity is the
simple module: one simple
module always executes on a single processor.

<p>
Parallel execution is also supported by NED: the language provides
an elegant way of specifying execution hosts for different modules.
We'll discuss this feature in the following sections.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec149"/>4.8.1. <FONTteal>Extensions to the compound module and system definitions</FONT></H3></font>

<p>To support the segmentation of the model for
execution of different modules, the compound module definition was
extended with the <tt>machines:</tt> and the <tt>on:</tt> keywords.

<p>Example:
<pre>
<b>module</b> SomeNameForCompoundModule
    <b>machines</b>: host1, host2, host3, host4;
    <b>parameters</b>: //...
    <b>gates</b>: //...
    <b>submodules</b>:
        submodule1 : submodtype1
            <b>on:</b> host1;
        submodule2 : submodtype2
            <b>on:</b> host2, host3;
        submodule3 : submodtype1
            <b>on:</b> host4;
    <b>connections</b>: //...
<b>endmodule</b>
</pre>

<p>
The <tt>machines:</tt> section lists formal host
names which are used in the <tt>on:</tt> lists of the
submodules.

<p>
In the example, the second submodule is itself a compound module that
can be further subdivided to run on two separate hosts, so its
definition must have a machines: section with two parameters.  You do
not have to propagate host names down to simple module level: you can
stop at a compound module which executes on a single host. In other
words, a compound module with no machines: section is equivalent to
one with one machine parameter.

<p>Of course, you can give the same value to several machine parameters,
as to submodule1's in the following example. In this case, the whole
compound module will be placed on a single host, as if it never had
machine parameters at all.

<p>
<pre>
<b>module</b> AnotherCompoundModule
    <b>machines</b>: host1, host2;
    <b>parameters</b>: //...
    <b>gates</b>: //...
    <b>submodules</b>:
        submodule1 : submodtype1
            <b>on:</b> host1, host1, host1;
        //...
    <b>connections</b>: //...
<b>endmodule</b>
</pre>

<p>
Host names propagate up to network definition level. Extension
to the network definition:

<p>
<pre>
<b>network</b> distVector: DistVector
    on: machine1, machine2, machine3;
<b>endnetwork</b>
</pre>

<p>

<p>The <tt>on:</tt> parameters of the network definition
can be actual host names, or alternatively, they can be symbolic names
that are mapped to actual host names in the config file.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec150"/>4.8.2. <FONTteal>Conditional 'on' sections</FONT></H3></font>

<p>Similarly to the parameters: and gatesizes: section, multiple
<tt>on:</tt> sections can exist for the submodules if
they are tagged with <tt>if</tt> phrases.

<p>This makes it possible to control the module distribution with
parameters. You can even put different parts of a module vector on
different machines using the index operator (see
later in Section <a href="#ch-ned-lang:sec:expressions">[click]</a>, Expressions).

<p>Example:

<p>
<pre>
<b>module</b> DistVector
    <b>machines</b>: host1, host2, host3;
    <b>submodules</b>:
        node : Node [count]
            <b>on</b> <b>if</b> index&lt;count*.33: host1;
            <b>on</b> <b>if</b> index&gt;=count*.33 && index&lt;count*.66: host2;
            <b>on</b> <b>if</b> index&gt;=count*.66: host3;
<b>endmodule</b>
<b>network</b> distvector: DistVector
    on machine1, machine2, machine3;
<b>endnetwork</b>
</pre>

<p>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec151"/>4.9. <FONTblue>Expressions</FONT></H2></font></hr>
<a name="ch-ned-lang:sec:expressions"/>

<p>In the NED language there are a number of places where
expressions are expected.

<p>
When such an expression is encountered by the NEDC compiler, it is
compiled and it will be evaluated
run-time.

<p>Expressions have a C-style syntax. They are built with the usual math
operators; they can use parameters taken by
value or by reference; call C functions; contain random and input
values etc.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec152"/>4.9.1. <FONTteal>Referencing other parameters</FONT></H3></font>

<p>Expressions can use the parameters of the enclosing compound module
(the one being defined) and of submodules defined earlier in NED file.
The syntax for the latter is <tt>submod.param</tt> or <tt>submod[index].param</tt>.

<p>A parameter can be taken by value or by
reference. The default is by value;
to select by-reference passing for a parameter, you have to use the
<tt>ref</tt> modifier. Parameters passed by
reference can be used by a module to propagate values (status info
etc.) to other modules.

<p>The ancestor modifier allows one to access parameters from higher
in the module hierarchy.

<p>
<pre>
<b>module</b> Compound
    <b>parameter</b>: nnn;
    <b>submodules</b>:
        proc: Processor
            <b>parameters</b>:
                par1 = <b>ref</b> nnn / 2,
                par2 = 10 * <b>ancestor</b> par_somewhere_up;
<b>endmodule</b>
</pre>

<p>
<font color="#006f00"><H3><A NAME="sec153"/>4.9.2. <FONTteal>Operators</FONT></H3></font>

<p>The following operators can be used
in expressions, in order of precedence:

<p>
<table border>
<TR> <TD align=left>

<p><b>Operator</b> </TD> <TD align=left> <b>Meaning</b></TD></TR>
<TR> <TD align=left> -, !, <IT>~</IT> </TD> <TD align=left> unary minus, negation, bitwise complement </TD></TR>
<TR> <TD align=left> ^        </TD> <TD align=left> power of </TD></TR>
<TR> <TD align=left>
$*$, /, %                </TD> <TD align=left> multiply, divide, modulus </TD></TR>
<TR> <TD align=left>
+, -                    </TD> <TD align=left> add, subtract </TD></TR>
<TR> <TD align=left>
<tt>&lt;</tt><tt>&lt;</tt>, <tt>&gt;</tt><tt>&gt;</tt>      </TD> <TD align=left> bitwise shifting </TD></TR>
<TR> <TD align=left>
&amp;, |, #        </TD> <TD align=left> bitwise and, or, xor
                         <EM>(^ is reserved for power)</EM> </TD></TR>
<TR> <TD align=left>
==                      </TD> <TD align=left> equal </TD></TR>
<TR> <TD align=left> !=                      </TD> <TD align=left> not equal </TD></TR>
<TR> <TD align=left> <tt>&gt;</tt>, <tt>&gt;=</tt>       </TD> <TD align=left> greater, greater or equal </TD></TR>
<TR> <TD align=left> <tt>&lt;</tt>, <tt>&lt;=</tt>       </TD> <TD align=left> less, less or equal </TD></TR>
<TR> <TD align=left>
&amp;&amp;, ||, ## </TD> <TD align=left> logical operators and, or, xor </TD></TR>
<TR> <TD align=left>
?:                      </TD> <TD align=left> the C/C++ ``inline if'' </TD></TR>
</table>

<p>

<p><font color="#006f00"><H3><A NAME="sec154"/>4.9.3. <FONTteal>The <tt>sizeof()</tt> and <tt>index</tt> operators</FONT></H3></font>

<p>A useful operator is <tt>sizeof()</tt>, which gives the
size of a vector gate. The <tt>index</tt>
operator gives the index of the current
submodule in its module vector.

<p>An example for both:

<p><pre>
<b>module</b> Compound
    <b>gates</b>: <b>in</b>: fromgens[];
    <b>submodules</b>:
        proc: Processor[ <b>sizeof</b>(fromgens) ];
            <b>parameters</b>: address = 10*(1+<b>index</b>);
    <b>connections</b>:
        <b>for</b> i = 0.. <b>sizeof</b>(fromgens)-1 <b>do</b>
            in[i] -&gt; proc[i].input;
        <b>endfor</b>;
<b>endmodule</b>
</pre>

<p>
Here, we create as many processors as there are input gates for
this compound module in the network. The address parameters of
the processors are 10, 20, 30 etc.

<p>

<p><font color="#006f00"><H3><A NAME="sec155"/>4.9.4. <FONTteal>Prompt text and default value</FONT></H3></font>

<p>When a parameter does not receive a value inside NED files or in <tt>omnetpp.ini</tt>,
the user will be prompted to enter its value at the beginning of the simulation.

<p>For such cases, it is possible to specify a prompt text and a default value.
The syntax is the following:

<p><pre>
    <EM>&lt;paramname&gt;</EM> = <b>input</b>(<EM>&lt;default-value&gt;</EM>, <EM>&lt;prompt&gt;</EM>)
    <EM>&lt;paramname&gt;</EM> = <b>input</b>(<EM>&lt;default-value&gt;</EM>)
    <EM>&lt;paramname&gt;</EM> = <b>input</b>
</pre>

<p>You can use the third version to make it explicit that you do not want to
assign a value from within the NED file; otherwise it is equivalent to
simply and quietly leaving out the parameter from the list of assignments.

<p>Examples:

<p><pre>
   ...
   parameters:
      numProc = <b>input</b>(10,"Number of processors:"),
      processingTime = <b>input</b>(10ms),
      ...
</pre>

<p>

<p><font color="#006f00"><H3><A NAME="sec156"/>4.9.5. <FONTteal>Time constants</FONT></H3></font>

<p>Anywhere you would put numeric constants
(integer or real) to mean time in seconds, you can also specify the
time in units like milliseconds, minutes or hours:

<p>
<pre>
    ...
    <b>parameters</b>:
        propagation_delay = 560ms, // 0.560s
        connection_timeout = 6m 30s 500ms, // 390.5s
        recovery_intvl = 0.5h; // 30 min
</pre>

<p>
The following units can be used:

<p><table border>
<TR> <TD align=center>
ns </TD> <TD align=left> nanoseconds </TD> <TD align=left> $*10^-9$ </TD></TR>
<TR> <TD align=center> us </TD> <TD align=left> microseconds </TD> <TD align=left> $*10^-6$ </TD></TR>
<TR> <TD align=center> ms </TD> <TD align=left> milliseconds </TD> <TD align=left> $*10^-3$ </TD></TR>
<TR> <TD align=center> s  </TD> <TD align=left> seconds </TD> <TD align=left> $*1$ </TD></TR>
<TR> <TD align=center> m  </TD> <TD align=left> minutes </TD> <TD align=left> $*60$ </TD></TR>
<TR> <TD align=center> h  </TD> <TD align=left> hours </TD> <TD align=left> $*3600$ </TD></TR>
<TR> <TD align=center> d  </TD> <TD align=left> days </TD> <TD align=left> $*24*3600$ </TD></TR>
</table>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec157"/>4.9.6. <FONTteal>Functions</FONT></H3></font>


<p>In NED expressions, you can use the following mathematical functions:
<UL>
  <li><strong></strong>many of the C language's <tt>&lt;math.h&gt;</tt> library functions:
    <tt>exp()</tt>, <tt>log()</tt>, <tt>sin()</tt>, <tt>cos()</tt>, <tt>floor()</tt>,
    <tt>ceil()</tt>, <tt>etc.</tt>
  <li><strong></strong>functions that generate random variables: <tt>uniform</tt>,
    <tt>exponential</tt>, <tt>normal</tt> and others were already
    discussed.
</UL>

<p>It is possible to add new ones, see <a href="#sec:ch-ned-lang:defining-functions">[click]</a>.

<p><font color="#006f00"><H3><A NAME="sec158"/>4.9.7. <FONTteal>Random values</FONT></H3></font>

<p>Expressions may contain random variates from different distributions.
This has the effect that unless the parameter was declared <tt>const</tt>,
it returns a different value each time it is evaluated.

<p>If the parameter <EM>was</EM> declared <tt>const</tt>, it is only evaluated
once at the beginning of the simulation, and subsequent queries
on the parameter will always return the same value.

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNeT++. By default this is generator 0, but you can specify
which one to be used.

<p>OMNeT++ has the following predefined distributions:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <EM>rng=0</tt>)</EM> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <EM>rng=0</tt>)</EM> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <EM>rng=0</tt>)</EM> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <EM>rng=0</tt>)</EM> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left> 
</table>


If you do not specify the optional <tt>rng</tt> argument, the functions will
use random number generator 0.

<p>Examples:

<pre>
intuniform(0,10)/10  // one of: 0, 0.1, 0.2, ..., 0.9, 1
exponential(5)       // exponential with mean=5 (thus parameter=0.2)
2+truncnormal(5,3)   // normal distr with mean 7 truncated to &gt;=2 values
</pre>
<p>
The above distributions are implemented with C functions, and you can easily
add new ones (see section <a href="#sec:ch-ned-lang:defining-functions">[click]</a>).
Your distributions will be treated in the same way as the built-in ones.

<p>

<p><font color="#006f00"><H3><A NAME="sec159"/>4.9.8. <FONTteal>Defining new functions</FONT></H3></font>

<a name="sec:ch-ned-lang:defining-functions"/>

<p>To use user-defined functions, one has
to code the function in C++.  The C++ function must take 0, 1, 2, 3, or 4
arguments of type double and return a double. The function must be
registered in one of the C++ files with the <tt>Define_Function()</tt>
macro.

<p>An example function (the following code must appear in one of the C++
sources):

<p>
<pre>
#include &lt;omnetpp.h&gt;

double average(double a, double b)
{
  return (a+b)/2;
}

Define_Function(average, 2);
</pre>

<p>
The number 2 means that the <tt>average()</tt> function has 2
arguments.  After this, the <tt>average()</tt> function can be used in
NED files:

<p>
<pre>
<b>module</b> Compound
    <b>parameter</b>: a,b;
    <b>submodules</b>:
        proc: Processor
            <b>parameters</b>: av = average(a,b);
<b>endmodule</b>
</pre>

<p>
If your function takes parameters that are <tt>int</tt> or <tt>long</tt> or
some other type which is not <tt>double</tt>, you can create wrapper function
that takes all doubles and does the conversion. In this case you have
to register the wrapper function with the <tt>Define_Function2()</tt> macro
which allows a function to be registered with a name different from the
name of the function that implements it. You can do the same
if the return value differs from <tt>double</tt>.

<pre>
#include &lt;omnetpp.h&gt;

long factorial(int k)
{
  ...
}

static double _wrap_factorial(double k)
{
  return factorial((int)k);
}

Define_Function2(factorial, _wrap_factorial, 1);
</pre>
<p>

<p><hr><font color="#006f00"><H2><A NAME="sec160"/>4.10. <FONTblue>Display strings</FONT></H2></font></hr>
<a name="sec:ch-ned-lang:display-strings"/>

<p>Display strings specify the arrangement and
appearance of modules in graphical user interfaces (currently only
Tkenv): they control how the objects (compound modules, their
submodules and connections) are displayed. Display strings occur in
NED description's <tt>display:</tt>
phrases.

<p>The display string format is a semicolon-separated list of tags.
Each tag consists of a key (usually one letter), an equal sign
and a comma-separated list of parameters, like:

<pre>
  "p=100,100;b=60,10,rect;o=blue,black,2"
</pre>
<p>
Parameters may be omitted also at the end and also inside the
parameter list, like:

<pre>
  "p=100,100;b=,,rect;o=blue,black"
</pre>
<p>
Module/submodule parameters can be included with the <tt>$name</tt> notation:

<pre>
  "p=$xpos,$ypos;b=rect,60,10;o=$fillcolor,black,2"
</pre>
<p>
Objects that may have display strings are:
<UL>
  <li><strong></strong>compound modules (as the enclosing module in the drawing),
  <li><strong></strong>submodules
  <li><strong></strong>connections
</UL>

<p><b>Tags used in submodule display strings:</b>

<p>

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b> </TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>
</TD> <TD align=left>
 Place submodule at (<EM>xpos</EM>,<EM>ypos</EM>) pixel position,
with the origin being the top-left corner of the enclosing module.

<p>Defaults: an appropriate automatic layout is where submodules do not overlap.

<p>If applied to a submodule vector, <EM>ring</EM> or <EM>row</EM> layout is
selected automatically.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>row</b>,<EM>deltax</EM> </TD> <TD align=left>
 Used for module vectors. Arranges submodules in a row starting
at (<EM>xpos</EM>,<EM>ypos</EM>), keeping <EM>deltax</EM> distances.

<p>Defaults: <EM>deltax</EM> is chosen so that submodules do not overlap.

<p><b>row</b> may be abbreviated as <b>r</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>column</b>,<EM>deltay</EM>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in a column starting
at (<EM>xpos</EM>,<EM>ypos</EM>), keeping <EM>deltay</EM> distances.

<p>Defaults: <EM>deltay</EM> is chosen so that submodules do not overlap.

<p><b>column</b> may be abbreviated as <b>col</b> or <b>c</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>matrix</b>,
<EM>itemsperrow</EM>,<EM>deltax</EM>,<EM>deltay</EM>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in a matrix starting
at (<EM>xpos</EM>,<EM>ypos</EM>), at most <EM>itemsperrow</EM> submodules in
a row, keeping <EM>deltax</EM> and <EM>deltay</EM> distances.

<p>Defaults: <EM>itemsperrow</EM>=5, <EM>deltax,deltay</EM> are chosen so that
submodules do not overlap.

<p><b>matrix</b> may be abbreviated as <b>m</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>ring</b>,<EM>width,height</EM>
</TD> <TD align=left>
 Used for module vectors. Arranges submodules in an ellipse,
with the top-left corner of its bounding boxes at (<EM>xpos</EM>,<EM>ypos</EM>),
with the <EM>width</EM> and <EM>height</EM>.

<p>Defaults: <EM>width</EM>=40, <EM>height</EM>=24

<p><b>ring</b> may be abbreviated as <b>ri</b>.</TD></TR>
<TR> <TD align=left> <b>p=</b><EM>xpos</EM>,<EM>ypos</EM>,<b>exact</b>,<EM>deltax</EM>,<EM>deltay</EM>
</TD> <TD align=left>
 Used for module vectors. Each submodule is placed at
<EM>(xpos+deltax</EM>, <EM>ypos+deltay)</EM>.
This is useful if <EM>deltax</EM> and <EM>deltay</EM> are parameters
 (e.g.:<EM>''p=100,100,exact,$x,$y''</EM>)
which take different values for each module in the vector.

<p>Defaults: <EM>none</EM>

<p><b>exact</b> may be abbreviated as <b>e</b> or <b>x</b>.</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>rect</b>
</TD> <TD align=left>
 Rectangle with the given <EM>height</EM> and <EM>width</EM>.

<p>Defaults: <EM>width</EM>=40, <EM>height</EM>=24</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>oval</b>
</TD> <TD align=left>
 Ellipse with the given <EM>height</EM> and <EM>width</EM>.

<p>Defaults: <EM>width</EM>=40, <EM>height</EM>=24</TD></TR>
<TR> <TD align=left> <b>o=</b><EM>fillcolor</EM>,<EM>outlinecolor</EM>,<EM>borderwidth</EM>
</TD> <TD align=left>
 Specifies options for the rectangle or oval. Any valid Tk color
specification is accepted: English color names or <EM>#rgb</EM>, <EM>#rrggbb</EM>
format (where <EM>r</EM>,<EM>g</EM>,<EM>b</EM> are hex digits).

<p>Defaults: <EM>fillcolor</EM>=#8080ff (a lightblue), <EM>outlinecolor</EM>=black,
<EM>borderwidth</EM>=2</TD></TR>
<TR> <TD align=left> <b>i=</b><EM>iconname</EM>
</TD> <TD align=left>
 Use the named icon.

<p>No default. If no icon name is present, <EM>box</EM> is used.</TD></TR>
</table>

<p>

<p>Examples:

<pre>
  "p=100,60;i=workstation"
  "p=100,60;b=30,30,rect;o=4"
</pre>
<p>

<p><b>Tags used in enclosing module display strings:</b>

<p>
<table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b></TD></TR>
<TR> <TD align=left>
<b>p=</b><EM>xpos</EM>,<EM>ypos</EM> </TD> <TD align=left> Place enclosing module at
(<EM>xpos</EM>,<EM>ypos</EM>) pixel position, with (0,0) being
the top-left corner of the window.</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>rect</b>
</TD> <TD align=left>
 Display enclosing module as a rectangle with the given <EM>height</EM>
and <EM>width</EM>.

<p>Defaults: <EM>width,</EM> <EM>height</EM> are chosen automatically</TD></TR>
<TR> <TD align=left> <b>b=</b><EM>width</EM>,<EM>height</EM>,<b>oval</b>
</TD> <TD align=left>
 Display enclosing module as an ellipse with the given <EM>height</EM>
and <EM>width</EM>.

<p>Defaults: <EM>width,</EM> <EM>height</EM> are chosen automatically</TD></TR>
<TR> <TD align=left> <b>o=</b><EM>fillcolor</EM>,<EM>outlinecolor</EM>,<EM>borderwidth</EM>
</TD> <TD align=left>
 Specifies options for the rectangle or oval. Any valid Tk color
specification is accepted: English color names or <EM>#rgb</EM>, <EM>#rrggbb</EM>
format (where <EM>r</EM>,<EM>g</EM>,<EM>b</EM> are hex digits).

<p>Defaults: <EM>fillcolor</EM>=#8080ff (a lightblue), <EM>outlinecolor</EM>=black,
<EM>borderwidth</EM>=2</TD></TR>
</table>

<p>

<p><b>Tags used in connection display strings:</b>

<p><table border>
<TR> <TD align=left>

<b>Tag</b> </TD> <TD align=left> <b>Meaning</b></TD></TR>
<TR> <TD align=left> <b>m=auto</b> <br>
<b>m=north</b> <br>
<b>m=west</b> <br>
<b>m=east</b> <br>
<b>m=south</b>
</TD> <TD align=left>
Drawing mode. Specifies the exact placement of the connection
arrow. The arguments can be abbreviated as a,e,w,n,s.</TD></TR>
<TR> <TD align=left>  <b>m=manual</b>,<EM>srcpx</EM>,<EM>srcpy</EM>,<EM>destpx</EM>,<EM>destpy</EM>
</TD> <TD align=left>
 The manual mode takes four parameters that explicitly specify
anchoring of the ends of the arrow: <EM>srcpx</EM>, <EM>srcpy</EM>,
<EM>destpx</EM>, <EM>destpy</EM>.
Each value is a percentage of the width/height of the source/destination
module's enclosing rectangle, with the upper-left corner being
the origin. Thus,
<pre>
m=m,50,50,50,50
</pre>
would connect the centers of the two module rectangles.</TD></TR>
<TR> <TD align=left> <b>o=</b><EM>color</EM>,<EM>width</EM> </TD> <TD align=left>
Specifies the appearance of the arrow. Any valid Tk color specification
is accepted: English color names or #rgb, #rrggbb specification
(where r,g,b are hex digits).

<p>Defaults: <EM>color</EM>=black, <EM>width</EM>=2</TD></TR>
</table>

<p>

<p>Examples:
<pre>
  "m=a;o=blue,3"
</pre>

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec161"/>4.11. <FONTblue>GNED - Graphical NED Editor</FONT></H2></font></hr>

<p>

<p>The GNED editor allows you to design compound modules graphically.
GNED works with NED files - it doesn't use any nasty internal file
format. You can load any of your existing NED files, edit the compound
modules in it graphically and then save the file back. The rest of the
stuff in the NED file (simple modules, channels, networks etc.) will
survive the operation. GNED puts all graphics-related data into
display strings.

<p>
GNED works by parsing your NED file into an internal data structure,
and regenerating the NED text when you save the file. One consequence
of this is that indentation will be ''canonized''
- hopefully you consider this fact as a plus and not as a minus.
Comments in the original NED are preserved - the parser associates
them with the NED elements they belong to, so comments won't
be messed up even if you edit the graphical representation to
death by removing/adding submodules, gates, parameters, connections,
etc.

<p>GNED is now a fully two-way visual tool. While editing the graphics,
you can always switch to NED source view, edit in there and switch
back to graphics. Your changes in the NED source will be immediately
backparsed to graphics; in fact, the graphics will be totally
reconstructed from the NED source and the display strings in
it.

<p>GNED is still under development. There are some missing functions
and bugs, but overall it should be fairly reliable. See the TODO
file in the GNED source directory for problems and missing features.

<p>
<b>Comment parsing:</b>

<p>
It is useful to know how exactly GNED identifies the comments
in the NED file. The following (maybe a bit long) NED code should
explain it:

<pre>
// ---------------------------------------------------------------
// File: sample.ned
//
// This is a file comment. File comments reach from the top of
// the file till the last blank line above the first code line.
// ---------------------------------------------------------------
//

// The file comment can also contain blank lines, so this is
// still part of the above file comment.
//
// Module1 --
//
// This is a banner comment for the Module1 declaration below.
// Banner comments can be multi-line, but they are not supposed
// to contain blank lines. (Otherwise the lines above the blank
// one will be taken as part of a file comment or trailing comment.)
//
module Module1
    submodules: // and this is right-comment
        // This is another banner comment, for the submodule
        submod1: Module;
            display: ''p=120,108;b=96,72,rect'';
            connections:
                out --&gt; submod1.in; // Right-comments can also be
                                    // multi-line.
endmodule

// Finally, this is a trailing comment, belonging to the above
// module. It may contain blank lines. Trailing comments are
// mostly used to put separator lines into the file, like this:
// --------------------------------------------------------------
// Module2 --
//
// an empty module
//
module Module2
endmodule
</pre>
<p>

<p><b>Key/mouse bindings:</b>

<p>

<p>In graphics view, there are two editing modes: draw and select/mode.
The mouse bindings are the following:

<p>
<table border>
<TR> <TD align=left>

<b>Mouse</b> </TD> <TD align=left> <b>Effect</b></TD></TR>
<TR> <TD align=center colspan=2><b>In <EM>draw</EM> mode:</b> </TD></TR>
<TR> <TD align=left>
Drag out a rectangle in empty area: </TD> <TD align=left>  create new submodule </TD></TR>
<TR> <TD align=left> Drag from one submodule to another: </TD> <TD align=left>  create new connection </TD></TR>
<TR> <TD align=left> Click in empty area: </TD> <TD align=left> switch to select/move mode </TD></TR>
<TR> <TD align=center colspan=2><b>In <EM>select/move</EM> mode:</b> </TD></TR>
<TR> <TD align=left> Click submodule/connection: </TD> <TD align=left> select it</TD></TR>
<TR> <TD align=left> Ctrl-click submodule/conn.: </TD> <TD align=left> add to selection </TD></TR>
<TR> <TD align=left> Click in empty area: </TD> <TD align=left> clear selection</TD></TR>
<TR> <TD align=left> Drag a selected object: </TD> <TD align=left> move selected objects </TD></TR>
<TR> <TD align=left> Drag submodule or connection: </TD> <TD align=left> move it </TD></TR>
<TR> <TD align=left> Drag either end of connection: </TD> <TD align=left> move that end </TD></TR>
<TR> <TD align=left> Drag corner of (sub)module: </TD> <TD align=left> resize module</TD></TR>
<TR> <TD align=left> Drag starting in empty area: </TD> <TD align=left> select enclosed submodules/connections </TD></TR>
<TR> <TD align=left> <EM>Del</EM> key </TD> <TD align=left> delete selected objects </TD></TR>
<TR> <TD align=center colspan=2><b>Both editing modes:</b> </TD></TR>
<TR> <TD align=left> Right-click on module/submodule/con\-nec\-tion: </TD> <TD align=left> popup menu </TD></TR>
<TR> <TD align=left> Double-click on submodule: </TD> <TD align=left> go into submodule </TD></TR>
<TR> <TD align=left> Click name label </TD> <TD align=left> edit name </TD></TR>
<TR> <TD align=left> Drag&amp;drop module type from the tree view to the canvas </TD> <TD align=left>
create a submodule of that type </TD></TR>
</table>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec162"/>5. <FONTgreen>Simple Modules</FONT></H1></font></hr>
<a name="cha:simple-modules"/>

<p>The activities of simple modules are implemented by the user.
The algorithms are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction
to discrete event simulation in general, how its concepts are
implemented in OMNeT++, and gives an overview and practical advice
on how to design and code simple modules.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec163"/>5.1. <FONTblue>Simulation concepts</FONT></H2></font></hr>

<p>This section contains a very brief introduction into how Discrete
Event Simulation (DES) works, in order to introduce terms we'll use
when explaining OMNeT++ concepts and
implementation. If you're familiar with DES, you can skip this
section.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec164"/>5.1.1. <FONTteal>Discrete Event Simulation</FONT></H3></font>

<p>A <EM>Discrete Event System</EM> is a system where state changes
(events) happen at discrete points of time, and events take zero time
to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change takes
place in the system between the events (in contrast to
<EM>continuous</EM> systems where state changes are continuous). Those
systems that can be viewed as Discrete Event Systems can be modeled
using Discrete Event Simulation.
(Continuous systems are modelled using differential equations and
suchlike.)

<p>For example, computer networks are usually viewed as discrete
event systems. Some of the events are:
<UL>
<li><strong></strong>start of a packet transmission
<li><strong></strong>end of a packet transmission
<li><strong></strong>expiry of a retransmission timeout
</UL>

<p>
This implies that between two events such as ''start of a packet
transmission'' and ''end of a packet transmission'', nothing
interesting happens. That is, the packet's state remains ''being
transmitted''. Note that the definition of events and states always
depends on the intent and purposes of the person doing the modeling.
If we were interested in the transmission of individual bits, we would
have included something like ''start of bit transmission'' and ''end
of bit transmission'' among our events.

<p>
The time when events occur is often called <EM>event
  timestamp</EM>\indexevent timestamp; with OMNeT++ we'll say
<EM>arrival time</EM> (because in the class
library, the word ''timestamp'' is reserved for a user-settable
attribute in the event class). Time within the model is often called
<EM>simulation time</EM>, <EM>model
  time</EM> or <EM>virtual time</EM>
as opposed to real time or CPU time
or which refers to how long the simulation program has been running or
how much CPU time it has consumed.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec165"/>5.1.2. <FONTteal>The event loop</FONT></H3></font>

<p>Discrete event simulations maintain a set of future
events, in a data structure often called
FES (Future Event Set). Such simulators usually work
according to the following pseudocode:

<p><pre>
<EM>initialize - this includes building the model and</EM>
              <EM>inserting initial events to FES</EM>

<p><EM>while (FES not empty and simulation not yet complete)</EM>
<EM>{</EM>
    <EM>retrieve first event from FES</EM>
    <EM>t:= timestamp of this event</EM>
    <STRONG><EM>process event</EM></STRONG>
    <EM>(processing may insert new events in  FES or delete existing ones)</EM>
<EM>}</EM>
<EM>finish simulation (write statistical results, etc.)</EM>
</pre>

<p>
The first, initialization step usually builds the data structures
representing the simulation model, calls any user-defined
initialization code, and inserts initial events
into the FES to ensure that the simulation can start. Initialization
strategy can be quite different from one simulator to another.

<p>
The subsequent loop consumes events from the FES and processes
them. Events are processed in strict timestamp order in order
to maintain causality, that is, to ensure that no event may have
an effect on earlier events.

<p>Processing an event involves calls to user-supplied code. For example,
using the computer network simulation example, processing a ''timeout
expired'' event may consist of re-sending a copy of the network
packet, updating the retry count, scheduling another ''timeout''
event, and so on. The user code may also remove events from the FES,
for example when cancelling timeouts.

<p>Simulation stops when there are no more events left (this happens
rarely in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the simulation
programmer will typically want to record statistics into output
files.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec166"/>5.1.3. <FONTteal>Simple modules in OMNeT++</FONT></H3></font>

<p>The user creates simple module types by
subclassing the <tt>cSimpleModule</tt>
class, which is part of the OMNeT++ class library.
<tt>cSimpleModule</tt>, just as <tt>cCompoundModule</tt>, is derived
from a common base class, <tt>cModule</tt>.

<p><tt>cSimpleModule</tt>, although stuffed with simulation-related
functionality, doesn't do anything useful by itself. The simulation
programmer has to redefine some virtual member functions to make it do
useful work.

<p>
These member functions are the following:
<UL>
  <li><strong></strong>void <tt>initialize()</tt>
  <li><strong></strong>void <tt>activity()</tt>
  <li><strong>void \fname[handleMessage()]</strong>handleMessage(cMessage *msg)
  <li><strong></strong>void <tt>finish()</tt>
</UL>

<p>In the initialization step, OMNeT++ builds the network: it creates the
necessary simple and compound modules and
connects them according to the NED definitions. OMNeT++ also calls the
<tt>initialize()</tt> functions of all modules.

<p>The <tt>activity()</tt> and <tt>handleMessage()</tt> functions are
called during event processing. This means that the user will
implement the model's behavior in these functions.
<tt>activity()</tt> and <tt>handleMessage()</tt> implement
different event processing strategies: for each simple module, the user
has to redefine exactly one of these functions. <tt>activity()</tt> is
a coroutine-based solution which implements the
process interaction approach (coroutines are non-pre\-emp\-tive
[cooperative] threads). <tt>handleMessage()</tt> is a method that is called
by the simulation kernel when the module receives a message.
Modules written with <tt>activity()</tt> and <tt>handleMessage()</tt>
can be freely mixed within a simulation model.

<p>The <tt>finish()</tt> functions are called when the simulation
terminates successfully. The most typical use of <tt>finish()</tt>
is the recording of statistics collected during simulation.

<p>All these functions will be discussed later in detail.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec167"/>5.1.4. <FONTteal>Events in OMNeT++</FONT></H3></font>

<p>OMNeT++ uses messages to represent
events. Each event is represented by an instance of the
<tt>cMessage</tt> class or one its subclasses; there is no separate
event class. Messages are sent from one module to another - this
means that the place where the ''event will occur'' is the
<EM>message's destination module</EM>, and the model time when the
event occurs is the <EM>arrival time</EM> of the
message. Events like ''timeout expired'' are implemented with the
module sending a message to itself.

<p>Simulation time in OMNeT++ is stored in the C++ type
<tt>simtime_t</tt>, which is a typedef for <tt>double</tt>.

<p>Events are consumed from the FES in arrival time order, to
maintain causality. More precisely, given two messages, the following
rules apply:
<OL>
<li><strong></strong>the message with <STRONG>earlier arrival time</STRONG> is executed
    first.  If arrival times are equal,
<li><strong></strong>the one with <STRONG>smaller priority value</STRONG> is executed first.
    If priorities are the same,
<li><strong></strong>the one <STRONG>scheduled or sent earlier</STRONG> is executed first.
</OL>

<p><EM>Priority</EM> is a user-assigned integer
attribute of messages.

<p>Storing simulation time in doubles may sometimes cause inconveniences.
Due to finite machine precision, two doubles calculated in two
different ways do not always compare equal even if they mathematically
should be. This means that if you want to explicitly rely on the
arrival times of two events being the same, you should take care that
simulation times which should be equal are calculated in exactly the
same way. Another possible approach is to avoid equal arrival times,
for example by adding/subtracting small values to schedule times to
ensure specific execution order
(<EM>inorder_epsilon</EM>).

<p>
One may suggest introducing a small <EM>simtime_precision</EM> parameter in
the simulation kernel that would force $t_1$ and $t_2$ to be regarded
equal if they are ''very close'' (if they differ
less than <EM>simtime_precision</EM>). However, in addition to the problem
determining the correct value for <EM>simtime_precision</EM>,
this approach is likely to cause confusion in many cases.

<p>

<p><font color="#006f00"><H3><A NAME="sec168"/>5.1.5. <FONTteal>FES implementation</FONT></H3></font>

<p>The implementation of the FES is a crucial factor in the
performance of a discrete event simulator. In OMNeT++, the FES is
implemented with <EM>binary heap</EM>, the most
widely used data structure for this purpose. Heap is also the best
algorithm we know, although exotic data structures like
<EM>skiplist</EM> may perform better than heap in some
cases. In case you're interested, the FES implementation is in the
<tt>cMessageHeap</tt> class, but as a simulation programmer you won't
ever need to care about it.

<p>
<hr><font color="#006f00"><H2><A NAME="sec169"/>5.2. <FONTblue>Defining simple module types</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec170"/>5.2.1. <FONTteal>Overview</FONT></H3></font>

<p>The C++ implementation of a simple module consists of:
<UL>
<li><strong></strong>declaration of the module class: your class subclassed from <tt>cSimpleModule</tt>
(either directly or indirectly)
<li><strong></strong>a module type registration (<tt>Define_Module()</tt> or
    <tt>Define_Module_Like()</tt> macro)
<li><strong></strong>implementation of the module class
</UL>

<p>
For example, the C++ source for a Sliding Window Protocol implementation
might look like this:

<pre>
// file: swp.cc
#include &lt;omnetpp.h&gt;

// module class declaration:
class SlidingWindow : public cSimpleModule
{
    Module_Class_Members(SlidingWindow,cSimpleModule,8192)
    virtual void activity();
};

// module type registration:
Define_Module( SlidingWindow );

// implementation of the module class:
void SlidingWindow::activity()
{
  int window_size = par("window_size");
...
}
</pre>
<p>
In order to be able to refer to this simple module type in NED
files, we should have an associated NED declaration which might
look like this:

<p>
<pre>
// file: swp.ned
<STRONG>simple</STRONG> SlidingWindow
    <STRONG>parameters</STRONG>:
        window_size: <STRONG>numeric const</STRONG>;
    <STRONG>gates</STRONG>:
        <STRONG>in:</STRONG> from_net, from_user;
        <STRONG>out:</STRONG> to_net, to_user;
<STRONG>endsimple</STRONG>
</pre>

<p>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec171"/>5.2.2. <FONTteal>The module declaration</FONT></H3></font>


<p>The module declaration
<UL>
<li><strong></strong>announces that you're going to use the class as a
    simple module type
<li><strong></strong>associates the module class with an interface declared in NED
</UL>

<p><STRONG>Forms of module declaration</STRONG>

<p>
Module declarations can take two forms:

<p><pre>
Define_Module(<EM>classname</EM>);
Define_Module_Like(<EM>classname</EM>, <EM>neddeclname</EM>);
</pre>

<p>The first form associates the class (subclassed from
<tt>cSimpleModule</tt>) with the NED simple
module declaration of the same name. For example, the

<pre>
Define_Module(SlidingWindow);
</pre>
<p>
line would ensure that when you create an instance of SlidingWindow in
your NED files, the module has the parameters and gates given in the
simple SlidingWindow NED declaration, and the implementation will be
an instance of the SlidingWindow C++ class.

<p>
The second form associates the class with a NED
simple module declaration of a different name.
You can use this form when you have several modules which share the
same interface. This feature will be discussed in detail in the next
section.

<p>
<STRONG>Header files</STRONG>

<p>
Module declarations should not be put into header files, because they are macros expanding to lines for which the
compiler generates code.

<p>
<STRONG>Compound modules</STRONG>

<p>All module types (including compound modules)
need to have module declarations. For all
compound modules, the NEDC compiler generates the
<tt>Define_Module(..)</tt> lines automatically.
However, it is your responsibility to put Define_Module(..) lines into
one of the C++ sources for all your simple module types.

<p>
<STRONG>Implementation</STRONG>

<p>
Unless you are dying to learn about the dirty internals, you may just
as well skip this section. But if you're interested, here it is:
<tt>Define_Module()</tt> (and also <tt>Define_Module_Like()</tt>) is a
macro which expands to a function definition plus the definition of a
global object, something like this ugly code (luckily, you won't ever
need to be interested in it):

<p><pre>
static cModule *<EM>MyClass</EM>__create(const char *name, cModule *parentmod)

    return (cModule *) new <EM>MyClass</EM>(name, parentmod);


<p>cModuleType <EM>MyClass</EM>__type("<EM>MyClass</EM>","<EM>MyClass</EM>",
 (ModuleCreateFunc)<EM>MyClass</EM>__create);
</pre>

<p>
The <tt>cModuleType</tt> object can act as a factory: it is able to
create an instance of the given module type. This, together with the
fact that all <tt>cModuleType</tt> objects are available in a single
linked list, allows OMNeT++ to instantiate module types given only
their class names as strings, without having to include the class
declaration into any other C++ source.

<p>
The global object also stores the name of the NED
interface associated with the module class. The
interface description object
(another object, generated by nedc) is looked up automatically at
network construction time. Whenever a module of the given type is
created, it will automatically have the parameters and gates specified
in the associated interface description.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec172"/>5.2.3. <FONTteal>Several modules, single NED interface</FONT></H3></font>

<p>Suppose you have three different C++ module classes (TokenRing_MAC,
Ethernet_MAC, FDDI_MAC) which have identical gates and parameters.
Then you can create a single NED declaration, General_MAC for them
and write the following module declarations in the C++ code:

<pre>
Define_Module_Like(TokenRing_MAC, General_MAC);
Define_Module_Like(Ethernet_MAC, General_MAC);
Define_Module_Like(FDDI_MAC, General_MAC);
</pre>
<p>
In this case, you won't be able to directly refer to the
TokenRing_MAC, Ethernet_MAC, FDDI_MAC module types in your NED
files. For example, you cannot write

<pre>
module PC
    submodules:
        mac: Ethernet_MAC; // error: Ethernet_MAC not defined
...
endmodule
</pre>
<p>

<p>However, you can pass the module type in a string-valued parameter to
the compound module:

<pre>
module PC
    parameters:
        mac_type: string;
    submodules:
        mac: mac_type like General_MAC; // OK!
    ...
endmodule
</pre>
<p>
<p>
The mac_type parameter should take the value ''TokenRing_MAC'',
''Ethernet_MAC'' or ''FDDI_MAC'', and a submodule of the appropriate
type will be created. The value for the parameter can even be given in
the ini file. This gives you a powerful tool to customize simulation
models (see also <EM>Topology templates</EM>, Section
<a href="#sec:ch-ned-lang:topology-templates">[click]</a>).
</p>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec173"/>5.2.4. <FONTteal>The class declaration</FONT></H3></font>

<p>As mentioned before, simple module classes have
to be derived from <tt>cSimpleModule</tt> (either directly or
indirectly). In addition to overwriting some of the previously
mentioned four member functions (<tt>initialize()</tt>,
<tt>activity()</tt>, <tt>handleMessage()</tt>,<tt>finish()</tt>), you
have to write a constructor and some more
functions. Some of this task can be automated, so when writing the C++
class declaration, you have two choices:
<OL>
<li><strong></strong>either use a macro which expands to the ''stock'' version of the
    functions
<li><strong></strong>or write them yourself.
</OL>

<p><STRONG>Using macro to declare the constructor</STRONG>

<p>If you choose the first solution, you use the
<tt>Module_Class_Members()</tt> macro:

<p><pre>
Module_Class_Members( <EM>classname</EM>, <EM>baseclass</EM>, <EM>stacksize</EM>);
</pre>

<p>The first two arguments are obvious (<EM>baseclass</EM> is usually <tt>cSimpleModule</tt>),
but <EM>stacksize</EM> needs some explanation. If you use <tt>activity()</tt>,
the module code runs as a coroutine, so it will need a separate
stack. (This will be discussed in detail later.)

<p>
As an example, the class declaration

<pre>
class SlidingWindow : public cSimpleModule
{
    Module_Class_Members( SlidingWindow,cSimpleModule,8192)
    ...
};
</pre>
<p>

<p>expands to something like this:

<pre>
class SlidingWindow : public cSimpleModule
{
  public:
    SlidingWindow(const char *name, cModule *parentmodule,
        unsigned stacksize = 8192) :
        cSimpleModule(name, parentmodule, stacksize) {}
...
};
</pre>
<p>
<STRONG>Expanded form of the constructor</STRONG>

<p>
You will implement:
<UL>
<li><strong></strong>a constructor with the argument list: (const
    char *name, cModule *parentmodule, unsigned stacksize =
    <EM>stacksize</EM>)
</UL>

<p>The advantage is that you get full control over the constructor,
so you can initialize data members of the class (if you have
any). You should not change the number or types of the arguments
taken by the constructor, because it is called by OMNeT++-generated
code.

<p>
An example:

<pre>
class TokenRing_MAC : public cSimpleModule
{
  public:
    cQueue queue; // a data member
    TokenRing_MAC(const char *name, cModule *parentmodule,
                 unsigned stacksize = 8192);
    ...
};

TokenRing_MAC(const char *name, cModule *parentmodule,
    unsigned stacksize) :
    cSimpleModule(name, parentmodule, stacksize), queue("queue")
{
  // initialize data members
}
</pre>
<p>

<p><STRONG>Stack size decides between activity() and handleMessage()</STRONG>

<p><UL>
<li><strong></strong>if the specified stack size is zero, <tt>handleMessage()</tt> will be used;
<li><strong></strong>if it is greater than zero, <tt>activity()</tt> will be used.
</UL>

<p>If you make a mistake (e.g. you forget to set zero stack size
 for a <tt>handleMessage()</tt>
simple module): the default versions of the
functions issue error messages telling you what is the problem.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec174"/>5.2.5. <FONTteal>Decomposing activity()/handleMessage() and inheritance</FONT></H3></font>

<p>It is usually a good idea to decompose a <tt>activity()</tt> or
<tt>handleMessage()</tt> function when it grows too large. ''Too
large'' is a matter of taste of course, but you should definitely
consider splitting up the function if it is more that a few screens
(say 50-100 lines) long. This will have a couple of advantages:
<UL>
<li><strong></strong>will help future readers of the code understand your program;
<li><strong></strong>will help <EM>you</EM> understand what it is you're really programming
and bring some structure into it;
<li><strong></strong>will enable you to customize the class by inheriting from it and
    overwriting member functions
</UL>

<p>If you have variables which you want to access from all member
functions (typically state variables are like that), you'll need to
add those variables to the class as data members.

<p>Let's see an example:

<pre>
class TransportProtocol : public cSimpleModule
{
  public:
    Module_Class_Members(TransportProtocol, cSimpleModule, 8192)
    int window_size;
    int n_s; // N(s)
    int n_r; // N(r)
    cOutVector eedVector;
    cStdDev eedStats;
    //...

    virtual void activity();
    virtual void recalculateTimeout();
    virtual void insertPacketIntoBuffer(cMessage *packet);
    virtual void resendPacket(cMessage *packet);
    //...
};

Define_Module( TransportProtocol );

void TransportProtocol::activity()
{
    window_size = par("window_size");
    n_s = n_r = 0;
    eedVector.setName(''End-to-End Delay'');
    eedStats.setName(''eedStats'');
    //...
}

//...
</pre>
<p>
<p>
  Note that you may have to use the expanded form of the
  constructor (instead of
  <tt>Module_Class_Members()</tt>) to pass arguments to the constructors
  of member objects like eedVector and eedStats. But most often you
  don't need to go as far as that; for example, you can set parameters
  later from <tt>activity()</tt>, as shown in the example above.
</p>

<p>To implement another variant of the Transport Protocol which uses a
different timeout scheme, you could simply subclass TransportProtocol:

<pre>
class AdvancedTransportProtocol : public TransportProtocol
{
  public:
    Module_Class_Members(AdvancedTransportProtocol, TransportProtocol,
                      8192)
    virtual void recalculateTimeout();
};

Define_Module( AdvancedTransportProtocol );

void AdvancedTransportProtocol::recalculateTimeout()
{
    //...
}
</pre>
<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec175"/>5.3. <FONTblue>Adding functionality to cSimpleModule</FONT></H2></font></hr>

<p>This section discusses <tt>cSimpleModule</tt>'s four previously
mentioned member functions, intended to be redefined by the user:
<tt>initialize()</tt>, <tt>activity()</tt>, <tt>handleMessage()</tt> and
<tt>finish()</tt>.

<p>
<font color="#006f00"><H3><A NAME="sec176"/>5.3.1. <FONTteal>activity()</FONT></H3></font>

<p><STRONG>Process-style description</STRONG>

<p>With <tt>activity()</tt>, you can code the simple
module much like you would code an operating system process or a
thread. You can wait for an incoming message (event) at any point of
the code, you can suspend the execution for some time (model time!),
etc. When the <tt>activity()</tt> function exits, the module is
terminated.  (The simulation can continue if there are other modules
which can run.)

<p>
The most important functions you can use in <tt>activity()</tt> are
(they will be discussed in detail later):
<UL>
<li><strong>\fname[receive()]</strong>receive..() family of functions - to receive messages (events)
<li><strong></strong><tt>wait()</tt> - to suspend execution
    for some time (model time)
<li><strong></strong><tt>send()</tt> family of functions - to send messages to other
    modules
<li><strong></strong><tt>scheduleAt()</tt> - to schedule an event (the module ''sends
    a message to itself'')
<li><strong></strong><tt>cancelEvent()</tt> - to delete an event scheduled with
    scheduleAt()
<li><strong></strong><tt>end()</tt> - to finish execution of this module (same as
    exiting the <tt>activity()</tt> function)
</UL>

<p>The <tt>activity()</tt> function normally contains an infinite loop,
with at least a <tt>wait()</tt> or <tt>receive()</tt> call in its body.

<p>

<p><STRONG>Application area</STRONG>

<p>
One area where the process-style description is especially convenient is when the process has many
states but transitions are very limited, ie. from any state the
process can only go to one or two other states.  For example, this is
the case when programming a network application which uses a single
network connection.  The pseudocode of the application which talks to
a transport layer protocol might look like this:

<p><pre>
<EM>activity()</EM>
{
    while(true)
    {
        open connection by sending OPEN command to transport layer
        receive reply from transport layer
        if (open not successful)
        {
            wait(some time)
            continue // loop back to while()
        }

<p>        while(there's more to do)
        {
            send data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
            receive data on network connection
            if (connection broken)
            {
                continue outer loop // loop back to outer while()
            }
            wait(some time)
        }
        close connection by sending CLOSE command to transport layer
        if (close not successful)
        {
            // handle error
        }
        wait(some time)
    }
}
</pre>

<p>

<p>If you want to handle several connections simultaneously, you may
dynamically create as instances of the simple
module above as needed. Dynamic module creation will be discussed
later.

<p>
<STRONG>Activity() is run as a coroutine</STRONG>

<p>
<tt>Activity()</tt> is run in a coroutine.
Coroutines are a sort of threads which are scheduled
non-preemptively (this is also called cooperative
multitasking). From one coroutine you
can switch to another coroutine by a
<tt>transferTo(otherCoroutine)</tt> call. Then this
coroutine is suspended and <EM>otherCoroutine</EM> will run. Later,
when <EM>otherCoroutine</EM> does a
<tt>transferTo(firstCoroutine)</tt> call, execution of
the first coroutine will resume from the point of the
<tt>transferTo(otherCoroutine)</tt> call.  The full state
of the coroutine, including local variables are preserved while the
thread of execution is in another coroutines.  This implies that each
coroutine must have an own processor stack, and
<tt>transferTo()</tt> involves a switch from one processor stack to
another.

<p>
Coroutines\indexcoroutine are at the heart of OMNeT++, and the
simulation programmer doesn't ever need to call <tt>transferTo()</tt>
or other functions in the coroutine library, nor does he need to care
about the coroutine library implementation. But it is important to
understand how the event loop found in discrete event simulators works
with coroutines.

<p>
When using coroutines, the event loop looks like
this (simplified):

<p>
<pre>
<EM>while (FES not empty and simulation not yet complete)</EM>
{
    retrieve first event from FES
    t:= timestamp of this event
    <STRONG>transferTo(module containing the event)</STRONG>
}
</pre>

<p>

<p>That is, when the module has an event, the simulation
kernel transfers the control to the module's coroutine. It is expected
that when the module ''decides it has finished the processing of the
event'', it will transfer the control back to the simulation kernel by
a <tt>transferTo(main)</tt> call. Initially,
simple modules using <tt>activity()</tt> are
''booted'' by events (<EM>''starter messages''</EM>)
inserted into the FES by the simulation kernel before the
start of the simulation.

<p>
How does the coroutine know it has ''finished processing the event''?
The answer: <EM>when it requests another event</EM>.  The functions
which request events from the simulation kernel are the
<tt>receive..()</tt> family and <tt>wait()</tt>, so their
implementations contain a <tt>transferTo(main)</tt> call
somewhere.

<p>
Their pseudocode, as implemented in OMNeT++:

<p>
<pre>
<EM>receiveNew() // other receive...() variations are similar</EM>
{
    transferTo(main)
    retrieve current event
    return the event // remember: events = messages
}

<p>wait()
{
    create an event e and schedule it at (current sim. time +
                                          wait interval)
    while(true) {
        transferTo(main)
        retrieve current event
        if (current event is e)
            break from loop
        else
            store current event for later use (in the "put-aside queue")
    }
    delete event e
    return
}
</pre>

<p>

<p>Thus, the <tt>receive...()</tt> and <tt>wait()</tt> calls are
special points in the <tt>activity()</tt> function, because that's
where:
<UL>
<li><strong></strong>simulation time elapses in the module, and
<li><strong></strong>other modules get a chance to execute.
</UL>

<p>
<STRONG>Starter messages</STRONG>

<p>
Modules written with <tt>activity()</tt> need starter
messages to ''boot''.  These starter messages
are inserted into the FES\indexFES automatically by OMNeT++ at the
beginning of the simulation, even before the <tt>initialize()</tt>
functions are called.

<p>
<STRONG>Coroutine stack size</STRONG>

<p>
All the simulation programmer needs to care about coroutines is to
choose the processor stack size for them.
This cannot be automated (Eerrr... at least not without hardware
support, some trick with virtual memory handling).

<p>
8 or 16 kbytes is usually a good choice, but you may need more if the
module uses recursive functions or has local variables which occupy a
lot of stack space. OMNeT++ has a built-mechanism that will usually
detect if the module stack is too small and
overflows\indexstack!overflow. OMNeT++ can also tell you how much
stack space a module actually uses, so you can find
it out if you overestimated the stack needs.

<p>
<STRONG>initialize() and finish() with activity()</STRONG>

<p>
Because local variables of <tt>activity()</tt> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of the
<tt>activity()</tt> function, so there isn't much need to use
<tt>initialize()</tt>.

<p>
However, you need <tt>finish()</tt> if you want to write statistics at
the end of the simulation. And because <tt>finish()</tt> cannot access
the local variables of <tt>activity()</tt>, you have to put the variables
and objects that contain the statistics into the module class.
You still don't need <tt>initialize()</tt> because class members can also
be initialized at the top of <tt>activity()</tt>.

<p>
Thus, a typical setup looks like this pseudocode:

<p>
<pre>
<EM>class MySimpleModule...</EM>
{
    ...
    variables for statistics collection
    activity();
    finish();
};

<p>MySimpleModule::activity()
{
    declare local vars and initialize them
    initialize statistics collection variables

<p>    while(true)
    {
        ...
    }
}

<p>MySimpleModule::finish()
{
    record statistics into file
}
</pre>

<p>

<p><STRONG>Advantages and drawbacks</STRONG>

<p>Advantages:
<UL>
<li><strong></strong><tt>initialize()</tt> not needed, state can be stored in local
    variables of <tt>activity()</tt>
<li><strong></strong>process-style description is a natural programming model in many
    cases
</UL>

<p>Drawbacks:
<UL>
<li><strong></strong>memory overhead: stack allocation may unacceptably increase the
    memory requirements of the simulation program if you have several
    thousands or ten thousands of simple modules;
<li><strong></strong>run-time overhead: switching between coroutines is somewhat slower
    than a simple function call
</UL>

<p>
<STRONG>Other simulators</STRONG>

<p>
Coroutines are used by a number of other simulation packages:
<UL>
<li><strong></strong>All simulation software which inherit from SIMULA (e.g. C++SIM)
    are based on coroutines, although all in all the programming
    model is quite different.
<li><strong></strong>The simulation/parallel programming language Maisie and its successor
    PARSEC (from UCLA) also use coroutines (although implemented
    on with ''normal'' preemptive threads). The philosophy
    is quite similar to OMNeT++. PARSEC, being ''just''
    a programming language, has a more elegant syntax but much less
    features than OMNeT++.
<li><strong></strong>Many Java-based simulation libraries are based on Java
    threads.
</UL>

<p>

<p><font color="#006f00"><H3><A NAME="sec177"/>5.3.2. <FONTteal>handleMessage()</FONT></H3></font>

<p><STRONG>Function called for each event</STRONG>

<p>
The idea is that at each event we simply call a
user-defined function instead of switching to a coroutine that has
<tt>activity()</tt> running in it. The ''user-defined function'' is the
<tt>handleMessage(cMessage *msg)</tt> virtual member
function of <tt>cSimpleModule</tt>; the user has to redefine the
function to make it do useful work.  Calls to <tt>handleMessage()</tt>
occur in the main stack of the program - no coroutine stack is needed
and no context switch is done.

<p>
The <tt>handleMessage()</tt> function will be called for every message
that arrives at the module. The function should process the message
and return immediately after that. The simulation time is potentially
different in each call. No simulation time elapses within a call
to <tt>handleMessage()</tt>.

<p>
The pseudocode of the event loop which is able to handle both <tt>activity()</tt>
and <tt>handleMessage()</tt> simple modules:

<p>
<pre>
<EM>while (FES not empty and simulation not yet complete)</EM>
{
    retrieve first event from FES
    t:= timestamp of this event
    m:= module containing this event
    if (m works with handleMessage())
        <STRONG>m-&gt;handleMessage( event )</STRONG>
    else // m works with activity()
    transferTo( m )
}
</pre>

<p>
Modules with <tt>handleMessage()</tt> are NOT started automatically:
the simulation kernel creates starter messages
only for modules with <tt>activity()</tt>. This means that you have to
schedule self-messages from the
<tt>initialize()</tt> function if you want the <tt>handleMessage()</tt>
simple module to start working ''by itself'', without first receiving
a message from other modules.

<p>
<STRONG>Programming with handleMessage()</STRONG>

<p>
To use the <tt>handleMessage()</tt> mechanism in a
simple module, you must specify <EM>zero
  stack size</EM> for the module. This is
important, because this tells OMNeT++ that you want to use
<tt>handleMessage()</tt> and not <tt>activity()</tt>.

<p>Message/event related functions you can use in <tt>handleMessage()</tt>:
<UL>
<li><strong></strong><tt>send()</tt> family of functions - to send messages to other modules
<li><strong></strong><tt>scheduleAt()</tt> - to schedule an event (the module ''sends
a message to itself'')
<li><strong></strong><tt>cancelEvent()</tt> - to delete an event scheduled with <tt>scheduleAt()</tt>
</UL>

<p>You cannot use the <tt>receive...()</tt> family and
<tt>wait()</tt> functions in <tt>handleMessage()</tt>, because they are
coroutine-based by nature, as explained in the section about
<tt>activity()</tt>. You also cannot use <tt>end()</tt> because its job
is to terminate the coroutine.

<p>
You have to add data members to the module class for every piece
of information you want to preserve. This information cannot
be stored in local variables of <tt>handleMessage()</tt> because they
are destroyed when the function returns. Also, they cannot be
stored in static variables in the function (or the class), because
they would be shared between all instances of the class.

<p>
Data members to be added to the module class will typically include
things like:
<UL>
<li><strong></strong>state (e.g. IDLE/BUSY, CONN_DOWN/CONN_ALIVE/...)
<li><strong></strong>other variables which belong to the state of the module: retry
    counts, packet queues, etc.
<li><strong></strong>values retrieved/computed once and then stored: values of module
    parameters, gate indices, routing information, etc.
<li><strong></strong>pointers of message objects created once and then reused for
    timers, timeouts, etc.
<li><strong></strong>variables/objects for statistics collection
</UL>

<p>You can initialize these variables from the <tt>initialize()</tt>
function.  The constructor is not a very good place
for this purpose because it is called in the network setup phase when
the model is still under construction, so a lot of information you may
want to use is not yet available then.

<p>
Another task you have to do in <tt>initialize()</tt> is to schedule
initial event(s) which trigger the first call(s)
to <tt>handleMessage()</tt>.  After the first call,
<tt>handleMessage()</tt> must take care to schedule further events for
itself so that the ''chain'' is not broken. Scheduling events is not
necessary if your module only has to react to messages coming from
other modules.

<p>
<tt>finish()</tt> is used in the normal way: to record statistics information
accumulated in data members of the class at the end of the simulation.

<p>
<STRONG>Application area</STRONG>

<p>
There are two areas where <tt>handleMessage()</tt> is definitely a better
choice than <tt>activity()</tt>:
<OL>
<li><strong></strong>For modules which have to maintain little or no state information,
    such as packet sinks.
<li><strong></strong>Other good candidates are modules with a large state space and
    many arbitrary state transition possibilities (i.e. where there
    are many possible subsequent states for any state). Such algorithms
    are difficult to program with <tt>activity()</tt>, or the result is code
    which is better suited for <tt>handleMessage()</tt> (see rule of thumb
    below). Most communication protocols are like this.
</OL>

<p>There's also a good rule of thumb. If your module, programmed
with <tt>activity()</tt>, looks like this:

<p><pre>
<EM>activity()</EM>
{
    initialization code
    while(true)
    {
        msg = receive();
        // arbitrary code which doesn't contain any receive()
        // or wait() calls
    }
}
</pre>

<p>Then it can be trivially converted to <tt>handleMessage()</tt>:

<p><pre>
<EM>initialize()</EM>
{
    initialization code
}

<p>handleMessage( msg )
{
    // arbitrary code which doesn't contain any receive()
    // or wait() calls
}
</pre>

<p>

<p><STRONG>Example 1: Simple traffic generators and sinks</STRONG>

<p>
The code for simple packet generators and sinks programmed with <tt>handleMessage()</tt> might
be as simple as this:

<p><pre>
PacketGenerator::handleMessage(m)
{
    create and send out packet
    schedule m again to trigger next call to handleMessage
      // (self-message)
}
PacketSink::handleMessage(m)
{
    delete m
}
</pre>

<p>

<p>Note that <EM>PacketGenerator</EM> will need to redefine <tt>initialize()</tt>
to create <EM>m</EM> and schedule the first event.

<p>The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been
discussed yet, but the code is probably understandable nevertheless.)

<p>
<pre>
class Generator : public cSimpleModule
{
    Module_Class_Members(Generator,cSimpleModule,0)
    // note zero stack size!
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

<p>Define_Module( Generator );

<p>void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new cMessage);
}

<p>void Generator::handleMessage(cMessage *msg)
{
    // generate & send packet
    cMessage *pkt = new cMessage;
    send(pkt, ''out'');
    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</pre>

<p>

<p><STRONG>Example 2: Bursty traffic generator</STRONG>

<p>
A bit more realistic example is to rewrite our Generator to create
packet bursts, each consisting of burst_length packets.

<p>
We add some data members to the class:
<UL>
<li><strong></strong>burst_length will store the parameter that specifies how many
    packets a burst must contain,
<li><strong></strong>burst_ctr will count in how many packets are left to be sent
    in the current burst.
</UL>

<p>The code:

<p>
<pre>
class BurstyGenerator : public cSimpleModule
{
    Module_Class_Members(Generator,cSimpleModule,0)
    // note the zero stack size!
    int burst_length;
    int burst_ctr;
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

<p>Define_Module( BurstyGenerator );
void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burst_length = par("burst_length");
    burst_ctr = burst_length;
    // schedule first packet of first burst
    scheduleAt(simTime(), new cMessage);
}

<p>void BurstyGenerator::handleMessage(cMessage *msg)
{
    // generate & send packet
    cMessage *pkt = new cMessage;
    send(pkt, ''out'');
    // if this was the last packet of the burst
    if (-burst_ctr == 0)
    {
        // schedule next burst
        burst_ctr = burst_length;
        scheduleAt(simTime()+exponential(5.0), msg);
    }
    else
    {
        // schedule next sending within burst
        scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</pre>

<p>

<p><STRONG>Advantages and drawbacks</STRONG>

<p>
Advantages:
<UL>
<li><strong></strong>consumes less memory: no separate stack needed for
    simple modules
<li><strong></strong>fast: function call is faster than switching between coroutines
</UL>

<p>
Drawbacks:
<UL>
<li><strong></strong>local variables cannot be used to store state information
<li><strong></strong>need to redefine <tt>initialize()</tt>
<li><strong></strong>programming model is inconvenient in some cases
</UL>

<p><STRONG>Other simulators</STRONG>

<p>
Many simulation packages use a similar approach, often topped with
something like a state machine
(FSM) which hides the underlying function calls. Such
systems are:
<UL>
  <li><strong></strong>OPNET<sup>(TM)</sup> (MIL3, Inc.) which uses FSM's designed using a graphical editor;
  <li><strong></strong>NetSim++ clones OPNET's approach;
  <li><strong></strong>SMURPH (University of Alberta) defines a (somewhat eclectic)
      language to describe FSMs, and uses a precompiler to turn it
      into C++ code;
  <li><strong></strong>Ptolemy (UC Berkeley) uses a similar method.
</UL>

<p>OMNeT++'s FSM support is described in the next section.

<p>

<p><font color="#006f00"><H3><A NAME="sec178"/>5.3.3. <FONTteal>initialize() and finish()</FONT></H3></font>

<p><STRONG>Purpose</STRONG>

<p>
<tt>initialize()</tt> - to provide place for any user setup code

<p><tt>finish()</tt> - to provide place where the user can record statistics
after the simulation has completed

<p>
<STRONG>When and how they are called</STRONG>

<p>
The <tt>initialize()</tt> functions of the modules are invoked
<EM>before</EM> the first event is processed, but <EM>after</EM> the
initial events (starter messages) have been
placed into the FES by the simulation kernel.

<p>
Both simple and compound modules have <tt>initialize()</tt> functions.
A compound module has its <tt>initialize()</tt> function called
<EM>before</EM> all its submodules have.

<p>
The <tt>finish()</tt> functions are called when the event
loop has terminated, and only if it terminated
normally (i.e. not with a runtime error).  The calling order is the
reverse as with <tt>initialize()</tt>: first submodules, then the
containing compound module. (The bottom line is that in the moment
there's no ''official'' possibility to redefine <tt>initialize()</tt>
and <tt>finish()</tt> for compound modules; the unofficial way is to
write into the nedc-generated C++ code. Future versions of OMNeT++ will
support adding these functions to compound
modules.)

<p>This is summarized in the following pseudocode (although you
won't find this code ''as is'' in the simulation
kernel sources):

<p>
<pre>
<EM>perform simulation run:</EM>
    build network
      (i.e. the system module and its submodules recursively)
    insert starter messages for all submodules using activity()
    do callInitialize() on system module
        <EM>enter event loop // (described earlier)</EM>
    if (event loop terminated normally) // i.e. not with a runtime
error
        do callFinish() on system module
    clean up
callInitialize()
{
    call to user-defined initialize() function
    if (module is compound)
        for (each submodule)
            do callInitialize() on submodule
}
callFinish()
{
    if (module is compound)
        for (each submodule)
            do callFinish() on submodule
    call to user-defined finish() function
}
</pre>

<p>

<p><STRONG>initialize() vs. constructor</STRONG>

<p>
Usually you should not put simulation-related code into the
simple module constructor. For
example, modules often need to investigate their surroundings (maybe
the whole network) at the beginning of the simulation and save the
collected info into internal tables.  Code like that cannot be placed
into the constructor since the network is still being set up when the
constructor is called.

<p>
<STRONG>finish() vs. destructor</STRONG>

<p>
Keep in mind that <tt>finish()</tt> is not always called, so it isn't a
good place for cleanup code which should run every time the module is
deleted. <tt>finish()</tt> is only a good place for writing statistics,
result post-processing and other stuff which are to run only on
successful completion.

<p>Cleanup code should go into the destructor. But in
fact, you almost never need to write a destructor because OMNeT++
keeps track of objects you create and disposes of them automatically
(sort of automatic garbage collection). However it cannot track
objects not derived from <tt>cObject</tt> (see later), so they may
need to be deleted manually from the destructor.

<p>
<STRONG>Multi-stage initialization</STRONG>

<p>
In simulation models, when one-stage
initialization provided by <tt>initialize()</tt>
is not sufficient, one can use multi-stage
initialization.  Modules have two
functions which can be redefined by the user:

<pre>
void initialize(int stage);

int numInitStages() const;
</pre>
<p>
At the beginning of the simulation, <tt>initialize(0)</tt>
is called for all modules, then <tt>initialize(1)</tt>,
<tt>initialize(2)</tt>, etc. For each module,
<tt>numInitStages()</tt> must be redefined to return the number of init
stages required, e.g. for a two-stage init, <tt>numInitStages()</tt>
should return 2, and initialize(int stage) must be implemented to
handle the stage=0 and stage=1 cases.

<p>
The <tt>callInitialize()</tt> function performs the full multi-stage initialization
for that module and all its submodules.

<p>If you do not redefine the multi-stage initialization functions, the
default behavior is single-stage initialization: the default
<tt>numInitStages()</tt> returns 1, and the default \fname[initialize]initialize(int
stage) simply calls <tt>initialize()</tt>.

<p>
<STRONG>''end-of-simulation event''</STRONG>

<p>
The task of <tt>finish()</tt> is solved in many simulators (e.g. OPNET)
by introducing a special
<EM>end-of-simulation</EM> event. This is not
a very good practice because the simulation programmer has to code the
algorithms (often FSMs) so that they can <EM>always</EM> properly
respond to end-of-simulation events, in whichever state they are. This
often makes program code unnecessarily complicated.

<p>This fact is also evidenced in the design of the PARSEC
simulation language (UCLA). Its predecessor Maisie used
end-of-simulation events, but - as documented in the PARSEC manual -
this has led to awkward programming in many cases, so for PARSEC,
end-of-simulation events were dropped in favour of <tt>finish()</tt>
(called <tt>finalize()</tt> in PARSEC).

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec179"/>5.4. <FONTblue>Finite State Machines in OMNeT++</FONT></H2></font></hr>

<p><STRONG>Overview</STRONG>

<p>
Finite State Machines (FSMs)
can make life with <tt>handleMessage()</tt> easier. OMNeT++ provides a
class and a set of macros to build FSMs. OMNeT++'s FSMs work very much
like OPNET's or SDL's.

<p>
The key points are:
<UL>
<li><strong></strong>There are two kinds of states:
    <EM>transient</EM> and
    <EM>steady</EM>. At each event (that is, at
    each call to <tt>handleMessage()</tt>), the FSM transitions out of
    the current (<EM>steady</EM>) state, undergoes a series of state
    changes (runs through a number of <EM>transient</EM> states), and
    finally arrives at another <EM>steady</EM> state. Thus between two
    events, the system is always in one of the steady states.
    Transient states are therefore not really a must - they exist
    only to group actions to be taken during a transition in a
    convenient way.
<li><strong></strong>You can assign program code to entering and leaving a state
    (known as entry/exit code).
    Staying in the same state is handled as leaving and re-entering
    the state.
<li><strong></strong>Entry code should not modify the state (this is verified by
    OMNeT++).  State changes (transitions) must be put into the exit
    code.
</UL>

<p>OMNeT++'s FSMs <EM>can</EM> be nested. This means
that any state (or rather, its entry or exit code) may contain a
further full-fledged <tt>FSM_Switch()</tt> (see below). This allows you
to introduce sub-states and thereby bring some structure into the
state space if it would become too large.

<p>
<STRONG>The FSM API</STRONG>

<p>
FSM state is stored in an object of type <tt>cFSM</tt>. The possible states
are defined by an enum; the enum is also a place to tell which
state is transient and which is steady. In the following example, SLEEP
and ACTIVE are steady states and SEND is transient (the numbers
in parens must be unique within the state type and they are used
for constructing the numeric IDs for the states):

<pre>
enum {
  INIT = 0,
  SLEEP = FSM_Steady(1),
  ACTIVE = FSM_Steady(2),
  SEND = FSM_Transient(1),
};
</pre>
<p>

<p>
The actual FSM is embedded in a switch-like statement,
<tt>FSM_Switch()</tt>, where you have cases for entering and leaving
each state:

<p>
<pre>
FSM_Switch(fsm)
{
  case FSM_Exit(<EM>state1</EM>):
    //...
  break;
  case FSM_Enter(<EM>state1</EM>):
    //...
  break;
  case FSM_Exit(<EM>state2</EM>):
    //...
  break;
  case FSM_Enter(<EM>state2</EM>):
    //...
  break;
    //...
};
</pre>

<p>
State transitions are done via calls to
<tt>FSM_Goto()</tt>, which simply stores the new state in the
<tt>cFSM</tt> object:

<p><pre>
FSM_Goto(fsm,<EM>newState</EM>);
</pre>

<p>The FSM starts from the state with the numeric code 0; this state
is conventionally named INIT.

<p>
<STRONG>Debugging FSMs</STRONG>

<p>
If you <tt>#define FSM_DEBUG</tt> before including
omnetpp.h, each state transition will be logged to ev:

<p>
<pre>
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;
</pre>

<p>

<p>The actual printing is done through the <tt>FSM_Print()</tt> macro. You
might redefine it if you don't like what it currently does:

<p>
<pre>
#define FSM_Print(fsm,exiting)
  (ev &lt;&lt; "FSM " &lt;&lt; (fsm).name()
      &lt;&lt; ((exiting) ? ": exiting " : ": entering ")
      &lt;&lt; (fsm).stateName() &lt;&lt; endl)
</pre>

<p>
<STRONG>Implementation</STRONG>

<p>
The <tt>FSM_Switch()</tt> is a macro. It expands to a <tt>switch()</tt>
statement embedded in a <tt>for()</tt> loop which repeats until the
FSM reaches a steady state. (The actual code is rather
ugly, but if you're dying to see it, it's in <SAMP>cfsm.h</SAMP>.)

<p>Infinite loops are avoided by counting state transitions: if
an FSM goes through 64 transitions without reaching a steady
state, the simulation will terminate with an error message.

<p>
<STRONG>An example</STRONG>

<p>
Let us write another flavour of a bursty generator. It has two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the fifo2 sample
simulation.

<p>
<pre>
#define FSM_DEBUG
#include &lt;omnetpp.h&gt;

<p>class BurstyGenerator : public cSimpleModule
{
 public:
  Module_Class_Members(BurstyGenerator,cSimpleModule,0);

<p>  // parameters
  double sleepTimeMean;
  double burstTimeMean;
  double sendIATime;
  cPar *msgLength;

<p>  // FSM and its states
  cFSM fsm;
  enum {
    INIT = 0,
    SLEEP = FSM_Steady(1),
    ACTIVE = FSM_Steady(2),
    SEND = FSM_Transient(1),
  };

<p>  // variables used
  int i;
  cMessage *startStopBurst;
  cMessage *sendMessage;

<p>  // the virtual functions
  virtual void initialize();
  virtual void handleMessage(cMessage *msg);
};

<p>Define_Module( BurstyGenerator );

<p>void BurstyGenerator::initialize()
{
  fsm.setName("fsm");
  sleepTimeMean = par("sleep_time_mean");
  burstTimeMean = par("burst_time_mean");
  sendIATime = par("send_ia_time");
  msgLength = &par("msg_length");
  i = 0;
  WATCH(i); // always put watches in initialize()
  startStopBurst = new cMessage("startStopBurst");
  sendMessage = new cMessage("sendMessage");
  scheduleAt(0.0,startStopBurst);
}

<p>void BurstyGenerator::handleMessage(cMessage *msg)
{
  FSM_Switch(fsm)
 {
    case FSM_Exit(INIT):
      // transition to SLEEP state
      FSM_Goto(fsm,SLEEP);
      break;
    case FSM_Enter(SLEEP):
      // schedule end of sleep period (start of next burst)
      scheduleAt(simTime()+exponential(sleepTimeMean),
                 startStopBurst);
    break;
    case FSM_Exit(SLEEP):
      // schedule end of this burst
      scheduleAt(simTime()+exponential(burstTimeMean),
                 startStopBurst);
      // transition to ACTIVE state:
      if (msg!=startStopBurst) {
        error("invalid event in state ACTIVE");
      }
      FSM_Goto(fsm,ACTIVE);
      break;
    case FSM_Enter(ACTIVE):
      // schedule next sending
      scheduleAt(simTime()+exponential(sendIATime), sendMessage);
    break;
    case FSM_Exit(ACTIVE):
      // transition to either SEND or SLEEP
      if (msg==sendMessage) {
        FSM_Goto(fsm,SEND);
      } else if (msg==startStopBurst) {
        cancelEvent(sendMessage);
        FSM_Goto(fsm,SLEEP);
      } else {
        error("invalid event in state ACTIVE");
      }
      break;
    case FSM_Exit(SEND):
    {
      // generate and send out job
      char msgname[32];
      sprintf( msgname, "job-0", ++i);
      ev &lt;&lt; "Generating " &lt;&lt; msgname &lt;&lt; endl;
      cMessage *job = new cMessage(msgname);
      job-&gt;setLength( (long) *msgLength );
      job-&gt;setTimestamp();
      send( job, "out" );
      // return to ACTIVE
      FSM_Goto(fsm,ACTIVE);
      break;
    }
  }
}
</pre>

<p>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec180"/>5.5. <FONTblue>Message transmission modeling</FONT></H2></font></hr>

<p><STRONG>Data rate modeling</STRONG>

<p>
If data rate is specified for a connection, a message
will have a certain nonzero transmission time, depending on its length.  This means that when a message is
sent out through an output gate, the message ''reserves'' the gate for
a given period (''it is being transmitted'').

<p>
  <DIV ALIGN=center>
    <img src="usmanFig9.gif">
    <center><i>Figure: Connection with a data rate</i></center>
    <a name="fig:ch-simple-modules:conn-w-data-rate"/>
  </DIV>

<p>
While a message is under transmission, other messages have to wait
until the transmission finishes. You can still use <tt>send()</tt>
while the gate is busy, but the message's arrival will be delayed;
just like the gate had an internal queue for the messages waiting to
be transmitted.

<p>
The OMNeT++ class library provides you with functions to check
whether a certain output gate is transmitting or to learn when
it finishes transmission.

<p>
If the connection with a data rate is not the immediate one connected
to the simple module's output gate but the second
one in the route, you have to check the second gate's busy
condition.

<p>
<STRONG>Implementation of message sending</STRONG>

<p>
Message sending is implemented in the following way: the arrival
time and the bit error flag of a
message are calculated at once, when the <tt>send()</tt> (or similar)
function is invoked. That is, if the message travels through several
links until it reaches its destination, it is <EM>not</EM> scheduled
individually for each link, but rather, every calculation is done
once, within the <tt>send()</tt> call. This implementation was chosen
because of its run-time efficiency.

<p>In the actual implementation of queuing the messages at busy gates and
modeling the transmission delay, messages do not actually queue up in
gates; gates do not have internal queues. Instead, as the time when
each gate will finish transmission is known at the time of sending the
message, the arrival time of the message can be
calculated in advance. Then the message will be stored in the event
queue (FES) until the simulation time advances to its
arrival time and it is retrieved by its destination module.



<p><STRONG>Consequence</STRONG>

<p>
The implementation has the following consequence. If you change the
delay (or the bit error rate, or the data rate) of a link during simulation, the modeling of messages sent ''just
before'' the parameter change will not be accurate. Namely, if link
parameters change while a message is ''under way'' in the model, that
message will not be affected by the parameter change, although it
should. However, all subsequent messages will be modelled correctly.
Similar for data rate: if a data rate changes during the simulation,
the change will affect only the messages that are <EM>sent</EM> after
the change.

<p>If it is important to model gates and channels with changing
properties, you can go two ways:
<UL>
  <li><strong></strong>write sender module such that they schedule events for when the
    gate finishes its current transmission and send then;
  <li><strong></strong>alternatively, you can implement channels with
    simple modules (``active channels'').
</UL>

<p><STRONG>The approach of some other simulators</STRONG>

<p>
Note that some simulators (e.g. OPNET) assign <EM>packet queues</EM>
to input gates (ports), and messages sent are buffered at the
destination module (or the remote end of the link) until received by
the destination module. With that approach, events and messages are
separate entities, that is, a <EM>send</EM> operation includes placing
the message in the packet queue <EM>and</EM> scheduling an event which
will signal the arrival of the packet. In some implementations, also
output gates have packet queues where packets wait until the channel
becomes free (available for transmission).

<p>OMNeT++ gates don't have associated queues. The place
where the sent but not yet received messages are buffered is the
<EM>FES</EM>\indexFES.  OMNeT++'s approach is potentially faster
than the above mentioned solution because it doesn't have the
enqueue/dequeue overhead and also spares an event creation. The
drawback is, as mentioned above, that changes to channel parameters do
not take effect immediately.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec181"/>5.6. <FONTblue>Coding conventions</FONT></H2></font></hr>

<p>Here's a bunch of advice on how to write OMNeT++ models. Some
of them are ``rules of thumb'', saying if you program like that,
you're likely to have less trouble; other conventions are aimed
at making the models produced by the OMNeT++ community more consistent.

<p>
Conventions for writing simple modules:

<OL>
<li><strong></strong>Put the NED description, the C++ class declaration and the
    implementation into three separate files. Do not put two or more
    modules' code into the same file unless they are build upon one
    another - don't be afraid of small files! Thus, for a
    simple module called Foobar, you should have
    Foobar.ned, Foobar.h and Foobar.cc. This reduces coupling of
    module sources and makes your code more reusable.
<li><strong></strong>Adopt a good coding style. Some hints: Choose your favourite
    indentation style and keep to that consistently. I recommend
    four-space indents and the brace placement style in which the
    OMNeT++ sources are written. Write only one statement per line.
    Avoid putting comments at the end of the line - place them
    <EM>above</EM> the code on a separate line instead! Use blank
    lines to break the code into not-very-long logical blocks, and put
    a few-word comment above each block what that block does. Leave at
    least two blank lines between two (member) functions. The purpose
    of all that is that the structure of your code be obvious at the
    first glance!
<li><strong></strong>Identifiers: Begin module type names with a capital letter, and
    capitalize the beginning of each word, like in TokenRingMAC.  Do
    not use underscore `_` in module names. Use the C++-style naming
    on member functions: beginning of each word is capitalized (except
    for the first one) and no underscores: sendUnnumberedFrame().  On
    parameter names, you may use C-style (window_size) or C++-style
    (windowSize) naming, whichever you prefer.
<li><strong></strong>Make the functions virtual. Maybe someone who reuses your code
    will need a different behavior than what you thought of.
<li><strong></strong>Use inheritance if you're writing a very complex
    simple module: create a basic
    simple module class and build upon it
    deriving new module classes. This will make your code more
    readable and easier to manage/reuse. Unfortunately, inheritance is
    not supported in NED so you actually have to make distinct NED
    descriptions for each simple module class.
    Even if you have an abstract classes, prepare a NED description
    for it: it is useful as a reference to others who might derive a
    different simple module class from your
    abstract class. Inheritance in NED is
    planned in later releases of OMNeT++.
<li><strong></strong>Avoid global variables (and what's the
    same, static class members).  They are not reset to their initial
    value (zero) when you run the simulation, stop it and rebuild the
    network. This can cause several problems when you use Cmdenv to
    execute several runs one after another, or in Tkenv when you
    rebuild the network from the menu.
<li><strong></strong>Query the values of parameters into state variables
    (-<SAMP>&gt;</SAMP>class members) of the <EM>same</EM> name at the top
    of the <tt>activity()</tt> function.  If you know the value of a
    parameter is a random value (like uniform 0..10) or it can change
    during simulation, then to avoid having to look it up by name each
    time (like <tt>d=par(''delay'')</tt>) you may query its pointer into a
    <tt>cPar*</tt> state variable with the same name prepended with
    'p' (like <tt>pDelay=&amp;par(''delay'')</tt>).
  <li><strong></strong>Use <tt>ev.printf()</tt> and <SAMP>ev &lt;</SAMP><SAMP>&lt;</SAMP>... (see
    later) to print out information on what the module is doing. Doing
    so will pay out several times when it comes to debugging. Use a
    parameter and a state variable called debug. Surround your
    debugging output (<SAMP>ev &lt;</SAMP><SAMP>&lt;</SAMP>... and
    <tt>ev.printf()</tt> calls) with <SAMP>if(debug)</SAMP>.  You may
    introduce more specific debug switches (like debug_queuing etc.)
</OL>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec182"/>5.7. <FONTblue>Component libraries</FONT></H2></font></hr>

<p>Because of the structure of the simulation system, one can create
libraries of reusable elements in several ways. The three basic
types are:
<UL>
<li><strong></strong>simple module libraries
<li><strong></strong>NED source libraries
<li><strong></strong>precompiled compound module libraries
</UL>

<p>The elegant thing is that the user of the library does not need
to know which kind of library he/she is using; the three types
of libraries are equivalent in terms of usage.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec183"/>5.7.1. <FONTteal>Simple module libraries</FONT></H3></font>

<p>Simple modules that can be used in more than one simulations can form an
object library. Good candidates for module
libraries are simple
modules that implement:
<UL>
<li><strong></strong>Physical/Data-link protocols: Ethernet, Token Ring, FDDI, LAPB
    etc.
<li><strong></strong>Higher layer protocols: IP, TCP, X.25 L2/L3, etc.
<li><strong></strong>Network application types: E-mail, NFS, X, audio etc.
<li><strong></strong>Basic elements: message generator, sink, concentrator/simple
    hub, queue etc.
<li><strong></strong>Modules that implement routing algorithms in a multiprocessor or
    network
<li><strong></strong>...
</UL>

<p>To create a library, you compile the simple module C++ sources
and collect the object files in one directory. You'll also need
to the provide the NED descriptions:

<p>
<pre>
library/generator.ned
generator.o
sink.ned
sink.o
ethernet.ned
ethernet.o
</pre>

<p>

<p>The NED files contain the interfaces of the
simple modules. For example:

<p>
<pre>
// generator.ned
<STRONG>simple</STRONG> Generator
    <STRONG>parameters</STRONG>:
        interarrival time, message_length, message_kind;
    <STRONG>gates</STRONG>:
        <STRONG>out</STRONG>: output;
<STRONG>endsimple</STRONG>
</pre>

<p>
The user of the library would include generator.ned in his/her
NED files, and link the executable with generator.o. This is
more or less the same concept as conventional C/C++ header files
and libraries. The basic advantage is the same as with C/C++:
you save compilation time and hide concrete implementation. The
latter also means that you can give the module library to others
without having to share the C++ source.

<p>
It could also be meaningful to provide the C++ header files with the
module class declarations. This would enable the user to directly call
the member functions of the module object from the simulation program
and derive new module classes by redefining the virtual functions.

<p>You do not need to have a separate NED file for each module: you could
merge all of them into a single library.ned that contains the NED
declarations of all modules without all side effects.  However, it is
not recommended to put all object files into one library (.a or .lib),
because then every simple module would be present
in simulation programs linked with the library, regardless whether the
simulation uses them or not.

<p>

<p><font color="#006f00"><H3><A NAME="sec184"/>5.7.2. <FONTteal>Compound module NED source libraries</FONT></H3></font>

<p>

<p>The NED sources of reusable compound modules
can also be placed in a library. Candidates are:
<UL>
<li><strong></strong>network nodes such as hubs, bridges, routers
<li><strong></strong>different workstation/computer types: file server, X terminal
    etc.
<li><strong></strong>node of a massively parallel multiprocessor (used in testing
    different topologies)
<li><strong></strong>topology templates: parameterized ring, mesh, hypercube, torus
    etc. topologies, with the sizes (shapes etc) and the actual node
    types to be left as parameters
<li><strong></strong>...
</UL>

<p>
The NED sources are used through the import
mechanism; the corresponding simple module object
files still to be linked in the executable.

<p>The user does not necessarily notice that he/she is using a
compound module library and not a
simple module library. In NED files, the user
imports and uses the compound module sources in exactly the same way
as he/she used the simple module interface
declarations.  Linking also goes in the same way; if the
simple modules objects necessary for a certain
compound module are aggregated into a library (.a or .lib), the user
does not even notice the difference from the number of files he/she
has to link in.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec185"/>5.7.3. <FONTteal>Precompiled compound module libraries</FONT></H3></font>

<p>

<p>If you share a compound module with others, you do not necessarily
have to share the NED source and reveal the internals of the compound
module. You can turn the compound module into something that very much
looks like a simple module.

<p>
Suppose you have the following compound module:

<p>
<pre>
// router-compound.ned
<STRONG>module</STRONG> Router:
    <STRONG>parameters</STRONG>:
        processing_delay, buffersize;
    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>: input_ports[];
        <STRONG>out</STRONG>: output_ports[];
    <STRONG>submodules</STRONG>:
        routing: RoutingModule
            <STRONG>parameters</STRONG>:
                //...
            <STRONG>gatesizes</STRONG>:
                //...
        datalink: DataLink[num_of_ports]
            <STRONG>parameters</STRONG>:
                retry_count = 5,
                window_size = 2;
                //...
    <STRONG>connections</STRONG>:
    //...
<STRONG>endmodule</STRONG>
</pre>

<p>
First, you would compile this NED file with the NEDC compiler
and the resulting C++ code with the C++ compiler. Then you would
aggregate this object file with the simple module object files
into a single library (.a or .lib). Also, you would write a separate
NED file that declares the interface of the new ''simple''
module:

<p>
<pre>
// router-simple.ned
<STRONG>simple</STRONG> Router:
    <STRONG>parameters</STRONG>:
        processing_delay, buffersize;
    <STRONG>gates</STRONG>:
        <STRONG>in</STRONG>: input_ports[];
        <STRONG>out</STRONG>: output_ports[];
<STRONG>endsimple</STRONG>
</pre>

<p>

<p>The method produced a <EM>precompiled compound
  module</EM>. The resulting two files
can be placed into a simple module library and
can be used identically to ordinary simple
modules.

<p>Using precompiled compound modules
you can hide the internal complexity of your model from direct
inspection. However, nothing can prevent a user from building a
simulation executable with it and exploring the structure of your
compound module using OMNeT++ simulation kernel
functions. Consequently, using precompiled
compound modules is more useful as a
structuring tool.

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec186"/>5.8. <FONTblue>Some simulation techniques</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec187"/>5.8.1. <FONTteal>Modeling computer networks</FONT></H3></font>

<p>The hierarchical module structure of OMNeT++ allows you to organize
the model around different levels:

<p>Physical topology:
<OL>
<li><strong></strong>Top-level network
<li><strong></strong>Subnetwork (site)
<li><strong></strong>LAN
<li><strong></strong>node
</OL>

<p>Within a node:
<OL>
<li><strong></strong>OSI layers. The Data-Link, Network, Transport, Application layers
are of greater importance.
<li><strong></strong>Applications/protocols within a layer.
</OL>

<p>The advantage of OMNeT++ over many existing simulators is that the
depth of the module nesting is not
limited, and, what is in connection with the previous one, that a
simple module can be transformed into a
compound module by splitting the code into
several simple modules <EM>without affecting
  existing users</EM> of the module and vice versa. The latter means that
the programmer of the model is not under pressure from possibly
incorrect early design decisions about what to implement with a single
module and what with a compound module.

<p>

<p><font color="#006f00"><H3><A NAME="sec188"/>5.8.2. <FONTteal>Modeling multiprocessor systems</FONT></H3></font>

<p>One can make use of flexible model topologies. It is straightforward
to create ring, mesh, butterfly, torus, hypercube, tree, fat tree and
other topologies with conditional loop
connections.

<p>
Furthermore, general <EM>topology
  templates</EM> (e.g. mesh or hypercube) can be
created, where the types of the actual nodes are left as parameters.
The actual node types are substituted as parameter values for each
concrete simulation. Topology templates could be placed in a library
and imported from there if needed.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec189"/>5.8.3. <FONTteal>Parameter tuning</FONT></H3></font>

<p>Tuning means finding the parameter values which produce optimal
operation of the system. In OMNeT++, you can tune the model during
runtime. The code that monitors performance and changes parameter
values can be placed:
<UL>
<li><strong></strong>inside the model. In this case, the code does not necessarily
    form separate module(s); you can add the extra code to any already
    existing module.
<li><strong></strong>outside the model of the actual system. If you choose this
    method, you will create new modules that monitor and control the
    model.
</UL>

<p>OMNeT++ supports the model tuning concept by
providing reference parameters. Parameters that influence the model
performance and need to be tuned will be declared at the highest layer
and taken by both the model and the monitor part.

<p>
An example of model tuning is how one can determine the critical
throughput of a communication network by changing the offered
load according to performance measures of the network (queuing
times etc.)

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec190"/>5.8.4. <FONTteal>Multiple experiments within one simulation run</FONT></H3></font>

<p>One might need to perform a large number of simulation runs where
the model parameters are not known in advance. This can be the
case when one wants to optimize a system and parameter tuning
cannot be used because
<OL>
<li><strong></strong>for each experiment, he wants to start the model from a
    well-defined initial state, or
<li><strong></strong>he wants to change the model topology from one simulation run to
    the other
</OL>

<p>In this case, the following solution be followed. The network would
consist of only one simple module that would
organize the simulation runs by creating, running and destroying the
actual models with each experiment. The simple
module's code would look like this:

<p>
<pre>
<EM>SimulationManager::activity()</EM>
{
    determine parameters for the first run
    while(true)
    {
        create the model (a compound module) with the current
          run parameters schedule
        wait( some time) // while the model runs
        delete future events that belong to the model
        get statistics out of the model
        destroy the model
        if (simulation is done)
            break
        calculate parameters for the next run
    }
    write out results
}
</pre>

<p>
The solutions built into OMNeT++ (flexible module topologies, dynamic
creation of compound modules etc.) strongly
support this concept.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec191"/>5.8.5. <FONTteal>Dynamic topology optimization</FONT></H3></font>

<p>Dynamic topology optimization is
the generalization of the ''parameter tuning'' and ''multiple
experiments within one simulation run'' concepts. If one wants to
simulate large systems, it is possible that one part of the model
needs its topology to be optimized (optimal number of servers, optimal
interconnection etc.) while other parts of the model have reached
their steady state and should not be bothered.

<p>
This can be achieved by modifying the previous scheme. Parts
of the model that do not need topology optimization can be created
once and left running for the whole duration of the simulation;
other parts are examined and their structure is modified from
time to time.

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec192"/>6. <FONTgreen>The Simulation Library</FONT></H1></font></hr>
<a name="cha:the-simulation-library"/>

<p>OMNeT++ has a rich C++ class library which you can use when implementing
simple modules. A quick overview of the areas supported by the
simulation library:
<UL>
  <li><strong></strong>sending and receiving messages, scheduling and cancelling
    events, terminating the module or the simulation: member functions
    of <tt>cSimpleModule</tt>
  <li><strong></strong>events, messages, network packets: the
    <tt>cMessage</tt> and <tt>cPacket</tt> classes
  <li><strong></strong>random number generation: <tt>normal()</tt>,
    <tt>exponential()</tt>, etc.
  <li><strong></strong>access to module gates and parameters: member functions of
    <tt>cModule</tt> (base class for
    <tt>cSimpleModule</tt>); <tt>cPar</tt> and
    <tt>cGate</tt> classes
  <li><strong></strong>accessing other modules in the network: member functions of <tt>cModule</tt>
    and <tt>cGate</tt>
  <li><strong></strong>storing data in containers: <tt>cArray</tt>,
    <tt>cQueue</tt>, <tt>cBag</tt> and
    <tt>cLinkedList</tt> classes
  <li><strong></strong>discovering network topology and support routing: <tt>cTopology</tt> class
  <li><strong></strong>recording statistics into file: <tt>cOutVector</tt> class
  <li><strong></strong>collecting simple statistics: <tt>cStdDev</tt> and
    <tt>cWeightedStddev</tt> classes
  <li><strong></strong>distribution estimation: <tt>cLongHistogram</tt>,
    <tt>cDoubleHistogram</tt>,
    <tt>cVarHistogram</tt>, <tt>cPSquare</tt>,
    <tt>cKSplit</tt> classes
  <li><strong></strong>making variables inspectable in the graphical user interface
    (Tkenv): the <tt>WATCH()</tt> macro (<tt>cWatch</tt> class)
  <li><strong></strong>sending debug output to and prompting for user input in the graphical
    user interface (Tkenv): the ev object (<tt>cEnvir</tt> class)
</UL>

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec193"/>6.1. <FONTblue>Class library conventions</FONT></H2></font></hr>

<p><STRONG>Base class</STRONG>

<p>
Classes in the OMNeT++ simulation library are derived from <tt>cObject</tt>.
Functionality and conventions that come from <tt>cObject</tt>:
<UL>
  <li><strong></strong>name attribute
  <li><strong></strong><tt>className()</tt> member and other member functions giving textual
    information about the object
  <li><strong></strong>conventions for assignment, copying, duplicating the object
  <li><strong></strong>ownership control for containers derived from <tt>cObject</tt>
  <li><strong></strong>support for traversing the object tree
  <li><strong></strong>support for inspecting the object in graphical user interfaces
    (Tkenv)
  <li><strong></strong>support for automatic cleanup (garbage collection) at the end
    of the simulation
</UL>

<p>
Classes inherit and redefine several <tt>cObject</tt> member functions;
in the following we'll discuss some of the practically important
ones.

<p>
<STRONG>Setting and getting attributes</STRONG>

<p>
Member functions that set and query object attributes follow
consistent naming. The setter member function has the form setSomething(...)
and its getter counterpart is named something(), i.e. the ''get''
verb found in Java and some other libraries is omitted for brevity.
For example, the <EM>length</EM> attribute of the <tt>cMessage</tt> class can
be set and read like this:

<pre>
msg-&gt;setLength( 1024 );
length = msg-&gt;length();
</pre>
<p>

<p><STRONG>className()</STRONG>

<p>
For each class, the <tt>className()</tt> member function returns the class
name as a string:

<pre>
const char *classname = msg-&gt;className(); // returns "cMessage"
</pre>
<p>
<STRONG>Name attribute</STRONG>

<p>
An object can be assigned a name (a character string). The name
string is the first argument to the constructor of every class,
and it defaults to NULL (no name string). If you supply a name
string, the object will make its own copy (<tt>strdup()</tt>). As an example,
you can create a message object like this:

<pre>
cMessage *mymsg = new cMessage("mymsg");
</pre>
<p>

<p>You can also set the name after the object has been created:

<pre>
mymsg-&gt;setName("mymsg");
</pre>
<p>
You can get a pointer to the internally stored copy of the name
string like this:

<pre>
const char *name = mymsg-&gt;name(); // --&gt; returns ptr to internal copy
                                  // of "mymsg"
</pre>
<p>

<p>For convenience and efficiency reasons, the empty string ''''
and NULL are treated as equivalent by library objects: ''''
is stored as NULL (so that it does not consume heap), but it
is returned as '''' (so that it is easier to print
out etc). Thus, if you create a message object with either NULL
or '''' as name, it will be stored as NULL and <tt>name()</tt>
will return a pointer to '''', a static string:

<pre>
cMessage *msg = new cMessage(NULL, &lt;additional args&gt;);
const char *str = msg-&gt;name(); // --&gt; returns ptr to  ""
</pre>
<p>

<p><STRONG>fullName() and fullPath()</STRONG>

<p>
Objects have two more member functions which return other sort
of names based on the name attribute: <tt>fullName()</tt> and <tt>fullPath()</tt>.

<p>Suppose we have a module in the network university_lan, compound
module fddi_ring, simple module station[10]. If you call the functions
on the simple module object (<tt>cSimpleModule</tt> inherits from
<tt>cObject</tt>, too), the functions will return these values:

<pre>
ev &lt;&lt; module-&gt;name(); // --&gt; "station"
ev &lt;&lt; module-&gt;fullName(); // --&gt; "station[10]"
ev &lt;&lt; module-&gt;fullPath(); // --&gt; "university_lan.fddi_ring.station[10]"
</pre>
<p>

<p>
These functions work for any object. For example, a local object
inside the module would produce results like this:

<p>
<pre>
void FDDIStation::activity()
{
    cQueue buffer("buffer");
    ev &lt;&lt; buffer-&gt;fullPath(); // --&gt; "university_lan.fddi_ring.
                              // station[10].buffer"
}
</pre>

<p>

<p><tt>fullName()</tt> and <tt>fullPath()</tt>, together with
<tt>className()</tt> can be used for example to generate informative
error messages.

<p>Be aware that <tt>fullName()</tt> and <tt>fullPath()</tt> return
pointers to static buffers. Each call will overwrite the previous
content of the buffer, so for example you shouldn't put two calls in a
single <tt>printf()</tt> statement:

<pre>
ev.printf("object1 is '', object2 is ''\n",
          object1-&gt;fullPath(),
          object2-&gt;fullPath()
         ); // WRONG! Same string is printed twice!!!
</pre>
<p>

<p><STRONG>Copying and duplicating objects</STRONG>

<p>
The <tt>dup()</tt> member function creates an exact copy of the
object, duplicating
contained objects also if necessary. This is especially useful in the
case of message objects. <tt>dup()</tt> returns a pointer of type
<tt>cObject*</tt>, so it needs to be cast to the proper type:

<pre>
cMessage *copyMsg = (cMessage *) msg-&gt;dup();
</pre>
<p>

<p><tt>dup()</tt> works through calling the copy constructor, which in
turn relies on the assignment operator between objects.
<tt>operator=()</tt> can be used to copy contents of an object into
another object of the same type. The copying is done properly; object
contained in the object will also be duplicated if necessary. For
various reasons, <tt>operator=()</tt> does not copy the name string;
the copy constructor does it.

<p>
<STRONG>Iterators</STRONG>

<p>
There are several container classes in the library (<tt>cQueue</tt>,
<tt>cArray</tt> etc.) For many of them, there is a corresponding
iterator class that you can use to loop through the objects stored in
the container.

<p>For example:

<pre>
cQueue queue;

//..
for (cQueueIterator queueIter(queue); !queueIter.end(); queueIter++)
{
    cObject *containedObject = queueIter();
}
</pre>
<p>

<p><STRONG>Ownership control</STRONG>

<p>
By default, if a container object is destroyed, it destroys the
contained objects too. If you call <tt>dup()</tt>, the contained
objects are duplicated too for the new container. This is done so
because contained objects are owned by the container; ownership is
defined as the right/duty of deallocation. However, there is a
fine-grain ownership control mechanism built
in which allows you to specify on per-object basis whether you want
objects to be owned by the container or not; by calling the
<tt>takeOwnership()</tt> member function with false, you tell the
container that you don't want it to become the owner of objects that
will be inserted in the future.  You can explicitly select an owner
for any object by calling its <tt>setOwner()</tt> member function.

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec194"/>6.2. <FONTblue>Utilities</FONT></H2></font></hr>

<p><STRONG>Tracing</STRONG>

<p>
The tracing feature will be used extensively in the code examples,
so it is shortly introduced here. It will be covered in detail
in a later section.

<p>The ev object represents the user interface of the
simulation.  You can send debugging output to ev with the C++-style
output operators:

<pre>
ev &lt;&lt; "packet received, sequence number is "
   &lt;&lt; seq_num &lt;&lt; endl;
</pre>
<p>
An alternative solution is <tt>ev.printf()</tt>:

<pre>
ev.printf("packet received, sequence number is 0\n", seq_num);
</pre>
<p>
<STRONG>Simulation time conversion</STRONG>

<p>
There are utility functions which convert simulation
time (<tt>simtime_t</tt>) to a printable string
(like ''3s 130ms 230us'') and vica versa.

<p>
The <tt>simtimeToStr()</tt> function converts a <tt>simtime_t</tt>
(passed in the first arg) to textual form. The result is placed into
the buffer pointed to by the second arg. If the second arg is omitted
or it is NULL, <tt>simtimeToStr()</tt> will place the result into a
static buffer which is overwritten with each call:

<pre>
char buf[32];
ev.printf("t1=, t2=\n", simtimeToStr(t1), simTimeToStr(t2,buf));
</pre>
<p>

<p>The <tt>strToSimtime()</tt> function parses a time specification passed
in a string, and returns a <tt>simtime_t</tt>. If the string cannot
be entirely interpreted, -1 is returned:

<pre>
simtime_t t = strToSimtime("30s 152ms");
</pre>
<p>
Another variant, <tt>strToSimtime0()</tt> can be used if the time
string is a substring in a larger string. Instead of taking a char*,
it takes a reference to char* (char*&amp;) as the first argument.  The
function sets the pointer to the first character that could not be
interpreted as part of the time string, and returns the value. It
never returns -1; if nothing at the beginning of the string looked
like simulation time, it returns 0.

<pre>
const char *s = ''30s 152ms and some rubbish'';

simtime_t t = strToSimtime0(s); // now s points to "and some rubbish"
</pre>
<p>
<STRONG>Utility <SAMP>&lt;</SAMP>string.h<SAMP>&gt;</SAMP> functions</STRONG>

<p><p>
The <tt>opp_strdup()</tt>, <tt>opp_strcpy()</tt>, <tt>opp_strcmp()</tt>
functions are the same as their <SAMP>&lt;string.h&gt;</SAMP> equivalents,
except that they treat NULL and the empty string ('''') as identical,
and <tt>opp_str\-dup()</tt> uses operator new instead of
<tt>malloc()</tt>.
</p>

<p>The <tt>opp_concat()</tt> function might also be useful, for example
in constructing object names. It takes up to four const char *
pointers, concatenates them in a static buffer and returns a pointer
to the result. The result's length shouldn't exceed 255 characters.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec195"/>6.3. <FONTblue>Messages and packets</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec196"/>6.3.1. <FONTteal>The cMessage class</FONT></H3></font>

<p><tt>cMessage</tt> is a central class in OMNeT++. Objects of <tt>cMessage</tt> and
subclasses may model a number of things: events;
messages; packets,
frames, cells, bits or signals travelling
in a network; entities travelling in a system and so on.

<p>
<STRONG>Attributes</STRONG>

<p>
A <tt>cMessage</tt> object has number of attributes. Some are used by
the simulation kernel, others are provided just for the convenience
of the simulation programmer. A more-or-less complete list:
<UL>
  <li><strong></strong>The <EM>name</EM> attribute is inherited from <tt>cObject</tt>.
  <li><strong></strong>The <EM>message kind</EM> attribute is supposed to carry some message
    type information. Zero and positive values can be freely used
    for any purpose. Negative values are reserved for use by the
    OMNeT++ simulation library; especially, MK_PACKET (-1) and MK_INFO
    (-2) are used to denote that the message is a network packet
    (see the <tt>cPacket</tt> class later).
  <li><strong></strong>The <EM>length</EM> attribute (understood in bits) is used to compute
    transmission delay when the message travels through a connection
    that has an assigned data rate.
  <li><strong></strong>The <EM>bit error flag</EM> attribute is set to true by the simulation
    kernel with a probability of $1-(1-<EM>ber</EM>)^<i>length</i>$ when the
    message is sent through a connection that has an assigned bit
    error rate (<EM>ber</EM>).
  <li><strong></strong>The <EM>priority</EM> attribute is used by the simulation kernel to
    order messages in the message queue (FES) that have the same
    arrival time values.
  <li><strong></strong>The <EM>time stamp</EM> attribute is not used by the simulation kernel;
    you can use it for purposes like remembering the time when the
    message was enqueued or re-sent.
  <li><strong></strong>Other attributes and data members make simulation programming
    easier, they will be discussed later: <EM>parameter list</EM>, <EM>encapsulated
      message</EM>, <EM>context pointer</EM>.
  <li><strong></strong>A number of read-only attributes store information about the
    message's (last) sending/scheduling: <EM>source/destination module
      and gate</EM>, <EM>sending (scheduling) and arrival time</EM>. They are
    mostly used by the simulation kernel while the message is in
    the FES, but the information is still in the message object when
    a module receives the message.
</UL>

<p>
<STRONG>Basic usage</STRONG>

<p>
A <tt>cMessage</tt> object can be created in the following way:

<pre>
cMessage *msg = new cMessage("msg-name", kind, length,
                             priority, errorflag);
</pre>
<p>


<p>The kind, length, and priority are integers, and errorflag is boolean.
All arguments have default values, so the following initializations
are also valid:

<pre>
cMessage *msg1 = new cMessage;
cMessage *msg2 = new cMessage("data-packet", DATAPACKET_KIND, 8*1500 );
</pre>
<p>

<p>Once a message has been created, its data members can be changed by the following functions:

<pre>
msg-&gt;setKind( kind );
msg-&gt;setLength( length );
msg-&gt;setPriority( priority );
msg-&gt;setBitError( err );
msg-&gt;setTimestamp();
msg-&gt;setTimestamp( simtime );
</pre>
<p>

<p>With these functions the user can set the message
kind, the message length,
the priority, the error
flag and the time stamp. The <tt>setTimeStamp()</tt> function without any argument
sets the time stamp to the current simulation time.

<p>
The values can be obtained by the following functions:

<pre>
int k       = msg-&gt;kind();
int p       = msg-&gt;priority();
int l       = msg-&gt;length();
bool b      = msg-&gt;hasBitError();
simtime_t t = msg-&gt;timestamp();
</pre>
<p>

<p><STRONG>Duplicating messages</STRONG>

<p>

<p>It is often needed to duplicate a message (for example, send
one and keep a copy). This can be done in the standard ways as
for any other OMNeT++ object:

<pre>
cMessage *copy1 = (cMessage *) msg-&gt;dup();
cMessage *copy2 = new cMessage( *msg );
</pre>
<p>

<p>The two are equivalent. The resulting message is an exact copy
of the original, including message parameters (<tt>cPar</tt> or other
object types) and encapsulated messages.

<p>

<p>
<font color="#006f00"><H3><A NAME="sec197"/>6.3.2. <FONTteal>Message encapsulation</FONT></H3></font>

<p>It is often necessary to encapsulate a
message into another when you're modeling
layered protocols of computer networks. Although you can encapsulate
messages by adding them to the parameter list, there's a better way.

<p>
The <tt>encapsulate()</tt> function encapsulates a message
into another one. The length of the message will grow by the length of
the encapsulated message. An exception: when the encapsulating (outer)
message has zero length, OMNeT++ assumes it is not a real packet but
some out-of-band signal, so its length is left at zero.

<pre>
cMessage *userdata = new cMessage("userdata");

userdata-&gt;setLength(8*2000);
cMessage *tcpseg = new cMessage("tcp");
tcpseg-&gt;setLength(8*24);
tcpseg-&gt;encapsulate(userdata);
ev &lt;&lt; tcpseg-&gt;length() &lt;&lt; endl; // --&gt; 8*2024 = 16192
</pre>
<p>

<p>A message can only hold one encapsulated message at a time. The
second <tt>encapsulate()</tt> call will result in an error. It is also
an error if the message to be encapsulated isn't owned by the
module.

<p>You can get back the encapsulated message by <tt>decapsulate()</tt>:

<pre>
cMessage *userdata = tcpseg-&gt;decapsulate();
</pre>
<p>
<tt>decapsulate()</tt> will decrease the length of the message accordingly,
except if it was zero. If the length would become negative, an
error occurs.

<p>
The <tt>encapsulatedMsg()</tt> function returns a pointer to the encapsulated
message, or NULL if no message was encapsulated.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec198"/>6.3.3. <FONTteal>Information about the last sending</FONT></H3></font>

<p>There are several variables in <tt>cMessage</tt> that store
information about the last time the message was sent or
scheduled. These variables can only be read.

<p><tt>isSelfMessage()</tt> returns true if the message has been scheduled
(<tt>scheduleAt()</tt>) as opposed to being sent with one of the
<tt>send...()</tt> methods.

<p><pre>
bool <tt>isSelfMessage()</tt>
</pre>

<p>The following methods can tell where the message came from and
where it arrived (will arrive).

<p><pre>
int <tt>senderModuleId()</tt>;
int <tt>senderGateId()</tt>;
int <tt>arrivalModuleId()</tt>;
int <tt>arrivalGateId()</tt>;
</pre>

<p>The following two methods are just convenience functions that
combine module id and gate id into a gate object pointer.

<p><pre>
cGate *<tt>senderGate()</tt>;
cGate *<tt>arrivalGate()</tt>;
</pre>

<p>And there are further convenience functions to tell whether
the message arrived on a specific gate given with id or
name+index.

<p><pre>
bool <tt>arrivedOn</tt>(int id);
bool <tt>arrivedOn</tt>(const char *gname, int gindex=0);
</pre>

<p>The following methods return message creation time and the last sending
and arrival times.

<p><pre>
simtime_t <tt>creationTime()</tt>
simtime_t <tt>sendingTime()</tt>;
simtime_t <tt>arrivalTime()</tt>;
</pre>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec199"/>6.3.4. <FONTteal>Context pointer</FONT></H3></font>

<p><tt>cMessage</tt> contains a void* pointer which is
set/returned by the <tt>setContextPointer()</tt> and
<tt>contextPointer()</tt> functions:

<pre>
void *context =...;
msg-&gt;setContextPointer( context );
void *context2 = msg-&gt;contextPointer();
</pre>
<p>

<p>It can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

<p>Intended purpose: a module which schedules several self-messages
(timers) will need to identify a self-message when it arrives back to
the module, ie. the module will have to determine which timer went off
and what to do then. The context pointer can be
made to point at a data structure kept by the module which can carry
enough ''context'' information about the event.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec200"/>6.3.5. <FONTteal>The cPacket class</FONT></H3></font>

<p>
The <tt>cPacket</tt> class is derived from <tt>cMessage</tt>. It is intended as
a base for all messages that model packets or frames in a telecommunications
network.

<p><tt>cPacket</tt> adds two new data members to <tt>cMessage</tt>:
<EM>protocol</EM> and <EM>PDU</EM> type (packet, frame or event type).
Both are short integers, and are handled by the following member
functions:

<p><pre>
short <tt>protocol()</tt>;
short <tt>pdu()</tt>;
setProtocol(short p);
setPdu(short p);
</pre>

<p>Acceptable message kind values are:
<UL>
<li><strong></strong>MK_PACKET
<li><strong></strong>MK_INFO
</UL>

<p>The <tt>cPacket</tt> constructor sets the message kind to <tt>MK_PACKET</tt>.
Both <tt>MK_PACKET</tt> and <tt>MK_INFO</tt> are defined as negative integers.
(Remember, negative message kind values are reserved for the simulation library.)

<p>The protocol and PDU fields would ideally take a value from the <tt>protocol.h</tt>
header in the simulation library. The contents of <tt>protocol.h</tt>
is currently experimental; comments and contributions are welcome.

<p>

<p><font color="#006f00"><H3><A NAME="sec201"/>6.3.6. <FONTteal>Attaching parameters and objects</FONT></H3></font>

<p>If you want to add parameters or objects to a message, the preferred
way to do that is via message definitions, described in chapter
<a href="#cha:message-definitions">[click]</a>.

<p><STRONG>Attaching objects</STRONG>

<p>The <tt>cMessage</tt> class has an internal <tt>cArray</tt> object which can
carry objects. Only objects
that are derived from <tt>cObject</tt> (most OMNeT++ classes are so) can be attached.
The <tt>addObject()</tt>, <tt>getObject()</tt>, <tt>hasObject()</tt>,
<tt>removeObject()</tt> methods use the object name
as the key to the array. An example:

<pre>
cLongHistogram *pklen_distr = new cLongHistogram("pklen_distr");
msg-&gt;addObject( pklen_distr );
...
if (msg-&gt;hasObject("pklen_distr"))
{
   cLongHistogram *pklen_distr =
       (cLongHistogram *) msg-&gt;getObject("pklen_distr");
   ...
}
</pre>
<p>
You should take care that names of the attached objects do not
clash with each other or with <tt>cPar</tt> parameter names
(see next section).
If you do not attach anything to the message and do not call the
<tt>parList()</tt> function, the internal <tt>cArray</tt> object
will not be created.
This saves both storage and execution time.

<p>You can attach non-object types (or non-<tt>cObject</tt> objects) to
the message by using
<tt>cPar</tt>'s void* pointer 'P') type (see later in the description
of <tt>cPar</tt>). An example:

<pre>
struct conn_t *conn = new conn_t; // conn_t is a C struct
msg-&gt;addPar("conn") = (void *) conn;
msg-&gt;par("conn").configPointer(NULL,NULL,sizeof(struct conn_t));
</pre>
<p>

<p>
<STRONG>Attaching parameters</STRONG>

<p>The old way of attaching parameters is adding <tt>cPar</tt> objects.
There are several downsides of this approach, the most notable ones
being large memory and runtime overhead. It has been reported that
using <tt>cPar</tt> message parameters might account for a large
part of execution time, sometimes as much as 80%. (This depends
on how many parameters you use.) Therefore it is recommended
that you use message definitions <a href="#cha:message-definitions">[click]</a>
which adds the required parameters to the new message class
as <tt>int</tt>, <tt>long</tt>, <tt>bool</tt> etc. class members, via
subclassing.

<p>However, if you still need to use cPars, here's a short summary
how you can do it.
You add a new parameter to the message with the
<tt>addPar()</tt> member function, and get back a reference
to the parameter object with the <tt>par()</tt> member function.
<tt>hasPar()</tt> tells you if the message has a
given parameter or not.

<p>Examples:

<pre>
msg-&gt;addPar("dest_addr");
msg-&gt;par("dest_addr") = 168;

if (msg-&gt;hasPar("dest_addr")) {
   long dest_addr = msg-&gt;par("dest_addr");
   ...
}
</pre>
<p>
Message parameters can be accessed also by index in the parameter
array. The <tt>findPar()</tt> function returns the index of a parameter
or -1 if the parameter cannot be found. The parameter can then be
accessed using an overloaded <tt>par()</tt> function.

<pre>
int index = msg-&gt;findPar("dest_addr");
long dest_addr = msg-&gt;par(index);
</pre>
<p>

<p><hr><font color="#006f00"><H2><A NAME="sec202"/>6.4. <FONTblue>Sending and receiving messages</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec203"/>6.4.1. <FONTteal>Sending messages</FONT></H3></font>

<p>Once the message has been created, it can be sent through an
output gate using one of these functions:

<p><tt>send(cMessage *msg, const char *gate_name, int index);</tt><br>
<tt>send(cMessage *msg, int gate)</tt>;

<p>

<p>For the first function, the argument <tt>gate_name</tt> is the name of
the gate the message has to be sent through. If this gate is
a vector gate, index determines though which particular output
gate this has to be done; otherwise, the index argument is not
needed.

<p>The second function uses the gate number and because it does
not have to search through the gate array, it is faster than
the first one.

<p>
Examples:

<pre>
send( new cMessage("token"), "out-gate");
send( new cMessage("token"), "vectorgate", i);

int out_gate_id = findGate("out-gate");
for (i=0; i&lt;n; i++)
{
  send( new cMessage("packet"), out_gate_id);
  wait(in_time);
}
</pre>
<p>

<p>All message sending functions check that you actually own the message
you are about to send. If the message is with another module,
currently scheduled or in a queue etc., you'll get a runtime error.
(The feature does not increase runtime overhead significantly, because
it uses the object ownership management;
it merely checks that the owner of the message is the module which
wants to send it.)

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec204"/>6.4.2. <FONTteal>Delayed sending</FONT></H3></font>

<p>It is often needed to model a delay (processing time, etc.) immediately
followed by message sending. In OMNeT++, it is possible to implement
it like this:

<pre>
wait( some_delay );
send( msg, "outgate" );
</pre>
<p>

<p>If the module needs to react to messages that arrive during the delay,
<tt>wait()</tt> cannot be used and the timer mechanism described in
Section <a href="#sec:ch-sim-lib:self-messages">[click]</a>, ``Self-messages'', would
need to be employed.

<p>
However, there is a more straightforward method than the above two,
and this is delayed sending. Delayed sending
can be done with one of these functions:

<p><tt>sendDelayed(cMessage *msg, double delay, const char *gate_name, int index);</tt><br>
<tt>sendDelayed(cMessage *msg, double delay, int gate_id);</tt>

<p>
The arguments are the same as for <tt>send()</tt>, except for the extra <EM>delay</EM>
parameter. The effect of the function is the same as if the module
had kept the message for the delay interval and sent it afterwards.
That is, the sending time of the message will be the current
simulation time (time at the <tt>sendDelayed()</tt> call) plus the delay.
The delay value must be nonnegative.

<p>Example:

<pre>
sendDelayed( new cMessage("token"), 0.005, "out-gate");
</pre>
<p>

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec205"/>6.4.3. <FONTteal>Direct message sending</FONT></H3></font>

<p>Sometimes it is necessary or convenient to ignore gates/connections
and send a message directly to a remote destination module. The <tt>sendDirect()</tt>
function does that, and it takes the pointer of the remote module
(<tt>cModule</tt> *). You can also specify a delay and an input gate of
the destination module.

<pre>
cModule *destinationmodule =...;
double delay = truncnormal(0.005, 0.0001);
sendDirect( new cMessage, delay, destinationmodule, "in" );
</pre>
<p>
The destination module receives the message as if it was sent
''normally''.

<p>

<p><font color="#006f00"><H3><A NAME="sec206"/>6.4.4. <FONTteal>Receiving messages</FONT></H3></font>

<p><STRONG>With activity() only!</STRONG> The message receiving functions can
only be used in the <tt>activity()</tt> function,
<tt>handleMessage()</tt> gets the messages in its argument list.

<p>A message can be received by a number of functions, the most
general one is the <tt>receive()</tt> function:

<pre>
cMessage *msg = receive();
</pre>
<p>
Simple module objects contain a built-in queue object called
putAsideQueue. The put-aside queue is used by
some of the message-receiving functions.

<p>There are two groups of functions that receive messages:
<UL>
<li><strong></strong><tt>receive()</tt>, <tt>receiveOn()</tt>
<li><strong></strong><tt>receiveNew()</tt>, <tt>receiveNewOn()</tt>
</UL>

<p>The functions <tt>receive()</tt>/<tt>receiveOn()</tt>check the put-aside queue
first and try to return a message from it. Only if they do not
find an appropriate message in the put-aside queue, will wait
for new messages.

<p>The functions <tt>receiveNew()</tt>/<tt>receiveNewOn()</tt> wait for new messages,
ignoring the put-aside queue.

<p>Furthermore, the ...On() functions expect messages to arrive on a
specific gate. Messages that arrive on another gate are inserted into
the put-aside queue. The On-less versions accept any message.

<p>Since the <tt>receive()</tt> and <tt>receiveOn()</tt> return messages
also from the put-aside queue, the arrival times of messages they
return can be less than the current simulation time. A naive (and also
incorrect) approach to check whether a message is a new one or it has
been retrieved from the putaside-queue could be the following:

<pre>
cMessage *msg = receive();

if (msg-&gt;arrivalTime()&lt;simTime()) // not correct! several events may
                                  // occur at the same simulation time
{
  // handle msg as an old message
}
</pre>
<p>

<p>The correct way to do this is to check the putaside-queue:

<pre>
bool queue_was_empty = putAsideQueue.empty();
cMessage *msg = receive();

if (!queue_was_empty)
{
  // handle msg as an old message
}
</pre>
<p>

<p>To discard the contents of the put-aside queue, one could use
the following code:

<pre>
while (!putAsideQueue.empty())
  delete receive();
</pre>
<p>

<p>To demonstrate <tt>receiveOn()</tt>, the following code fragment waits
for a message on one specific input gate and discards all messages
that arrived on other gates in the meanwhile:

<pre>
cMessage *msg = receiveNewOn("important_input_gate");
while (!putAsideQueue.empty())
  delete receive();
</pre>
<p>

<p>The above code is almost equivalent to the following, except
that it preserves the previous contents of the put-aside queue:

<pre>
cMessage *msg;
for(;;)
{
  msg = receiveNew();
  if (msg-&gt;arrivedOn("important_input_gate"))
    break;
  delete msg;
}
</pre>
<p>

<p>All message receiving functions can be given a timeout
value. (This is a <EM>delta</EM>, not an
absolute simulation time.) If an appropriate message doesn't arrive
within the timeout period, the function returns a NULL pointer. An
example:

<pre>
simtime_t timeout = 3.0;
cMessage *msg = receive( timeout );

if (msg=NULL)
  // timeout expired without any messages
else
  // process message
</pre>
<p>

<p>
<font color="#006f00"><H3><A NAME="sec207"/>6.4.5. <FONTteal>The wait() function</FONT></H3></font>

<p><STRONG>With activity() only!</STRONG> The <tt>wait()</tt> function's implementation
contains a <tt>receive()</tt> call which cannot be used in <tt>handleMessage()</tt>.

<p>The <tt>wait()</tt> function suspends the execution of the module for
a given amount of simulation time (a <EM>delta</EM>), regardless whether
messages arrive at the module in the meanwhile or not:

<pre>
wait( delay_interval );
</pre>
<p>
In other simulation software, <tt>wait()</tt> is often called hold.
Internally, the <tt>wait()</tt> function is implemented by a
<tt>scheduleAt()</tt> followed by a <tt>receive()</tt>. The
<tt>wait()</tt> function is very convenient in modules that do not need
to be prepared for arriving messages, for example message generators.
An example:

<pre>
for(;;)
{
  wait( par("interarrival-time") );
  // generate and send message
}
</pre>
<p>
The messages that arrived during the <tt>wait()</tt> call will
accumulate in the putaside-queue. The putaside-queue can be examined
directly (an example was shown in the previous section), and its
contents is also retrieved by the <tt>receive()</tt> or
<tt>receiveOn()</tt> functions.

<p>

<p>
<font color="#006f00"><H3><A NAME="sec208"/>6.4.6. <FONTteal>Self-messages</FONT></H3></font>
<a name="sec:ch-sim-lib:self-messages"/>

<p>The module can send a message to itself using the
<tt>scheduleAt()</tt> function:

<pre>
scheduleAt( time, msg );
</pre>
<p>
<tt>scheduleAt()</tt> accepts an <EM>absolute</EM> simulation time
(usually <tt>simTime()</tt>+<EM>something</EM>).  Messages sent via
<tt>scheduleAt()</tt> are called <EM>self-messages</EM>, and in OMNeT++
they are used to model events which occur within the module.
Self-messages are delivered to the module in the same way as other
messages (via the usual receive calls or <tt>handleMessage()</tt>); the
module may call the <tt>isSelfMessage()</tt> member of any received
message to determine if it is a self-message.

<p>
Before self-messages are delivered, they can be
cancelled
(removed from the FES). This is particularly useful because
self-messages are often used to model timers.

<pre>
cancelEvent( msg );
</pre>
<p>

<p>The <tt>cancelEvent()</tt> function takes a pointer to the message to
be cancelled, and also returns the same pointer. After having it
cancelled, you may delete the message or reuse it in the next
<tt>scheduleAt()</tt> calls. <tt>cancelEvent()</tt> gives an error if
the message is not in the FES.

<p>The following example shows how to implement timers:

<pre>
cMessage *timeout_msg = new cMessage;

scheduleAt( simTime()+10.0, timeout_msg );
//...

cMessage *msg = receive();
if (msg == timeout_msg)
{
  // timeout expired
}
else
{
  // other message has arrived, timer can be cancelled now:
  delete cancelEvent( timeout_msg );
}
</pre>
<p>
You can determine if a message is currently in the FES by calling
its <tt>isScheduled()</tt> member:

<pre>
if (msg-&gt;isScheduled())
  delete cancelEvent(msg);
else
  ...
</pre>
<p>
An advanced version of the above code which also checks the put-aside
queue:

<pre>
if (msg-&gt;isScheduled())
  delete cancelEvent(msg);
else if (putAsideQueue.contains(msg))
  delete putAsideQueue.remove(msg);
else
  ...
</pre>
<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec209"/>6.4.7. <FONTteal>Querying the state of an output gate</FONT></H3></font>

<p>You may have reasons to check whether a certain output gate is
transmitting or to learn when it will finish
transmission. This is done with gate
object's <tt>isBusy()</tt> and <tt>transmissionFinishes()</tt> member
functions.  The latter function, <tt>transmissionFinishes()</tt> returns the
time when the gate will finish its current transmission or (if it is
currently free) when it finished its last transmission.

<p>
An example:

<pre>
cMessage *packet = new cMessage("DATA");
packet-&gt;setLength( 1000 );

if (gate("TxGate")-&gt;isBusy()) // if gate is busy, wait until it
{                             // becomes free
  wait( gate("TxGate")-&gt;transmissionFinishes() - simTime());
}
send( packet, ''TxGate'');
</pre>
<p>

<p>If the connection with a data rate is not immediately the one
connected to the simple module's output gate but
the second one in the route, you have to check the second gate's busy
condition.  You would use the following code:

<pre>
if (gate("mygate")-&gt;toGate()-&gt;isBusy())
  //...
</pre>
<p>

<p>Note that if data rates change during the
simulation, the changes will affect only the messages that are
<EM>sent</EM> after the change.

<p>

<p><font color="#006f00"><H3><A NAME="sec210"/>6.4.8. <FONTteal>Stopping the simulation</FONT></H3></font>

<p><STRONG>Normal termination</STRONG>

<p>
You can finish the simulation with the <tt>endSimulation()</tt> function:

<p>
<tt>endSimulation()</tt>;

<p>
However, typically you don't need <tt>endSimulation()</tt> because you
can specify simulation time and CPU time limits in the ini file (see later).

<p>
<STRONG>Stopping on errors</STRONG>

<p>
If your simulation detects an error condition and wants to stop
the simulation, you can do it with the <tt>error()</tt> member function
of <tt>cModule</tt>. It is used like <tt>printf()</tt>:

<pre>
if (windowSize&lt;1)
  error("Invalid window size 0; must be &gt;=1", windowSize);
</pre>
<p>

<p>Do not include a newline (''\n'') or punctuation (period
or exclamation mark) in the printed-out text, it will be added
by OMNeT++.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec211"/>6.5. <FONTblue>Accessing module parameters and gates</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec212"/>6.5.1. <FONTteal>Module parameters</FONT></H3></font>

<p>Module parameters can be accessed
with the <tt>par()</tt> member function of <tt>cModule</tt>:

<pre>
cPar& delay_par = par("delay");
</pre>
<p>
The <tt>cPar</tt> class is a general value-storing object. It supports
type casts to numeric types, so parameter values can be read
like this:

<pre>
int num_tasks = par("num_tasks");
double proc_delay = par("proc_delay");
</pre>
<p>
If the parameter is a random variable or its value can change
during execution, it is best to store a reference to it and re-read
the value each time it is needed:

<pre>
cPar& wait_time = par("wait_time");
for(;;)
{
  //...
  wait( (simtime_t)wait_time );
}
</pre>
<p>
If the wait_time parameter was given a random value (e.g. exponential(1.0))
in the NED source or the ini file, the above code results in
a different delay each time.

<p>Parameter values can also be changed from the program, during
execution. If the parameter was taken by reference
 (with a
<tt>ref</tt> modifier in the NED file), other modules
will also see the change.  Thus, parameters taken by reference can be
used as a means of module communication.

<p>
An example:

<pre>
par("wait_time") = 0.12;
</pre>
<p>
Or:

<pre>
cPar& wait_time = par("wait_time");
wait_time = 0.12;
</pre>
<p>

<p>See <tt>cPar</tt> explanation later in this manual for further information
on how to change a <tt>cPar</tt>'s value.

<p>

<p><font color="#006f00"><H3><A NAME="sec213"/>6.5.2. <FONTteal>Gates and links</FONT></H3></font>

<p><STRONG>Gate objects</STRONG>

<p>
Module gates are <tt>cGate</tt> objects. Gate objects
know whether and to which gate they are connected, and they can be
asked about the parameters of the link (delay, data rate, etc.)

<p>The <tt>gate()</tt> member function of <tt>cModule</tt> returns a
pointer to a <tt>cGate</tt> object, and an overloaded form of the
function lets you to access elements of a vector gate:

<pre>
cGate *outgate = gate("out");
cGate *outvec5gate = gate("outvec",5);
</pre>
<p>

<p>For gate vectors, the first form returns the first gate in the
vector (at index 0).

<p>
The <tt>isVector()</tt> member function can be used to determine if a
gate belongs to a gate vector or not. But this is almost insignificant,
because non-vector gates are treated as vectors with size 1.

<p>
Given a gate pointer, you can use the <tt>size()</tt> and
<tt>index()</tt> member functions of <tt>cGate</tt> to determine the
size of the gate vector and the
index of the gate within the vector:

<pre>
int size2 = outvec5gate-&gt;size(); // --&gt; size of outvec[]
int index = outvec5gate-&gt;index(); // --&gt; 5 (it is gate 5 in the vector)
</pre>
<p>

<p>For non-vector gates, <tt>size()</tt> returns 1 and <tt>index()</tt> returns 0.

<p>The <tt>type()</tt> member function returns a character, 'I' for input
gates and 'O' for output gates:

<pre>
char type = outgate-&gt;type() // --&gt; 'O'
</pre>
<p>
<STRONG>Gate IDs</STRONG>

<p>
Module gates (input and output, single and vector) are stored in an
array within their modules. The gate's position in the array is called
the <EM>gate ID</EM>. The gate ID is returned by the <tt>id()</tt>
member function:

<p>
<pre>
int id = outgate-&gt;id();
</pre>

<p>For a module with input gates from_app and in[3] and output gates
of to_app and status, the array may look like this:

<p>
<table border>
<TR> <TD align=center>

<STRONG>ID</STRONG> </TD> <TD align=center> <STRONG>dir</STRONG> </TD> <TD align=center> <STRONG>name[index]</STRONG></TD></TR>
<TR> <TD align=center> 0 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>from_app</tt> </TD></TR>
<TR> <TD align=center> 1 </TD> <TD align=center> <EM>output</EM> </TD> <TD align=center> <tt>to_app</tt> </TD></TR>
<TR> <TD align=center> 2 </TD> <TD align=center colspan=2><EM>empty</EM></TD></TR>
<TR> <TD align=center> 3 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>in[0]</tt></TD></TR>
<TR> <TD align=center> 4 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>in[1]</tt></TD></TR>
<TR> <TD align=center> 5 </TD> <TD align=center> <EM>input</EM> </TD> <TD align=center> <tt>in[2]</tt></TD></TR>
<TR> <TD align=center> 6 </TD> <TD align=center> <EM>output</EM> </TD> <TD align=center> <tt>status</tt></TD></TR>
</table>

<p>

<p>The array may have empty slots. Gate vectors are guaranteed to
occupy contiguous IDs, that is, it is legal to calculate the
ID of <EM>gate[k]</EM> as <tt>gate(''gate'',0).id()+k</tt>.

<p>Message sending and receiving functions accept both gate names
and gate IDs; the functions using gates IDs are a bit faster.
Gate IDs do not change during execution, so it is often worth
retrieving them in advance and using them instead of gate names.

<p>
Gate IDs can also be determined with the <tt>findGate()</tt>
member of <tt>cModule</tt>:

<pre>
int id1 = findGate("out");
int id2 = findGate("outvect",5);
</pre>
<p>

<p><STRONG>Link parameters</STRONG>

<p>
The following member functions return the link attributes:

<pre>
cLinkType *link = outgate-&gt;link();
cPar *d = outgate-&gt;delay();
cPar *e = outgate-&gt;error();
cPar *r = outgate-&gt;datarate();
</pre>
<p>
<STRONG>Transmission state</STRONG>

<p>
The <tt>isBusy()</tt> member function returns whether the gate
is currently transmitting, and if so, the
<tt>transmissionFinishes()</tt> member function
returns the simulation time when the gate is going to finish
transmitting.

<p>
<STRONG>Connectivity</STRONG>


The <tt>isConnected()</tt> member function returns whether
the gate is connected. If the gate is an output gate, the gate to
which it is connected is obtained by the <tt>toGate()</tt>
member function. For input gates, the function is
<tt>fromGate()</tt>.

<pre>
cGate *gate = gate("somegate");
if (gate-&gt;isConnected())
{
  cGate *othergate = (gate-&gt;type()=='O') ?
                     gate-&gt;toGate() : gate-&gt;fromGate();

  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
}
else
{
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
}
</pre>
<p>

<p>An alternative to <tt>isConnected()</tt> is to check the return value
of <tt>toGate()</tt> or <tt>fromGate()</tt>. The following code is fully equivalent
to the one above:

<pre>
cGate *gate = gate("somegate");
cGate *othergate = (gate-&gt;type()=='O') ?
                   gate-&gt;toGate() : gate-&gt;fromGate();
if (othergate)
  ev &lt;&lt; "gate is connected to: " &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
else
  ev &lt;&lt; "gate not connected" &lt;&lt; endl;
</pre>
<p>
To find out to which simple module a given output
gate leads finally, you would have to walk
along the path like this (the <tt>ownerModule()</tt> member function
returns the module to which the gate belongs):

<pre>
cGate *gate = gate("out");
while (gate-&gt;toGate()!=NULL)
{
  gate = gate-&gt;toGate();
}

cModule *destmod = gate-&gt;ownerModule();
</pre>
<p>

<p>but luckily, there are two convenience functions which do that:
<tt>sourceGate()</tt> and
<tt>destinationGate()</tt>.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec214"/>6.6. <FONTblue>Walking the module hierarchy</FONT></H2></font></hr>

<p><STRONG>Module vectors</STRONG>

<p>
If a module is part of a module vector, the
<tt>index()</tt> and <tt>size()</tt> member functions can be used to
query its index and the vector size:

<pre>
ev &lt;&lt; "This is module [" &lt;&lt; module-&gt;index() &lt;&lt;
      "] in a vector of size [" &lt;&lt; module-&gt;size() &lt;&lt; "].\n";
</pre>
<p>

<p><STRONG>Module IDs</STRONG>

<p>
Each module in the network has a unique ID that is returned by the
<tt>id()</tt> member function. The module ID is used
internally by the simulation kernel to identify modules.

<pre>
int myModuleId = id();
</pre>
<p>
If you know the module ID, you can ask the simulation object
(a global variable) to get back the module pointer:

<pre>
int id = 100;
cModule *mod = simulation.module( id );
</pre>
<p>

<p>Module IDs are guaranteed to be unique, even when modules are
created and destroyed dynamically. That is, an ID which once
belonged to a module which was deleted is never issued to another
module later.

<p>
<STRONG>Walking up and down the module hierarchy</STRONG>

<p>
The surrounding compound module can be accessed by the
<tt>parentModule()</tt> member function:

<pre>
cModule *parent = parentModule();
</pre>
<p>
For example, the parameters of the parent module are accessed
like this:

<pre>
double timeout = parentModule()-&gt;par( "timeout" );
</pre>
<p>

<p><tt>cModule</tt>'s <tt>findSubmodule()</tt> and <tt>submodule()</tt>
member functions make it possible to look up the module's submodules
by name (or name+index if the submodule
is in a module vector). The first one returns the numeric module ID of
the submodule, and the latter returns the module pointer.  If the
submodule is not found, they return -1 or NULL, respectively.

<pre>
int submodID = compoundmod-&gt;findSubmodule("child",5);
cModule *submod = compoundmod-&gt;submodule("child",5);
</pre>
<p>

<p>The <tt>moduleByRelativePath()</tt> member function can be used to find
a submodule nested deeper than one level below. For example,

<pre>
compoundmod-&gt;moduleByRelativePath("child[5].grandchild");
</pre>
<p>
would give the same results as

<pre>
compoundmod-&gt;submodule("child",5)-&gt;submodule("grandchild");
</pre>
<p>
(Provided that child[5] does exist, because otherwise the second
version will crash with an access violation because of the NULL
pointer.)

<p>
The <tt>cSimulation</tt>::<tt>moduleByPath()</tt> function is similar
to <tt>cModule</tt>'s <tt>moduleByRelative\-Path()</tt> function, and it
starts the search at the top-level module.

<p>
<STRONG>Iterating over submodules</STRONG>

<p>
To access all modules within a compound module,
use <tt>cSubModIterator</tt>.

<p>For example:

<pre>
for (cSubModIterator iter(*parentModule()); !iter.end(); iter++)
{
  ev &lt;&lt; iter()-&gt;fullName();
}
</pre>
<p>
(<tt>iter()</tt> is pointer to the current module the iterator is at.)

<p>
The above method can also be used to iterate along a module
vector, since the <tt>name()</tt>
function returns the same for all modules:

<pre>
for (cSubModIterator iter(*parentModule()); !iter.end(); iter++)
{
  if (iter()-&gt;isName(name())) // if iter() is in the same
                              // vector as this module
  {
    int its_index = iter()-&gt;index();
    // do something to it
  }
}
</pre>
<p>

<p><STRONG>Walking along links</STRONG>

<p>
To determine the module at the other end of a connection, use
<tt>cGate</tt>'s <tt>fromGate()</tt>, <tt>toGate()</tt> and
<tt>ownerModule()</tt> functions. For example:

<pre>
cModule *neighbour = gate( "outputgate" )-&gt;toGate()-&gt;ownerModule();
</pre>
<p>

<p>For input gates, you would use <tt>fromGate()</tt> instead of <tt>toGate()</tt>.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec215"/>6.7. <FONTblue>Dynamic module creation</FONT></H2></font></hr>

<p><STRONG>Why</STRONG>

<p>
If you do not know how many modules you'll need, you can create
modules dynamically and dispose of them
when they are no longer needed. Both simple and compound modules
can be created this way. If you create a compound module dynamically,
all its submodules will be recursively built.

<p>
Let's suppose you are implementing a transport protocol for a
computer network model. It is convenient to have a separate module
to handle each connection. However, there's no way to know how
many connections there'll be simultaneously. The solution is
to create a manager module which receives connection requests
and creates a module for each connection. The Dyna example simulation
does something like this.

<p>It is often convenient to use direct message sending with dynamically
created modules.

<p>
<STRONG>Overview </STRONG>

<p>
To understand how dynamic module creation works, you have to know a
bit about how normally OMNeT++ instantiates modules. Each module type
(class) has a corresponding description object of the class
<tt>cModuleType</tt>. This object is created under the hood by the
<tt>Define_Module()</tt> macro, and it has a factory
function which can instantiate the module
class (this function basically only consists of a return new
<EM>module-class</EM>(...)  statement).

<p>The <tt>cModuleType</tt> object can be looked up by its name
string (which is the same as the module class name). Once you have its
pointer, it's possible to call its factory method and create an
instance of the corresponding module class - without having to
include the module's class declaration into your C++ file.

<p>
The <tt>cModuleType</tt> object also knows what gates and
parameters the given module type has to have. (This info comes from
compiled NED code.)

<p>
Simple modules can be created in one step. For a compound module, the
situation is more complicated, because its internal structure
(submodules, connections) may depend on parameter values and gate
vector sizes. Thus, for compound modules it is generally required to
set parameter values and gate vector sizes after creation of the
module itself, but before creating its submodules and internal
connections.

<p>
As you know already, simple modules with <tt>activity()</tt> need a
starter message. For statically created
modules, this message is created automatically by OMNeT++, but for
dynamically created modules, you have to do this explicitly by calling
the appropriate functions.

<p>
Calling <tt>initialize()</tt> has to take place after insertion of the
stater messages, because the initializing code may insert new messages
into the FES, and these messages should be processed
<EM>after</EM> the starter message.


<pre>
cModuleType *moduleType = findModuleType("TCPConnectionHandler");
</pre>
<p>

<p><STRONG>Simple form</STRONG>

<p>
Mainly for creating simple modules.


<tt>cModuleType</tt> has
\fname[createScheduleInit()]createScheduleInit(const char *name,
  cModule *parentmod) convenience function to get a module up and
running in one step.

<pre>
mod = modtype-&gt;createScheduleInit("name",this);
</pre>
<p>
It does <tt>create()</tt> + <tt>buildInside()</tt> + <tt>callInitialize()</tt> +
<tt>scheduleStart(now)</tt>.

<p>
Should work for both simple and compound modules.

<p>This method is not applicable if the module:
<UL>
  <li><strong></strong>has parameters to be set
  <li><strong></strong>has gate vector sizes to be set
  <li><strong></strong>has gates to be connected before <tt>initialize()</tt>
</UL>


<STRONG>Expanded form</STRONG>

<p>
If the previous simple form cannot be used. There are 5 steps:
<OL>
  <li><strong></strong>find descriptor object
  <li><strong></strong>create module
  <li><strong></strong>set up parameters and gate sizes (if needed)
  <li><strong></strong>call function that builds out submodules and finalizes the
    module
  <li><strong></strong>call function that creates activation message(s) for the new
    simple module(s)
</OL>
Each step (except for Step 3.) can be done with one line of code.

<p>

<p>See the following example where Step 3. is omitted:

<pre>
// find descriptor object
cModuleType *moduleType = findModuleType("TCPConnectionHandler");
// create (possibly compound) module and build its submodules (if any)
cModule *module = moduleType-&gt;create( "TCPconn", this );
module-&gt;buildInside();
// create activation message
module-&gt;scheduleStart( simTime() );
</pre>
<p>
If you want to set up parameter values or gate vector sizes (Step 3.),
the code goes between the <tt>create()</tt> and
<tt>buildInside()</tt> calls:

<pre>
cModuleType *moduleType = findModuleType("TCP-conn-handler");
cModule *module = moduleType-&gt;create( "TCPconn", this );
// set up parameters and gate sizes before we set up its submodules
module-&gt;par("window-size") = 4096;
module-&gt;setGateSize("to-apps", 3);
module-&gt;buildInside();
module-&gt;scheduleStart( simTime() );
</pre>
<p>

<p><STRONG>Deleting</STRONG>

<p>
To delete a module dynamically:

<pre>
module-&gt;deleteModule();
</pre>
<p>

<p>
If the module was a compound module, this involves recursively
destroying all its submodules. A simple module can also delete itself;
in this case, if the module was implemented using <tt>activity()</tt>,
the <tt>deleteModule()</tt> call does not return to the caller (the
reason is that deleting the module also deletes the CPU stack of the
coroutine).

<p>Currently, you cannot safely delete a
compound module from a simple module
in it; you must delegate the job to a module outside the compound
module.

<p>
<STRONG>Creating connections</STRONG>

<p>
There are two <tt>connect()</tt>-functions that you can use to connect
gates. For a normal user, they are useful for creating connections to
dynamically created modules.

<pre>
connect( cModule *src_module, int src_gatenumber,
         cLinkType *channeltype,
         cModule *dest_module, int dest_gatenumber );

connect( cModule *src_module, int src_gatenumber,
         cPar *delay, cPar *error, cPar *datarate,
         cModule *dest_module, int dest_gatenumber );
</pre>
<p>

<p>Any of the channeltype, delay, error and datarate pointers can
be NULL.

<p>An example:

<pre>
connect( this, findGate("out"),
         (cLinkType *)NULL,
         module, module-&gt;findGate("in",0) );
</pre>
<p>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec216"/>6.8. <FONTblue>Routing support: cTopology</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec217"/>6.8.1. <FONTteal>Overview</FONT></H3></font>

<p>The <tt>cTopology</tt> class was designed primarily to support
routing in telecommunication or multiprocessor
networks.

<p>A <tt>cTopology</tt> object stores an abstract representation of the
network in graph form:
<UL>
  <li><strong></strong>each <tt>cTopology</tt> node corresponds to a <EM>module</EM>
    (simple or compound), and
  <li><strong></strong>each <tt>cTopology</tt> edge corresponds to a <EM>link</EM> or
    <EM>series of connecting links</EM>.
</UL>

<p>You can specify which modules (either simple or compound) you want to
include in the graph. The graph will include all connections among the
selected modules. In the graph, all nodes are at the same level,
there's no submodule nesting.  Connections which span across compound
module boundaries are also represented as one graph edge. Graph edges
are directed, just as module gates are.

<p>
If you're writing a router or switch model, the <tt>cTopology</tt>
graph can help you determine what nodes are available through which
gate and also to find optimal routes. The
<tt>cTopology</tt> object can calculate shortest paths between nodes for you.

<p>The mapping between the graph (nodes, edges) and network model
(modules, gates, connections) is preserved: you can easily find
the corresponding module for a <tt>cTopology</tt> node and vica versa.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec218"/>6.8.2. <FONTteal>Basic usage</FONT></H3></font>

<p>You can extract the network topology into a <tt>cTopology</tt>
object by a single function call. You have several ways to select
which modules you want to include in the topology:
<UL>
  <li><strong></strong>by module type
  <li><strong></strong>by a parameter's presence and its value
  <li><strong></strong>with a user-supplied boolean function
</UL>

<p>First, you can specify which node types you want to include. The
following code extracts all modules of type Router or User. (Router
and User can be both simple and compound module types.)

<pre>
cTopology topo;
topo.extractByModuleType( "Router", "User", NULL );
</pre>
<p>

<p>Any number of module types (up to 32) can be supplied; the list
must be terminated by NULL.

<p>Second, you can extract all modules which have a certain parameter:

<pre>
topo.extractByParameter( "ip_address" );
</pre>
<p>

<p>You can also specify that the parameter must have a certain value
for the module to be included in the graph:

<pre>
cPar yes = "yes";
topo.extractByParameter( "include_in_topo", &yes );
</pre>
<p>
The third form allows you to pass a function which can determine for
each module whether it should or should not be included.  You can have
<tt>cTopology</tt> pass supplemental data to the function through a
void* pointer. An example which selects all top-level modules (and
does not use the void* pointer):

<pre>
int select_function(cModule *mod, void *)
{
  return mod-&gt;parentModule() == simulation.systemModule();
}

topo.extractFromNetwork( select_function, NULL );
</pre>
<p>

A <tt>cTopology</tt> object uses two types: <tt>sTopoNode</tt> for
nodes and <tt>sTopoLink</tt> for edges. (<tt>sTopo\-Link\-In</tt> and
<tt>sTopoLinkOut</tt> are 'aliases' for <tt>sTopoLink</tt>; we'll
speak about them later.)

<p>Once you have the topology extracted, you can start exploring
it. Consider the following code (we'll explain it shortly):

<pre>
for (int i=0; i&lt;topo.nodes(); i++)
{
  sTopoNode *node = topo.node(i);
  ev &lt;&lt; "Node i=" &lt;&lt; i &lt;&lt; " is " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
  ev &lt;&lt; " It has " &lt;&lt; node-&gt;outLinks() &lt;&lt; " conns to other nodes\n";
  ev &lt;&lt; " and " &lt;&lt; node-&gt;inLinks() &lt;&lt; " conns from other nodes\n";

  ev &lt;&lt; " Connections to other modules are:\n";
  for (int j=0; j&lt;node-&gt;outLinks(); j++)
  {
    sTopoNode *neighbour = node-&gt;out(j)-&gt;remoteNode();
    cGate *gate = node-&gt;out(j)-&gt;localGate();
    ev &lt;&lt; " " &lt;&lt; neighbour-&gt;module()-&gt;fullPath()
       &lt;&lt; " through gate " &lt;&lt; gate-&gt;fullName() &lt;&lt; endl;
  }
}
</pre>
<p>
The <tt>nodes()</tt> member function (1st line) returns the number of
nodes in the graph, and node(i) returns a pointer to the <EM>i</EM>th
node, an <tt>sTopoNode</tt> structure.

<p>
The correspondence between a graph node and a module can be obtained
by:

<pre>
sTopoNode *node = topo.nodeFor( module );
cModule *module = node-&gt;module();
</pre>
<p>

<p>The <tt>nodeFor()</tt> member function returns a pointer to the graph
node for a given module. (If the module is not in the graph, it
returns NULL). <tt>nodeFor()</tt> uses binary search within the
<tt>cTopology</tt> object so it is fast enough.

<p>
<tt>sTopoNode</tt>'s other member functions let you determine the
connections of this node: <tt>inLinks()</tt>, <tt>outLinks()</tt> return
the number of connections, <tt>in(i)</tt> and
<tt>out(i)</tt> return pointers to graph edge objects.

<p>
By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <tt>remoteNode()</tt>
function returns the other end of the connection, and
<tt>localGate()</tt>, <tt>remoteGate()</tt>, <tt>localGateId()</tt> and
<tt>remoteGateId()</tt> return the gate pointers and ids of the gates
involved. (Actually, the implementation is a bit tricky here: the same
graph edge object <tt>sTopoLink</tt> is returned either as
<tt>sTopoLinkIn</tt> or as <tt>sTopoLinkOut</tt> so that ''remote''
and ''local'' can be correctly interpreted for edges of both
directions.)

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec219"/>6.8.3. <FONTteal>Shortest paths</FONT></H3></font>

<p>The real power of <tt>cTopology</tt> is in finding shortest
paths in the network to support optimal
routing. <tt>cTopology</tt> finds shortest paths
from <EM>all</EM> nodes <EM>to</EM> a target node. The algorithm is
computationally inexpensive. In the simplest case, all edges are
assumed to have the same weight.

<p>A real-life example when we have the target module pointer, finding
the shortest path looks like this:

<pre>
cModule *targetmodulep =...;
sTopoNode *targetnode = topo.nodeFor( targetmodulep );
topo.unweightedSingleShortestPathsTo( targetnode );
</pre>
<p>

<p>This performs the Dijkstra algorithm and
stores the result in the <tt>cTopology</tt> object. The result can
then be extracted using <tt>cTopology</tt> and
sTopoNode methods.  Naturally, each call to
<tt>unweightedSingleShortestPathsTo()</tt> overwrites the results of
the previous call.

<p>Walking along the path from our module to the target node:

<pre>
sTopoNode *node = topo.nodeFor( this );

if (node == NULL)
{
  ev &lt; "We (" &lt;&lt; fullPath() &lt;&lt; ") are not included in the topology.\n";
}
else if (node-&gt;paths()==0)
{
  ev &lt;&lt; "No path to destination.\n";
}
else
{
  while (node != topo.targetNode())
  {
    ev &lt;&lt; "We are in " &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;
    ev &lt;&lt; node-&gt;distanceToTarget() &lt;&lt; " hops to go\n";
    ev &lt;&lt; "There are " &lt;&lt; node-&gt;paths()
       &lt;&lt; " equally good directions, taking the first one\n";
    sTopoLinkOut *path = node-\texttt{&gt;}path(0);
    ev &lt;&lt; "Taking gate " &lt;&lt; path-&gt;localGate()-&gt;fullName()
       &lt;&lt; " we arrive in " &lt;&lt; path-&gt;remoteNode()-&gt;module()-&gt;fullPath()
       &lt;&lt; " on its gate " &lt;&lt; path-&gt;remoteGate()-&gt;fullName() &lt;&lt; endl;
    node = path-&gt;remoteNode();
  }
}
</pre>
<p>

<p>The purpose of the <tt>distanceToTarget()</tt> member function of a
node is self-explanatory. In the unweighted case, it returns the
number of hops. The <tt>paths()</tt> member function returns the number
of edges which are part of a shortest path, and
<tt>path(i)</tt> returns the <EM>i</EM>th edge of them as
<tt>sTopoLinkOut</tt>. If the shortest paths were created by the
<tt>...SingleShortestPaths()</tt> function,
<tt>paths()</tt> will always return 1 (or 0 if the target is not
reachable), that is, only one of the several possible shortest paths
are found.  The
<tt>...MultiShortestPathsTo()</tt> functions
find all paths, at increased run-time cost. The <tt>cTopology</tt>'s
<tt>targetNode()</tt> function returns the target node of the last
shortest path search.

<p>You can enable/disable nodes or edges in the graph. This is done by
calling their <tt>enable()</tt> or <tt>disable()</tt> member functions.
Disabled nodes or edges are ignored by the shortest paths calculation
algorithm. The <tt>enabled()</tt> member function returns the state of
a node or edge in the topology graph.

<p>One usage of <tt>disable()</tt> is when you want to determine in how many
hops the target node can be reached from our node <EM>through
a particular output gate</EM>. To calculate this, you calculate the
shortest paths to the target <EM>from the neighbor node</EM>, but
you must disable the current node to prevent the shortest paths
from going through it:

<pre>
sTopoNode *thisnode = topo.nodeFor( this );
thisnode-&gt;disable();
topo.unweightedSingleShortestPathsTo( targetnode );
thisnode-&gt;enable();

for (int j=0; j&lt;thisnode-&gt;outLinks(); j++)
{
  sTopoLinkOut *link = thisnode-&gt;out(i);
  ev &lt;&lt; "Through gate " &lt;&lt; link-&gt;localGate()-&gt;fullName() &lt;&lt; " : "
     &lt;&lt; 1 + link-&gt;remoteNode()-&gt;distanceToTarget() &lt;&lt; " hops" &lt;&lt; endl;
}
</pre>
<p>
In the future, other shortest path algorithms will also be implemented:

<pre>
unweightedMultiShortestPathsTo(sTopoNode *target);
weightedSingleShortestPathsTo(sTopoNode *target);
weightedMultiShortestPathsTo(sTopoNode *target);
</pre>
<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec220"/>6.9. <FONTblue>Generating random numbers</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec221"/>6.9.1. <FONTteal>Random number generators</FONT></H3></font>

<p>Having high quality random numbers is usually
very important in simulation programs. The random number generator
used in OMNeT++ is a linear congruential generator\indexlinear
  congruential generator (LCG) with a cycle length of $2^31-2$. The
startup code of OMNeT++ contains code that checks if the random number
generator works OK, so you do not have to worry about this if you port
the simulator to a new architecture or use a different compiler.

<p>
If a simulation program uses random numbers for more than one purpose,
the numbers should come from different random number generators.
OMNeT++ provides several independent random number generators (by
default 32; this number is #defined as
<tt>NUM_RANDOM_GE\-NE\-RA\-TORS</tt> in utils.h).

<p>
To avoid unwanted correlation, it is also important that different
simulation runs and different random number sources within one
simulation run use non-overlapping series of random numbers,
so the generators should be started with seeds well apart. For
selecting good seeds, the seedtool program can be used (it is
documented later).

<p>The random number generator was taken from [JAIN91, pp. 441-444,455].
It has the following properties:
<UL>
<li><strong></strong>Range: ... 2^31-2$
<li><strong></strong>Period length: ^31-2$
<li><strong></strong>Method: $x := (x * 7^5) mod (2^31-1)$
<li><strong>To check: if $x[0]</strong>=1$ then $x[10000]=1,043,618,065$
<li><strong></strong>Required hardware: exactly 32-bit integer arithmetics
</UL>

<p>The concrete implementation:

<pre>
long intrand()
{
  const long int a=16807, q=127773, r=2836;
  seed=a*(seed%q) - r*(seed/q);
  if (seed&lt;=0) seed+=INTRAND_MAX;
  return seed;
}
</pre>
<p>

<p>The generator is directly accessible through the <tt>intrand()</tt> function:

<pre>
long rnd = intrand();   // in the range 1..INTRAND\_MAX-1
</pre>
<p>
The random number seed can be specified in the ini file
(<tt>random-seed=</tt>) or set directly from within
simple modules with the <tt>randseed()</tt>
function:

<pre>
randseed( 10 );         // set seed to 10
long seed = randseed(); // current seed value
</pre>
<p>

<p>Zero is not allowed as a seed.

<p>
The <tt>intrand()</tt> and <tt>randseed()</tt> functions use generator 0. They have
another variant which uses a specified generator:

<pre>
long rnd = genk_intrand(6); // like intrand(), using generator 6
genk_randseed( k, 167 );    // set seed of generator k to 167
</pre>
<p>

<p>The <tt>intrand(n)</tt> and <tt>dblrand()</tt> functions are based on <tt>intrand()</tt>:

<pre>
int dice = 1 + intrand(6); // result of intrand(6) is in the range 0..5
                           // (it is calculated as intrand()%6)

double prob = dblrand();   // dblrand() produces numbers in [0,1)
                           // calculated as
                           // intrand()/(double)INTRAND_MAX
</pre>
<p>

<p>They also have their counterparts that use generator $k$:

<pre>
int dice = 1 + genk_intrand(k,6); // uses generator k
double prob = genk_dblrand(k);    // ""
</pre>
<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec222"/>6.9.2. <FONTteal>Random variates</FONT></H3></font>

<p>The following functions are based on <tt>dblrand()</tt> and return
random variables of different distributions:

<p>Random variate functions use one of the random number generators (RNGs)
provided by OMNeT++. By default this is generator 0, but you can specify
which one to be used.

<p>OMNeT++ has the following predefined distributions:

<p><table border>
<TR> <TD align=left>
<b>Function</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>Continuous distributions</b></TD></TR>
<TR> <TD align=left> <tt>uniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform distribution in the range [a,b) </TD></TR>
<TR> <TD align=left> <tt>exponential(mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> exponential distribution with the given mean </TD></TR>
<TR> <TD align=left> <tt>normal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution with the given mean and standard deviation </TD></TR>
<TR> <TD align=left> <tt>truncnormal(mean, stddev, <EM>rng=0</tt>)</EM> </TD> <TD align=left> normal distribution truncated to nonnegative values </TD></TR>
<TR> <TD align=left> <tt>gamma_d(alpha, beta, <EM>rng=0</tt>)</EM> </TD> <TD align=left> gamma distribution with parameters alpha&gt;0, beta&gt;0 </TD></TR>
<TR> <TD align=left> <tt>beta(alpha1, alpha2, <EM>rng=0</tt>)</EM> </TD> <TD align=left> beta distribution with parameters alpha1&gt;0, alpha2&gt;0 </TD></TR>
<TR> <TD align=left> <tt>erlang_k(k, mean, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Erlang distribution with k&gt;0 phases and the given mean </TD></TR>
<TR> <TD align=left> <tt>chi_square(k, <EM>rng=0</tt>)</EM> </TD> <TD align=left> chi-square distribution with k&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>student_t(i, <EM>rng=0</tt>)</EM> </TD> <TD align=left> student-t distribution with i&gt;0 degrees of freedom </TD></TR>
<TR> <TD align=left> <tt>cauchy(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Cauchy distribution with parameters a,b where b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>triang(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> triangular distribution with parameters a&lt;=b&lt;=c, a!=c </TD></TR>
<TR> <TD align=left> <tt>lognormal(m, s, rng=0)</tt> </TD> <TD align=left> lognormal distribution with mean m and variance s&gt;0 </TD></TR>
<TR> <TD align=left> <tt>weibull(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Weibull distribution with parameters a&gt;0, b&gt;0 </TD></TR>
<TR> <TD align=left> <tt>pareto_shifted(a, b, c, <EM>rng=0</tt>)</EM> </TD> <TD align=left> generalized Pareto distribution with parameters a, b and shift c </TD></TR>
<TR> <TD align=center colspan=2><b>Discrete distributions</b> </TD></TR>
<TR> <TD align=left> <tt>intuniform(a, b, <EM>rng=0</tt>)</EM> </TD> <TD align=left> uniform integer from a..b </TD></TR>
<TR> <TD align=left> <tt>bernoulli(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> result of a Bernoulli trial with probability 0&lt;=p&lt;=1 (1 with probability p and 0 with probability (1-p)) </TD></TR>
<TR> <TD align=left> <tt>binomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;=0 and 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>geometric(p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> geometric distribution with parameter 0&lt;=p&lt;=1 </TD></TR>
<TR> <TD align=left> <tt>negbinomial(n, p, <EM>rng=0</tt>)</EM> </TD> <TD align=left> binomial distribution with parameters n&gt;0 and 0&lt;=p&lt;=1</TD></TR>
<TR> <TD align=left> <tt>poisson(lambda, <EM>rng=0</tt>)</EM> </TD> <TD align=left> Poisson distribution with parameter lambda </TD></TR>
<TR> <TD align=left> 
</table>

<p>
They are the same functions that can be used in NED files.
<tt>intuniform()</tt> generates integers including both the lower and
upper limit, so for example the outcome of tossing a coin could be
written as intuniform(1,2).  <tt>truncnormal()</tt> is the normal
distribution truncated to nonnegative values; its implementation
generates a number with normal distribution and if the result is
negative, it keeps generating other numbers until the outcome is
nonnegative.

<p>If the above distributions do not suffice, you can write your own
functions. If you register your functions
with the <tt>Register_Function()</tt> macro, you can use them in NED
files and ini files too.

<p>
<font color="#006f00"><H3><A NAME="sec223"/>6.9.3. <FONTteal>Random numbers from histograms</FONT></H3></font>

<p>You can also specify your distribution as a
histogram. The
<tt>cLongHistogram</tt>, <tt>cDoubleHistogram</tt>,
<tt>cVarHistogram</tt>, <tt>cKSplit</tt> or <tt>cPSquare</tt> classes
are there to generate random numbers from equi\-dis\-tant-cell or
equiprobable-cell histograms.  This feature is documented later, with
the statistical classes.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec224"/>6.10. <FONTblue>Container classes</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec225"/>6.10.1. <FONTteal>Queue class: cQueue</FONT></H3></font>

<p><STRONG>Basic usage</STRONG>

<p>
<tt>cQueue</tt> is a container class that acts as a queue.
<tt>cQueue</tt> can hold objects of type derived from <tt>cObject</tt>
(almost all classes from the OMNeT++ library), such as
<tt>cMessage</tt>, <tt>cPar</tt>, etc. Internally, <tt>cQueue</tt>
uses a double-linked list to store the elements.

<p>As an example of use, the simple modules'
put-aside queues (<tt>putAsideQueue</tt> member) are <tt>cQueues</tt>
which store <tt>cMessage</tt> objects. (However, the Future Event Set
[FES] is not a <tt>cQueue</tt>; it is implemented with heap
[class <tt>cMessageHeap</tt>] because it is a lot more efficient.)

<p>A queue object has a head and a tail. Normally, new elements
are inserted at its head and elements are removed at its tail.

<p>

<p>  <DIV ALIGN=center>
    <img src="usmanFig10.gif">
    <center><i>Figure: What is what with cQueue</i></center>
    <a name="fig:ch-sim-lib:cqueue"/>
  </DIV>

<p>
The basic <tt>cQueue</tt> member functions dealing with insertion and removal
are <tt>insert()</tt> and <tt>pop()</tt>. They are used
like this:

<pre>
cQueue queue("my-queue");
cMessage *msg;

// insert messages
for (int i=0; i&lt;10; i++)
{
  msg = new cMessage;
  queue.insert( msg );
}

// remove messages
while( ! queue.empty() )
{
  msg = (cMessage *)queue.pop();
  delete msg;
}
</pre>
<p>

<p>The <tt>length()</tt> member function returns the number of items in the
queue, and <tt>empty()</tt> tells whether there's anything in the queue.

<p>There are other functions dealing with insertion and removal.  The
<tt>insertBefore()</tt> and <tt>insertAfter()</tt> functions insert a
new item exactly before and after a specified one, regardless of the
ordering function.

<p>The <tt>tail()</tt> and <tt>head()</tt> functions return pointers to the objects
at the tail and head of the queue, without affecting queue contents.

<p>

<p>The <tt>pop()</tt> function can be used to remove items from the
tail of the queue, and the <tt>remove()</tt> function can be
used to remove any item known by its pointer from the queue:

<p>
<tt>queue.remove( msg );</tt>

<p>

<p><STRONG>Priority queue</STRONG>

<p>
By default, <tt>cQueue</tt> implements a FIFO, but it can also act as
a priority queue, that is, it can keep the inserted objects
ordered.  If you want to use this feature, you have
to provide a function that takes two <tt>cObject</tt> pointers,
compares the two objects and returns -1, 0 or 1 as the result (see the
reference for details).  An example of setting up an ordered
<tt>cQueue</tt>:

<pre>
cQueue sortedqueue("sortedqueue", cObject::cmpbyname, true );
                        // sorted by object name, ascending
</pre>
<p>

<p>If the queue object is set up as an ordered queue, the <tt>insert()</tt>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there.

<p>
<STRONG>Iterators</STRONG>

<p>
Normally, you can only access the objects at the head or tail of the
queue. However, if you use an iterator class, <tt>cQueueIterator</tt>,
you can examine each object in the queue.

<p>The <tt>cQueueIterator</tt> constructor takes two arguments, the first
is the queue object and the second one specifies the initial position
of the iterator: 0=tail, 1=head. Otherwise it acts as any other
OMNeT++ iterator class: you can use the ++ and - operators to advance
it, the () operator to get a pointer to the current item, and the
<tt>end()</tt> member function to examine if you're at the end (or the
beginning) of the queue.

<p>
An example:

<pre>
for( cQueueIterator iter(queue,1); !iter.end(), iter++)
{
  cMessage *msg = (cMessage *) iter();
  //...
}
</pre>
<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec226"/>6.10.2. <FONTteal>Expandable array: cArray</FONT></H3></font>

<p><STRONG>Basic usage</STRONG>

<p>
<tt>cArray</tt> is a container class that holds objects derived from
<tt>cObject</tt>. <tt>cArray</tt> stores the pointers of the objects
inserted instead of making copies. <tt>cArray</tt> works as an array,
but if it gets full, it grows automatically. Internally,
<tt>cArray</tt> is implemented with an array of pointers; if the array
gets full, it is reallocated.

<p><tt>cArray</tt> objects are used in OMNeT++ to store parameters
attached to messages, and internally, for storing module parameters
and gates.

<p>
Creating an array:

<pre>
cArray array("array");
</pre>
<p>
Adding an object at the first free index:

<pre>
cPar *p = new cPar("par");
int index = array.add( p );
</pre>
<p>

<p>Adding an object at a given index (if the index is occupied,
you'll get an error message):

<pre>
cPar *p = new cPar("par");
int index = array.addAt(5,p);
</pre>
<p>

<p>Finding an object in the array:

<pre>
int index = array.find(p);
</pre>
<p>
Getting a pointer to an object at a given index:

<pre>
cPar *p = (cPar *) array[index];
</pre>
<p>
You can also search the array or get a pointer to an object by
the object's name:

<pre>
int index = array.find("par");
Par *p = (cPar *) array["par"];
</pre>
<p>

<p>You can remove an object from the array by calling <tt>remove()</tt>
with the object name, the index position or the object pointer:

<pre>
array.remove("par");
array.remove(index);
array.remove( p );
</pre>
<p>

<p>The <tt>remove()</tt> function doesn't deallocate the object, but it
returns the object pointer. If you also want to deallocate it, you can
write:

<pre>
delete array.remove( index );
</pre>
<p>
<STRONG>Iteration</STRONG>

<p>
<tt>cArray</tt> has no iterator, but it's easy to loop through all the
indices with an integer variable. The <tt>items()</tt> member function
returns the largest index plus one.

<pre>
for (int i=0; i&lt;array.items(); i++)
{
  if (array[i]) // is this position used?
  {
    cObject *obj = array[i];
    ev &lt;&lt; obj-&gt;name() &lt;&lt; endl;
  }
}
</pre>
<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec227"/>6.11. <FONTblue>Non-object container classes</FONT></H2></font></hr>

<p>There are two container classes to store non-object
items: <tt>cLinkedList</tt> and
<tt>cBag</tt>.  The first one parallels with <tt>cQueue</tt>, the
second one with <tt>cArray</tt>. They can be useful if you have to
deal with C structs or objects that are not derived from
<tt>cObject</tt>.

<p>See the class library reference for more info about them.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec228"/>6.12. <FONTblue>The parameter class: cPar</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec229"/>6.12.1. <FONTteal>Basic usage</FONT></H3></font>

<p><tt>cPar</tt> is a class that is designed to hold a value. The value
is numeric (long or double) in the first place, but string, pointer
and other types are also supported.

<p>cPar is used in OMNeT++ in the following places:

<p><UL>
  <li><strong></strong>as module parameters
  <li><strong></strong>as message parameters
</UL>

<p>There are many ways to set a <tt>cPar</tt>'s value. One is the set...Value()
member functions:

<pre>
cPar pp("pp");
pp.setDoubleValue(1.0);
</pre>
<p>

<p>or by using overloaded operators:

<pre>
cPar pp("pp");
pp = 1.0;
</pre>
<p>

<p>For reading its value, it is best to use overloaded type cast
operators:

<pre>
double d1 = (double)pp;
// or simply:
double d2 = pp;
</pre>
<p>
Long integers:

<pre>
pp = 89363L; // or:
pp.setLongValue( 89363L );
</pre>
<p>
Character string:

<pre>
pp = "hi there"; // or:
pp.setStringValue( "hi there" );
</pre>
<p>

<p>The <tt>cPar</tt> object makes its own copy of the string, so the
original one does not need to be preserved. Short strings (less than
<IT>~</IT>20 chars) are handled more efficiently because they
are stored in the object's memory space (and are not dynamically
allocated).

<p>There are several other types <tt>cPar</tt> can store: such as boolean,
void* pointer; cObject* pointer,  function with constant args;
they will be mentioned in the next section.

<p>For numeric and string types, an input flag can be
set. In this case, when the object's value is first used, the
parameter value will be searched for in the configuration (ini)
file; if it is not found there, the user will be given
a chance to enter the value interactively.

<p>
Examples:

<pre>
cPar inp("inp");
inp.setPrompt("Enter my value:");
inp.setInput( true );   // make it an input parameter
double a = (double)inp; // the user will be prompted HERE
</pre>
<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec230"/>6.12.2. <FONTteal>Random number generation through cPar</FONT></H3></font>

<p>Setting <tt>cPar</tt> to call a function with constant arguments can
be used to make <tt>cPar</tt> return random variables of different distributions:

<pre>
cPar rnd("rnd");
rnd.setDoubleValue(intuniform, -10.0, 10.0);// uniform distr.
rnd.setDoubleValue(normal, 100.0, 5.0); // normal distr. (mean,dev)
rnd.setDoubleValue(exponential, 10.0); // exponential distr. (mean)
</pre>
<p>
<tt>intuniform()</tt>, <tt>normal()</tt> etc. are ordinary C functions
taking double arguments and returning double. Each time you read the
value of a <tt>cPar</tt> containing a function like above, the
function will be called with the given constant arguments (e.g.
normal(100.0,5.0)) and its return value used.

<p>
The above functions use number 0 from the several random number
generators. To use another generator, use the genk_xxx versions
of the random functions:

<pre>
rnd.setDoubleValue(genk\_normal, 3, 100.0, 5.0); // uses generator 3
</pre>
<p>
A <tt>cPar</tt> object can also be set to return a random variable from
a distribution collected by a statistical data collection object:

<pre>
cDoubleHistogram hist =....; // the distribution
cPar rnd2("rnd2");
rnd2.setDoubleValue(hist);
</pre>
<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec231"/>6.12.3. <FONTteal>Storing object and non-object pointers in cPar</FONT></H3></font>

<p><tt>cPar</tt> can store pointers to OMNeT++ objects. You can use both
assignment and the <tt>setObjectValue()</tt> member function:

<pre>
cQueue *queue = new cQueue("queue"); // just an example
cPar par1, par2;
par1 = (cObject *) queue;
par2.setObjectValue( queue );
</pre>
<p>
To get the store pointer back, you can use typecast or the <tt>objectValue()</tt>
member function:

<pre>
cQueue *q1 = (cQueue *)(cObject *)par1;
cQueue *q2 = (cQueue *)par2.objectValue();
</pre>
<p>

<p>Whether the <tt>cPar</tt> object will own the other object or not is
controlled by the <tt>takeOwnership()</tt> member
function, just as with container classes. This is documented in detail
in the class library reference.  By default, <tt>cPar</tt> will own
the object.

<p><tt>cPar</tt> can be used to store non-object
pointers (for example C structs) or
non-OMNeT++ object types in the parameter object.  It works very
similarly to the above mechanism. An example:

<pre>
double *mem = new double[15];
cPar par1, par2;
par1 = (void *) mem;
par2.setPointerValue( (void *)mem );
...
double *m1 = (double *)(void *)par1;
double *m2 = (double *)par2.pointerValue();
</pre>
<p>

<p>Memory management can be specified by
<tt>cPar</tt>'s <tt>configPointer()</tt> member function. It takes
three arguments: a pointer to a user-supplied deallocation
function, a pointer to a user-supplied duplication function and
an item size. If all three are 0 (NULL), no memory management is done,
that is, the pointer is treated as a mere pointer. This is the default
behaviour. If you supply only the item size (and both function
pointers are NULL), <tt>cPar</tt> will use the delete operator to
deallocate the memory area when the <tt>cPar</tt> object is
destructed, and it will use new char[size] followed by a
<tt>memcpy()</tt> to duplicate the memory area whenever the
<tt>cPar</tt> object is duplicated. If you need more sophisticated
memory management, you can supply your own deallocation and
duplication functions.  All this is documented in detail in the class
library reference.  An example for simple memory management:

<pre>
double *mem = new double[15];
cPar par;
par.setPointerValue((void *) mem);
par.configPointer(NULL, NULL, 15*sizeof(double));
// -&gt; now if par goes out of scope, it will delete the 15-double array.
</pre>
<p>
The <tt>configPointer()</tt> setting only affects what happens when the
<tt>cPar</tt> is deleted, duplicated or copied, but does <EM>not</EM>
apply to assigning new pointers. That is, if <EM>you</EM> assign a new
void* to the <tt>cPar</tt>, you simply overwrite the pointer - the
block denoted by the old pointer is <EM>not</EM> deleted. This fact
can be used to extract some dynamically allocated block out of the
<tt>cPar</tt>: carrying on the previous example, you would extract the
array of 15 doubles from the <tt>cPar</tt> like this:

<pre>
double *mem2 = (double *)par.pointerValue();
par.setValue( (void *)0 );
// -&gt; now par has nothing to do with the double[15] array
</pre>
<p>

<p>
However, if you assign some non-pointer value
to the <tt>cPar</tt>, beware: this <EM>will</EM> activate the memory
management for the block. If you temporarily use the same
<tt>cPar</tt> object to store other than void* ('P') values, the
<tt>configPointer()</tt> setting is lost.

<p>

<p><font color="#006f00"><H3><A NAME="sec232"/>6.12.4. <FONTteal>Reverse Polish expressions</FONT></H3></font>

<p>This feature is rarely needed by the user, it is more used internally.
A <tt>cPar</tt> object can also store
expressions. In this case, the expression must
be given in reversed Polish form. An
example:

<pre>
sXElem *expression = new sXElem[5];
expression[0] = &par( ''count'' ); // pointer to
module parameter
expression[1] = 1;
expression[2] = '+';
expression[3] = 2;
expression[4] = '/';

cPar expr("expr");
expr.setDoubleValue(expression,5);
</pre>
<p>

<p>The <tt>cPar</tt> object created above contains the $(count+1)/2$
expression where <EM>count</EM> is a module parameter. Each time the
<tt>cPar</tt> is evaluated, it recalculates the expression, using the
current value of count. Note the &amp; sign in front of
<SAMP>par(''count'')</SAMP> expression: if it was not there, the parameter
would be taken by value, evaluated once and
then the resulting constant would be used.

<p>Another example is a distribution with mean and
standard deviation given by module parameters:

<pre>
sXElem *expression = new sXElem[3];
expression[0] = &par("mean");
expression[1] = &par("stddev");
expression[2] = normal; // pointer to the normal(double,double) func.

cPar expr("expr");
expr.setDoubleValue(expression,3);
</pre>
<p>

<p>For more information, see the reference and the code NEDC generates
for parameter expressions.

<p>

<p><font color="#006f00"><H3><A NAME="sec233"/>6.12.5. <FONTteal>Using redirection</FONT></H3></font>

<p>A <tt>cPar</tt> object can be set to stand for a value actually stored
in another <tt>cPar</tt> object. This is called <EM>indirect</EM> or
<EM>redirected</EM> value. When using redirection,
every operation on the value (i.e.  reading or changing it) will be
actually done to the other <tt>cPar</tt> object:

<p>
  <DIV ALIGN=center>
    <img src="usmanFig11.gif">
    <center><i>Figure: cPar redirection</i></center>
    <a name="fig:ch-sim-lib:cPar-redirection"/>
  </DIV>

<p>
Redirection is how module parameters taken by
reference are implemented.  The
redirection does not include name strings. That is, if you say
A-<SAMP>&gt;</SAMP>setName(''newname'') in the above example, A's name will
be changed as the name member is not redirected. (This is natural if
you consider parameters taken by reference: a parameter should/can
have different name than the value it refers to.)

<p>
You create a redirection with the <tt>setRedirection()</tt> function:

<pre>
cPar *bb = new cPar("bb"); // background value
bb = 10L;
cPar a("a"); // we'll redirect this object

a.setRedirection(bb); // create redirection
</pre>
<p>

<p>Now every operation you do on a's value will be done to bb:

<pre>
long x = a; // returns bb's value, 10L
a = 5;      // bb's value changes to 5
</pre>
<p>

<p>The only way to determine whether a is really holding the value or it
is redirected to another <tt>cPar</tt> is to use the
<tt>isRedirected()</tt> member function which returns a bool, or
<tt>redirection()</tt> which returns the pointer to the background
object, or NULL if there's no redirection:

<pre>
cPar *redir = a.redirection(); // returns bb's pointer
if (redir != NULL)
  ev &lt;&lt; "a is redirected to " &lt;&lt; redir-&gt;name() &lt;&lt; endl;
</pre>
<p>

<p>To break the link between the two objects, use the
<tt>cancelRedirection()</tt> member function. (No other method will
work, including assigning a the value of another <tt>cPar</tt>
object.) The <tt>cancelRedirection()</tt> function gives the <SAMP>(long)0</SAMP>
value to the redirected object (the other will be unaffected). If you
want to cancel the indirection but keep the old value, you can do
something like this:

<pre>
cPar *value = a.redirection();  // bb's pointer
a.cancelRedirection();          // break the link; value of a is now 0
a = *value;                     // copy the contents of bb into a
</pre>
<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec234"/>6.12.6. <FONTteal>Type characters</FONT></H3></font>

<p>Internally, <tt>cPar</tt> objects identify the types of the stored values
by type characters. The type character is returned by the <tt>type()</tt>
member function:

<pre>
cPar par = 10L;
char typechar = par.type(); // returns 'L'
</pre>
<p>
The full table of type characters is presented in the <EM>Summary</EM>
section below.

<p>The <tt>isNumeric()</tt> function tells whether the object
stores one of the numeric types, so that e.g. <tt>asDoubleValue()</tt>
can be invoked on it.

<p>

<p>
<font color="#006f00"><H3><A NAME="sec235"/>6.12.7. <FONTteal>Summary</FONT></H3></font>

<p>The various <tt>cPar</tt> types and the member functions used to manipulate them are summarized
in the following table:

<p><table border>
<TR> <TD align=left>

<STRONG>Type<br>
char</STRONG> </TD> <TD align=left>
<STRONG>Type <br>
name</STRONG> </TD> <TD align=left>
<STRONG>Member functions</STRONG> </TD> <TD align=left>
<STRONG>Description</STRONG></TD></TR>
<TR> <TD align=left>
S </TD> <TD align=left>  string </TD> <TD align=left>
<tt>setStringValue( <br>
  const char *); <br>
const char * <br>
 <tt>stringValue()</tt>; <br>
op const char *(); <br>
op=(const char *);</tt> </TD> <TD align=left>

string value. Short strings (len<SAMP>&lt;</SAMP>=27) are stored inside
<tt>cPar</tt> object, without using heap allocation.</TD></TR>
<TR> <TD align=left> B </TD> <TD align=left>  boolean </TD> <TD align=left>
<tt>setBoolValue(bool); <br>
bool <tt>boolValue()</tt>; <br>
op <tt>bool()</tt>; <br>
op=(bool);</tt> </TD> <TD align=left>
boolean value. Can also be retrieved from the object as long  (0 or 1).</TD></TR>
<TR> <TD align=left> L </TD> <TD align=left> long int </TD> <TD align=left>
<tt>setLongValue(long); <br>
long <tt>longValue()</tt>; <br>
op <tt>long()</tt>; <br>
op=(long);</tt> </TD> <TD align=left>
signed long integer value. Can also be retrieved from the object
as double.</TD></TR>
<TR> <TD align=left> D </TD> <TD align=left> double </TD> <TD align=left>
<tt>setDoubleValue(double); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
op=(double);</tt> </TD> <TD align=left>
double-precision floating point value.</TD></TR>
<TR> <TD align=left> F </TD> <TD align=left> function </TD> <TD align=left>
<tt>setDoubleValue( <br>
 MathFunc, <br>
 [double], <br>
 [double], <br>
 [double]); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
Mathematical function with constant arguments. The function
is given by its pointer; it must take 0,1,2 or 3 doubles and
return a double. This type is mainly used to generate random
numbers: e.g. the function takes mean and standard deviation
and returns random variable of a certain distribution.</TD></TR>
<TR> <TD align=left> X </TD> <TD align=left> expr. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 sXElem*,int); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>;</tt>
</TD> <TD align=left>
Reverse Polish expression. Expression can contain constants,
<tt>cPar</tt> objects, refer to other <tt>cPars</tt> (e.g. module parameters),
can use many math operators (+-*/^ 0.000000e+000tc), function calls
(function must take 0,1,2 or 3 doubles and return a double).
The expression must be given is in an sXElem array (see later).</TD></TR>
<TR> <TD align=left> T </TD> <TD align=left> distrib. </TD> <TD align=left>
<tt>setDoubleValue( <br>
 <tt>cStatistic</tt>*); <br>
double <tt>doubleValue()</tt>; <br>
op <tt>double()</tt>; <br>
</tt> </TD> <TD align=left>
random variable generated from a distribution collected by a
statistical data collection object (derived from <tt>cStatistic</tt>).</TD></TR>
<TR> <TD align=left> P </TD> <TD align=left> void* pointer </TD> <TD align=left>
<tt>setPointerValue(void*); <br>
void *<tt>pointerValue()</tt>; <br>
op void *(); <br>
op=(void *);</tt> </TD> <TD align=left>
pointer to a non-<tt>cObject</tt> item (C struct, non-<tt>cObject</tt> object
etc.) Memory management can be controlled through the <tt>configPointer()</tt>
member function.</TD></TR>
<TR> <TD align=left> O </TD> <TD align=left> object pointer </TD> <TD align=left>
<tt>setObjectValue(cObject*); <br>
cObject *<tt>objectValue()</tt>; <br>
op cObject *(); <br>
op=(cObject *);</tt>
</TD> <TD align=left>
 pointer to an object derived from <tt>cObject</tt>.</TD></TR>
<TR> <TD align=left> Ownership management is done through <tt>takeOwnership()</tt>.</TD></TR>
<TR> <TD align=left> I </TD> <TD align=left> indirect value </TD> <TD align=left>
<tt>setRedirection(cPar*); <br>
bool <tt>isRedirected()</tt>; <br>
cPar *<tt>redirection()</tt>; <br>
<tt>cancelRedirection()</tt>;</tt>
</TD> <TD align=left>
 value is redirected to another <tt>cPar</tt> object. All value setting
and reading operates on the other <tt>cPar</tt>; even the <tt>type()</tt> function
will return the type in the other <tt>cPar</tt> (so you'll never get 'I'
as the type). This redirection can only be broken with the <tt>cancelRedirection()</tt>
member function.</TD></TR>
<TR> <TD align=left> Module parameters taken by REF use this mechanism.</TD></TR>
</table>

<p>

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec236"/>6.13. <FONTblue>Statistics and distribution estimation</FONT></H2></font></hr>

<p><H3><A NAME="sec237"/>6.13.1. <FONTteal>
cStatistic and descendants</FONT></H3>

<p>There are several statistic and result collection classes:
<tt>cStdDev</tt>, <tt>cWeightedStdDev</tt>, <tt>Long\-Histogram</tt>,
<tt>cDoubleHistogram</tt>, <tt>cVarHistogram</tt>, <tt>cPSquare</tt> and
<tt>cKSplit</tt>. They are all derived from the abstract base class
<tt>cStatistic</tt>.

<p><UL>
  <li><strong></strong><tt>cStdDev</tt> keeps number of samples, mean, standard
    deviation, minimum and maximum value etc.
  <li><strong></strong><tt>cWeightedStdDev</tt> is similar to <tt>cStdDev</tt>, but
    accepts weighted observations. <tt>cWeightedStdDev</tt> can be used
    for example to calculate time average. It is the only weighted
    statistics class.
  <li><strong></strong><tt>cLongHistogram</tt> and <tt>cDoubleHistogram</tt> are
    descendants of <tt>cStdDev</tt> and also keep an approximation of
    the distribution of the observations using equidistant
    (equal-sized) cell histograms.
  <li><strong></strong><tt>cVarHistogram</tt> implements a histogram where cells do not
    need to be the same size. You can manually add the cell (bin)
    boundaries, or alternatively, automatically have a partitioning
    created where each bin has the same number of observations (or as
    close to that as possible).
  <li><strong></strong><tt>cPSquare</tt> is a class that uses the $P^2$ algorithm
    described in [JCH85]. The algorithm calculates quantiles without
    storing the observations; one can also think of it as a histogram
    with equiprobable cells.
  <li><strong></strong><tt>cKSplit</tt> uses a novel, experimental method, based on an
    adaptive histogram-like algorithm. (Published papers about
    <EM>k-split</EM>\indexk-split can be downloaded from the OMNeT++
    Web site; just go one level up in the directories:
    http://www.hit.bme.hu/phd/vargaa). Because k-split is not very
    well known, we'll devote a section to it.
</UL>

<p><STRONG>Basic usage</STRONG>

<p>
One can insert an observation into a statistic object with the
<tt>collect()</tt> function or the <SAMP>+=</SAMP> operator (they are
equivalent).  <tt>cStdDev</tt> has the following methods for getting
statistics out of the object: <tt>samples()</tt>, <tt>min()</tt>,
<tt>max()</tt>, <tt>mean()</tt>, <tt>stddev()</tt>, <tt>variance()</tt>,
<tt>sum()</tt>, <tt>sqrSum()</tt> with the obvious meanings. An example
usage for <tt>cStdDev</tt>:

<pre>
cStdDev stat("stat");
for (int i=0; i&lt;10; i++)
  stat.collect( normal(0,1) );
long num_samples = stat.samples();
double smallest = stat.min(),
largest = stat.max();
double mean = stat.mean(),
standard_deviation = stat.stddev(),
variance = stat.variance();
</pre>
<p>

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec238"/>6.13.2. <FONTteal>Distribution estimation</FONT></H3></font>

<p><STRONG>Initialization and usage</STRONG>

<p>
The distribution estimation classes (the histogram classes,
<tt>cPSquare</tt> and <tt>cKSplit</tt>) are derived from
<tt>cDensityEstBase</tt>. Distribution estimation classes (except for
<tt>cPSquare</tt>) assume that the observations are within a range.
You may specify the range explicitly (based on some a-priori info
about the distribution) or you may let the object collect the first
few observations and determine the range from them. Methods which let
you specify range settings are part of <tt>cDensityEstBase</tt>. The
following member functions exist:

<pre>
setRange(lower,upper);
setRangeAuto(num_firstvals, range_ext_factor);
setRangeAutoLower(upper, num_firstvals, range_ext_factor);
setRangeAutoUpper(lower, num, range_ext_factor);
</pre>
<p>
<STRONG>setNumFirstVals(num_firstvals);</STRONG>

<p>
The following example creates a histogram with 20 cells and automatic
range estimation:

<pre>
cDoubleHistogram histogram("histogram", 20);
histogram.setRangeAuto(100,1.5);
</pre>
<p>

<p>Here, 20 is the number of cells (not including the underflow/overflow
cells, see later), and 100 is the number of observations to be
collected before setting up the cells. 1.5 is the range extension
factor. It means that the actual range of the initial observations
will be expanded 1.5 times and this expanded range will be used to lay
out the cells. This method increases the chance that further
observations fall in one of the cells and not outside the histogram
range.

<p>
  <DIV ALIGN=center>
    <img src="usmanFig12.gif">
    <center><i>Figure: Setting up a histogram's range</i></center>
  </DIV>

<p>
After the cells have been set up, collecting can go on.

<p>The <tt>transformed()</tt> function returns <EM>true</EM> when the cells have
already been set up. You can force range estimation and setting
up the cells by calling the <tt>transform()</tt> function.

<p>The observations that fall outside the histogram range will be counted
as underflows and overflows. The number of underflows and overflows
are returned by the <tt>underflowCell()</tt> and <tt>overflowCell()</tt>
member functions.

<p>
<DIV ALIGN=center>
  <img src="usmanFig13.gif">
  <center><i>Figure: Histogram structure after setting up the cells</i></center>
</DIV>

<p>
You create a $P^2$ object by specifying the number of cells:

<pre>
cPSquare psquare("interarrival-times", 20);
</pre>
<p>
Afterwards, a <tt>cPSquare</tt> can be used with the same member functions
as a histogram.

<p>
<STRONG>Getting histogram data</STRONG>

<p>
There are three member functions to explicitly return cell boundaries
and the number of observations is each cell. <tt>cells()</tt> returns
the number of cells, <tt>basepoint(int k)</tt> returns the
<EM>k</EM>th base point, <tt>cell(int k)</tt> returns the
number of observations in cell <EM>k</EM>, and
<tt>cellPDF(int k)</tt> returns the PDF value in the cell
(i.e. between <tt>basepoint(k)</tt> and
<tt>basepoint(k+1)</tt>).  These functions work for all
histogram types, plus <tt>cPSquare</tt> and <tt>cKSplit</tt>.

<p>
  <DIV ALIGN=center>
    <img src="usmanFig14.gif">
    <center><i>Figure: base points and cells</i></center>
  </DIV>

<p>
An example:

<pre>
long n = histogram.samples();
for (int i=0; i&lt;histogram.cells(); i++)
{
  double cellWidth = histogram.basepoint(i+1)-histogram.basepoint(i);
  int count = histogram.cell(i);
  double pdf = histogram.cellPDF(i);
  //...
}
</pre>
<p>

<p>The <tt>pdf(x)</tt> and <tt>cdf(x)</tt> member functions
return the value of the probability density function and the cumulated
density function at a given <EM>x</EM>, respectively.

<p>
<STRONG>Random number generation from distributions</STRONG>

<p>
The <tt>random()</tt> member function generates random
numbers from the distribution stored by the
object:

<pre>
double rnd = histogram.random();
</pre>
<p>

<p><tt>cStdDev</tt> assumes normal distribution.

<p>You can also wrap the distribution object in a <tt>cPar</tt>:

<pre>
cPar rnd_par("rnd_par");
rnd_par.setDoubleValue(&histogram);
</pre>
<p>

<p>The <tt>cPar</tt> object stores the pointer to the histogram (or $P^2$ object),
and whenever it is asked for the value, calls the histogram object's <tt>random()</tt>
function:

<pre>
double rnd = (double)rnd_par; // random number from the cPSquare
</pre>
<p>
<STRONG>Storing/loading distributions</STRONG>

<p>
The statistic classes have <tt>loadFromFile()</tt> member functions
that read the histogram data from a text file. If you need a custom
distribution that cannot be written (or it
is inefficient) as a C function, you can describe it in histogram form
stored in a text file, and use a histogram object with
<tt>loadFromFile()</tt>.

<p>You can also use <tt>saveToFile()</tt>that writes out the distribution
collected by the histogram object:

<pre>
FILE *f = fopen("histogram.dat","w");
histogram.saveToFile( f ); // save the distribution
fclose( f );

FILE *f2 = fopen("histogram.dat","r");}
cDoubleHistogram hist2("Hist-from-file");
hist2.loadFromFile( f2 ); // load stored distribution
fclose( f2 );
</pre>
<p>

<p><STRONG>Histogram with custom cells</STRONG>

<p>
The <tt>cVarHistogram</tt> class can be used to create
histograms with arbitrary (non-equidistant) cells.
It can operate in two modes:

<p><UL>
  <li><strong></strong> <EM>manual</EM>, where you specify cell boundaries explicitly
     before starting collecting
  <li><strong></strong> <EM>automatic</EM>, where <tt>transform()</tt> will set up the cells
     after collecting a certain number of initial observations. The cells
     will be set up so that as far as possible, an equal number of observations
     fall into each cell (equi-probable cells).
</UL>

<p>Modes are selected with a <EM>transform-type</EM> parameter:
<UL>
  <li><strong></strong><tt>HIST_TR_NO_TRANSFORM</tt>: no transformation; uses bin boundaries
    previously defined by <tt>addBinBound()</tt>
  <li><strong></strong><tt>HIST_TR_AUTO_EPC_DBL</tt>: automatically creates equiprobable cells
  <li><strong></strong><tt>HIST_TR_AUTO_EPC_INT</tt>: like the above, but for integers
</UL>

<p>Creating an object:

<pre>
cVarHistogram(const char *s=NULL,
              int numcells=11,
              int transformtype=HIST_TR_AUTO_EPC_DBL);
</pre>
<p>
Manually adding a cell boundary:

<pre>
void addBinBound(double x);
</pre>
<p>
Rangemin and rangemax is chosen after collecting the
<SAMP>num_firstvals</SAMP> initial observations. One cannot add cell
boundaries when the histogram has already been transformed.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec239"/>6.13.3. <FONTteal>The k-split algorithm</FONT></H3></font>

<p><STRONG>Purpose</STRONG>

<p>
The <EM>k</EM>-split algorithm is an on-line distribution
estimation method.  It was
designed for on-line result collection in simulation programs.  The
method was proposed by Varga and Fakhamzadeh in 1997. The primary
advantage of <EM>k</EM>-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size. The
<EM>k</EM>-split algorithm can be extended to multi-dimensional
distributions, but here we deal
with the one-dimensional version only.

<p>
<STRONG>The algorithm</STRONG>

<p>
The <EM>k-split</EM> algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out with
a histogram range $[x_lo, x_hi)$ with $k$ equal-sized histogram
cells with observation counts $n_1,n_2, .. n_k$.  Each collected
observation increments the corresponding observation count. When an
observation count $n_i$ reaches a <EM>split threshold</EM>, the cell
is split into $k$ smaller, equal-sized cells with observation counts
$n_i,1, n_i,2, .. n_i,k$ initialized to zero. The $n_i$
observation count is remembered and is called the <EM>mother
  observation count</EM> to the newly created cells. Further observations
may cause cells to be split further (e.g. $n_i,1,1,...n_i,1,k$
etc.), thus creating a $k$-order tree of observation counts where
leaves contain live counters that are actually incremented by new
observations, and intermediate nodes contain mother observation counts
for their children. If an observation falls outside the histogram
range, the range is extended in a natural manner by inserting new
level(s) at the top of the tree. The fundamental parameter to the
algorithm is the split factor $k$. Low values of $k$, $k=2$ and $k=3$
are to be considered. In this paper we examine only the $k=2$ case.

<p>
  <DIV ALIGN=center>
    <img src="usmanFig15.gif">
    <center><i>Figure: Illustration of the k-split algorithm, $k=2$. The
      numbers in boxes represent the observation count values</i></center>
  </DIV>

<p>

<p>For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.

<p>
Let $n_...,i$ be the (mother) observation count for a cell,
$s_...,i$ be the total observation count in a cell $n_...,i$ plus
the observation counts in all its sub-, sub-sub-, etc. cells), and
$m_...,i$ the mother observations propagated to the cell. We are
interested in the $&ntilde;_...,i = n_...,i + m_...,i$
estimated amount of observations in the tree nodes, especially in the
leaves. In other words, if we have $&ntilde;_...,i$ estimated
observation amount in a cell, how to divide it to obtain $m_...,i,1,
m_...,i,2 .. m_...,i,k$ that can be propagated to child cells.
Naturally, $m_...,i,1 + m_...,i,2 + .. + m_...,i,k =
&ntilde;_...,i$.

<p>
Two natural distribution methods are even
distribution\indexdistribution!even (when $m_...,i,1 = m_...,i,2
= .. = m_...,i,k$) and proportional
distribution\indexdistribution!proportional (when $m_...,i,1 :
m_...,i,2 : .. : m_...,i,k = s_...,i,1 : s_...,i,2 :
.. : s_...,i,k$). Even distribution is optimal when the
$s_...,i,j$ values are very small, and proportional distribution is
good when the $s_...,i,j$ values are large compared to
$m_...,i,j$. In practice, a linear combination of them seems
appropriate, where $lambda=0$ means even and $lambda=1$ means
proportional distribution:

<p>
<blockquote>
m_..,i,j=(1-lambda )<fontmaroon><em> Unknown LaTeX command </em> \frac </font>&ntilde;_..,i<fontmaroon><em>  </em>  </font>k + lambda &ntilde;_..,i <fontmaroon><em> Unknown LaTeX command </em> \frac </font>s_...,i,j<fontmaroon><em>  </em>  </font>s_..,i, lambda\in[0,1]
</blockquote>

<p>
  <DIV ALIGN=center>
    <img src="usmanFig16.gif">
    <center><i>Figure: Density estimation from the k-split cell tree. We
      assume $lambda=0$, i.e. we distribute mother observations
      evenly.</i></center>
  </DIV>

<p>
Note that while $n_...,i$ are integers, $m_...,i$ and thus
$&ntilde;_...,i$ are typically real numbers. The histogram estimate
calculated from <EM>k</EM>-split is not exact, because the frequency
counts calculated in the above manner contain a degree of estimation
themselves. This introduces a certain <EM>cell division error</EM>;
the lambda parameter should be selected so that it minimizes that
error. It has been shown that the cell division error can
be reduced to a more-than-acceptable small value.<br>
Strictly speaking, the <EM>k</EM>-split algorithm is semi-online,
because its needs some observations to set up the initial histogram
range.  However, because of the range extension and cell split
capabilities, the algorithm is not very sensitive to the choice of the
initial range, so very few observations are enough for range
estimation (say $N_pre=10$). Thus we can regard <EM>k</EM>-split as
an on-line method.

<p><EM>K</EM>-split can also be used in semi-online mode, when the
algorithm is only used to create an optimal partition from a larger
number of $N_pre$ observations. When the partition has been created,
the observation counts are cleared and the $N_pre$ observations are
fed into <EM>k</EM>-split once again. This way all mother (non-leaf)
observation counts will be zero and the cell division error is
eliminated. It has been shown that the partition created by
<EM>k</EM>-split can be better than both the equi-distant and the
equal-frequency partition.

<p>
OMNeT++ contains an experimental implementation of the <EM>k</EM>-split
algorithm, the <tt>cKSplit</tt> class. Research on <EM>k</EM>-split is
still under way.

<p>
<STRONG>The cKSplit class</STRONG>

<p>The <tt>cKSplit</tt> class is an implementation of the <EM>k-split</EM> method.
Member functions:


<pre>
void setCritFunc(KSplitCritFunc _critfunc, double *_critdata);
void setDivFunc(KSplitDivFunc \_divfunc, double *\_divdata);
void rangeExtension( bool enabled );
</pre>
<p>

<pre>
int treeDepth();
int treeDepth(sGrid& grid);
</pre>
<p>
<pre>
double realCellValue(sGrid& grid, int cell);
void printGrids();
</pre>

<pre>
sGrid& grid(int k);
sGrid& rootGrid();
</pre>
<p>
<pre>
struct sGrid
{
  int parent;   // index of parent grid
  int reldepth; // depth = (reldepth - rootgrid's reldepth)
  long total;   // sum of cells & all subgrids (includes 'mother')
  int mother;   // observations 'inherited' from mother cell
  int cells[K]; // cell values
};
</pre>

<p>

<p><font color="#006f00"><H3><A NAME="sec240"/>6.13.4. <FONTteal>Transient detection and result accuracy</FONT></H3></font>

<p>In many simulations, only the steady state performance (i.e.
the performance after the system has reached a stable state)
is of interest. The initial part of the simulation is called
the transient period. After the model has entered steady state,
simulation must proceed until enough statistical data have been
collected to compute result with the required accuracy.

<p>
Detection of the end of the transient period and a certain result
accuracy is supported by OMNeT++. The user can attach transient
detection and result accuracy objects to a result object (<tt>cStatistic</tt>'s
descendants). The transient detection and result accuracy objects will
do the specific algorithms on the data fed into the result object and
tell if the transient period is over or the result accuracy has been
reached.

<p>The base classes for classes implementing specific transient
detection and result accuracy detection algorithms are:
<UL>
<li><strong></strong><tt>cTransientDetection</tt>: base class for transient detection
<li><strong></strong><tt>cAccuracyDetection</tt>: base class for result accuracy detection
</UL>

<p>
<STRONG>Basic usage</STRONG>


Attaching detection objects to a <tt>cStatistic</tt> and getting pointers
to the attached objects:

<pre>
addTransientDetection(cTransientDetection *object);
addAccuracyDetection(cAccuracyDetection *object);
cTransientDetection *transientDetectionObject();
cAccuracyDetection *accuracyDetectionObject();
</pre>
<p>

<p>Detecting the end of the period:
<UL>
<li><strong></strong>polling the <tt>detect()</tt> function of the object
<li><strong></strong>installing a post-detect function
</UL>

<p>
<STRONG>Transient detection</STRONG>

<p>
Currently one transient detection algorithm
is implemented, i.e.  there's one class derived from
<tt>cTransientDetection</tt>. The <tt>cTDExpandingWindows</tt> class
uses the sliding window approach with two windows, and checks the
difference of the two averages to see if the transient period is over.

<pre>
void setParameters(int reps=3,
                   int minw=4,
                   double wind=1.3,
                   double acc=0.3);
</pre>
<p>
<STRONG>Accuracy detection</STRONG>

<p>
Currently one accuracy detection algorithm
is implemented, i.e.  there's one class derived from
<tt>cAccuracyDetection</tt>. The algorithm implemented in the
<tt>cADByStddev</tt> class is: divide the standard deviation by the
square of the number of values and check if this is small enough.

<pre>
void setParameters(double acc=0.1,
                   int reps=3);
</pre>
<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec241"/>6.14. <FONTblue>Recording simulation results</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec242"/>6.14.1. <FONTteal>Output vectors: cOutVector</FONT></H3></font>

<p>Objects of type <tt>cOutVector</tt> are responsible for writing time series
data (referred to as <EM>output vectors</EM>) to a file. The <tt>record()</tt>
member is used to output a value (or a value pair) with a timestamp.

<p>It can be used like this:

<pre>
cOutVector resp_v("response time");

while (...)
{
  double response_time;
  //...
  resp_v.record( response_time );
  //...
}
</pre>
<p>

<p>All <tt>cOutVector</tt> objects write to the same, common file. The
file is textual; each <tt>record()</tt> call generates a line in the
file. The output file can be processed using Plove, but otherwise its
simple format allows it to be easily processed with <tt>sed</tt>,
<tt>awk</tt>, <tt>grep</tt> and the like, and it can be imported by
spreadsheet programs.  The file format is described later in this
manual (in the section about simulation execution).

<p>You can disable the output vector or specify a
simulation time interval for recording either from the ini file or
directly from program code:

<pre>
cOutVector v("v");
simtime_t t =...;

v.enable();
v.disable();
v.setStartTime( t );
v.setStopTime( t+100.0 );
</pre>
<p>

<p>If the output vector object is disabled or the simulation time is
outside the specified interval, <tt>record()</tt> doesn't write
anything to the output file. However, if you have a Tkenv inspector
window open for the output vector object,
the values will be displayed there, regardless of the state of the
output vector object.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec243"/>6.14.2. <FONTteal>Output scalars</FONT></H3></font>

<p>While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars are supposed to record a single
value per simulation run. You can use outputs scalars
<UL>
<li><strong></strong>to record summary data at the end of the simulation run
<li><strong></strong>to do several runs with different parameter settings/random seed
    and determine the dependence of some measures on the parameter
    settings. For example, multiple runs and output scalars are the
    way to produce <EM>Throughput vs. Offered Load</EM> plots.
</UL>

<p>Output scalars are recorded with the <tt>recordScalar()</tt> member
function.  It is overloaded, you can use it to write doubles and
strings (const char *):

<pre>
double avg_throughput = total_bits / simTime();
recordScalar("Average throughput", avg_throughput);
</pre>
<p>

<p>You can record whole statistics objects by calling <tt>recordStats()</tt>:

<pre>
cStdDev *eedstats = new cStdDev;
...
recordStats("End-to-end Statistics", eedstats);
</pre>
<p>

<p>
Calls to <tt>recordScalar()</tt> and <tt>recordStats()</tt> are usually
placed in the redefined <tt>finish()</tt> member function of a
simple module.

<p>
The above calls write into the (textual) output scalar file.  The
output scalar file is preserved across simulation runs (unlike the
output vector file is, scalar files are not deleted at the beginning
of each run). Data are always appended at the end of the file, and
output from different simulation runs are separated by special lines.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec244"/>6.15. <FONTblue>Deriving new classes</FONT></H2></font></hr>

<p>Nearly all classes in the simulation class library are descendants of
<tt>cObject</tt>. If you want to derive a new class from
<tt>cObject</tt> or a <tt>cObject</tt> descendant, you must redefine
some member functions so that objects of the new type can fully
co-operate with other parts of the simulation system. A more-or-less
complete list of these functions are presented here. Do not be
embarrassed at the length of the list: most functions are not
absolutely necessary to implement. For example, you do not need to
redefine <tt>forEach()</tt> unless your class is a container class.

<p><UL>
  <li><strong></strong>default constructor, copy constructor. The copy constructor
    can simply call the assignment operator.
  <li><strong></strong><tt>operator=()</tt>: the assignment operator (copies object
    contents from another object)
  <li><strong></strong><tt>dup()</tt>: duplicates the object by creating an exact copy
    (uses copy constructor)
  <li><strong></strong><tt>info()</tt>: returns a one-line info about object contents
  <li><strong></strong><tt>writeContents()</tt>: write a more detailed report about the
    object into a file
  <li><strong></strong><tt>forEach()</tt>: iterates through all contained objects if
    any
  <li><strong></strong><tt>netPack()</tt>, <tt>netUnpack()</tt>: they are needed only if
    objects of this type will be sent over
    PVM/MPI from one segment to another.  The
    <tt>netPack()</tt>,<tt>netUnpack()</tt>functions of the library
    classes are in the sim/pvm (sim/mpi) directory.
</UL>

<p>One should also use the <tt>Register_Class()</tt> macro to register the
new class. It is used by the <tt>createOne()</tt> function and the
PVM/MPI extension of OMNeT++.

<p>Let us see a simple example. The header file:

<pre>
// File: cmyclass.h
#include &lt;omnetpp.h&gt;

class cMyClass : public cObject
{
 public:
  int samples;

  cMyClass(const cMyClass& myclass);
  cMyClass(const char *name=NULL, int k=0);
  virtual ~cMyClass() {}
  virtual cObject *dup() const {return new cMyClass(*this);}
  virtual void info(char *buf);
  virtual void writeContents(ostream& os);
  cMyClass& operator=(const cMyClass& myclass);
};
</pre>
<p>
The corresponding .cc file:

<pre>
// File: cmyclass.cc
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include "cmyclass.h"

Register_Class( cMyClass );

cMyClass::cMyClass(const cMyClass& myclass) : cObject()
{
  setName( myclass.name() );
  operator=( myclass );
}

cMyClass::cMyClass(const char *name, int k) : cObject( name )
{
  samples = k;
}

void cMyClass::info(char *buf)
{
  cObject::info( buf );
  sprintf( buf+strlen(buf), " samples=0", samples);
}

void cMyClass::writeContents(ostream& os)
{
  os &lt;&lt; " samples: " &lt;&lt; samples &lt;&lt; '\n';
}

cMyClass& cMyClass::operator=(const cMyClass& myclass)
{
  cObject::operator=(myclass);
  samples = myclass.samples;
}
</pre>
<p>

<p>See the virtual functions of <tt>cObject</tt> in the class library reference
for more information.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec245"/>6.16. <FONTblue>Tracing and debugging aids</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec246"/>6.16.1. <FONTteal>Displaying information about module activity</FONT></H3></font>

<p>You can have simple modules print textual output for
debugging purposes.

<p>The global object called ev represents the user interface of the
simulation program. You can send data to ev using the
C++-style I/O operator (<tt>&lt;</tt><tt>&lt;</tt>).

<pre>
ev &lt;&lt; "started\n";
ev &lt;&lt; "about to send message #" &lt;&lt;  i &lt;&lt; endl;
ev &lt;&lt; "queue full, discarding packet\n";
</pre>
<p>
The more traditional-looking but functionally equivalent
<tt>ev.printf()</tt> form also exists.

<pre>
ev.printf("0 packets dropped out of 0\n", drops, total);
</pre>
<p>
The exact way messages are displayed to the user depends on the user
interface. In the command-line user interface (Cmdenv),
it is simply dumped to the standard output. (This output can also be
disabled from the ini file so that it doesn't slow down simulation
when it is not needed.) In windowing user interfaces
(Tkenv), each simple module can have
a separate text output window.

<p>The above means that you should <EM>not</EM> use <tt>printf()</tt>,
<tt>cout</tt> <tt>&lt;&lt;</tt> and the like because with Tkenv, their output
would appear in the terminal window behind the graphical window of the
simulation application.

<p>
<font color="#006f00"><H3><A NAME="sec247"/>6.16.2. <FONTteal>Watches</FONT></H3></font>

<p>You may want some of your int, long, double, char, etc. variables to
be inspect-able in Tkenv and to be output into the snapshot
file. In this case, you can create
<tt>cWatch</tt> objects for them with the <tt>WATCH()</tt> macro:

<pre>
int i; WATCH(i);
char c; WATCH(c);
</pre>
<p>
When you open an inspector for the simple module in Tkenv and click
the Objects/Watches tab in it, you'll see your WATCHed variables
and their values there. Tkenv also lets you change the value of a
WATCHed variable.

<p>The <tt>WATCH()</tt> macro expands to a dynamically created <tt>cWatch</tt>
object.  The object remembers the address and type of your variable.
The macro expands to something like:

<pre>
new cWatch("i",i);
</pre>
<p>

<p>You can also make a <SAMP>WATCH</SAMP> for pointers of type <tt>char*</tt> or
<tt>cObject*</tt>, but this may cause a segmentation fault if
the pointer does not point to a valid location when Tkenv or
<tt>snapshot()</tt> wants to use it.

<p>You can also set watches for variables that are members of the
module class or for structure fields:

<pre>
WATCH( lapbconfig.timeout );
</pre>
<p>

<p><STRONG>Placement of WATCHes</STRONG>

<p>
Be careful not to execute a <tt>WATCH()</tt> statement more than once,
as each call would create a new <tt>cWatch</tt> object! If you use
<tt>activity()</tt>, the best place for WATCHes is the top of the
<tt>activity()</tt> function.  If you use <tt>handleMessage()</tt>,
place the <tt>WATCH()</tt> statement into <tt>initialize()</tt>.
<tt>WATCH()</tt> creates a dynamic <tt>cWatch</tt> object, and we do
not want to create a new object each time <tt>handleMessage()</tt> is
called.

<p>

<p><font color="#006f00"><H3><A NAME="sec248"/>6.16.3. <FONTteal>Snapshots</FONT></H3></font>

<p>The <tt>snapshot()</tt> function outputs textual information about all
or selected objects of the simulation (including the objects created
in module functions by the user) into the snapshot file.

<pre>
bool snapshot(cObject *obj = &simulation, const char *label = NULL);
</pre>
<p>

<p>The function can be called from module functions, like this:

<pre>
snapshot();     // dump the whole network
snapshot(this); // dump this simple module and all its objects
snapshot(&putAsideQueue);       // dump queue contents
snapshot(&simulation.msgQueue); // dump future events
</pre>
<p>
This will append snapshot information to the end of the snapshot file.
(The snapshot file name has an extension of .sna, default is
omnetpp.sna. Actual file name can be set in the
config file.)

<p>
The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <tt>snapshot()</tt>, one can trace
how the values of variables, objects changed over the simulation.
The arguments: label is a string that will appear in the output
file; obj is the object whose inside is of interest. By default,
the whole simulation (all modules etc) will be written out.

<p>If you run the simulation with Tkenv, you can also create a snapshot
from the menu.

<p>
An example of a snapshot file:

<p><pre>
================================================
|| SNAPSHOT ||
================================================
| Of object:    `simulation'
| Label:        `three-station token ring'
| Sim. time:    0.0576872457 ( 57ms)
| Network:      `token'
| Run no.       1
| Started at:   Mar 13, 1997, 14:23:38
| Time:         Mar 13, 1997, 14:27:10
| Elapsed:      5 sec
| Initiated by: operator
================================================

<p>
(cSimulation) `simulation' begin
  Modules in the network:
    `token' #1 (TokenRing)
      `comp[0]' #2 (Computer)
        `mac' #3 (TokenRingMAC)
        `gen' #4 (Generator)
        `sink' #5 (Sink)
      `comp[1]' #6 (Computer)
        `mac' #7 (TokenRingMAC)
        `gen' #8 (Generator)
        `sink' #9 (Sink)
      `comp[2]' #10 (Computer)
        `mac' #11 (TokenRingMAC)
        `gen' #12 (Generator)
        `sink' #13 (Sink)
end

<p>(cCompoundModule) `token' begin
  #1 params     (cArray) (n=6)
  #1 gates      (cArray) (empty)
  comp[0]          (cCompoundModule,#2)
  comp[1]          (cCompoundModule,#6)
  comp[2]          (cCompoundModule,#10)
end

<p>(cArray) `token.parameters' begin
  num_stations (cModulePar) 3 (L)
  num_messages (cModulePar) 10000 (L)
  ia_time      (cModulePar) truncnormal(0.005,0.003) (F)
  THT          (cModulePar) 0.01 (D)
  data_rate    (cModulePar) 4000000 (L)
  cable_delay  (cModulePar) 1e-06 (D)
end

<p>(cModulePar) `token.num_stations' begin
  Type: L
  Value: 3
end

<p><EM>[...token.num_messages omitted...]</EM>

<p>(cModulePar) `token.ia_time' begin
  Type:  F
  Value: truncnormal(0.005,0.003)
end

<p><EM>[...rest of parameters &amp; gates stuff deleted from here...]</EM>

<p>(cCompoundModule) `token.comp[0]' begin
  parameters    (cArray) (empty)
  gates         (cArray) (n=2)
  mac           (TokenRingMAC,#3)
  gen           (Generator,#4)
  sink          (Sink,#5)
end

<p>(cArray) `token.comp[0].parameters' begin
end

<p>(cArray) `token.comp[0].gates' begin
  in            (cGate)  &lt;- comp[2].out
  out           (cGate)  -&gt; D -&gt; comp[1].in
end

<p>(cGate) `token.comp[0].in' begin
  type:  input
  inside connection:  token.comp[0].mac.phy_in
  outside connection: token.comp[2].out
  delay: -
  error: -
  data rate: -
end

<p>(cGate) `token.comp[0].out' begin
  type: output
  inside connection: token.comp[0].mac.phy_out
  outside connection: token.comp[1].in
  delay: (cPar) 1e-06 (D)
  error: -
  data rate: -
end

<p>(TokenRingMAC) `token.comp[0].mac' begin
  parameters    (cArray) (n=2)
  gates         (cArray) (n=4)
  local-objects (cHead)
  class-data-members (cHead)
  putaside-queue (cQueue) (empty)
end

<p><EM>[...comp[0].mac parameters stuff deleted from here...]</EM>

<p>(cArray) `token.comp[0].mac.gates' begin
  phy_in        (cGate)  &lt;- &lt;parent&gt;.in
  from_gen      (cGate)  &lt;- gen.out
  phy_out       (cGate)  -&gt; &lt;parent&gt;.out
  to_sink       (cGate)  -&gt; sink.in
end

<p><EM>[...detailed gate list deleted from here...]</EM>

<p>(cHead) `token.comp[0].mac.local-objects' begin
  sendqueue-length (cOutVector) (single)
  send-queue   (cQueue) (n=11)
end

<p>(cOutVector) `token.comp[0].mac.local-objects.sendqueue-length' begin
end

<p>(cQueue) `token.comp[0].mac.local-objects.send-queue' begin
  0-&gt;1         (cMessage) Tarr=0.0158105774 ( 15ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0163553310 ( 16ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0205628236 ( 20ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0242203591 ( 24ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0300994268 ( 30ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0364005251 ( 36ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0370745702 ( 37ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0387984129 ( 38ms) Src=#4 Dest=#3
  0-&gt;1         (cMessage) Tarr=0.0457462493 ( 45ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0487308918 ( 48ms) Src=#4 Dest=#3
  0-&gt;2         (cMessage) Tarr=0.0514466766 ( 51ms) Src=#4 Dest=#3
end

<p>(cMessage) `token.comp[0].mac.local-objects.send-queue.0-&gt;1' begin
  #4 -&gt; #3
  sent:         0.0158105774 ( 15ms)
  arrived:      0.0158105774 ( 15ms)
  length:       33536
  kind:         0
  priority:     0
  error:        FALSE
  time stamp:   0.0000000 ( 0.00s)
  parameter list:
    dest        (cPar) 1 (L)
    source      (cPar) 0 (L)
    gentime     (cPar) 0.0158106 (D)
end

<p>(cArray) `token.comp[0].mac.local-objects.send-queue.0-&gt;1.par-vector' begin
  dest          (cPar) 1 (L)
  source        (cPar) 0 (L)
  gentime       (cPar) 0.0158106 (D)
end

<p><EM>[...message parameters and the other messages' stuff deleted...]</EM>

<p>(cHead) `token.comp[0].mac.class-data-members' begin
end

<p>(cQueue) `token.comp[0].mac.putaside-queue' begin
end

<p><EM>[...comp[0].gen and comp[0].sink stuff deleted from here...]</EM>
<EM>[...whole comp[1] and comp[2] stuff deleted from here...]</EM>

<p>(cMessageHeap) `simulation.message-queue' begin
  1-&gt;0         (cMessage) Tarr=0.0576872457 ( 57ms) Src=#8 Dest=#7
                (cMessage) Tarr=0.0577201630 ( 57ms) Mod=#8 (selfmsg)
                (cMessage) Tarr=0.0585677054 ( 58ms) Mod=#4 (selfmsg)
                (cMessage) Tarr=0.0594939072 ( 59ms) Mod=#12 (selfmsg)
                (cMessage) Tarr=0.0601010000 ( 60ms) Mod=#7 (selfmsg)
  1-&gt;2         (cMessage) Tarr=0.0601020000 ( 60ms) Src=#11 Dest=#13
end

<p><EM>[...detailed list of message queue contents deleted from here...]</EM>
</pre>

<p>To reduce the size of the file, you may well decide to make a snapshot
only of a part of the model. This example
reports only about the current simple module's put-aside queue:

<pre>
snapshot(&putAsideQueue);
</pre>
<p>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec249"/>6.16.4. <FONTteal>Breakpoints</FONT></H3></font>

<p><STRONG>With activity() only!</STRONG> In those user interfaces which support
debugging, breakpoints stop execution and the state of the simulation
can be examined.

<p>You can set a breakpoint inserting a
<tt>breakpoint()</tt> call into the source:

<pre>
for(;;)
{
  cMessage *msg = receive();
  breakpoint("before-processing");
  breakpoint("before-send");
  send( reply_msg, "out" );
  //..
}
</pre>
<p>

<p>In user interfaces that do not support debugging, <tt>breakpoint()</tt>
calls are simply ignored.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec250"/>6.16.5. <FONTteal>Disabling warnings</FONT></H3></font>

<p>Some container classes and functions suspend the simulation and issue
warning messages in potentially bogus/dangerous situations, for
example when an object is not found and NULL pointer/reference is
about to be returned. Very often this is useful, but sometimes it is
more trouble. You can turn warnings on/off from the ini file
(warnings=yes/no).

<p>
It is a good practice to leave warnings enabled, and
temporarily disable warnings in places where OMNeT++ would normally
issue warnings but you know the code is correct. This is done in the
following way:

<pre>
bool w = simulation.warnings();
simulation.setWarnings( false );
...
... // critical code
...
simulation.setWarnings( w );
</pre>
<p>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec251"/>6.16.6. <FONTteal>Getting coroutine stack usage</FONT></H3></font>

<p>It is important to choose the correct stack size for
modules.  If the stack is
too large, it unnecessarily consumes memory; if it is too small, stack
violation occurs.

<p>From the Feb99 release, OMNeT++ contains a mechanism that detects stack
overflows. It checks the intactness of a
predefined byte pattern (<SAMP>0xdeadbeef</SAMP>) at the stack boundary,
and reports ``stack violation'' if it was
overwritten. The mechanism usually works fine, but occasionally it can
be fooled by large - and not fully used - local variables (e.g. char
buffer[256]): if the byte pattern happens to fall in the middle of
such a local variable, it may be preserved intact and OMNeT++ does not
detect the stack violation.

<p>To be able to make a good guess about stack size, you can use
the <tt>stackUsage()</tt> call which tells you how much stack the module
actually uses. It is most conveniently called from <tt>finish()</tt>:

<pre>
void FooModule::finish()
{
  ev &lt;&lt; stackUsage() &lt;&lt;  "bytes of stack used\n";
}
</pre>
<p>

<p>The value includes the extra stack added by the user interface library
(see <EM>extraStackforEnvir</EM> in
envir/omnetapp.h), which is currently 8K for Cmdenv and at least 16K
for Tkenv <font size=-1>[the actual value is dependent on the operating
  system, e.g.  SUN Solaris needs more space]</font>.

<p><tt>stackUsage()</tt>also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the above
effect with local variables.

<p>
<hr><font color="#006f00"><H2><A NAME="sec252"/>6.17. <FONTblue>Changing the network graphics at run-time</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec253"/>6.17.1. <FONTteal>Setting display strings</FONT></H3></font>

<p>Sometimes it is useful to change the appearance or position of
some components in the network graphics, such as the color of the
modules, color/width of connection arrows,
position of a submodule, etc.

<p>The appearance of nodes and connections is determined by the display
strings. Display strings (e.g. <tt>"p=100,10;i=pc"</tt>)
are initially taken from the NED description.
You can change the display string of a module or connection arrow
at run-time by calling methods named <tt>setDisplayString()</tt>.

<p>Setting the module's appearance when it is displayed as a component
within a compound module:

<pre>
setDisplayString("p=100,100;b=60,30,rect;o=red,black,3", true);
</pre>
<p>
Setting appearance of a compound module when it's displayed as a
bounding box for its submodules:

<pre>
parentModule()-&gt;setDisplayStringAsParent("p=100.....", true);
</pre>
<p>
The display string of a connection arrow
is stored in its source gate, so you'll need to write something
like this:

<pre>
gate("out")-&gt;setDisplayString("o=yellow,3");
</pre>
<p>
The <tt>setDisplayString()</tt> methods additionally take a bool
argument called <tt>immediate</tt>. It specifies whether the display
string change should take effect immediately, or only after processing
the current event (the default is <EM>immediate=true</EM>). If several
display string changes are going to be done within one event, then
<EM>immediate=false</EM> is useful because it reduces the number of
necessary redraws. <EM>Immediate=false</EM> also uses less stack.  But
its drawback is that a <tt>setDisplayString()</tt> followed by a
<tt>send()</tt> would actually be displayed in reverse order (message
animation first), because message animations are performed immediately
(actually within the <tt>send()</tt> call).

<p>
<font color="#006f00"><H3><A NAME="sec254"/>6.17.2. <FONTteal>The cDisplayStringParser class</FONT></H3></font>

<p>The <tt>cDisplayStringParser</tt> utility class lets you parse and
manipulate display strings.

<p>As far as <tt>cDisplayStringParser</tt> is concerned, a display string
(e.g. <tt>"p=100,125;i=cloud"</tt>) is a string that consist of several
<EM>tags</EM> separated by semicolons, and each tag has a <EM>name</EM>
and after an equal sign, zero or more <EM>arguments</EM> separated by commas.

<p>The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags,
removing tags or replacing arguments. The internal storage method allows
very fast operation; it will generally be faster than direct string manipulation.
The class doesn't try to interpret the display string in any way, nor does
it know the meaning of the different tags; it merely parses the string
as data elements separated by semicolons, equal signs and commas.

<p>An example:

<p><pre>
cDisplayStringParser dispstr("a=1,2;p=alpha,,3");
dispstr.insertTag("x");
dispstr.setTagArg("x",0,"joe");
dispstr.setTagArg("x",2,"jim");
dispstr.setTagArg("p",0,"beta");
ev &lt;&lt; dispstr.getString();  // result: "x=joe,,jim;a=1,2;p=beta,,3"
</pre>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec255"/>6.18. <FONTblue>Tips for speeding up the simulation</FONT></H2></font></hr>

<p>Here are a few tips that can help you make the simulation faster:
<UL>
<li><strong></strong>Turn off the display of screen messages when you run the
    simulation.  You can do this in the ini file. Alternatively, you
    can place #ifdefs around your ev<SAMP>&lt;</SAMP><SAMP>&lt;</SAMP> and
     calls and turn off the define when compiling
    the simulation for speed.
  <li><strong></strong>Store the module parameters in local variables to avoid
    calling <tt>cPar</tt> member functions every time.
  <li><strong></strong>Use gate numbers instead of gate names.
  <li><strong></strong>Try to minimize message creations and deletions. Reuse
    messages if possible.
  <li><strong></strong>Do not give name strings to objects that are created and
    deleted many times (pass NULL pointer as name).
  <li><strong></strong>Use numeric index to get an object from a <tt>cArray</tt>, not the
    object name. You can do this also with message parameters.
</UL>

<p>
Two techniques are discussed here in detail:
<UL>
<li><strong></strong>message subclassing, and
<li><strong></strong>using shared objects
</UL>

<p>

<p><font color="#006f00"><H3><A NAME="sec256"/>6.18.1. <FONTteal>Using shared objects</FONT></H3></font>

<p>In a complex simulation, a lot of messages are created, sent and
destroyed. Messages typically have some parameters attached to them as
<tt>cPar</tt> objects and it frequently happens that a certain
parameter has identical values in all messages (for example, source
address in a frame is the same in all messages sent by one module).
Still, separate parameter objects are created and destroyed with each
message, which is very costly. One could save significant amount of
CPU time and memory if a single object could serve as a parameter to
all existing messages.

<p>
This can be achieved with proper ownership
control. See the following example:

<p><pre>
void MyComputer::activity()
{
  cPar source_addr;     // address of this node
  cPar dest_addrs[3];   // possible destinations

<p>  source_addr.setStringValue( "DECnet000728" );
  dest_addrs[0].setStringValue( "cisco_F99030" );
  dest_addrs[1].setStringValue( "DEC___28E6AD" );
  dest_addrs[2].setStringValue( "DECnet000B04" );

<p>  long k=0;
  for(;;)
  {
    cMessage *packet = new cMessage("DATA");

<p>    packet-&gt;addPar( *new cPar("sequence", 'L', k++) );

<p>    packet-&gt;parList().takeOwnership( false ); <b>// NOTE THIS LINE!!!</b>

<p>    packet-&gt;addPar( source_addr );
    packet-&gt;addPar( dest_addrs[ k%3 ] );

<p>    send(packet, "output-gate");

<p>    wait( truncnormal(1.5, 0.5) );
  }
}
</pre>

<p>
The above simple module code models the message generation part
of a computer on a LAN. The module sends out messages (packets)
to different stations in every 1.5 seconds or so. The messages
have three parameters: the source address, the destination address
and a sequence number. The source address is the same in each
packet, and there are only three possible destination stations.
The sequence number is different in each packet.

<p>
To avoid the overhead caused by having to create source and
destination address objects for each message, the module creates these
objects only once; they will be shared among all messages. Separate
sequence number objects are created for each message.

<p>
Let us see what happens to the sequence number object when it is
inserted into the message. The message object, by default, takes the
ownership of the object. Ownership means the <EM>responsibility of
  destruction</EM>; that is, when the message is destroyed, the parameter
object will be destroyed as well.

<p>This is exactly what we need most of the time. But if we just added
the <EM>shared</EM> source and destination address objects to a
message, then we would have problems when the message is destroyed.
Somehow it must be told to the message object to leave our shared
parameters alone and not to become their
owner. This is exactly what the

<pre>
packet-&gt;parList().takeOwnership(false);
</pre>
<p>

<p>line does: it sets a flag that tells the message (to be more precise,
to its internal parameter list object) not to take the ownership of
objects that will be inserted from then on. It does not affect objects
already inserted. As a result, all messages will just hold pointers to
the shared <tt>cPar</tt> objects and never do any harm to them.

<p>The above example shows that with CPU-intensive simulations, you can
save a lot of computation time and memory just by using the ownership
mechanism already present in OMNeT++.

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec257"/>6.19. <FONTblue>Building large networks</FONT></H2></font></hr>

<p>There are situations when using NED files to describe network topology
is inconvenient, for example because the topology information comes
from an external source (e.g. it is
exported from a network management program). In such case, you have
two possibilities to avoid writing NED files by hand:
<OL>
<li><strong></strong>generating NED files from data files
<li><strong></strong>building the network from C++ code
</OL>

<p>The two solutions have different advantages and disadvantages.
The first is more useful in the model development phase, while
the second one is better for writing larger scale, more productized
simulation programs. In the next sections we examine both methods.

<p>

<p>
<font color="#006f00"><H3><A NAME="sec258"/>6.19.1. <FONTteal>Generating NED files</FONT></H3></font>

<p>
Text processing programs like <tt>awk</tt> or <tt>perl</tt> are
excellent tools to read in textual data files and generate NED files
from them.  Perl also has extensions to
access SQL databases, so it can also be used if the network topology
is stored in a database.

<p>The advantage is that the necessary <tt>awk</tt> or <tt>perl</tt>
program can be written in a releatively short time, and it is
inexpensive to maintain afterwards: if the structure of the data files
change, the NED-creating program can be easily modified. The
disadvantage is that the resulting NED files are often quite big and
the C++ compilation of the *_n.cc files take too long.

<p>This method is best suited in the first phase of a simulation
project when the topology, the format of the data files, etc.
have not yet settled down.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec259"/>6.19.2. <FONTteal>Building the network from C++ code</FONT></H3></font>

<p>Another alternative is to write C++ code which becomes part of the
simulation executable. The code would read the topology data from data
files or a database, and build the network directly.  The code which
builds the network would be quite similar to the *_n.cc files output
by nedc.

<p>
Since writing such code is more complex than letting perl generate
NED files, this method is recommended when the simulation program
has to be somewhat more productized, for example when OMNeT++
and the simulation model is embedded into a larger program, e.g.
a network design tool.

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 14 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec260"/>7. <FONTgreen>Message Definitions</FONT></H1></font></hr>
<a name="cha:message-definitions"/>

<p><hr><font color="#006f00"><H2><A NAME="sec261"/>7.1. <FONTblue>Motivation</FONT></H2></font></hr>

<p>In former releases of OMNeT++, <tt>cPar</tt> objects were the only way
to add data to message objects. This technique had significant drawbacks:
<tt>cPar</tt>'s were fairly complex objects themselves,
and they added both execution and memory overhead. They were
also error-prone because <tt>cPar</tt> objects had to be
added dynamically and individually to each message object.

<p>A better approach is to leave out <tt>cPar</tt> objects and rely on
the C++ language instead. Since the simulation library is written in C++,
it is very easy to subclass <tt>cMessage</tt>, and add the necessary
parameters as instance variables.

<p>For defining a new message class, one could write the following:

<pre>
class RadioMsg : public cMessage {
  public:
    int freq;
    double power;
    ...
};
</pre>
<p>

<p>Now it is possible to write code like this:

<pre>
RadioMsg *msg = new RadioMsg();
msg-&gt;freq = 1;
msg-&gt;power = 10.0;
...
</pre>
<p>
This code is more efficient than using <tt>cPar</tt>s, and
also benefits from static type checking: if you mistype the name
of a parameter, already the compiler can detect the mistake.

<p>Note that the above code is only for illustration.
In real code, one should avoid public data members:
<tt>freq</tt> and <tt>power</tt> should be private members,
and getter/setter methods should exist to access them.
Also, the above class definition misses several member functions
(constructor, assignment operator, etc.) that should be written.

<p>In one test (slotted Aloha simulation with 10 nodes), the simulation was
8 times faster when using this technique. Of course, if your simulation
doesn't create and destroy many messages (compared to other activities),
you may not benefit this much.

<p>However, you'll notice one drawback of this solution when you try to use
Tkenv for debugging. While <tt>cPar</tt>-based message parameters can be viewed in
message inspector windows, parameters added by subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because the C++ language
does not support ``reflection'' (extracting class information at runtime)
like for example Java does.

<p>There is a solution however: one can supply Tkenv with missing ``reflection''
information about the new class. Reflection info might take the form of
a separate C++ class whose methods return information about the
<tt>RadioMsg</tt> fields. This descriptor class might look like this:

<pre>
class RadioMsgDescriptor : public Descriptor
{
  public:
    virtual int getFieldCount() {return 2;}

    virtual const char *getFieldName(int k) {
        const char *fieldname[] = {"freq", "power";}
        if (k&lt;0 || k&gt;=2) return NULL;
        return fieldname[k];
    }

    virtual double getFieldAsDouble(RadioMsg *msg, int k) {
        if (k==0) return msg-&gt;freq;
        if (k==1) return msg-&gt;power;
        return 0.0; // not found
    }
    //...
};
</pre>
<p>
Then you have to inform Tkenv that a <tt>RadioMsgDescriptor</tt> exists and that it
should be used whenever Tkenv finds messages of type <tt>RadioMsg</tt> (as it is
currently implemented, whenever the object's <tt>className()</tt> method returns
<tt>"RadioMsg"</tt>). So when you inspect a <tt>RadioMsg</tt> in your simulation, Tkenv
can use <tt>RadioMsgDescriptor</tt> to extract and display the values of
the <tt>freq</tt> and <tt>power</tt> variables.

<p>The actual implementation is somewhat more complicated than this, but not
much.

<p>To relieve the simulation programmer from having to write this extra code,
messages are described in a higher-level syntax, and a compiler is used to
generate the necessary C++ code with subclasses of <tt>cMessage</tt> and <tt>cPacket</tt>.
The message compiler can add the necessary data members and methods.
It also generates the necessary reflection code which makes it
possible to inspect message contents in Tkenv.

<p>OMNeT++ currently contains an experimental implementation of the message
subclassing feature described above. ``Experimental'' means that:

<p><UL>
  <li><strong></strong> The message description syntax and features may change in the future,
    based on feedback from the community;
  <li><strong></strong> The compiler that translates message descriptions into C++ is
    a perl script <tt>opp_msgc</tt>. This is a temporary solution until
    the C++-based <tt>nedtool</tt> is finished.
</UL>

<p>The subclassing approach for adding message parameters was originally
suggested by Nimrod Mesika.

<p>
<hr><font color="#006f00"><H2><A NAME="sec262"/>7.2. <FONTblue>The first message class</FONT></H2></font></hr>

<p>Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a <tt>mypacket.msg</tt> file with the following contents:

<p><pre>
<b>message</b> MyPacket
{
    <b>fields</b>:
       <b>int</b> srcAddress;
       <b>int</b> destAddress;
       <b>int</b> hops = 0;
};
</pre>

<p>The task of the ``message subclassing compiler'' is to generate C++ classes
you can use from your models as well as ``reflection'' classes that allow
Tkenv to inspect these data stuctures.

<p>If you process <tt>mypacket.msg</tt> with ``message subclassing compiler'', it will
create the following files for you: <tt>mypacket_m.h</tt> and <tt>mypacket_m.cc</tt>.
<tt>mypacket_m.h</tt> contains the declaration of the <tt>MyPacket</tt> C++ class, and
it should be included into your C++ sources where you need to handle
<tt>MyPacket</tt> objects.

<p>The <tt>MyPacket</tt> class declaration in <tt>mypacket_m.h</tt> will look like this:

<pre>
class MyPacket : public cMessage {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
</pre>
<p>
So in your C++ file, you could use it like this:

<pre>
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt-&gt;setSrcAddress( localAddr );
...
</pre>
<p>
The <tt>mypacket_m.cc</tt> file contains implementation of the generated <tt>MyPacket</tt>
class, as well as ``reflection'' code that allows you to inspect these data
stuctures in the Tkenv GUI. The <tt>mypacket_m.cc</tt> file should be compiled and
linked into your simulation. (If you use the <tt>opp_makemake</tt> tool
to generate your makefiles, the latter will be automatically taken care of.)

<p>
<hr><font color="#006f00"><H2><A NAME="sec263"/>7.3. <FONTblue>Features</FONT></H2></font></hr>

<p>The following sections describe the message syntax and features in detail.

<p>
<font color="#006f00"><H3><A NAME="sec264"/>7.3.1. <FONTteal>Declaring enums</FONT></H3></font>

<p>An <tt>enum {..}</tt> generates a normal C++ enum, plus creates an object
which stores text representations of the constants. The latter makes it possible
to display symbolic names in Tkenv.
An example:

<p><pre>
<b>enum</b> ProtocolTypes
{
   IP = 1;
   TCP = 2;
};
</pre>


<font color="#006f00"><H3><A NAME="sec265"/>7.3.2. <FONTteal>Message declarations</FONT></H3></font>

<p><STRONG>Basic use</STRONG>

<p>You can describe messages with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>int</b> sourceAddress;
        <b>int</b> destAddress;
        <b>bool</b> hasPayload;
};
</pre>

<p>Processing this description with the message compiler will produce
a C++ header file with a generated class, <tt>FooPacket</tt>.
<tt>FooPacket</tt> will be a subclass of <tt>cMessage</tt>.

<p>For each field in the above description, the generated class will have
a protected data member, a getter and a setter method. The names of the
methods will begin with <tt>get</tt> and <tt>set</tt>,
followed by the field name with its first letter converted to uppercase.
Thus, <tt>FooPacket</tt> will contain the following methods:

<pre>
virtual int getSourceAddress() const;
virtual void setSourceAddress(int sourceAddress);

virtual int getDestAddress() const;
virtual void setDestAddress(int destAddress);

virtual bool getHasPayload() const;
virtual void setHasPayload(bool hasPayload);
</pre>
<p>
Note that the methods are all declared <tt>virtual</tt> to give you the possibility
of overriding them in subclasses.

<p>Two constructors will be generated: one that optionally accepts an object name,
and a copy constructor:

<pre>
FooPacket(const char *name=NULL);
FooPacket(const FooPacket& other);
</pre>
<p>
Appropriate assignment operator (<tt>operator=()</tt>) and <tt>dup()</tt> methods will
also be generated.

<p>Data types for fields are not limited to <tt>int</tt> and <tt>bool</tt>. You can use the
following primitive types (i.e. primitive types as defined in the C++ language):

<p><UL>
   <li><strong></strong> <tt>bool</tt>
   <li><strong></strong> <tt>char</tt>, <tt>unsigned char</tt>
   <li><strong></strong> <tt>short</tt>, <tt>unsigned short</tt>
   <li><strong></strong> <tt>int</tt>, <tt>unsigned int</tt>
   <li><strong></strong> <tt>long</tt>, <tt>unsigned long</tt>
   <li><strong></strong> <tt>double</tt>
</UL>

<p>Field values are initialized to zero.

<p>
<STRONG>Initial values</STRONG>

<p>You can initialize field values with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
        <b>int</b> sourceAddress = 0;
        <b>int</b> destAddress = 0;
        <b>bool</b> hasPayload = false;
};
</pre>

<p>Initialization code will be placed in the constructor of the generated class.

<p>
<STRONG>Enum declarations</STRONG>

<p>You can declare that an <tt>int</tt> (or other integral type) field
takes values from an enum. The message compiler can than generate code
that allows Tkenv display the symbolic value of the field.

<p>Example:

<p><pre>
<b>message</b> FooPacket
{
  <b>fields</b>:
      <b>int</b> payloadType <b>enum</b>(PayloadTypes);
};
</pre>

<p>The enum has to be declared separately in the message file.

<p>
<STRONG>Fixed-size arrays</STRONG>

<p>You can specify fixed size arrays:

<p><pre>
<b>message</b> FooPacket
{
    <b>fields</b>:
        <b>long</b> route[4];
};
</pre>

<p>The generated getter and setter methods will have an extra <tt>k</tt> argument,
the array index:

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
</pre>
<p>
If you call the methods with an index that is out of bounds, an exception
will be thrown.

<p>
<STRONG>Dynamic arrays</STRONG>

<p>If the array size is not known in advance, you can declare the field
to be a dynamic array:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>long</b> route[];
};
</pre>

<p>In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

<pre>
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
</pre>
<p>
The <tt>set...ArraySize()</tt> method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

<p>The default array size is zero. This means that you need to call the
<tt>set...ArraySize()</tt> before you can start filling array elements.

<p>
<STRONG>String members</STRONG>

<p>You can declare string-valued fields with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>string</b> hostName;
};
</pre>

<p>The generated getter and setter methods will return and accept <tt>const char*</tt>
pointers:

<pre>
virtual const char *getHostName() const;
virtual void setHostName(const char *hostName);
</pre>
<p>
The generated object will have its own copy of the string.

<p>NOTE: a string member is different from a character array,
which is treated as an array of any other type. For example,

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       <b>char</b> chars[10];
};
</pre>

<p>will generate the following methods:

<pre>
virtual char getChars(unsigned k);
virtual void setChars(unsigned k, char a);
</pre>
<p>

<p><font color="#006f00"><H3><A NAME="sec266"/>7.3.3. <FONTteal>Inheritance, composition</FONT></H3></font>

<p>So far we have discussed how to add fields of primitive types
(<tt>int</tt>, <tt>double</tt>, <tt>char</tt>, ...) to <tt>cMessage</tt>.
This might be sufficient for simple models, but if you have
more complex models, you'll probably need to:

<p><UL>
  <li><strong></strong> set up a hierarchy of message (packet) classes, that is,
    not only subclass from <tt>cMessage</tt> but also from your
    own message classes;
  <li><strong></strong> use not only primitive types as fields, but also structs,
    classes or typedefs. Sometimes you'll want to use a C++ type
    present in an already existing header file, another time you'll
    want a struct or class to be generated by the message
    compiler so that you can benefit from Tkenv inspectors.
</UL>

<p>The following section describes how to do these tasks.

<p>
<STRONG>Inheritance among message classes</STRONG>

<p>By default, messages are subclassed from <tt>cMessage</tt>. However, you can
explicitly specify the base class using the <tt>extends</tt> keyword:

<p><pre>
<b>message</b> FooPacket <b>extends</b> FooBase
{
    <b>fields</b>:
        ...
};
</pre>

<p>For the above example, the generated C++ code will look like:

<pre>
class FooPacket : public FooBase { ... };
</pre>
<p>
Inheritance also works for structs and classes (see next sections
for details).

<p>

<p><STRONG>Defining classes</STRONG>

<p>Until now we have used the <tt>message</tt> keyword to define classes, which
implies that the base class is <tt>cMessage</tt>, either directly or indirectly.

<p>But as part of complex messages, you'll need structs and other classes
(rooted or not rooted in <tt>cObject</tt>) as building blocks.
Classes can be created with the <tt>class</tt> class keyword;
structs we'll cover in the next section.

<p>The syntax for defining classes is almost the same as defining messages,
only the <tt>class</tt> keyword is used instead of <tt>message</tt>.

<p>Slightly different code is generated for classes that are rooted in
<tt>cObject</tt> than for those which are not.
If there is no <tt>extends</tt>, the generated class will not be
derived from <tt>cObject</tt>, thus it will not have <tt>name()</tt>,
<tt>className()</tt>, <tt>setOwner()</tt>, etc. methods.
To create a class with those methods, you have to explicitly write
<tt>extends cObject</tt>.

<p><pre>
<b>class</b> MyClass <b>extends</b> cObject
{
    <b>fields</b>:
        ...
};
</pre>

<p>

<p><STRONG>Defining plain C structs</STRONG>

<p>You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods''.
(Actually, in the C++ language a struct can have methods,
and in general it can do anything a class can.)

<p>The syntax is similar to that of defining messages:

<p><pre>
<b>struct</b> MyStruct
{
    <b>fields</b>:
        <b>char</b> array[10];
        <b>short</b> version;
};
</pre>

<p>However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. For the above definition, the
following code is generated:

<pre>
// generated C++
struct MyStruct
{
    char array[10];
    short version;
};
</pre>
<p>
A struct can have primitive types or other structs are fields. It cannot
have string or class as field.

<p>Inheritance is supported for structs:

<p><pre>
<b>struct</b> Base
{
    ...
};

<p><b>struct</b> MyStruct extends Base
{
    ...
};
</pre>

<p>But because a struct has no member functions, there are limitations:

<p><UL>
   <li><strong></strong> field initialization is not supported (it would need constructor)
   <li><strong></strong> struct fields are not initialized to zero (it would need constructor)
   <li><strong></strong> dynamic arrays are not supported (no place for the array allocation code)
   <li><strong></strong> ``generation gap'' or abstract fields (see later) cannot be used,
      because they would build upon virtual functions.
</UL>

<p>
<STRONG>Using structs and classes as fields</STRONG>

<p>In addition to primitive types, you can also use other structs or objects
as a field. For example, if you have a struct named <tt>IPAddress</tt>,
you can write the following:

<p><pre>
<b>message</b> FooPacket
{
   <b>fields</b>:
       IPAddress src;
};
</pre>

<p>The <tt>IPAddress</tt> structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via <tt>cplusplus {{...}}</tt> and its type announced
(see Announcing C++ types).

<p>The generated class will contain an <tt>IPAddress</tt> data member
(that is, <STRONG>not</STRONG> a pointer to an <tt>IPAddress</tt>).
The following getter and setter methods will be generated:

<pre>
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
</pre>
<p>

<p><STRONG>Pointers</STRONG>

<p>Not supported yet.

<p>

<p><font color="#006f00"><H3><A NAME="sec267"/>7.3.4. <FONTteal>Using existing C++ types</FONT></H3></font>

<p>
<STRONG>Announcing C++ types</STRONG>

<p>If you want to use one of your own types (a class, struct or typedef,
declared in a C++ header) in a message definition, you have to
announce those types to the message compiler. You also have to make sure
that your header file gets included into the generated <tt>_m.h</tt> file
so that the C++ compiler can compile it.

<p>Suppose you have an <tt>IPAddress</tt> structure, defined in an <tt>ipaddress.h</tt>
file:

<pre>
// ipaddress.h
struct IPAddress {
    int byte0, byte1, byte2, byte3;
};
</pre>
<p>
To be able to use <tt>IPAddress</tt> in a message definition, the message
file (say <tt>foopacket.msg</tt>) should contain the following lines:

<p><pre>
<b>cplusplus</b> {{
#include "ipaddress.h"
}};

<p><b>struct</b> IPAddress;
</pre>

<p>The effect of the first three lines is simply that the <tt>#include</tt>
statement will be copied into the generated <tt>foopacket_m.h</tt>
file to let the C++ compiler know about the <tt>IPAddress</tt> class.
The message compiler itself will not try to make sense of the
text in the body of the <tt>cplusplus {{ ... }}</tt> directive.

<p>The next line, <tt>struct IPAddress</tt>, tells the message compiler that
<tt>IPAddress</tt> is a C++ struct. This information will (among others)
affect the generated code.

<p>Classes can be announced using the <tt>class</tt> keyword:

<p><pre>
<b>class</b> cSubQueue;
</pre>

<p>The above syntax assumes that the class is derived from <tt>cObject</tt>
either directly or indirectly. If it is not, the <tt>noncobject</tt>
keyword should be used:

<p><pre>
<b>class</b> <b>noncobject</b> IPAddress;
</pre>

<p>The distinction between classes derived and not derived from <tt>cObject</tt>
is important because the generated code differs at places.
The generated code is set up so that if you incidentally
forget the <tt>noncobject</tt> keyword (and so you mislead the
message compiler into thinking that your class is rooted in
<tt>cObject</tt> when in fact it is not), you'll get a C++ compiler
error in the generated header file.

<p>
<font color="#006f00"><H3><A NAME="sec268"/>7.3.5. <FONTteal>Customizing the generated class</FONT></H3></font>

<p>
<STRONG>The Generation Gap pattern</STRONG>

<p>Sometimes you need the generated code to something
more or do something differently than the version generated
by the message compiler.
For example, when setting a integer field named <tt>payloadLength</tt>,
you might also need to adjust the packet length. That is,
the following default (generated) version of the
<tt>setPayloadLength()</tt> method is not suitable:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    this-&gt;payloadLength = payloadLength;
}
</pre>
<p>
Instead, it should look something like this:

<pre>
void FooPacket::setPayloadLength(int payloadLength)
{
    int diff = payloadLength - this-&gt;payloadLength;
    this-&gt;payloadLength = payloadLength;
    setLength( length() + diff );
}
</pre>
<p>
According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

<p>However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the <EM>Generation Gap</EM> design pattern.
It is enabled with the following syntax:

<p><pre>
<b>message</b> FooPacket
{
   <b>properties</b>:
       customize = true;
   <b>fields</b>:
       <b>int</b> payloadLength;
};
</pre>

<p>The <tt>properties</tt> section within the message declaration contains
meta-info that affects how generated code will look like.
The customize property enables the use of the Generation Gap
pattern.

<p>If you process the above code with the message compiler,
the generated code will contain a <tt>FooPacket_Base</tt> class
instead of <tt>FooPacket</tt>. The idea is that you have
to subclass from <tt>FooPacket_Base</tt> to produce
<tt>FooPacket</tt>, while doing your customizations
by redefining the necessary methods.

<pre>
class FooPacket_Base : public cMessage
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
</pre>
<p>
There is a minimum amount of code you have to write
for <tt>FooPacket</tt>, because not everything can be
pre-generated as part of <tt>FooPacket_Base</tt>, e.g.
constructors cannot be inherited. This minimum
code is the following (you'll find it the generated C++ header
too, as a comment):

<pre>
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual cObject *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
</pre>
<p>
So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

<pre>
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy contructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
</pre>
<p>

<p>
<STRONG>Abstract fields</STRONG>

<p>The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

<p>For example, this is the situation when you want to store a bitfield
in a single <tt>int</tt> or <tt>short</tt>, and still you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

<p>You can declare any field to be abstract with the following syntax:

<pre>
<b>message</b> FooPacket
{
   <b>properties</b>:
       customize = true;
   <b>fields</b>:
       <b>abstract</b> <b>bool</b> urgentBit;
};
</pre>

<p>For an <tt>abstract</tt> field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

<pre>
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
</pre>
<p>

<p>Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.

<p>
<hr><font color="#006f00"><H2><A NAME="sec269"/>7.4. <FONTblue>Summary</FONT></H2></font></hr>

<p>This section attempts to summarize the possibilities.

<p>You can generate:

<p><UL>
  <li><strong></strong>  classes rooted in <tt>cObject</tt>
  <li><strong></strong>  messages (default base class is <tt>cMessage</tt>)
  <li><strong></strong>  classes not rooted in <tt>cObject</tt>
  <li><strong></strong>  plain C structs
</UL>

<p>The following data types are supported for fields:

<p><UL>
  <li><strong></strong>  primitive types: <tt>bool</tt>, <tt>char</tt>, <tt>short</tt>,
    <tt>int</tt>, <tt>long</tt>, <tt>unsigned short</tt>, <tt>unsigned int</tt>,
    <tt>unsigned long</tt>, <tt>double</tt>
  <li><strong></strong>  <tt>string</tt>, a dynamically allocated string, presented as <tt>const char *</tt>
  <li><strong></strong>  fixed-size arrays of the above types
  <li><strong></strong>  structs, classes (both rooted and not rooted in <tt>cObject</tt>),
    declared with the message syntax or externally in C++ code
  <li><strong></strong>  variable-sized arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
</UL>

<p>Further features:

<p><UL>
  <li><strong></strong>  fields initialize to zero (except struct members)
  <li><strong></strong>  fields initializers can be specified (except struct members)
  <li><strong></strong>  assigning <tt>enum</tt>s to variables of integral types.
  <li><strong></strong>  inheritance
  <li><strong></strong>  customizing the generated class via subclassing (<EM>Generation Gap</EM> pattern)
  <li><strong></strong>  abstract fields (for nonstandard storage and calculated fields)
</UL>

<p>Generated code (all generated methods are <tt>virtual</tt>, although
this is not written out in the following table):

<p><table border>
<TR> <TD align=left>

<p>
<b>Field declaration</b>
    </TD> <TD align=left>
<b>Generated code</b>
</TD></TR>
<TR> <TD align=left> 
primitive types
<pre>
double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField();
void setField(double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
string type
<pre>
string field;
</pre>
     </TD> <TD align=left>
<pre>
const char *getField();
void setField(const char *);
</pre>
</TD></TR>
<TR> <TD align=left> 
fixed-size arrays
<pre>
double field[4];
</pre>
     </TD> <TD align=left>
<pre>
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
</pre>

<p></TD></TR>
<TR> <TD align=left> 
dynamic arrays
<pre>
double field[];
</pre>
     </TD> <TD align=left>
<pre>
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
</pre>
</TD></TR>
<TR> <TD align=left> 
customized class
<pre>
class Foo {
  properties:
    customize=true;
</pre>
     </TD> <TD align=left>
<pre>
class Foo_Base { ... };
</pre>
and you have to write:
<pre>
class Foo : public Foo_Base {
   ...
};
</pre>
</TD></TR>
<TR> <TD align=left> 
abstract fields
<pre>
abstract double field;
</pre>
     </TD> <TD align=left>
<pre>
double getField() = 0;
void setField(double d) = 0;
</pre>
</TD></TR>
<TR> <TD align=left> 
</table>

<p>
<hr><font color="#006f00"><H2><A NAME="sec270"/>7.5. <FONTblue>Example</FONT></H2></font></hr>

<p>Several of the example simulations (Token Ring, Dyna2, Hypercube)
use message definitions. For example, in Dyna2 you'll find this:

<p><UL>
 <li><strong></strong> <tt>dynapacket.msg</tt> defines <tt>DynaPacket</tt> and <tt>DynaDataPacket</tt>;
 <li><strong></strong> <tt>dynapacket_m.h</tt> and <tt>dynapacket_m.cc</tt> are produced
   by the message subclassing compiler from it, and they contain
   the generated <tt>DynaPacket</tt> and <tt>DynaDataPacke</tt>t
   C++ classes (plus code for Tkenv inspectors);
 <li><strong></strong> other model files (<tt>client.cc</tt>, <tt>server.cc</tt>, ...)
   use the generated message classes
</UL>

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec271"/>8. <FONTgreen>Building Simulation Programs</FONT></H1></font></hr>
<a name="cha:building-simulation-programs"/>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec272"/>8.1. <FONTblue>Overview</FONT></H2></font></hr>

<p>As it was already mentioned, an OMNeT++ model physically consists of
the following parts:
<UL>
<li><strong></strong>NED language topology description(s). These
    are files with the .ned suffix.
<li><strong></strong>Simple modules. These are C++ files, with .cc suffix.
</UL>

<p>Model files are usually placed in the projects/modelname subdirectory
of the main OMNeT++ directory.

<p>
The NED files are compiled into C++ using the NEDC
compiler\indexned!compiler which is part of OMNeT++. The NEDC
compiler (source and executable) is normally located in the nedc
subdirectory of the main OMNeT++ directory.

<p>
The simulation system provides the following components that will be
part of the simulation executable:
<UL>
<li><strong></strong>Simulation kernel with the simulation
    class library. This is a library
    file with .a or .lib extension, normally in the sim subdirectory
    of the main OMNeT++ directory. It comes in several versions:
    <SAMP>libsim_std.a</SAMP> (sim_std.lib) is the standard version and
    <SAMP>libsim_pvm.a</SAMP> (sim_pvm.lib) and <SAMP>libsim_mpi.a</SAMP>
    (sim_mpi.lib) are the ones to be used with parallel execution.
<li><strong></strong>User interfaces. These are also library files (.a or .lib file),
    normally in the envir directory and other directories. The common
    part of all user interfaces is <SAMP>libenvir.a</SAMP> (envir.lib),
    and the specific user interfaces are <SAMP>libcmdenv.a</SAMP>
    (cmdenv.lib), <SAMP>libtkenv.a</SAMP> (tkenv.lib).
</UL>

<p>Simulation programs are built from the above components. First, the
NED files are compiled into C++ source code using the
NEDC compiler. Then all C++ sources are compiled
and linked with the simulation kernel and a
user interface to form a simulation executable.

<p>
The following figure gives an overview of the process of building
and running simulation programs.

<p>

<p>  <DIV ALIGN=center>
    <img src="usmanFig17.gif">
    <center><i>Figure: Building and running simulation</i></center>
  </DIV>

<p>

<p>This section discusses how to use the simulation system on the
following platforms:
<UL>
  <li><strong></strong>Unix with gcc (also Windows with Cygwin or MinGW)
  <li><strong></strong>MSVC 6.0 on Windows
</UL>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec273"/>8.2. <FONTblue>Using Unix and gcc</FONT></H2></font></hr>

<p>This section applies to using OMNeT++ on Linux, Solaris, FreeBSD and
other Unix derivatives, and also more or less to Cygwin and MinGW
on Windows.

<p>Here in the manual we can give a rough overview only.
The <tt>doc/</tt> directory of your OMNeT++ installation contains
<tt>Readme.</tt><EM>&lt;platform&gt;</EM> files that provide
up-to-date, more detailed and more precise instructions.

<p>
<font color="#006f00"><H3><A NAME="sec274"/>8.2.1. <FONTteal>Installation</FONT></H3></font>

<p>The installation process depends on what distribution you take
(source, precompiled RPM, etc.) and it may change from release
to release, so it is better to refer to the readme files.
If you compile from source, you can expect the usual GNU
procedure: <tt>./configure</tt>, <tt>make</tt>.

<p>
<font color="#006f00"><H3><A NAME="sec275"/>8.2.2. <FONTteal>Building simulation models</FONT></H3></font>

<p>The <tt>opp_makemake</tt> script can automatically generate the
<SAMP>Makefile</SAMP> for your simulation program, based on the source files
in the current directory. (It can also handle large models
which are spread across several directories; this is covered later in
this section.)

<p><tt>opp_makemake</tt> has several options, with the <tt>-h</tt>
option it displays a summary.

<pre>
0pp_makemake -h
</pre>
<p>
Once you have the source files (<tt>*.ned</tt>, <tt>*.msg</tt>, <tt>*.cc</tt>,
<tt>*.h</tt>) in a directory, cd there then type:

<pre>
0pp_makemake
</pre>
<p>
This will create a file named <SAMP>Makefile</SAMP>. Thus if you
simply type <tt>make</tt>, your simulation program should build. The name of
the executable will be the same as the name of the directory
containing the files.

<p>
The freshly generated <SAMP>Makefile</SAMP> doesn't contain
dependencies, it is advisable to add them
by typing <tt>make depend</tt>. The warnings during the
dependency generation process can be safely ignored.

<p>In addition to the simulation executable, the <SAMP>Makefile</SAMP>
contains other targets, too. Here is a list of important ones:

<p><table border>
<TR> <TD align=left>

<p><b>Target</b> </TD> <TD align=left> <b>Action</b></TD></TR>
<TR> <TD align=left>  </TD> <TD align=left> The default target is to build the simulation executable</TD></TR>
<TR> <TD align=left> depend </TD> <TD align=left> Adds (or refreshes) dependencies in the <SAMP>Makefile</SAMP></TD></TR>
<TR> <TD align=left> clean </TD> <TD align=left>  Deletes all files that were produced by the make process</TD></TR>
<TR> <TD align=left> neddoc.html </TD> <TD align=left> Generates documentation for all NED files. The resulting file is named <SAMP>neddoc.html</SAMP></TD></TR>
<TR> <TD align=left> htmldoc </TD> <TD align=left> Generates code documentation using doxygen. The documentation will be placed into the directory <SAMP>htmldoc</SAMP></TD></TR>
<TR> <TD align=left> doc </TD> <TD align=left> Convenience target that calls neddoc.html and htmldoc</TD></TR>
<TR> <TD align=left> re-makemake </TD> <TD align=left> Regenerates the <SAMP>Makefile</SAMP> using <tt>opp_makemake</tt> (this is useful if e.g.  after upgrading OMNeT++, if <tt>opp_makemake</tt> has changed)</TD></TR>
<TR> <TD align=left> re-makemake-m </TD> <TD align=left> Similar to <tt>make re-makemake</tt>, but it regenerates the <SAMP>Makefile.in</SAMP> instead</TD></TR>
</table>

<p>If you already had a <SAMP>Makefile</SAMP> in that directory, <tt>opp_makemake</tt>
will refuse overwriting it. You can force overwriting the old <SAMP>Makefile</SAMP>
with the -f option:

<pre>
0pp_makemake -f
</pre>
<p>
If you have problems, check the path definitions (locations of include
files and libraries etc.) in the configure script and correct them if necessary. Then re-run configure to
commit the changes to all makefiles, the <tt>opp_makemake</tt> script
etc.

<p>
You can specify the user interface (Cmdenv/Tkenv) with the -u option
(with no -u, Tkenv is the default):

<pre>
0pp_makemake -u Tkenv
</pre>
<p>
The name of the output file is set with the -o
option (the default is the name of the directory):

<pre>
0pp_makemake -o fddi-net
</pre>
<p>
If some of your source files are generated from other files (for
example, you use machine-generated NED files), write your make rules
into a file called makefrag. When you run <tt>opp_makemake</tt>, it
will automatically insert makefrag into the resulting <SAMP>makefile</SAMP>.  With
the -i option, you can also name other files to be included into
<SAMP>Makefile</SAMP>.

<p>
If you want better portability for your models, you can generate
<SAMP>Makefile.in</SAMP> instead of <SAMP>Makefile</SAMP> with <tt>opp_makemake</tt>'s -m
option. You can then use autoconf-like configure scripts to generate
the <SAMP>Makefile</SAMP>.

<p>

<p>
<font color="#006f00"><H3><A NAME="sec276"/>8.2.3. <FONTteal>Multi-directory models</FONT></H3></font>

<p>In the case of a large project, your source files may be spread across
several directories. You have to decide whether you want to use static
linking, shared or run-time loaded (shared)
libraries. Here we discuss static linking.

<p>
In each subdirectory (say trafgen/ and router/), run

<pre>
opp_makemake -n
</pre>
<p>
The -n option means no linking is necessary, only compiling has
to be done.

<p>
In your toplevel source directory, run

<pre>
opp_makemake trafgen/ router/
</pre>
<p>
This results in recursive makefiles: when you build the simulation, make
will descend into trafgen/ and router/, run make in both, then
it will link an executable with the object files in the two directories.

<p>
You may need to use the -I option if you include files from other
directories. The -I option is for both C++ and NED
files. In our example, you could run

<pre>
opp_makemake -n -I../router
</pre>
<p>
in the trafgen/ directory and vice versa.

<p>
If you're willing to play with shared and run-time loaded libraries,
several <tt>opp_makemake</tt> options and the
<SAMP>[General]/load-libs=</SAMP> ini file option leave you enough room to
do so.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec277"/>8.2.4. <FONTteal>Static vs shared OMNeT++ system libraries</FONT></H3></font>

<p>Default linking uses the shared libraries. One
reason you would want static linking is that
debugging\indexdebugging the OMNeT++ class library is more trouble
with shared libraries. Another reason might be that you want to run
the executable on another machine without having to worry about
setting the <tt>LD_LIBRARY_PATH</tt> variable (which should contain the name
of the directory where the OMNeT++ shared libraries are).

<p>If you want static linking, find the

<pre>
build_shared_libs=yes
</pre>
<p>

<p>line in the configure.user script and change it to

<pre>
build_shared_libs=no
</pre>
<p>
Then you have to re-run the configure script and rebuild everything:

<pre>
./configure
make clean
make
</pre>
<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec278"/>8.3. <FONTblue>Using Windows and Microsoft Visual C++</FONT></H2></font></hr>

<p>This is only a rough overview. Up-to-date, more detailed and more
precise instructions can be found in the <tt>doc/</tt> directory
of your OMNeT++ installation, in the file <tt>Readme.MSVC</tt>.

<p>
<font color="#006f00"><H3><A NAME="sec279"/>8.3.1. <FONTteal>Installation</FONT></H3></font>

<p>It is easiest to start with the binary, autoinstaller version.
It contains all necessary software except MSVC,
and you can get a working system up and running very fast.

<p>Later you'll probably want to download and build the source
distribution too. Reasons for that might be to compile the libraries
with different flags, to debug into them, or to recompile
with support for additional packages (e.g. Akaroa, MPI).
Compilation should be painless (it takes a single
<tt>nmake -f Makefile.vc</tt> command) after you get the different
component directories right in <tt>configuser.vc</tt>.
Additional software needed for the compilation is also described
in <tt>doc/</tt>.

<p><font color="#006f00"><H3><A NAME="sec280"/>8.3.2. <FONTteal>Building simulation models</FONT></H3></font>

<p>Now OMNeT++ has an automatic MSVC makefile creator named <tt>opp_nmakemake</tt>
which is probably the easier way to go. Its usage is very similar
to the similarly named tool for Unix.

<p>However, if you like the MSVC IDE, you can also use it.
There is an MSVC wizard which will create project files for you,
or you can start by copying one of the sample simulations.
There is also an AddNEDFileToProject macro that can, well, add
NED files to your project with the necessary custom build step
(invoke nedc, etc.)

<p>Some caveats (please read <tt>doc/Readme.MSVC</tt> for more!):

<p><UL>
 <li><strong></strong> <b>how to get the graphical environment</b>. By default,
   the sample simulations link with Cmdenv if you rebuild them
   from the IDE. To change to Tkenv, choose Build|Set
   active configuration from the menu, select ``Debug-Tkenv''
   or ``Release-Tkenv'', then re-link the executable.

<p> <li><strong></strong> <b>can't find a usable init.tcl</b>. If you get this message,
   Tcl/Tk is missing the <tt>TCL_LIBRARY</tt> environment variable
   which is normally set by the installer. If you see this message,
   you need to set this variable yourself to the Tcl <tt>lib/</tt> directory.

<p> <li><strong></strong> <b>changed compiler settings</b>. Changes since OMNeT++ 2.2:
   You'll need exception handling and RTTI turned ON, and
   stack size set to as low as 64K.
   See the readme file for rationale and more hints.

<p> <li><strong></strong> <b>adding NED files</b>. After you added a <SAMP>.ned</SAMP> file
   to the project, you also have to add a <tt>_n.cpp</tt> file, and set a
   <EM>Custom Build Step</EM> for them:

<pre>
Description: NED Compiling $(InputPath)
Command: nedc -s _n.cpp $(InputPath)
Outputs: $(InputName)_n.cpp
</pre>
<p>
   For msg files you need an analogous procedure.

<p> <li><strong></strong> <b>file name extension</b>: as a gesture toward the free software
   community, MSVC refuses to treat <SAMP>.cc</SAMP> files as C++ sources,
   so first you have to rename them to <SAMP>.cpp</SAMP>.
   For the sample simulations this is done by <tt>samples/cc2cpp.bat</tt>.

<p></UL>

<p>





<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec281"/>9. <FONTgreen>Running The Simulation</FONT></H1></font></hr>
<a name="cha:running-the-simulation"/>

<p><hr><font color="#006f00"><H2><A NAME="sec282"/>9.1. <FONTblue>User interfaces</FONT></H2></font></hr>

<p>OMNeT++ simulations can be run under different user interfaces.
Currenly, two user interfaces are supported:

<p><UL>
  <li><strong></strong> Tkenv: Tcl/Tk-based graphical, windowing user interface
  <li><strong></strong> Cmdenv: command-line user interface for batch execution
</UL>

<p>
You would typically test and debug your simulation under Tkenv,
then do actual simulation experiments with Cmdenv which supports
batch execution. Tkenv is also better suited for educational or
demonstration purposes.

<p>Both Tkenv and Cmdenv are provided in the form of a library, and
you choose between them by linking one or the other into your
simulation executable. (Creating the executable was described in
chapter <a href="#cha:building-simulation-programs">[click]</a>). Both user interfaces
are supported on Unix and Windows platforms.

<p>Common functionality in Tkenv and Cmdenv has been collected and
placed into the Envir library, which can be thought of as the
``common base class'' for the two user interfaces.

<p>The user interface is separated from the
simulation kernel, and the two parts interact through a well-defined
interface. This also means that, if needed, you can write your
own user interface or embed an OMNeT++ simulation into your application
without any change to models or the simulation library.

<p>Configuration and input data for the simulation are described in
a configuration file usually called <tt>omnetpp.ini</tt>.
Some entries in this file apply to Tkenv or Cmdenv only, other
settings are in effect regardless of the user interface.
Both user interfaces accept command-line arguments, too.

<p>
The following sections explain <tt>omnetpp.ini</tt> and the common part of
the user interfaces, describe Cmdenv and Tkenv in detail, then
go on to specific problems.

<p>
<hr><font color="#006f00"><H2><A NAME="sec283"/>9.2. <FONTblue>The configuration file: omnetpp.ini</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec284"/>9.2.1. <FONTteal>An example</FONT></H3></font>

<p>For a start, let us see a simple <tt>omnetpp.ini</tt> file which
can be used to run the Fifo1 sample simulation under Cmdenv.

<pre>
[General]
network = fifonet1
sim-time-limit = 500000s
output-vector-file = fifo1.vec

[Cmdenv]
express-mode = yes

[Parameters]
# generate a large number of jobs of length 5..10 according to Poisson
fifonet1.gen.num_messages = 10000000
fifonet1.gen.ia_time = exponential(1)
fifonet1.gen.msg_length = intuniform(5,10)
# processing speeed of queue server
fifonet1.fifo.bits_per_sec = 10
</pre>
<p>
The file is grouped into <EM>sections</EM> named <tt>[General]</tt>, <tt>[Cmdenv]</tt>
and <tt>[Parameters]</tt>, each one containing several <EM>entries</EM>.
The <tt>[General]</tt> section applies to both Tkenv and Cmdenv, and the entries
in this case specify that the network named <tt>fifonet1</tt> should be simulated and run
for 500,000 simulated seconds, and vector results should be written into the
<tt>fifo1.vec</tt> file. The entry in the <tt>[Cmdenv]</tt> section tells
Cmdenv to run the simulation at full speed and print periodic updates
about the progress of the simulation. The <tt>[Parameters]</tt> section assigns
values to parameters that did not get a value (or got <tt>input</tt> value)
inside the NED files. Lines that start with "#" or ";" are comments.

<p>When you build the Fifo1 sample with Cmdenv and you run it by typing <tt>fifo1</tt>
(or on Unix, <tt>./fifo1</tt>) on the command prompt, you should see
something like this.

<pre>
OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Preparing for Run #1...
Setting up network `fifonet1'...
Running simulation...
** Event #0        T=0.0000000  ( 0.00s)   Elapsed: 0m  0s   ev/sec=0
** Event #100000   T=25321.99 ( 7h  2m)    Elapsed: 0m  1s   ev/sec=0
** Event #200000   T=50275.694 (13h 57m)   Elapsed: 0m  3s   ev/sec=60168.5
** Event #300000   T=75217.597 (20h 53m)   Elapsed: 0m  5s   ev/sec=59808.6
** Event #400000   T=100125.76 ( 1d  3h)   Elapsed: 0m  6s   ev/sec=59772.9
** Event #500000   T=125239.67 ( 1d 10h)   Elapsed: 0m  8s   ev/sec=60168.5
...
** Event #1700000  T=424529.21 ( 4d 21h)   Elapsed: 0m 28s   ev/sec=58754.4
** Event #1800000  T=449573.47 ( 5d  4h)   Elapsed: 0m 30s   ev/sec=59066.7
** Event #1900000  T=474429.06 ( 5d 11h)   Elapsed: 0m 32s   ev/sec=59453
** Event #2000000  T=499417.66 ( 5d 18h)   Elapsed: 0m 34s   ev/sec=58719.9
&lt;!&gt; Simulation time limit reached -- simulation stopped.

Calling finish() at end of Run #1...
*** Module: fifonet1.sink***
Total jobs processed: 9818
Avg queueing time:    1.8523
Max queueing time:    10.5473
Standard deviation:   1.3826

End run of OMNeT++
</pre>
<p>
As Cmdenv runs the simulation, periodically it prints the sequence number
of the current event, the simulation time, the elapsed (real) time,
and the performance of the simulation (how many events are processed per
second; the first two values are 0 because there wasn't enough data
for it to calculate yet). At the end of the simulation, the <tt>finish()</tt>
methods of the simple modules are run, and the output from them are displayed.
On my machine this run took 34 seconds. This Cmdenv output can be
customized via other <tt>omnetpp.ini</tt> entries. The output file <tt>fifo1.vec</tt>
contains vector data recorded during simulation (here, queueing times),
and it can be processed using Plove or other tools.

<p><font color="#006f00"><H3><A NAME="sec285"/>9.2.2. <FONTteal>The concept of simulation runs</FONT></H3></font>

<p>OMNeT++ can execute several simulation runs automatically one after
another. If multiple runs are
selected, option settings and parameter values can be given either
individually for each run, or together for all runs, depending in
which section the option or parameter appears.

<p><font color="#006f00"><H3><A NAME="sec286"/>9.2.3. <FONTteal>Sections and entries</FONT></H3></font>

<p>The ini file is a text file consisting of entries grouped
into different sections.

<p>Lines that start with "#" or ";" are comments, and will be ignore during
processing.

<p>The following sections can exist:

<p><table border>
<TR> <TD align=left>

<p><b>Section</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left> <tt>[General]</tt> </TD> <TD align=left> Contains general settings that apply to all simulation runs
and all user interfaces. For details, see section <a href="#sec:ch-run-sim:general-section">[click]</a>.
</TD></TR>
<TR> <TD align=left> <tt>[Run 1]</tt>, <tt>[Run 2]</tt>, ...  </TD> <TD align=left> Contains per-run settings.
These sections may contain any entries that are accepted in other
sections (except <tt>[Machines]</tt>).
</TD></TR>
<TR> <TD align=left> <tt>[Cmdenv]</tt> </TD> <TD align=left> Contains Cmdenv-specific settings.
For details, see section <a href="#sec:ch-run-sim:cmdenv-section">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Tkenv]</tt> </TD> <TD align=left> Contains Tkenv-specific settings.
For details, see section <a href="#sec:ch-run-sim:tkenv-section">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Parameters]</tt> </TD> <TD align=left> Contains values for module parameters that did not
get a value (or got <tt>input</tt> value) inside the NED files.
For details, see section <a href="#sec:ch-run-sim:parameter-settings">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[OutVectors]</tt> </TD> <TD align=left> Configures recording of output vectors. You can specify
filtering by vector names and by simulation time (start/stop recording).
For details, see section <a href="#sec:ch-run-sim:outvectors-section">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[DisplayStrings]</tt> </TD> <TD align=left> Module display strings for Tkenv.
For details, see section <a href="#sec:ch-run-sim:displaystrings-section">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Machines]</tt> </TD> <TD align=left> Used with distributed execution, describes logical - physical
machine mapping.
For details, see section <a href="#sec:ch-parallel-exec:machine-mapping">[click]</a>
</TD></TR>
<TR> <TD align=left> <tt>[Slaves]</tt> </TD> <TD align=left> Used with distributed execution, contains settings
for slave processes.
For details, see section <a href="#sec:ch-run-sim:slaves-section">[click]</a>
</TD></TR>
<TR> <TD align=left> </table>

<p>
<font color="#006f00"><H3><A NAME="sec287"/>9.2.4. <FONTteal>File inclusion</FONT></H3></font>

<p>OMNeT++ supports including an ini file in another,
via the <tt>include</tt> keyword. This feature allows you to partition large ini
files into logical units, fixed and varying part etc.

<p>An example:

<pre>
# omnetpp.ini
...
include parameters.ini
include per-run-pars.ini
...
</pre>
<p>

<p><font color="#006f00"><H3><A NAME="sec288"/>9.2.5. <FONTteal>The [General] section</FONT></H3></font>
<a name="sec:ch-run-sim:general-section"/>

<p>The most important options of the <SAMP>[General]</SAMP> section are the
following.
<UL>
  <li><strong></strong>The <tt>ini-warnings</tt> option can be used for ''debugging'' ini
    files: if enabled, it lists which options were searched for but
    not found.
  <li><strong></strong>The <tt>network</tt> option selects the model to be set up and run.
  <li><strong></strong>The length of the simulation can be set with the
    <tt>sim-time-limit</tt> and the <tt>cpu-time-limit</tt> options (the
    usual time units such as ms, s, m, h, etc. can be used).
  <li><strong></strong>The output file names can be set with the following options:
    <tt>output-vector-file</tt>, <tt>output-scalar-file</tt> and <tt>snapshot-file</tt>.
</UL>

<p>The full list of supported options follows. Almost every one these options
can also be put into the <tt>[Run <EM>n</EM>]</tt> sections. Per-run settings
have priority over globally set ones.

<p>
<table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>[General]</b> </TD></TR>
<TR> <TD align=left> <tt>ini-warnings</tt> = yes </TD> <TD align=left> Helps debugging of the ini file. If turned
on, OMNeT++ prints out the name of the entries it that it wanted to
read but they were not in the ini file.</TD></TR>
<TR> <TD align=left> <tt>network</tt> = </TD> <TD align=left> The name of the network to be simulated. </TD></TR>
<TR> <TD align=left> <tt>distributed</tt> = no </TD> <TD align=left> Parallel execution or not. </TD></TR>
<TR> <TD align=left> <tt>parallel-system</tt> = MPI </TD> <TD align=left> MPI or PVM. Defaults to MPI.</TD></TR>
<TR> <TD align=left> <tt>snapshot-file</tt> = omnetpp.sna </TD> <TD align=left> Name of the snapshot file. The result of
each <tt>snapshot()</tt> call will be appended to this file. </TD></TR>
<TR> <TD align=left> <tt>output-vector-file</tt> = omnetpp.vec </TD> <TD align=left> Name of output vector file. </TD></TR>
<TR> <TD align=left> <tt>output-scalar-file</tt> = omnetpp.sca </TD> <TD align=left> Name of output scalar file. </TD></TR>
<TR> <TD align=left> <tt>pause-in-sendmsg</tt> = no </TD> <TD align=left> Only makes sense with step-by-step execution.
If enabled, OMNeT++ will split <tt>send()</tt> calls to two steps.</TD></TR>
<TR> <TD align=left> <tt>sim-time-limit</tt> = </TD> <TD align=left> Duration of the simulation in simulation time.</TD></TR>
<TR> <TD align=left> <tt>cpu-time-limit</tt> = </TD> <TD align=left> Duration of the simulation in real time.</TD></TR>
<TR> <TD align=left> <tt>random-seed</tt> = </TD> <TD align=left> Random number seed for generator 0. Should be nonzero.</TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mbox </font><tt>gen0-seed</tt> = <fontmaroon><em>  </em>  </font> <br>
<fontmaroon><em> Unknown LaTeX command </em> \mbox </font><tt>gen1-seed</tt> = <fontmaroon><em>  </em>  </font> <br>
<fontmaroon><em> Unknown LaTeX command </em> \mbox </font>...<fontmaroon><em>  </em>  </font> </TD> <TD align=left> Seeds for the given random number generator. They should be
nonzero. <tt>gen0-seed</tt> is equivalent to <tt>random-seed</tt>.</TD></TR>
<TR> <TD align=left> <tt>total-stack-kb</tt> = </TD> <TD align=left> Specifies the total stack size (sum of all coroutine stacks)
in kilobytes. You need to increase this value if you get the
``Cannot allocate coroutine stack...'' error.</TD></TR>
<TR> <TD align=left> <tt>load-libs</tt> = </TD> <TD align=left>  Name of shared libraries (.so files) to load after startup.
You can use it to load simple module code etc.</TD></TR>
<TR> <TD align=left> Example:</TD></TR>
<TR> <TD align=left> <tt>load-libs</tt> =../x25/x25.so../lapb/lapb.so</TD></TR>
<TR> <TD align=left> <tt>netif-check-freq</tt> = </TD> <TD align=left> Used with parallel execution.</TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mbox </font><tt>outputvectormanager-class</tt> =<fontmaroon><em>  </em>  </font> <br>
<tt>cFileOutputVectorManager</tt>
</TD> <TD align=left>
Part of the Envir plugin mechanism: defines the name of
the output vector manager class to be used to record data from output
vectors.  The class has to implement the
<tt>cOutputVectorManager</tt> interface defined in <tt>envirext.h</tt>.</TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mbox </font><tt>outputscalarmanager-class</tt> =<fontmaroon><em>  </em>  </font> <br>
<tt>cFileOutputScalarManager</tt>
</TD> <TD align=left>
Part of the Envir plugin mechanism: defines the name of the output
scalar manager class to be used to record data passed to
<tt>recordScalar()</tt>. The class has to implement the
<tt>cOutputScalarManager</tt> interface defined in <tt>envirext.h</tt>.
</TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mbox </font><tt>snapshotmanager-class</tt> =<fontmaroon><em>  </em>  </font> <br>
<tt>cFileSnapshotManager</tt>
</TD> <TD align=left>
Part of the Envir plugin mechanism: defines the name of the class to
handle streams to which <tt>snapshot()</tt> writes its output.  The
class has to implement the <tt>cSnapshotManager</tt> interface defined
in <tt>envirext.h</tt>.</TD></TR>
<TR> <TD align=left> 
</table>

<p><hr><font color="#006f00"><H2><A NAME="sec289"/>9.3. <FONTblue>Cmdenv: the command-line interface</FONT></H2></font></hr>

<p>The command line user interface is
a small, portable and fast user interface that compiles and runs on
all platforms. Cmdenv is designed primarily for batch execution.

<p>Cmdenv uses simply executes some or all simulation runs that are described
in the configuration file. If one run stops with an error message,
subsequent ones will still be executed. The runs to be executed can be
passed via command-line argument or in the ini file.

<p><font color="#006f00"><H3><A NAME="sec290"/>9.3.1. <FONTteal>Command-line switches</FONT></H3></font>

<p>A simulation program built with Cmdenv accepts the following command line
switches:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left> 
  <tt>-f</tt> <SAMP>&lt;</SAMP><EM>fileName<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <SAMP>omnetpp.ini</SAMP>.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left> 
  <tt>-l</tt> <SAMP>&lt;</SAMP><EM>fileName<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  Load a shared object (<SAMP>.so</SAMP> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <SAMP>.so</SAMP> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<SAMP>_n.o</SAMP> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <SAMP>gcc -shared...</SAMP>)</TD></TR>
<TR> <TD align=left> 
  <tt>-r</tt> <SAMP>&lt;</SAMP><EM>runs<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  It specifies which runs should be executed (e.g. <tt>-r 2,4,6-8</tt>).
  This option overrides the <SAMP>runs-to-execute=</SAMP> option
  in the <SAMP>[Cmdenv]</SAMP> section of the ini file
  (see later).</TD></TR>
</table>

<p>All other options are read from the configuration file.

<p>An example of running an OMNeT++ executable with the -h flag:

<pre>

% ./fddi -h

OMNeT++ Discrete Event Simulation  (C) 1992-2003 Andras Varga
See the license for distribution terms and warranty disclaimer
Setting up Cmdenv (command-line user interface)...

Command line switches:
  -h            print this help and exit.
  -f &lt;inifile&gt;  use the given ini file instead of omnetpp.ini.
  -r &lt;runs&gt;     execute the specified runs in the ini file.
                &lt;runs&gt; is a comma-separated list of run numbers or
                run number ranges, for example 1,2,5-10.
  -l &lt;library&gt;  load the specified shared library on startup.
                The library can contain modules, networks, etc.

Available networks:
  FDDI1
  NRing
  TUBw
  TUBs

Available modules:
  FDDI_MAC
  FDDI_MAC4Ring
  ...

Available channels:


End run of OMNeT++
</pre>
<p>

<p><font color="#006f00"><H3><A NAME="sec291"/>9.3.2. <FONTteal>Cmdenv ini file options</FONT></H3></font>
<a name="sec:ch-run-sim:cmdenv-section"/>

<p>Cmdenv can be executed in two modes, selected by the <tt>express-mode</tt> ini file entry:

<p><UL>
    <li><strong></strong> <b>Normal</b> (non-express) mode is for debugging: detailed information
        will be written to the standard output (event banners, module output,
        etc).
    <li><strong></strong> <b>Express</b> mode can be used for long simulation runs: only
        periodical status update is displayed about the progress of the
        simulation.
</UL>

<p>The full list of ini file options recognized by Cmdenv:

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=left colspan=2><b>[Cmdenv]</b></TD></TR>
<TR> <TD align=left> <tt>runs-to-execute</tt> = </TD> <TD align=left> Specifies which simulation runs should be executed.
It accepts a comma-separated list of run numbers or run number ranges, e.g.
<tt>1,3-4,7-9</tt>. If the value is missing, Cmdenv executes all runs that have
ini file sections; if no runs are specified in the ini file, Cmdenv does one run.
The -r command line option overrides this ini file setting. </TD></TR>
<TR> <TD align=left> <tt>express-mode</tt>=yes/no (default: no) </TD> <TD align=left> Selects ``normal'' (debug/trace) or ``express'' mode.
</TD></TR>
<TR> <TD align=left> <tt>module-messages</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing module ev&lt;&lt; output on/off </TD></TR>
<TR> <TD align=left> <tt>event-banners</tt>=yes/no (default: yes) </TD> <TD align=left> In normal mode only:
printing event banners on/off </TD></TR>
<TR> <TD align=left> <tt>message-trace</tt>=yes/no (default: no) </TD> <TD align=left> In normal mode only: print a line
about each message sending (by <tt>send()</tt>,<tt>scheduleAt()</tt>, etc)
and delivery on the standard output </TD></TR>
<TR> <TD align=left> <tt>autoflush</tt>=yes/no (default: no) </TD> <TD align=left>  Call <tt>fflush(stdout)</tt> after each
event banner or status update; affects both express and normal mode. Turning on
autoflush can be useful with printf-style debugging for tracking down
program crashes. </TD></TR>
<TR> <TD align=left> <tt>status-frequency</tt>=&lt;integer&gt; (default: 50000) </TD> <TD align=left> In express mode only:
print status update every n events (on today's computers, and
for a typical model, this will produce an update every few seconds,
perhaps a few times per second) </TD></TR>
<TR> <TD align=left> <tt>performance-display</tt>=yes/no (default: no) </TD> <TD align=left> In express mode only:
print detailed performance information. Turning it on results in a 3-line
entry printed on each update, containing ev/sec, simsec/sec, ev/simsec,
number of messages created/still present/currently scheduled in FES.
</TD></TR>
<TR> <TD align=left> <tt>extra-stack</tt> = 16384 </TD> <TD align=left> Specifies the extra amount of stack
(bytes) that is reserved for each <tt>activity()</tt>
simple module when the simulation is linked with Cmdenv. </TD></TR>
</table>

<p>Sample output when the simulation is running in ``express'' mode,
with detailed performance display:

<pre>
...
** Event #250000   T=123.74354 ( 2m  3s)    Elapsed: 0m 12s
     Speed:     ev/sec=19731.6   simsec/sec=9.80713   ev/simsec=2011.97
     Messages:  created: 55532   present: 6553   in FES: 8
** Event #300000   T=148.55496 ( 2m 28s)    Elapsed: 0m 15s
     Speed:     ev/sec=19584.8   simsec/sec=9.64698   ev/simsec=2030.15
     Messages:  created: 66605   present: 7815   in FES: 7
...
</pre>
<p>
<hr><font color="#006f00"><H2><A NAME="sec292"/>9.4. <FONTblue>Tkenv: the graphical user interface</FONT></H2></font></hr>

<p><b>Features</b>

<p>Tkenv is a portable graphical windowing user interface.
Tkenv supports interactive execution of the simulation, tracing and
debugging. Tkenv is recommended in the
development stage of a simulation or for presentation and educational
purposes, since it allows one to get a detailed picture of the state
of simulation at any point of execution and to follow what happens
inside the network. The most important feaures are:
<UL>
  <li><strong></strong>message flow animation
  <li><strong></strong>graphical display of statistics (histograms etc.) and output
    vectors during simulation execution
  <li><strong></strong>separate window for each module's text output
  <li><strong></strong>scheduled messages can be watched in a window as simulation
    progresses
  <li><strong></strong>event-by-event, normal and fast execution
  <li><strong></strong>labeled breakpoints
  <li><strong></strong>inspector windows to examine and alter objects and variables
    in the model
  <li><strong></strong>simulation can be restarted
  <li><strong></strong>snapshots (detailed report about the model: objects, variables
    etc.)
</UL>

<p>
Tkenv makes it possible to view simulation results (output vectors
etc.) during execution. Results can be displayed as histograms and
time-series diagrams. This can speed up the process of verifying the
correct operation of the simulation program and provides a good
environment for experimenting with the model during execution.  When
used together with <tt>gdb</tt> or <tt>xxgdb</tt>, Tkenv can speed up
debugging a lot.

<p>Tkenv is built with Tcl/Tk, and it work on all platforms where
Tcl/Tk has been ported to: Unix/X, Windows, Macintosh.
You can get more information about Tcl/Tk on the Web pages listed
in the Reference.

<p><font color="#006f00"><H3><A NAME="sec293"/>9.4.1. <FONTteal>Command-line switches</FONT></H3></font>

<p>A simulation program built with Tkenv accepts the following command line
switches:

<p><table>
<TR> <TD align=left>   <tt>-h</tt>
  </TD> <TD align=left>
  The program prints a short help message and the networks
  contained in the executable, then exits.</TD></TR>
<TR> <TD align=left> 
  <tt>-f</tt> <SAMP>&lt;</SAMP><EM>fileName<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  Specify the name of the configuration file.
  The default is <SAMP>omnetpp.ini</SAMP>.
  Multiple <tt>-f</tt> switches can be given; this allows you to partition your
  configuration file.  For example, one file can contain your general
  settings, another one most of the module parameters, another one the
  module parameters you change often.</TD></TR>
<TR> <TD align=left> 
  <tt>-l</tt> <SAMP>&lt;</SAMP><EM>fileName<SAMP>&gt;</SAMP></EM>
  </TD> <TD align=left>
  Load a shared object (<SAMP>.so</SAMP> file on Unix).
  Multiple <tt>-l</tt> switches are accepted. Your <SAMP>.so</SAMP> files may contain module
  code etc. By dynamically loading all simple
  module code and compiled network description (<SAMP>_n.o</SAMP> files
  on Unix) you can even eliminate the need to re-link the simulation
  program after each change in a source file.  (Shared objects can be
  created with <SAMP>gcc -shared...</SAMP>)</TD></TR>
</table>

<p><font color="#006f00"><H3><A NAME="sec294"/>9.4.2. <FONTteal>Tkenv ini file settings</FONT></H3></font>
<a name="sec:ch-run-sim:tkenv-section"/>

<p>Tkenv accepts several settings in the <tt>[Tkenv]</tt> section of the ini file.
These settings can also be set within the graphical environment too,
via menu items and dialogs.

<p>
<table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2></TD></TR>
<TR> <TD align=center colspan=2><b>[Tkenv]</b></TD></TR>
<TR> <TD align=left> <tt>default-run</tt> = 1 </TD> <TD align=left> Specifies which run Tkenv should set up
automatically after startup. If there's no default-run= entry or the
value is 0, Tkenv will ask which run to set up. </TD></TR>
<TR> <TD align=left> <tt>use-mainwindow</tt> = yes </TD> <TD align=left> Enables/disables writing <EM>ev</EM> output to the Tkenv main window. </TD></TR>
<TR> <TD align=left> <tt>print-banners</tt> = yes </TD> <TD align=left> Enables/disables printing banners for
each event.</TD></TR>
<TR> <TD align=left> <tt>breakpoints-enabled</tt> = yes </TD> <TD align=left> Specifies whether the simulation
should be stopped at each <tt>breakpoint()</tt> call in the
simple modules. </TD></TR>
<TR> <TD align=left> <tt>update-freq-fast</tt> = 10 </TD> <TD align=left> Number of events executed between two
display updates when in <EM>Fast</EM> execution mode. </TD></TR>
<TR> <TD align=left> <tt>update-freq-express</tt> = 500 </TD> <TD align=left> Number of events executed between
two display updates when in <EM>Express</EM> execution mode. </TD></TR>
<TR> <TD align=left> <tt>animation-delay</tt> = 0.3s </TD> <TD align=left> Delay between steps when you slow-execute the simulation. </TD></TR>
<TR> <TD align=left> <tt>animation-enabled</tt> = yes </TD> <TD align=left> Enables/disables message flow animation. </TD></TR>
<TR> <TD align=left> <tt>animation-msgnames</tt> = yes </TD> <TD align=left> Enables/disables displaying message names during message flow
animation. </TD></TR>
<TR> <TD align=left> <tt>animation-msgcolors</tt> = yes </TD> <TD align=left> Enables/disables using different colors
for each message kind during message flow animation. </TD></TR>
<TR> <TD align=left> <tt>animation-speed</tt> = 1.0 </TD> <TD align=left> Specifies the speed of message flow animation. </TD></TR>
<TR> <TD align=left> <tt>extra-stack</tt> = 32768 </TD> <TD align=left> Specifies the extra amount of stack
(bytes) that is reserved for each <EM><tt>activity()</tt></EM>
simple module when the simulation is linked with
Tkenv. </TD></TR>
</table>

<p>
<font color="#006f00"><H3><A NAME="sec295"/>9.4.3. <FONTteal>Using the graphical environment</FONT></H3></font>

<p><b>Simulation running modes in Tkenv</b>

<p>
Tkenv has the following modes for running the simulation :

<p><UL>
   <li><strong></strong>Step
   <li><strong></strong>Run
   <li><strong></strong>Fast run
   <li><strong></strong>Express run
</UL>

<p>
The running modes have their corresponding buttons on Tkenv's
toolbar.

<p>
In <b>Step</b> mode, you can execute the simulation event-by-event.

<p>
In <b>Run</b> mode, the simulation runs with all tracing aids on.
Message animation is active and inspector windows are updated
after each event. Output messages are displayed in the main window
and module output windows. You can stop the simulation with the
Stop button on the toolbar. You can fully interact with the user
interface while the simulation is running: you can open inspectors
etc.

<p>
In <b>Fast</b> mode, animation is turned off. The inspectors and
the message output windows are updated after each 10 events (the
actual number can be set in Options|Simulation options and
also in the ini file). Fast mode is several times faster than
the Run mode; the speedup can get close to 10 (or the configured
event count).

<p>In <b>Express</b> mode, the simulation runs at about the same speed
as with Cmdenv, all tracing disabled. Module output is not recorded
in the output windows any more. You can interact with the simulation
only once in a while (1000 events is the default as I recall),
thus the run-time overhead of the user interface is minimal.
You have to explicitly push the Update inspectors button if you
want an update.

<p>
<b>Inspectors</b>

<p>
In Tkenv, objects can be viewed through inspectors. To start, choose
Inspect|Network from the menu. Usage should be obvious; just
use double-clicks and popup menus that are brought up by
right-clicking. In Step, Run and Fast Run modes, inspectors are
updated automatically as the simulation progresses. To make ordinary
variables (int, double, char etc.) appear in Tkenv, use the
<tt>WATCH()</tt> macro in the C++ code.

<p>Tkenv inspectors also display the object pointer, and can also copy
the pointer value to the clipboard. This can be invaluable for debugging:
when the simulation is running under a debugger like gdb or the MSVC IDE,
you can paste the object pointer into the debugger and have closer look
at the data structures.

<p>
<b>Configuring Tkenv</b>

<p>
In case of nonstandard installation, it may be necessary to set the
<tt>OMNETPP_TKENV_DIR</tt> environment variable so that Tkenv can find
its parts written in Tcl script.

<p><p>
The default path from where the icons are loaded can be changed with
the <tt>OMNETPP_BITMAP_PATH</tt> variable, which is a
semicolon-separated list of directories and defaults to
''<EM>omnetpp-dir</EM>/bitmaps;.;./bitmaps''.
</p>

<p><b>Embedding Tcl code into the executable</b>

<p>A significant part of Tkenv is written in Tcl, in several
<SAMP>.tcl</SAMP> script files. The default location of the scripts is
passed compile-time to <SAMP>tkapp.cc</SAMP>, and it can be overridden at
run-time by the <tt>OMNETPP_TKENV_DIR</tt> environment variable. The
existence of a separate script library can be inconvenient if you want
to carry standalone simulation executables to different machines. To
solve the problem, there is a possibility to compile the script parts
into Tkenv.

<p>The details: the <tt>tcl2c</tt> program (its C source is there in the
Tkenv directory) is used to translate the <SAMP>.tcl</SAMP> files into C
code (<SAMP>tclcode.cc</SAMP>), which gets included into
<SAMP>tkapp.cc</SAMP>. This possibility is built into the makefiles
and can be optionally enabled.

<p><font color="#006f00"><H3><A NAME="sec296"/>9.4.4. <FONTteal>In Memoriam... </FONT></H3></font>

<p>There used to be other windowing user interfaces which have been removed
from the distribution:

<p><UL>
  <li><strong></strong> <b>TVEnv</b>. A Turbo Vision-based user interface, the first
    interactive UI for OMNeT++. Turbo Vision was an excellent
    character-graphical windowing environment, originally shipped with
    Borland C++ 3.1.
  <li><strong></strong> <b>XEnv</b>. A GUI written in pure X/Motif. It was an
    experiment, written before I stumbled into Tcl/Tk and discovered
    its immense productivity in GUI building. XEnv never got too far
    because it was really very-very slow to program in Motif...
</UL>

<p>
<hr><font color="#006f00"><H2><A NAME="sec297"/>9.5. <FONTblue>More about omnetpp.ini</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec298"/>9.5.1. <FONTteal>The [Slaves] section</FONT></H3></font>
<a name="sec:ch-run-sim:slaves-section"/>

<p><table border>
<TR> <TD align=left>

<p><b>Entry and default value</b> </TD> <TD align=left> <b>Description</b></TD></TR>
<TR> <TD align=center colspan=2><b>[Slaves]</b></TD></TR>
<TR> <TD align=left> <tt>write-slavelog</tt> = yes </TD> <TD align=left> Enables/disables writing to the slave.log file</TD></TR>
<TR> <TD align=left> <tt>slavelog-file</tt> = slave.log </TD> <TD align=left> Specifies an alternative filename for slave.log. </TD></TR>
<TR> <TD align=left> <tt>module-messages</tt> = yes </TD> <TD align=left> Specifies whether module messages are printed or not. </TD></TR>
<TR> <TD align=left> <tt>errmsgs-to-console</tt> = yes </TD> <TD align=left> Specifies whether error messages should be
sent to and displayed at the 'console' segment. </TD></TR>
<TR> <TD align=left> <tt>infomsgs-to-console</tt> = no </TD> <TD align=left> Specifies whether info messages
should be sent to and displayed at the 'console' segment. </TD></TR>
<TR> <TD align=left> <tt>modmsgs-to-console</tt> = no </TD> <TD align=left> Specifies whether module <EM>ev</EM>
output should be sent to and displayed at the 'console'
segment.</TD></TR>
</table>

<p>

<p><font color="#006f00"><H3><A NAME="sec299"/>9.5.2. <FONTteal>Module parameters in the configuration file</FONT></H3></font>
<a name="sec:ch-run-sim:parameter-settings"/>


<p>Values for module parameters go into the <SAMP>[Parameters]</SAMP> or the
<SAMP>[Run 1]</SAMP>, <SAMP>[Run 2]</SAMP> etc. sections of the ini file. The
run-specific settings take precedence over the overall settings.
Parameters that were assigned a (non-input) value in the NED file are
not influenced by ini file settings.

<p>Wildcards (*,?) can be used to supply values
to several model parameters at a time. Filename-style (glob) and not
regex-style pattern matching is used. Character ranges use curly
braces instead of square brackets to avoid interference with the
notation of module vectors: {a-zA-Z}. If a parameter name matches
several wildcards-patterns, the first matching occurrence is used.

<p>
An example ini file:

<p><pre>
# omnetpp.ini

<p><b>[Parameters]</b>
token.num_stations = 3
token.num_messages = 10000

<p><b>[Run 1]</b>
token.stations[*].wait_time = 10ms

<p><b>[Run 2]</b>
token.stations[0].wait_time = 5ms
token.stations[*].wait_time = 1000ms
</pre>

<p>
<font color="#006f00"><H3><A NAME="sec300"/>9.5.3. <FONTteal>Configuring output vectors</FONT></H3></font>
<a name="sec:ch-run-sim:outvectors-section"/>

<p>As a simulation program is evolving, it is becoming capable of
collecting more and more statistics. The size of output vector
files can easily reach a magnitude of
several ten or hundred megabytes, but very often, only some of the
recorded statistics are interesting to the analyst.

<p>
In OMNeT++, you can control how <tt>cOutVector</tt> objects record data
to disk. You can turn output vectors on/off or you can assign a result
collection interval. Output vector configuration is given in the
<SAMP>[OutVectors]</SAMP> section of the ini file, or in the <SAMP>[Run
  1]</SAMP>, <SAMP>[Run 2]</SAMP> etc sections individually for each run. By
default, all output vectors are turned on.

<p>
Entries configuring output vectors can be like that:

<p><pre>
<EM>module-pathname</EM>.<EM>objectname</EM>.enabled = yes/no
<EM>module-pathname</EM>.<EM>objectname</EM>.interval = <EM>start</EM>..<EM>stop</EM>
<EM>module-pathname</EM>.<EM>objectname</EM>.interval = ..<EM>stop</EM>
<EM>module-pathname</EM>.<EM>objectname</EM>.interval = <EM>start</EM>..
</pre>

<p>The object name is the string passed to <tt>cOutVector</tt> in its constructor
or with the <tt>setName()</tt> member function.

<pre>
cOutVector eed("End-to-End Delay",1);
</pre>
<p>
Start and stop values can be any time specification accepted
in NED and config files (e.g. <EM>10h 30m 45.2s</EM>).

<p>
As with parameter names, wildcards are allowed in the object
names and module path names.

<p>An example:

<pre>
#
# omnetpp.ini
#

[OutVectors]
*.interval = 1s..60s
*.End-to-End Delay.enabled = yes
*.Router2.*.enabled = yes
*.enabled = no
</pre>
<p>

<p>The above configuration limits collection of all output vectors
to the 1s..60s interval, and disables collection of output vectors
except all end-to-end delays and the ones in any module called Router2.



<p><font color="#006f00"><H3><A NAME="sec301"/>9.5.4. <FONTteal>Display strings</FONT></H3></font>
<a name="sec:ch-run-sim:displaystrings-section"/>

<p>Display strings control the modules' graphical
appearance in the Tkenv user interface. Display strings can be
assigned to modules, submodules and gates (a connection's display
string is stored in its ''from'' gate). Display strings can be
hardcoded into the NED file or specified in the configuration file.
(Hardcoded display strings take precedence over the ones given in ini
files.) Format of display string are documented in the Display String
section (~<a href="#sec:ch-ned-lang:display-strings">[click]</a>).

<p>Display strings can appear in the <SAMP>[DisplayStrings]</SAMP> section of
the ini file. They are expected as entries in one of the following
forms:

<pre>
moduletype = "..."
moduletype.submodulename = "..."

moduletype.inputgatename = "..."
moduletype.submodulename.outputgatename = "..."
</pre>
<p>
As with parameter names, wildcards
are allowed in module types, submodule and gate names.

<p>
<font color="#006f00"><H3><A NAME="sec302"/>9.5.5. <FONTteal>Specifying seed values</FONT></H3></font>

<p>As is was pointed out earlier, it is of great importance that
different simulation runs and different random number sources
within one simulation run use non-overlapping sequences of random
numbers.

<p>
In OMNeT++, you have three choices:
<OL>
  <li><strong></strong>Automatic seed selection.
  <li><strong></strong>Specify seeds in the ini file (with the help of the seedtool
    program, see later)
  <li><strong></strong>Manually set the seed from within the program.
</OL>

<p>If you decide for automatic seed selection, do not specify any seed value in the ini file. For the
random number generators, OMNeT++ will automatically select seeds that
are 1,000,000 values apart in the sequence. If you have several runs,
each run is started with a fresh set of seeds that are 1,000,000
values apart from the seeds used for previous runs. Since the
generation of new seed values is costly, OMNeT++ has a table of
pre-calculated seeds (256 values); if they are all used up, OMNeT++
starts from the beginning of the table again.

<p>
Automatic seed selection may not be appropriate for you for several
reasons. First, you may need more than 256 seeds values; or, if you
use variance reduction techniques, you may want to use the same seeds
for several simulation runs. In this case, there is a standalone
program to generate appropriate seed values (<tt>seedtool</tt> will be
discussed in Section <a href="#sec:ch-run-sim:choosing-good-seed">[click]</a>), and you
can specify the seeds explicitly in the ini file.

<p>
The following ini file explicitly initializes two of the random
number generators, and uses different seed values for each run:

<pre>
[Run 1]
gen0-seed = 1768507984
gen1-seed = 33648008

[Run 2]
gen0-seed = 1082809519
gen1-seed = 703931312
...
</pre>
<p>

<p>If you want the same seed values for all runs, you will write
something like this:

<pre>
[General]
gen0-seed = 1768507984
gen1-seed = 33648008
</pre>
<p>

<p>All other random number generators (2,3,...) will have their seeds
automatically assigned.  As a third way, you can also set the seed
values from the code of a simple module using
<tt>genk_randseed()</tt>, but I see no reason why you would want to do
so.

<p>
<hr><font color="#006f00"><H2><A NAME="sec303"/>9.6. <FONTblue>Choosing good seed values: the seedtool utility</FONT></H2></font></hr>
<a name="sec:ch-run-sim:choosing-good-seed"/>

<p>For selecting good seeds, the <tt>seedtool</tt> program can be used (it
is in the utils directory). When started without command-line
arguments, the program prints out the following help:

<pre>
seedtool - part of OMNeT++, (c) 1992-2001 Andras Varga, TU Budapest
See the license for distribution terms and warranty disclaimer.

A tool to help select good random number generator seed values.
Usage:
  seedtool i seed         - index of 'seed' in cycle
  seedtool s index        - seed at index 'index' in cycle
  seedtool d seed1 seed2  - distance of 'seed1' and 'seed2' in cycle
  seedtool g seed0 dist   - generate seed 'dist' away from 'seed0'
  seedtool g seed0 dist n - generate 'n' seeds 'dist' apart, starting
                            at 'seed0'
  seedtool t              - generate hashtable
  seedtool p              - print out hashtable
</pre>
<p>

<p>The last two options, p and t were used internally to generate
a hash table of pre-computed seeds that greatly speeds up the
tool. For practical use, the g option is the most important.
Suppose you have 4 simulation runs that need two independent
random number generators each and you want to start their seeds
at least 10,000,000 values apart. The first seed value can be
simply 1. You would type the following command:

<pre>
C:\OMNETPP\UTILS&gt; seedtool g 1 10000000 8
</pre>
<p>

<p>The program outputs 8 numbers that can be used as random number
seeds:

<pre>
1768507984
33648008
1082809519
703931312
1856610745
784675296
426676692
1100642647
</pre>
<p>

<p>You would specify these seed values in the ini file.

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec304"/>9.7. <FONTblue>Repeating or iterating simulation runs</FONT></H2></font></hr>


<b>Variations over parameter values</b>

<p>
You don't need to generate the whole <SAMP>omnetpp.ini</SAMP> from program if you
use include files. You can have a fixed
<SAMP>omnetpp.ini</SAMP> which contains the line

<pre>
include parameters.ini
</pre>
<p>
and then generate parameters.ini by program for each run.

<p>
Here's the ''runall'' script of Joel Sherrill's <EM>File
System Simulator</EM> as an example:

<pre>
#! /bin/bash
#
# This script runs multiple variations of the file system simulator.
#
all_cache_managers="NoCache FIFOCache LRUCache PriorityLRUCache..."
all_schedulers="FIFOScheduler SSTFScheduler CScanScheduler..."

for c in ${all_cache_managers}; do
  for s in ${all_schedulers}; do
  (
    echo "[Parameters]"
    echo "filesystem.generator_type = \"GenerateFromFile\""
    echo "filesystem.iolibrary_type = \"PassThroughIOLibrary\""
    echo "filesystem.syscalliface_type = \"PassThroughSysCallIface\""
    echo "filesystem.filesystem_type = \"PassThroughFileSystem\""
    echo "filesystem.cache_type = \"${c}\""
    echo "filesystem.blocktranslator_type = \"NoTranslation\""
    echo "filesystem.diskscheduler_type = \"${s}\""
    echo "filesystem.accessmanager_type = \"MutexAccessManager\""
    echo "filesystem.physicaldisk_type = \"HP97560Disk\""
  ) &gt;algorithms.ini

  ./filesystem
  done
done
</pre>
<p>
And <SAMP>omnetpp.ini</SAMP> includes <SAMP>algorithms.ini</SAMP>.

<p>
<b>Variations over seed value (multiple independent runs)</b>

<p>
The same technique can be used if you want several runs with different
random seeds. This code should do 500 runs with
independent seeds (suppose one run doesn't use more than 10 million
random values):

<pre>
#! /bin/bash

for seed in `seedtool g 1 10000000 500`
do
   (
     echo "[General]"
     echo "random-seed = ${seed}"
     echo "output-vector-file = xcube-${seed}.vec"
   ) &gt; parameters.ini
   ./xcube
done
</pre>
<p>

<p><SAMP>omnetpp.ini</SAMP> should include parameters.ini.

<p>
<b>Other languages for writing the control script</b>

<p>
The above examples use the Unix shell, but you have quite a number
of options in what language to implement the controlling script.
Some ideas:
<UL>
  <li><strong></strong>shell (mentioned above)
  <li><strong></strong>Perl
  <li><strong></strong>Tcl
  <li><strong></strong>Octave (suggested by Richard Lyon, see the contrib/octave
    directory for examples)
</UL>

<p>
<hr><font color="#006f00"><H2><A NAME="sec305"/>9.8. <FONTblue>Typical problems</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec306"/>9.8.1. <FONTteal>Stack problems</FONT></H3></font>

<p><b>''Stack violation (<EM>FooModule</EM> stack too
  small?) in module <EM>bar.foo</EM>''</b>

<p>OMNeT++ detected that the module has used more stack space than it has
allocated. You should increase the stack for that module type. You can call
the <tt>stackUsage()</tt> from <tt>finish()</tt> to find out actually
how much stack the module used.

<p><b>''Error: Cannot allocate <EM>nn</EM> bytes stack for module <EM>foo.bar''</EM></b>

<p>If you get the above message, you have to increase the total stack
size (the sum of all coroutine stacks). You can do
so in <SAMP>omnetpp.ini</SAMP>:

<pre>
[General]
total-stack-kb = 2048 # 2MB
</pre>
<p>

<p>There is no penalty if you set <tt>total-stack-kb</tt> too high. I
recommend to set it to a few K less than the maximum process stack
size allowed by the operating system (<tt>ulimit -s</tt>; see
next section).

<p>
<b>''Segmentation fault''</b>

<p>
On Unix, if you set the total stack size higher, you may get a
segmentation fault during network setup (or
during execution if you use dynamically created modules) for exceeding
the operating system limit for maximum stack size. For example, in
Linux 2.0.x, the stack can be at most 8192K (that is, 8MB). The
<tt>ulimit</tt> syscall and utility program can be used to modify the
resource limits, but you can only increase if you're root.
Furthermore, resource limits are inherited by child processes. The
following statement worked out for me under Linux to get a shell with
a 64M stack limit:

<pre>
$ su root
Password:
# ulimit -s 65536
# su andras
$ ulimit -s
65536
</pre>
<p>
If you do not want to go through the above process at each login, you
can change the limit in the PAM configuration files. In Redhat Linux
(maybe other systems too), add the following line to
<tt>/etc/pam.d/login</tt>:

<pre>
session    required    /lib/security/pam_limits.so
</pre>
<p>
and the following line to <tt>/etc/security/limits.conf</tt>:

<pre>
*    hard    stack    65536
</pre>
<p>
<p>
A more drastic solution is to recompile the kernel with a larger stack
limit. Edit <tt>/usr/src/linux/include/linux/sched.h</tt> and increase
<tt>_STK_LIM</tt> from <tt>(8*1024*1024)</tt> to <tt>(64*1024*1024)</tt>.
</p>

<p>Finally, it you're tight with memory, you can switch to Cmdenv. Tkenv
increases the stack size of each module by about 32K so that user interface code that is called from a
simple module's context can be safely executed.
Cmdenv does not need that much extra stack.

<p>

<p>
<font color="#006f00"><H3><A NAME="sec307"/>9.8.2. <FONTteal>Memory allocation problems</FONT></H3></font>

<p>If you suspect that you may have memory allocation problems,
it is best to use tools like Purify to track them down.

<p>However, if you don't have such tools, you can use the basic
heap debugging code in Cmdenv. It is disabled by default;
to turn it on, you have to uncomment the <tt>#defines</tt>
in <tt>src/envir/cmdenv/heap.cc</tt>:

<p><table>
<TR> <TD align=left> <tt>HEAPCHECK</tt> </TD> <TD align=left> checks heap on new/delete</TD></TR>
<TR> <TD align=left> <tt>COUNTBLOCKS</tt> </TD> <TD align=left> counts blocks on heap and tells it if none left</TD></TR>
<TR> <TD align=left> <tt>ALLOCTABLE</tt> </TD> <TD align=left> remembers pointers and reports heap contents if only LASTN
blocks remained</TD></TR>
<TR> <TD align=left> <tt>DISPLAYALL</tt> </TD> <TD align=left> reports every new/delete</TD></TR>
<TR> <TD align=left> <tt>DISPSTRAYS</tt> </TD> <TD align=left> reports deleting of pointers that were not registered
by operator new or that were deleted since then</TD></TR>
<TR> <TD align=left> <tt>BKPT</tt> </TD> <TD align=left>  calls a function at a specified new/delete; you can set a
breakpoint to that function</TD></TR>
</table>

<p>
If <tt>COUNTBLOCKS</tt> is turned on, you should see the
<SAMP>[heap.cc-DEBUG:ALL BLOCKS FREED OK]</SAMP> message at the end of the
simulation. If you do not see it, it means that some blocks have not
been freed up properly, that is, your simulation program is likely to
have memory leaks.

<p>


<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec308"/>10. <FONTgreen>Analyzing Simulation Results</FONT></H1></font></hr>
<a name="cha:analyzing-simulation-results"/>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec309"/>10.1. <FONTblue>Plotting output vectors with Plove</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec310"/>10.1.1. <FONTteal>Plove features</FONT></H3></font>

<p>Typically, you'll get output vector files as a result of a simulation.
Data written to <tt>cOutVector</tt> objects from
simple modules go to output vector
files. Normally, you use Plove to look
into output vector files and plot vectors in it.

<p>Plove\indexPlove is a handy tool for plotting OMNeT++ output vectors.
It uses Gnuplot to do the actual work. You can specify
the drawing style (lines, dots etc) for each vector as well as set the
most frequent drawing options like axis bounds, scaling, titles and
labels etc. You can save the gnuplot graphs to files (postscript,
latex, pbm etc) with a click. Plove can also generate standalone shell
scripts that plot output vectors in much the same way Plove does
itself. These scripts can be used for batch processing or to debug
filters (see later). Plove does not take away any of gnuplot's
flexibility - you can embed your own gnuplot commands to customize
the output.

<p>
Filtering the results before plotting is
possible. Filters can do averaging, truncation of extreme values,
smoothing, they can do density estimation by
calculating histograms etc. Some filters are built
in, and you can easily create new filters or modify the existing ones.
Filters can be incorporated in one of three ways: as <tt>awk</tt> expressions,
as <tt>awk</tt> programs and as external filter programs. Filters can be
parameterized. Multiple filters for the same vector is not currently
supported; also, you cannot currently feed several vectors into a
single filter.

<p>Plove does not create temporary files, so you don't need to worry
about disk space: if the output vector is there, Plove can plot
it for you. Moreover, it can also work with gzipped vector files
without extracting them - just make sure you have zcat.

<p>
Plove never modifies the output vector files themselves.

<p>On startup, Plove automatically reads the <SAMP>.ploverc</SAMP> file in
your home directory. The file contains general gnuplot settings, the
filter configuration etc.  (that is, the stuff from the Options menu).

<p>
\underline Portability: Plove works fine on Unix and (with some
limitations) on Win95/NT.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec311"/>10.1.2. <FONTteal>Usage</FONT></H3></font>

<p>First, you load an output vector file (<SAMP>.vec</SAMP>) into the left
pane.  You can also load gzipped vector files (<SAMP>.vec.gz</SAMP>)
without having to decompress them. You can copy vectors from the left
pane to the right pane by clicking the right arrow icon in the middle.
The large PLOT button will plot the <EM>selected</EM> vectors in the
right pane. Selection works as in Windows: dragging and shift+left
click selects a range, and ctrl+left click selects/deselects
individual items. To adjust drawing style, change vector title or add
filter, push the Options... button. This works for several selected
vectors too. Plove accepts nc/mc-like keystrokes: F3, F4, F5, F6, F8,
grey '+' and grey '*'.

<p>
The left pane works as a general storage for vectors you're working
with. You can load several vector files, delete vectors you don't
want to deal with, rename them etc. All this will not affect
the vector files on disk. In the right pane, you can duplicate
vectors if you want to filter the vector and also keep the original.
If you set the right options for a vector but temporarily do
not want it to hang around in the right pane, you can put it
back into the left pane for storage.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec312"/>10.1.3. <FONTteal>Writing filters</FONT></H3></font>

<p>Filters get an output vector on their standard input (as plain
text, with the timestamp being the second and the value being
the third field on each line), do some processing to it and write
the result to the standard output.

<p>
Filters can be incorporated in one of three ways: as <tt>awk</tt>
expressions, as <tt>awk</tt> programs or as external programs. An 'awk
expression' filter means assembling and launching a command like this:

<p><pre>
cat foobar.vec | awk '{$3 = <EM>&lt;expression&gt;</EM>; print}' | ...
</pre>

An <tt>awk</tt> program filter means running the following command:

<p><pre>
cat foobar.vec | awk '{<EM>&lt;program&gt;</EM>}' | ...
</pre>

<p>The third type of filters is used like this:

<p><pre>
cat foobar.vec | <EM>&lt;program&gt; &lt;parameters&gt;</EM> | ...
</pre>

<p>Before the filter pipeline is launched, the following substitutions
are performed on the <tt>awk</tt> scripts:

<p><UL>
  <li><strong></strong> <b>t</b> gets substituted to \, which is the simulation time
  (the second column in the output vector file)
  <li><strong></strong> <b>x</b> gets substituted to \, the actual value (the third column)
</UL>

<p>The parameters of the form <tt>$(paramname)</tt> are also replaced with
their actual value.

<p>For example, if you want to add 1 to all values, you can use the <tt>awk</tt>
expression filter <tt>x+1</tt>. It will turn into the following awk script:

<pre>
awk '{$3 = $3+1}; print'
</pre>
<p>

<p>When you want to shift the vector by a used-defined DT time,
you can create the following <tt>awk</tt> program filter:

<pre>
{t += $(DT); print}
</pre>
<p>
To plot the mean on <EM>(0,t)</EM>, you'd write

<pre>
{sum+=x; x=sum/++n; print}
</pre>
<p>
Do not forget the print statement, or your filter will not output
anything and the gnuplot graph will be empty.

<p>Filters are automatically saved into and loaded from the <tt>$&~tilde;$/.ploverc</tt>
file.



<p>

<p><hr><font color="#006f00"><H2><A NAME="sec313"/>10.2. <FONTblue>Format of output vector files</FONT></H2></font></hr>

<p>An output vector file contains several
series of data produced during simulation. The file is textual, it
looks like this:

<p><pre>
<STRONG>mysim.vec:</STRONG>
vector 1   "subnet[4].term[12]"  "response time"  1
1  12.895  2355.66666666
1  14.126  4577.66664666
vector 2   "subnet[4].srvr"  "queuelen+queuingtime"  2
2  16.960  2.00000000000.63663666
1  23.086  2355.66666666
2  24.026  8.00000000000.44766536
</pre>

<p>
There are label lines (beginning with vector) and data lines.

<p>A vector line introduces a new vector. Its columns are: vector ID,
module of creation, name of <tt>cOutVector</tt> object, multiplicity
of data (single numbers or pairs will be written).

<p>Lines beginning with numbers are data lines. The columns: vector
ID, current simulation time, and one or two double values.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec314"/>10.3. <FONTblue>Working without Plove</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec315"/>10.3.1. <FONTteal>Extracting vectors from the file</FONT></H3></font>

<p>You can use the Unix <tt>grep</tt> tool to extract a particular vector
from the file. As the first step, you must find out the ID of the
vector. You can find the appropriate vector line with a text editor or
you can use <tt>grep</tt> for this purpose:

<pre>
 0rep "queuelen+queuingtime" vector.vec
</pre>
<p>
Or, you can get the list of all vectors in the file by typing:

<pre>
 0rep ^vector vector.vec
</pre>
<p>
This will output the appropriate vector line:

<pre>
vector 6  "subnet[4].srvr"  "queuelen+queuingtime"  2
</pre>
<p>
Pick the vector ID, which is 6 in this case, and grep the file
for the vector's data lines:

<pre>
grep ^6 vector.vec &gt; vector6.vec
</pre>
<p>

<p>Now, <SAMP>vector6.vec</SAMP> contains the appropriate vector. The only
potential problem is that the vector ID is there at the beginning of
each line and this may be hard to explain to some programs that you
use for post-processing and/or visualization. This problem is
eliminated by the OMNeT++ <tt>splitvec</tt> utility (written in
<tt>awk</tt>), to be discussed in the next section.

<p>

<p>
<font color="#006f00"><H3><A NAME="sec316"/>10.3.2. <FONTteal>Using splitvec</FONT></H3></font>

<p>The <tt>splitvec</tt> script (part of OMNeT++) breaks the vector file
into several files which contain one vector each:

<pre>
plitvec mysim.vec
</pre>
<p>

<p>creates several files: mysim1.vec, mysim2.vec etc.

<p><pre>
<STRONG>mysim1.vec:</STRONG>
# vector 1  "subnet[4].term[12]"  "response time"  1
12.895  2355.66666666
14.126  4577.66664666
23.086  2355.66666666

<p><STRONG>mysim2.vec:</STRONG>
# vector 2  "subnet[4].srvr"  "queuelen+queuingtime"  2
16.960  2.00000000000.63663666
24.026  8.00000000000.44766536
</pre>

<p>
As you can see, the vector ID is gone.

<p>The files can be further processed with math packages, or read
by analysis or spreadsheet programs which provide numerous ways
to display data as diagrams, do calculations on them etc. One
could use for example Gnuplot, Matlab, Excel, etc.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec317"/>10.3.3. <FONTteal>Visualization under Unix</FONT></H3></font>

<p>Two programs are in common use: Gnuplot and Xmgr. Both are free
and both have their good and bad sides; we'll briefly discuss
them. There are innumerable tutorials and documentation about
them on the Web; some of them you will find among the References.

<p>
Both programs can eat files produced by <tt>splitvec</tt>. Both
programs can produce output in various forms: on screen, in Postscript
format, printer files, Latex output etc. For DTP purposes, Postscript
seems to be the most appropriate. On Windows, the easiest way is to
copy the picture to the clipboard from the Gnuplot window's system
menu.

<p>
Gnuplot has an interactive command interface. To get the vectors in
<SAMP>mysim1.vec</SAMP> and <SAMP>mysim4.vec</SAMP> plotted in the same graph,
you can type:

<pre>
plot "mysim1.vec" with lines, "mysim4.vec" with lines
</pre>
<p>
To adjust the $y$ range, you would type:

<pre>
set yrange [0:1.2]
replot
</pre>
<p>

<p>There are several commands to adjust ranges, plotting style, labels,
scaling etc. Gnuplot can also plot 3D graphs. Gnuplot
is also available for Windows and other platforms. Gnuplot also
has a simple graphical interactive user interface called PlotMTV.
However, we recommend that you use OMNeT++'s Plove tool, described in
an earlier section.

<p>
Xmgr is an X/Motif based program, with a menu-driven
graphical interface. You load the appropriate file by selecting in a
dialog box. The icon bar and menu commands can be used to customize
the graph. Some say that Xmgr can produce nicer output that Gnuplot
and it is easier to use. Xmgr cannot do 3D and only runs on Unixes
with X and Motif installed. Xmgr also has a batch interface so you can
use it from scripts too.

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec318"/>11. <FONTgreen>Parallel Execution</FONT></H1></font></hr>
<a name="cha:parallel-execution"/>

<p><hr><font color="#006f00"><H2><A NAME="sec319"/>11.1. <FONTblue>OMNeT++ support for parallel execution</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec320"/>11.1.1. <FONTteal>Introduction to Parallel Discrete Event Simulation</FONT></H3></font>

<p>OMNeT++ supports parallel execution of large
simulations. The following paragraphs provide a very brief (and thus
not very accurate) picture of the problems and methods of parallel
discrete event simulation (PDES). Interested readers -
and those who are thinking about doing PDES with OMNeT++ - are
strongly encouraged to look into the literature.

<p>
For parallel execution, the model is to be partitioned to several
segments that will be simulated independently on different hosts or
processors. Each segment will have its own local Future Event Set,
thus they will maintain local simulation times. The main issue with
parallel simulations is keeping segments synchronized in order to
avoid violating causality of events. Without synchronization, a
message sent by one segment could arrive in another segment when the
simulation time in the receiving segment has already passed the
timestamp (arrival time) of the message. This would break
causality of events in the receiving segment.

<p>There are mainly three different methods used for synchronizing
segments:
<OL>
  <li><strong></strong><STRONG>Conservative synchronization</STRONG> exploits knowledge about when segments send
    messages to other segments, and uses 'null' messages to propagate
    this info to other segments. This may speed up simulation, since
    e.g. if a segment knows it won't receive any messages from other
    segments until $t+delta t$ simulation time, it may advance until
    $t+delta t$ without the need for external synchronization.
    Conservative syncronization requires modifications to existing
    models, i.e., inserting code which sends out the 'null' messages.
    Conservative simulation tends to converge to sequential simulation
    (slowed down by communication between segments) if there's not
    enough parallelism in the model, or parallelism is not exploited
    by sending enough 'null' messages.

<p>  <li><strong></strong><STRONG>Optimistic synchronization</STRONG> allows incausalities to occur, but detects and
    repairs them. Repairing involves rollbacks to a previous state,
    sending out anti-messages to cancel messages sent out during the
    period that is being rolled back, etc.  Optimistic synchronization
    is extremely difficult to implement, because it requires periodic
    state saving and the ability to restore previous states. In any
    case, implementing optimistic synchronization in OMNeT++ would
    require - in addition to a more complicated simulation kernel -
    writing significantly more complex simple
    module code from the user.  Optimistic synchronization may be slow
    in cases of excessive rollbacks.

<p>  <li><strong></strong><STRONG>Statistical synchronization</STRONG> is a compromise where segments do not exchange
    individual messages but distributions of the traffic flow
    characteristics. While conservative and optimistic synchronization
    are exact methods (they produce exactly the same results as the
    corresponding sequential simulation would), this is certainly not
    true for statistical synchronization where the results may contain
    error introduced by the statistical nature of the synchronization.
    Statistical synchronization does not require changes to existing
    models, only the insertion of extra modules, called
    <EM>''statistical interfaces''</EM>, therefore it is significantly
    easier to implement than either conservative or optimistic. In
    addition to easier implementation, there is a potential for much
    larger speedup than with conservative or optimistic, because the
    method is much less sensitive to communication delay between
    processors running the segments. Therefore, for parallel
    simulation on a cluster of workstations, statistical
    synchronisation may be the only feasible method.
</OL>

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec321"/>11.1.2. <FONTteal>OMNeT++ support for parallel simulation</FONT></H3></font>

<p>The simulation kernel makes it possible to send messages from one
segment to another. A message can contain arbitrarily complex data
structures; these are transferred transparently, even between hosts of
different architectures. The simulation kernel provides a simple
synchronization mechanism (<EM>syncpoints</EM>, available through the
<tt>syncpoint()</tt> call) that can ensure that causality is kept when
sending messages between segments. Syncpoints correspond to
<EM>null messages</EM> found in the literature.

<p>Message sending and syncpoints enable one to implement conservative
PDES and also Statistical Synchronization. The simulation class
library contains objects that explicitly support the implementation
of models using Statistical Synchronization.

<p>
High level debugging is supported by saving the textual output
from remote segments to a log file and/or relaying them to a
single console.

<p>OMNeT++ supports flexible partitioning of the
model. In the NED language, by using
<EM>machine parameters</EM> you can specify <EM>logical
  hosts</EM> for different modules at any level of
the module hierarchy of the network. You map logical hosts to physical
ones in the ini file; if you map several logical hosts into the same
physical machine, they will be merged into a single OMNeT++ process.

<p>
One may choose between using the MPI (Message Passing
Interface) and the PVM3 (Parallel Virtual Machine Version
3) libraries for communication between hosts. Both libraries are
portable and widely used in university and research environments. MPI
is newer though and considered to be the successor of PVM. You can
find MPI and PVM readings in the Reference.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec322"/>11.1.3. <FONTteal>Syncpoints</FONT></H3></font>

<p><STRONG>Overview</STRONG>

<p>
When running a simulation in parallel, different segments of
the model execute as independent UNIX processes, typically on
separate hosts. Since the hosts can be of different speed and
the simulated model segments can be of different complexity,
at a given moment the model times of different segments will
differ: some segments are ahead of the others and some lag behind.
Suppose that a message is sent from segment A to segment B which
is ahead of A in model time. If B processed the message, causality
would break. This should never happen.

<p>
The solution built in OMNeT++ is the following. Segment A must know in
advance when it will send the next message to segment B and announce
it with the <tt>syncpoint()</tt> call. The simulation kernel sends the
syncpoint to segment B. When segment B's model time reaches the
specified time, segment B's simulation kernel blocks execution until
the promised message arrives from A. Then the simulation continues,
typically but not necessarily with the message that has just been
received from A.

<p>In the reverse case when A is ahead of B, A's message arrived at B
before it has reached the syncpoint. In this case, there is no problem
and the syncpoint is just an unnecessary precaution. B just inserts
the message in its future event set, clears the syncpoint and
continues execution.

<p>
<STRONG>The syncpoint API</STRONG>

<p>
The <tt>syncpoint()</tt> call takes two arguments. The first is the
model time when (or more precisely: when of after when) the simple
module will send a message to another simple module in a different
segment. The second argument is a gate given with its number or its
name. The gate implicitly specifies the destination segment to
synchronize with.

<pre>
syncpoint(t, "outgate");
</pre>
<p>

<p><STRONG>Details of the syncpoint implementation</STRONG>

<p>
If the destination module is in the same segment, the call is ignored.
(This makes it possible to run models designed to execute in parallel
as a single process, without any modification.) Each segment keeps a
list of syncpoints sent to it (time + gate), ordered by time.
Simulation executes normally until it comes to an event that has a
time <EM>definitely past</EM> the first syncpoint in the list. That
event is not processed, but the segment goes into a blocked state.
While the segment is blocked, it listens for messages arriving from
other segments. (In the actual implementation, passive wait is used so
a blocked segment doesn't use much CPU time.) Each message that
arrives deletes the first syncpoint in the list that matches its gate.
The segment goes out of the blocked state when - because of deletions
- the first syncpoint in the list is no longer past the event in
question. Then the simulation goes on normally, either with the newly
arrived message (or the earliest of them) or the original event. A
message that arrives outside of the blocked state also causes deletion
of the first matching syncpoint in the list; this case corresponds to
the reverse case when the sender segment is ahead of the receiving
segment in model time.

<p>
<STRONG>Deadlock</STRONG>

<p>
It is possible to cause deadlock
with carelessly placed syncpoints.  Suppose that segment A declares a
syncpoint at 10s with segment B, but it will actually send a message
only at 10.5s. If segment B does the same to segment A, a nice
deadlock is created. OMNeT++ makes no effort to detect or prevent such
deadlocks; it is entirely the simulation programmer's task to take
care that deadlocks do not occur.

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec323"/>11.2. <FONTblue>Configuring a simulation for parallel execution</FONT></H2></font></hr>

<p><font color="#006f00"><H3><A NAME="sec324"/>11.2.1. <FONTteal>Configuring OMNeT++</FONT></H3></font>

<p><font color="#006f00"><H4><A NAME="sec325"/>11.2.1.1. <FONTteal>Choosing between MPI and PVM</FONT></H4></font>

<p>
You must let OMNeT++ know if you want to use MPI or
PVM. This can be configured in the <SAMP>[General]</SAMP>
section of the ini file, via te
<tt>parallel-system=</tt> entry. Its value can be
''PVM'' or ''MPI''; it defaults to ''MPI''.

<p><pre>
; file: omnetpp.ini
;...
<STRONG>[General]</STRONG>
parallel-system = MPI
</pre>

<p>
<font color="#006f00"><H4><A NAME="sec326"/>11.2.1.2. <FONTteal>Mapping logical machines to physical ones</FONT></H4></font>
<a name="sec:ch-parallel-exec:machine-mapping"/>

<p>The <tt>on:</tt> phrases in the NED descriptions
specify the logical machine(s) on which the module is run. The machine
parameters are mapped to physical machines in the <SAMP>[Machines]</SAMP>
section of the configuration file:

<p><pre>
; file: omnetpp.ini
;...
<b>[Machines]</b>
node1 = whale.hit.bme.hu
node4 = whale.hit.bme.hu
node2 = puppis.hit.bme.hu
node3 = dolphin.hit.bme.hu
;...
</pre>

<p>
<font color="#006f00"><H4><A NAME="sec327"/>11.2.1.3. <FONTteal>Configuration of the slaves</FONT></H4></font>

<p>Slave processes can be configured in the <SAMP>[Slaves]</SAMP> section of
the configuration file:

<p><pre>
; file: omnetpp.ini
<STRONG>[Slaves]</STRONG>
write-slavelog=
slavelog-file=
module-messages=
errmsgs-to-console=
infomsgs-to-console=
modmsgs-to-console=
</pre>

<p>Screen input/output of the slaves is re-routed to the console.
However, any file I/O is done in the local file system of each host.

<p>

<p><font color="#006f00"><H3><A NAME="sec328"/>11.2.2. <FONTteal>Setting up PVM</FONT></H3></font>

<p><font color="#006f00"><H4><A NAME="sec329"/>11.2.2.1. <FONTteal>The PVM virtual machine</FONT></H4></font>

<p>
The <tt>pvmhosts</tt> file is used by PVM to describe what computers will
participate in the virtual machine, where the executables (in our
case, the OMNeT++ programs) are located on each computer, what working
directories should be set etc.

<p>
It is advisable to have a common, shared directory mounted on all
participating hosts; this eliminates the tedious work of having to
copy files to all hosts again and again.

<p>
If using OMNeT++, it is a good idea to write separate <SAMP>pvmhosts</SAMP>
files for each simulation program. Since simulation programs are
typically in separate directories, the <SAMP>pvmhosts</SAMP> file in each
directory can name that directory as executables directory and working
directory for each host. This way, there is no need to create soft
links or explicitly name directories in the OMNeT++ ini files.

<p>
Each line in the <SAMP>pvmhosts</SAMP> file describes one host. An example
line (this all should be a <EM>single line</EM>!):

<pre>
whale ip=whale.hit.bme.hu lo=andras
   dx=/home/andras/pvm/pvm
   ep=/home/andras/omnetpp/projects/fddi
   wd=/home/andras/omnetpp/projects/fddi
</pre>
<p>
To start PVM with this configuration:

<pre>
cd ~/omnetpp/projects/fddi
pvm pvmhosts
</pre>
<p>
<font color="#006f00"><H4><A NAME="sec330"/>11.2.2.2. <FONTteal>Configuration and running</FONT></H4></font>

<p>The user must have PVM installed on the hosts he is going to
run segments on.

<p>
To set up a simulation for distributed execution, the user must:
<OL>
<li><strong></strong>set the <tt>PVM_ROOT</tt> environment variable
<li><strong></strong>link the simulation executable with <tt>sim_pvm</tt> instead of
  <tt>sim_std</tt> (You can do it by setting <tt>PVM_SUPPORT</tt> to
  <tt>yes</tt> in a <tt>opp_makemake</tt>-generated makefile.)
<li><strong>set <tt>distributed=true</tt> in the <tt>[General]</strong></tt> section of the
  configuration file.
<li><strong></strong>specify the logical-hosts-to-physical-machines mapping in the
  <tt>[Machines]</tt> section
<li><strong></strong>copy the simulation executable and the configuration file to
  each host if they have physically different disks
<li><strong></strong>start <tt>pvm</tt> with an appropriate <tt>pvmhosts</tt> file
<li><strong></strong>start the simulation executable on the host which is supposed to
  be the console. That process will start up the program on the other
  hosts too and do the simulation.
</OL>

<p>The first machine is called ''console'' or ``master'', the
others are called ``slaves''.

<p>
<font color="#006f00"><H4><A NAME="sec331"/>11.2.2.3. <FONTteal>If there are problems...</FONT></H4></font>

<p>
PVM programs in general are more difficult to get running than
ordinary programs. Wrong settings in the PVM configuration files
can cause various problems, for example. Also, parallel programs
are a lot harder to test and debug.

<p>
What can you do if your distributed OMNeT++ simulation won't
work?
<UL>
  <li><strong></strong>First of all, check the <tt>pvmhosts</tt> file to see if PVM
    looks for the executables in the right directories on all hosts
    and the working directories are right (typically, the same
    directory as the executable's).
  <li><strong></strong>In the ini file, enable writing the <tt>slave.log</tt> files for
    the slave processes and check what is written into them.
  <li><strong></strong>You can try enabling the <tt>SINGLE_HOST</tt> define in the
    <tt>sim/pvm/pvmmod.cc</tt> source file. This will make OMNeT++ run all
    segments of the distributed simulation on the local host, making
    things a lot easier to manage. 
  <li><strong></strong>Also, try the defining <tt>PVM_DEBUG</tt> at the same place: it
    enables a lot of <tt>ev.printf()</tt>s in the code interfacing with
    PVM, so it is easier to spot where the problems are.
  <li><strong></strong>PVM itself also has an environment variable which, if set,
    causes the PVM library to print out debugging information.
    However, this is very low-level information, it will rarely be
    useful.
</UL>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec332"/>11.2.3. <FONTteal>Setting up MPI</FONT></H3></font>

<p>TBD

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec333"/>11.3. <FONTblue>Statistical synchronization</FONT></H2></font></hr>
<p>
<font color="#006f00"><H3><A NAME="sec334"/>11.3.1. <FONTteal>The description of the Statistical Synchronization Method (SSM)</FONT></H3></font>
</p>

<p>Similarly to other parallel discrete event simulation methods, the
model to be simulated - which is more or less a precise representation
of a real system - is divided into segments, where the segments
usually describe the behaviour of functional units of the real system.
The communication of the segments can be represented by sending and
receiving various messages. The simulators of the segments are
executed by separate processors.

<p>
The communication of these segments is simulated with appropriate
interfaces. The messages generated in a given segment and to be
processed in a different segment are not transmitted there, but the
output interfaces collect the statistical data of them.  If the input
interfaces generate messages for the segments according to the
statistical characteristics of the messages collected by the proper
output interfaces, the segments with their input- and output
interfaces can be simulated separately, giving statistically correct
results. The events in one segment have not the same effect in other
segments as in the original model, so the results collected during the
SSM are not exact. The precision depends on the
segmentation, on the accuracy of statistics collection and
regeneration, and on the frequency of the statistics exchange among
the processors.

<p>
<STRONG>Segmentation</STRONG>

<p>
The segments of the simulator are
executed by separate processors, they have their own, independent
virtual times. Because the interactions among segments are performed
by the statistical parameters of these interactions, the segmentation
should be done so, that the overwhelming majority of the interactions
should happen within the segments and not among them. This speeds up
the so-called inter-segment transients
and improves the accuracy as well.

<p>
<STRONG>Timing of statistics exchange</STRONG>

<p>
Asynchronous statistics exchange means, that whenever a statistical result collection in an
output interface is ready, it is applied - after mapping and
correction - in the proper input interface.  This is clearly more
efficient, than the so-called synchronous statistics
exchange, which means, that we
delay the application of collected values until all the output
interfaces get ready with the result collection. Frequent statistics
exchange makes the inter-segment transient faster, but the lower
sample numbers makes the estimation - and the whole simulation - less
precise.

<p>
To learn more about SSM, see [PON92] and [PON93].

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec335"/>11.3.2. <FONTteal>Using SSM in OMNeT++</FONT></H3></font>

<p>OMNeT++ directly supports the implementation of statistical
interface with the following classes:

<p><tt>cLongHistogram</tt>, <tt>cDoubleHistogram</tt>, <tt>cPSquare</tt>, <tt>cPar</tt>.

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec336"/>12. <FONTgreen>The Design of OMNeT++</FONT></H1></font></hr>
<a name="cha:the-design-of-omnet"/>

<p><hr><font color="#006f00"><H2><A NAME="sec337"/>12.1. <FONTblue>Structure of an OMNeT++ executable</FONT></H2></font></hr>

<p>Consider the following diagram:

<p>
  <DIV ALIGN=center>
    <img src="usmanFig18.gif">
    <center><i>Figure: Architecture of OMNeT++ simulation programs</i></center>
  </DIV>

<p>
A simulation program contains the simulated network (with its
simple and compound
modules etc.), SIM, ENVIR and exactly one of CMDENV and TKENV. SIM
contains the simulation class library
and the simulation kernel. The model only interacts with
SIM<font size=-1>[the only exception is textual module output: it is sent
  directly to ENVIR: ev<SAMP>&lt;</SAMP><SAMP>&lt;</SAMP>''hello''; ev.printf(''
  world'');]</font>. ENVIR contains code that is common for all user
interfaces, and provides infrastructure like ini file handling for
them. <tt>main()</tt> is also in ENVIR. Specific user interface code is
contained in CMDENV and TKENV. The above components are also
physically separated: they are in separate source directories and form
separate library files (<tt>libsim_std.a</tt>, <tt>libenvir.a</tt> etc.)

<p>The simulation program may contain several linked-in model
components: networks,
simple module types,
compound module types, channel types etc. Any
network (but only one at a time) can be set up for simulation which
has all necessary components linked in.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec338"/>12.2. <FONTblue>Embedding OMNeT++</FONT></H2></font></hr>

<p>Embedding is a special issue. You probably
do not want to keep the appearance of the simulation program, so you
do not want Cmdenv and Tkenv. You may or may not want to keep ENVIR.

<p>What you'll absolutely need for a simulation to run is the SIM
package. You can keep ENVIR if its philosophy and the infrastructure
it provides (<tt>omnetpp.ini</tt>, certain command-line options etc.)
fit into your design. Then the embedding program will take the
place of Cmdenv and Tkenv.

<p>If ENVIR does not fit your needs (for example, you want the model
parameters to come from a database not from <tt>omnetpp.ini</tt>), then you
have to replace it. Your ENVIR replacement (the embedding program,
practically) must implement the <tt>cEnvir</tt> member functions from
<tt>envir/cenvir.h</tt>, but you have full control over the simulation.

<p>Normally, code that sets up a network or builds the internals of a
compound module comes from compiled NED source.  You may not like the
restriction that your simulation program can only simulate networks
whose setup code is linked in. No problem; your program can contain
pieces of code like what is generated by nedc and then it can build
any network whose components (primarily the simple modules) are linked
in. Moreover, it is possible to write an integrated environment where
you can put together a network using a graphical editor and right
after that you can run it, without intervening NED compilation and
linkage.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec339"/>12.3. <FONTblue>The simulation kernel</FONT></H2></font></hr>

<p>The source code for the simulation kernel of
OMNeT++ and the library classes reside in the sim directory.

<p>Almost all objects are derived from <tt>cObject</tt> which
provides a common interface for them.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec340"/>12.3.1. <FONTteal>The central object: cSimulation simulation</FONT></H3></font>

<p>The <tt>cSimulation</tt> class stores a network and manages simulation.
There is only one instance, a global object called <tt>simulation</tt>.
The object has two basic roles:
<UL>
  <li><strong></strong>as a vector of modules
  <li><strong></strong>holds global variables (for example, the message queue).
</UL>

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec341"/>12.3.2. <FONTteal>Module classes</FONT></H3></font>

<p>Base class for module classes: <tt>cModule</tt>. Two derived classes:
<tt>cCompoundModule</tt>, <tt>cSimpleModule</tt>.  User simple
modules are derived from <tt>cSimpleModule</tt>.

<p>A <tt>cModule</tt> has: array of parameters, array of gates + member
functions to set up and query parameters and gates.

<p><tt>cSimpleModule</tt> adds: put-aside queue, list of local objects + the
virtual function <tt>activity()</tt> + member functions like
<tt>send()</tt>, <tt>receive()</tt> etc.

<p>Gates are represented by the <tt>cGate</tt> objects.
Connections are not real objects: their attributes (delay, error,
datarate) are managed by the connection's source gate.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec342"/>12.3.3. <FONTteal>Global registration lists</FONT></H3></font>

<p>There are global objects holding lists of components available
in an OMNeT++ executable. These lists are:

<p>
<table border>
<TR> <TD align=left>

<STRONG>List object</STRONG>
</TD> <TD align=left>
<STRONG><fontmaroon><em> Unknown LaTeX command </em> \mbox </font>Macro that creates a<fontmaroon><em>  </em>  </font></STRONG><br>
<STRONG>member.</STRONG> <br><br>
<STRONG>Class of members</STRONG>
</TD> <TD align=left>
<STRONG>Function</STRONG> </TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt>  <br>
<tt> networks;</tt>
</TD> <TD align=left>
<tt><tt>Define_Network()</tt></tt> <br>
<br>
<tt><tt>cNetworkType</tt></tt>
</TD> <TD align=left>
 List of available networks.</TD></TR>
<TR> <TD align=left> A <tt>cNetworkType</tt> object holds a pointer to a function that can
build up the network.</TD></TR>
<TR> <TD align=left> <tt>Define_Network()</tt> macros occur in the code generated by the NEDC
compiler.</TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt> <br>
<tt> modtypes;</tt>
</TD> <TD align=left>
<tt><tt>Define_Module()</tt>,</tt> <br>
<tt><tt>Define_Module_Like()</tt>,</tt>  <br>
<br>
<tt><tt>cModuleType</tt></tt>
</TD> <TD align=left>
 List of available module types.</TD></TR>
<TR> <TD align=left> A <tt>cModuleType</tt> object knows how to create a module of a specific
type. If it is compound, it holds a pointer to a function that can
build up the inside.</TD></TR>
<TR> <TD align=left> Usually, <tt>Define_Module()</tt> macros for compound modules occur in
the code generated by the NEDC compiler; for simple modules,
the <tt>Define_Module()</tt> lines are added by the user.</TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt> <br>
<tt> classes;</tt>
</TD> <TD align=left>
<tt>Register_Class()</tt> <br>
<br>
<tt>ClassRegister</tt>
</TD> <TD align=left>
 List of available classes of which the user can create
  an instance.</TD></TR>
<TR> <TD align=left> A <tt>cClassRegister</tt> object knows how to create an (empty) object of a specific class.</TD></TR>
<TR> <TD align=left> The list is used by the <tt>createOne()</tt> function that can create an
object of any (registered) type from a string containing the class
name. (E.g. <tt>ptr = createOne( ``cArray'')</tt> creates an empty
array.)</TD></TR>
<TR> <TD align=left> <tt>createOne()</tt> is used by the PVM extension.</TD></TR>
<TR> <TD align=left> <tt>Register_Class()</tt> macros are present in the simulation source
files for existing classes; has to be written by the user for new
classes.</TD></TR>
<TR> <TD align=left> <tt>cHead</tt> <br>
<tt> functions;</tt>
</TD> <TD align=left>
<tt><tt>Define_Function()</tt></tt> <br>
<br>
<tt><tt>cFunctionType</tt></tt>
</TD> <TD align=left>
 List of mathematical functions.</TD></TR>
<TR> <TD align=left> A <tt>cFunctionType</tt> object holds a pointer to the function and knows
how many arguments it takes.</TD></TR>
<TR> <TD align=left> <tt>cHead</tt> <br>
<tt> linktypes;</tt>
</TD> <TD align=left>
<tt>Define_Link()</tt> <br>
<br>
<tt>cLinkType</tt>
</TD> <TD align=left>
 List of link types.</TD></TR>
<TR> <TD align=left> A <tt>cLinkType</tt> object knows how to create <tt>cPar</tt> objects representing
the delay, error and datarate attributes for a channel.</TD></TR>
<TR> <TD align=left> <tt>Define_Link()</tt> macros occur in the code generated by the NEDC
compiler, one for each channel definition. </TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt> <br>
<tt> locals;</tt>
</TD> <TD align=left>
<tt>-</tt> <br>
<br>
<tt>any object</tt>
</TD> <TD align=left>
This is only `dummy' object, it stands for the current module's
local object list</TD></TR>
<TR> <TD align=left> <tt><tt>cHead</tt></tt> <br>
<tt> superhead;</tt>
</TD> <TD align=left>
<tt>-</tt> <br>
<br>
<tt><tt>cHead</tt></tt>
</TD> <TD align=left>
List of all other lists. </TD></TR>
</table>

<p>

<p><font color="#006f00"><H3><A NAME="sec343"/>12.3.4. <FONTteal>The coroutine package</FONT></H3></font>

<p>The coroutine package is in fact two coroutine
packages:

<p><UL>
  <li><strong></strong> Portable coroutine package creates all coroutine stacks
     inside the main stack. It was taken from [KOF85]. It
     allocates stack by deep-deep recursions and then plays with
     <tt>setjmp()</tt> and <tt>longjmp()</tt> to switch from one another.

<p>  <li><strong></strong> On Windows, the Fiber functions (<tt>CreateFiber()</tt>,
     <tt>SwitchToFiber()</tt>, etc) are used, which are part of
     the standard Win32 API.
</UL>

<p>The coroutines are represented by the <tt>cCoroutine</tt>
class. <tt>cSimpleModule</tt> has <tt>cCoroutine</tt> as one a
base class.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec344"/>12.3.5. <FONTteal>Object ownership/contains relationships</FONT></H3></font>

<p><STRONG>Ownership:</STRONG> Exclusive right and duty to delete the child
objects.  Ownership works through <tt>cObject</tt>'s
ownerp/prevp/nextp and firstchildp/lastchildp pointers.

<p>
<STRONG>'Contains' relationship:</STRONG> Only
for container classes, e. g.  <tt>cArray</tt> or <tt>cQueue</tt>.
Keeping track of contained objects works with another mechanism,
<EM>not</EM> the previously mentioned ptrs. (E.g., <tt>cArray</tt>
uses a vector, <tt>cQueue</tt> uses a separate list).

<p>The two mechanisms are <EM>independent</EM>.

<p><STRONG>What <tt>cObject</tt> does:</STRONG>
<UL>
  <li><strong></strong>Owner of a new object can be explicitly given; if omitted,
    <tt>defaultOwner()</tt> will be used.
  <li><strong></strong>An object created through the copy
    constructor will have the same
    owner as original and does not <tt>dup()</tt> or take objects owned
    by the original.
  <li><strong></strong>Destructor calls <tt>free()</tt> for owned objects (see later)
</UL>

<p>
<STRONG>Rules for derived classes:</STRONG>
<UL>
  <li><strong></strong>Objects contained as data members: the enclosing object should
    own them.
</UL>

<p><STRONG>Rules for container objects derived from cObject:</STRONG>
<UL>
  <li><strong>they use the functions: \fname[take()]</strong>take(obj),
    <tt>drop(obj)</tt>, <tt>free(obj)</tt>
  <li><strong></strong>when an object is inserted, if <tt>takeOwnership()</tt> is
    true, should take ownership of object by calling
    <tt>take(obj)</tt>. <tt>takeOwnership()</tt> defaults to
    true!
  <li><strong></strong>when an object is removed, they should call
    <tt>drop(obj)</tt> for it if they were the owner.
  <li><strong></strong>copy constructor copies should <tt>dup()</tt> and take
    ownership of objects that were owned by the original.
  <li><strong></strong>destructor doesn't need not call <tt>free()</tt> for objects:
    this will be done in <tt>cObject</tt>'s destructor.
</UL>

<p>The class <tt>cHead</tt> is special case: it behaves as a container,
displaying objects it owns as contents.

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec345"/>12.4. <FONTblue>The user interface</FONT></H2></font></hr>

<p>The source code for the user interface of OMNeT++ resides in the
<SAMP>envir</SAMP> directory (common part) and in the <SAMP>cmdenv</SAMP>,
<SAMP>tkenv</SAMP> directories.

<p>The classes in the user interface are <EM>not</EM> derived from <tt>cObject</tt>,
they are completely separated form the simulation kernel.

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec346"/>12.4.1. <FONTteal>The main() function</FONT></H3></font>

<p>The <tt>main()</tt> function of OMNeT++ simply sets up the user
interface and runs it. Actual simulation is done in
<tt>cEnvir::run()</tt> (see later).

<p>

<p>

<p><font color="#006f00"><H3><A NAME="sec347"/>12.4.2. <FONTteal>The cEnvir interface</FONT></H3></font>

<p>The <tt>cEnvir</tt> class has only one instance, a global object
called <tt>ev</tt>:

<pre>
cEnvir ev;
</pre>
<p>
<tt>cEnvir</tt> basically is only an interface, its member functions
hardly contain any code. <tt>cEnvir</tt> maintains a pointer to a
dynamically allocated simulation application object (derived from
<tt>TOmnetApp</tt>, see later) which does all actual work.

<p>
<tt>cEnvir</tt> member functions deal with four basic tasks:
<UL>
  <li><strong></strong>I/O for module activities; actual implementation is different
    for each user interface (e.g. stdin/stdout for Cmdenv, windowing
    in Tkenv)
  <li><strong></strong>setting up and running the simulation application
  <li><strong></strong>provides functions called by simulation kernel objects to get
    information (for example, get module parameter settings from the
    configuration file)
  <li><strong></strong>provides functions called by simulation kernel objects to
    notify the user interface of some events. This is especially
    important for windowing user interfaces (Tkenv), because the
    events are like this: an object was deleted so its inspector
    window should be closed; a message was sent so it can be
    displayed; a breakpoint was hit.
</UL>

<p>

<p>
<font color="#006f00"><H3><A NAME="sec348"/>12.4.3. <FONTteal>Implementation of the user interface: simulation applications</FONT></H3></font>

<p>The base class for simulation application is <tt>TOmnetApp</tt>.
Specific user interfaces such as <tt>TCmdenv</tt>,
<tt>TOmnetTkApp</tt> are derived from <tt>TOmnetApp</tt>.

<p><tt>TOmnetApp</tt>'s member functions are almost all virtual.
<UL>
  <li><strong></strong>Some of them implement the <tt>cEnvir</tt> functions
    (described in the previous section)
  <li><strong></strong>Others implement the common part of all user interfaces (for
    example: reading options from the configuration files; making the
    options effective within the simulation kernel)
  <li><strong></strong>The <tt>run()</tt> function is pure virtual (it is different
    for each user interface).
</UL>

<p><tt>TOmnetApp</tt>'s data members:
<UL>
  <li><strong></strong>a pointer to the object holding configuration file contents
    (type <tt>cInifile</tt>);
  <li><strong></strong>the options and switches that can be set from the
    configuration file (these members begin with <tt>opt_</tt>)
</UL>

<p>Concrete simulation applications:
<UL>
  <li><strong></strong>add new configuration options
  <li><strong></strong>provide a <tt>run()</tt> function
  
<p>  <li><strong></strong>implement functions left empty in <tt>TOmnetApp</tt> (like
    <tt>breakpointHit()</tt>, <tt>objectDeleted()</tt>).
</UL>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb  9 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec349"/>13. <FONTgreen>OPNET and OMNeT++</FONT></H1></font></hr>
<a name="cha:opnet-and-omnet"/>

<p><hr><font color="#006f00"><H2><A NAME="sec350"/>13.1. <FONTblue>Comparison of OPNET and OMNeT++</FONT></H2></font></hr>

<p>OPNET<sup>TM</sup> (from MIL3 Inc.) is a state-of-the art commercial simulation
program for the modeling of communication systems. OPNET is designed
to enable full-detail modeling: every tool is given to implement
nonstandard protocols or behaviour.

<p>
A quote from the OPNET brochure:

<p>
<UL>
<li><strong></strong><EM>OPNET presents an advanced graphical user
interface that supports multi-windowing, makes use of menus and
icons, and runs under X Windows. Supported platforms include
popular engineering workstations from SUN, DEC, HP and Silicon
Graphics. (Windows NT version also exists.)</EM>
<li><strong></strong><EM>Graphical object-oriented editors for defining topologies
and architectures directly parallel actual systems, allowing
an intuitive mapping between a system and its model. OPNET's
hierarchical approach simplifies the specification and representation
of large and complex systems.</EM>
<li><strong></strong><EM>The process editor provides a powerful and flexible
language to design models of protocols, resources, applications,
algorithms, queuing policies, and other processes. Specification
is performed in the Proto-C language, which combines a graphical
state-transition diagram approach with a library of more than
300 communication- and simulation-specific functions. The full
generality and power of the C language is also available.</EM>
<li><strong></strong><EM>OPNET simulations generate user-selected performance
and behavioral data. Simulation results can be plotted as time
series graphs, scatter plots, histograms, and probability functions.
Standard statistics and confidence intervals are easily generated
and additional insight can be obtained by applying mathematical
operators to the collected data. </EM>
<li><strong></strong><EM>OPNET provides an advanced animation capability for
visualising simulation events. Both automatic and user-customised
animations can be displayed interactively during or after a simulation.
Animations can depict messages flowing between objects, control
flow in a process, paths of mobile nodes, and dynamic values
such as queue size or resource status. </EM>
<li><strong></strong><EM>OPNET provides open system features including: interfaces
to standard languages; the ability to take advantage of third-party
libraries; an application program interface; access to databases
and data files such as those generated by network analysers;
and PostScript and TIFF export for desktop publishing. OPNET
users are guided by a comprehensive documentation set and are
backed by outstanding technical support.</EM>
</UL>

<p>OPNET is very well designed and built commercial simulation software.
The author of OMNeT++ has worked for the Hungarian distributor
of OPNET for over three years and he has gained significant experience
with the software. He has taken part in several computer network
simulation projects for major Hungarian companies and also delivered
OPNET training. He has also written simulation models for a VSAT
system in OPNET. <br>
Following is a comparison of the features that concern general-purpose
computer systems simulation (and are not specific to computer
network simulation) and that are present both in OMNeT++ and
OPNET.

<p>
<STRONG>Model hierarchy levels</STRONG>
<table border>
<TR> <TD align=left>
  
  <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left>    network level (subnetwork nesting possible) <br>
   node level (no nesting) <br>
  process level (no nesting)
  </TD> <TD align=left>
  arbitrary levels of submodule nesting </TD></TR>
</table>

<p>

<p><STRONG>Topology description method</STRONG>

<p>
OPNET provides two tools for defining module topology: graphical
editors to design network and node level models, and EMA (External
Model Access), an API for building model files from C programs.
These tools correspond to OMNeT++'s tools in the following way:

<p>
<table border>
<TR> <TD align=left>

 </TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Graphical</STRONG> </TD> <TD align=left> graphical editor within the IDE </TD> <TD align=left> graphical editor: GNED </TD></TR>
<TR> <TD align=left> <STRONG>High-level</STRONG> </TD> <TD align=left> - </TD> <TD align=left> NED language</TD></TR>
<TR> <TD align=left> <STRONG>Low-level</STRONG> </TD> <TD align=left> EMA </TD> <TD align=left> C++ output of NED compilation</TD></TR>
</table>

<p>

<p>There is no high-level textual model description in OPNET (like
NED is in OMNeT++). This means that one has either to use the
graphical editor or write lengthy C code using the EMA API.

<p>
The OPNET graphical model editor can only create fixed (non-parameterized)
topologies.

<p>
There's a significant difference between how EMA and OMNeT++'s
NED are used. OPNET's EMA generates model files. EMA applications
are standalone programs: one writes the EMA C code, compiles
and runs it, and the EMA executable will generate a model file
that can be read into the graphical editor or loaded by simulation
programs. EMA cannot be used from within a simulation program.
In contrast, the compiled NED code of OMNeT++ becomes part of
the simulation program and it builds the model without having
to run external programs; this means that you can have a single
simulation executable that can be used to perform simulation
studies on networks with different topologies.

<p>
<STRONG>Module parameters</STRONG>

<p><table border>
<TR> <TD align=left>

</TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Expressions</STRONG> </TD> <TD align=left> no expressions are allowed: only literals or exact copy of another
parameter </TD> <TD align=left> arbitrary expressions using other parameters </TD></TR>
<TR> <TD align=left> <STRONG>Parameter passing</STRONG> </TD> <TD align=left> by value </TD> <TD align=left> parameters can be passed by value or by reference, and be changed during simulation</TD></TR>
<TR> <TD align=left> <STRONG>Usage</STRONG> </TD> <TD align=left> by process models only </TD> <TD align=left> by process models; also to define flexible topologies </TD></TR>
</table>

<p>

<p>In OPNET, module parameter values can be passed only ''as
is''.

<p>
<STRONG>Packet streams or gates<br>
</STRONG>

<p><table border>
<TR> <TD align=left>

</TD> <TD align=left>
<STRONG>OPNET</STRONG> </TD> <TD align=left>
<STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Identification</STRONG> </TD> <TD align=left>
Packet streams are numbered from 0; no names can be assigned. </TD> <TD align=left>
 Gates are identified by names. Gate vectors are supported.</TD></TR>
<TR> <TD align=left> In the code, gates can be referenced by ID for greater speed.</TD></TR>
<TR> <TD align=left> <STRONG>Directionality</STRONG> </TD> <TD align=left>
Packet streams are uni-directional. </TD> <TD align=left>
Gates are uni-directional.</TD></TR>
</table>

<p>
<STRONG>Flexible topologies</STRONG>

<p><table border>
<TR> <TD align=left>

<STRONG>OPNET</STRONG> </TD> <TD align=left>
<STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> not really supported<font size=-1>[If really necessary, it can be done through C programming (writing
EMA code) and running external program to create a separate model  file for each case.]</font>
</TD> <TD align=left>
in the NED file, parameters can define submodule types, count
of submodules, gates and describe connections </TD></TR>
</table>

<p>

<p>

<p><STRONG>Tracing, animation and interactive simulation</STRONG>

<p><table border>
<TR> <TD align=left>

 </TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Tracing and debugging</STRONG>
</TD> <TD align=left>
powerful command line debugger (ODB)
</TD> <TD align=left>
separate window for each module's output, single-steps, run
until, inspectors, snapshot, etc. (Tkenv) </TD></TR>
<TR> <TD align=left> <STRONG>Animation</STRONG>
</TD> <TD align=left>
 mostly used in record/ playback mode; <br>
animation spec. must be given in advance (via anim. probes)
</TD> <TD align=left>
interactive execution with message-flow animation, statistics
animation etc. (Tkenv) </TD></TR>
<TR> <TD align=left> <STRONG>Interactive simulation</STRONG>
</TD> <TD align=left>
not supported
</TD> <TD align=left>
strongly supported via object inspectors and watches. (Tkenv) </TD></TR>
</table>

<p>
<STRONG>Random numbers</STRONG>

<p><table border>
<TR> <TD align=left>

</TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Distributions provided</STRONG>
</TD> <TD align=left>
many built-in distributions (through algorithms)
</TD> <TD align=left>
four built-in distributions, as C functions </TD></TR>
<TR> <TD align=left> <STRONG>Additional distributions</STRONG>
</TD> <TD align=left>
through histograms
</TD> <TD align=left>
as C functions (algorithms); or through histograms </TD></TR>
<TR> <TD align=left> <STRONG>Random number generation</STRONG>
</TD> <TD align=left>
one random number generator, no support for seed selection
</TD> <TD align=left>
 several independent random number generators;</TD></TR>
<TR> <TD align=left> tool to support selecting good seed values </TD></TR>
</table>

<p>

<p>OPNET has many built-in distributions implemented with algorithms
(C functions). Additional distributions are supported as histograms.
There is only one common source of random numbers. OPNET has
no aid for selecting seed values that produce long non-overlapping
random number sequences.

<p>
OMNeT++, only four basic distributions are provided. They are
implemented as C functions. Additional distributions can be added
by the user, and they are treated exactly in the same way as
built-in ones. Defining and using distributions in histogram
form is also supported. OMNeT++ provides several random number
generators, and also a tool for selecting good seed values.

<p>
<STRONG>Process description method</STRONG>

<p><table border>
<TR> <TD align=left>

</TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Method</STRONG>
</TD> <TD align=left>
finite state machine (graphical spec. only)
</TD> <TD align=left>
both process-style (coroutine-based) and finite state machine
(textual spec. only)</TD></TR>
</table>

<p>

<p><STRONG>Direct (non-scheduled) process interaction</STRONG>

<p><table border>
<TR> <TD align=left>

</TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Method</STRONG> </TD> <TD align=left> ''forced interrupt'' </TD> <TD align=left> member function call of other module</TD></TR>
</table>

<p>

<p><STRONG>Dynamic module creation</STRONG>

<p><table border>
<TR> <TD align=left>

</TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>What can be created</STRONG>
</TD> <TD align=left>
only processes within an existing module
</TD> <TD align=left>
 simple modules;</TD></TR>
<TR> <TD align=left> connections;</TD></TR>
<TR> <TD align=left> compound modules with arbitrarily complex, parameterized topologies</TD></TR>
</table>

<p>

<p><STRONG>Object-oriented concepts</STRONG>

<p><table border>
<TR> <TD align=left>

</TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Language</STRONG> </TD> <TD align=left> C </TD> <TD align=left> C++</TD></TR>
<TR> <TD align=left> <STRONG>Objects</STRONG>
</TD> <TD align=left>
 C API functions operating on object-like data structures;</TD></TR>
<TR> <TD align=left> no support for inheritance<font size=-1>[The graphical user interface of OPNET (from version 3.0) contains an ''inheritance mechanism'' for models. This is no real inheritance in the object-oriented sense because it just means that parameter values can be changed or fixed down, parameters renamed, merged etc. There is no mention about changing the behaviour of a module (that is, anything like C++'s virtual functions).]</font>, polymorphism or the like
</TD> <TD align=left>
 full flexibility of C++: inheritance, polymorphism etc;</TD></TR>
<TR> <TD align=left> built-in object-oriented mechanisms</TD></TR>
</table>

<p>
<STRONG>Statistics collection and run-time analysis</STRONG>

<p><table border>
<TR> <TD align=left>

<STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left>  writing observations to output file; ''probes''
to select statistics to be collected;</TD></TR>
<TR> <TD align=left> only off-line analysis (analysis of output files) is supported
</TD> <TD align=left>
 writing observations to output files (roughly equivalent to
OPNET's solution);</TD></TR>
<TR> <TD align=left> run-time processing: basic measures (mean etc); distribution
estimation with histograms; quantiles ($P^2$ algorithm);</TD></TR>
<TR> <TD align=left> support for detecting the end of the transient period and sufficient
result accuracy</TD></TR>
</table>

<p>

<p><STRONG>Parallel execution</STRONG>

<p><table border>
<TR> <TD align=left>

<STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left>  not supported </TD> <TD align=left> supported by PVM and MPI; arbitrary synchronization can be used</TD></TR>
</table>

<p>

<p><STRONG>Openness</STRONG>

<p><table border>
<TR> <TD align=left>

 </TD> <TD align=left> <STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> <STRONG>Input file formats</STRONG>
</TD> <TD align=left>
 binary model files<font size=-1>[Can be read and analyzed by EMA programs.]</font>;</TD></TR>
<TR> <TD align=left> textual parameter files
</TD> <TD align=left>
text files </TD></TR>
<TR> <TD align=left> <STRONG>Output file formats</STRONG>
</TD> <TD align=left>
binary files<font size=-1>[Can be exported to text files from the main OPNET program.]</font>
</TD> <TD align=left>
text files</TD></TR>
<TR> <TD align=left> <STRONG>Availability of source</STRONG>
</TD> <TD align=left>
not available (only the source of the shipped models is available)
</TD> <TD align=left>
available</TD></TR>
<TR> <TD align=left> <STRONG>Embedding simulations into other software product</STRONG>
</TD> <TD align=left>
not supported and also not possible (the <tt>main()</tt> function cannot
be supplied by the user etc.)
</TD> <TD align=left>
 supported.</TD></TR>
<TR> <TD align=left> Embedding application becomes a new ''user interface''
based on Envir (1); or embedding application replaces Envir (2).</TD></TR>
</table>

<p>

<p>

<p>

<p>

<p>
<hr><font color="#006f00"><H2><A NAME="sec351"/>13.2. <FONTblue>Quick reference for OPNET users</FONT></H2></font></hr>

<p>This section is intended to help OPNET users learn OMNeT++ faster.

<p><table border>
<TR> <TD align=left>

<STRONG>OPNET</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left> network, subnetwork, node </TD> <TD align=left> Compound modules</TD></TR>
<TR> <TD align=left> module, process </TD> <TD align=left> An OMNeT++ simple module corresponds to an OPNET module with
its process.</TD></TR>
<TR> <TD align=left> interrupts, invocations, states
</TD> <TD align=left>
 When using <tt>handleMessage()</tt>: interrupt = event, invocation = call
to <tt>handleMessage()</tt>, state = FSM state or the value of the state
vars stored in the class <br>
 When using modules with <tt>activity()</tt>, this means a little different
way of thinking from OPNET's. In OMNeT++, you write a simple
module as you would write an operating system process or a thread,
thus there's no need to distinguish 'states' or speak about 'invocations'.
Within the simulation kernel, an 'invocation' corresponds to
a <tt>transferTo(<EM>module</EM>)</tt> call. <br>
 An OMNeT++ module accepts messages (and simulation time advances)
within <tt>receive... (... )</tt> calls; <tt>wait()</tt> is just a <tt>scheduleAt()</tt> followed
by a <tt>receive()</tt>. <br>
An OPNET interrupt is the event being processed. In this sense,
OMNeT++ messages returned by <tt>receive()</tt> correspond to OPNET interrupts.</TD></TR>
<TR> <TD align=left> endsim interrupt
</TD> <TD align=left>
The <tt>finish()</tt> virtual member functions of the simple modules are
called at the end of the simulation run. You can redefine <tt>finish()</tt>
to write statistics etc. </TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> <tt>op_ima_obj_attr_get(... )</tt>
</TD> <TD align=left>
 <tt>foo = par(''foo'');</tt> <br>
<tt>foo = module-<SAMP>&gt;</SAMP>par(''foo'');</tt></TD></TR>
<TR> <TD align=left> <tt>op_ima_sim_attr_get(... )</tt>
</TD> <TD align=left>
 There are no simulation attributes. You can use the parameters
of the top-level module instead: <br>
<tt>foo = simulation.systemModule()-<SAMP>&gt;</SAMP>par(''foo'');</tt></TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left>  <tt>op_prg_odb_print_minor(... )</tt>  <br>
<tt>op_prg_odb_print_major(... )</tt>
</TD> <TD align=left>
 <tt>ev &lt;&lt; ''hello!'' &lt;&lt; endl;</tt> <br>
<tt>ev.printf(... );</tt></TD></TR>
<TR> <TD align=left> <tt>op_sim_end(... )</tt>
</TD> <TD align=left>
<tt>simulation.error(''Your fault! error 0'',ec);</tt></TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c </TD></TR>
<TR> <TD align=left> <tt>op_subq_....()</tt>
</TD> <TD align=left>
 Create a queue object and then manipulate it with its member
  functions.
<pre>
cQueue queue;
queue.insert( msg );
if (!queue.empty())
  msg = queue.pop();
</pre>
<p></TD></TR>
<TR> <TD align=left> 
 <tt>List</tt> <br>
<tt>op_prg_list_...()</tt>
</TD> <TD align=left>
<pre>
cLinkedList list;
list.insert( ptr );
if (!list.empty())
ptr = list.pop();
</pre>
</TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
 <tt>Topology</tt> <br>
<tt>op_rte_...()</tt>
</TD> <TD align=left>
The <tt>cTopology</tt> class offers similar functionality, and you can
expect greater speed than with OPNET's routing functions. </TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
<pre>
Packet
op_pk_create(... )
op_pk_destroy( )
</pre>
</TD> <TD align=left>
 Use the <tt>cMessage</tt> class.
<pre>
cMessage *msg = new cMessage;
delete msg;
</pre>
<p></TD></TR>
<TR> <TD align=left> 
 packet fields
<pre>
op_pk_nfd_set(... )
op_pk_nfd_get_(... )
op_pk_fd_set(... )
op_pk_fd_get(... )
</pre>
<p></TD> <TD align=left>
 Message parameters. A parameter has both name and index. <br>
<pre>
msg-&gt;par("foo") = foo;
msg-&gt;addPar("new-foo") = foo;
int foo = msg-&gt;par("foo");

int fooindex =
  msg-&gt;parList().find("foo");
msg-&gt;par(fooindex) = foo;
</pre>
</TD></TR>
<TR> <TD align=left> 
packet field modeled size
</TD> <TD align=left>
 Message parameters do not have associated modelled bit sizes.
  Message length can be used instead. <br>
<pre>
msg-&gt;addPar("dest_addr") = dest_addr;
msg-&gt;addLength( 32 );
</pre>
</TD></TR>
<TR> <TD align=left> 
packet formats
</TD> <TD align=left>
There are no explicit packet formats in OMNeT++. However, you
can write function to create messages with specific fields and
length:
<pre>
cMessage *createEthernetFrame()
{
  cMessage *msg = new cMessage;
  msg-&gt;setKind(PACKET);
  msg-&gt;addPar("source");
  msg-&gt;addPar("destination");
  msg-&gt;addPar("protocol");
  msg-&gt;setLength( 8*16 );
  return msg;
}
</pre>
</TD></TR>
<TR> <TD align=left> 
packet encapsulation
</TD> <TD align=left>
 As in OPNET, message parameters can be assigned object pointers,
thus also message pointers.  <br>
However, there is also direct support encapsulation:
<pre>
msg-&gt;encapsulate(innermsg)
innermsg = msg-&gt;encapsulatedMsg();
innermsg = msg-&gt;decapsulate();
</pre>
</TD></TR>
<TR> <TD align=left> 
ICI
</TD> <TD align=left>
 ICIs are also represented by cMessage objects, naturally with
zero length.  <br>
If it is important to distinguish between packets and ICIs, you
can use the message kind field:
<pre>
#define PACKET 0
#define ICI 1

cMessage *pk = new cMessage;
pk-&gt;setKind(PACKET);

cMessage *ici = new cMessage;
ici-&gt;setKind(ICI);
</pre>
</TD></TR>
<TR> <TD align=left> 
ICI formats </TD> <TD align=left> See packet formats.</TD></TR>
<TR> <TD align=left> ICI attributes </TD> <TD align=left> See packet fields.</TD></TR>
<TR> <TD align=left> packet and ICI in the same interrupt
</TD> <TD align=left>
You can use encapsulation. At the sender side:
<pre>
cMessage *ici, *pk;
ici-&gt;encapsulate(pk);
send(ici,"out-gate");
</pre>
The receiver side:
<pre>
ici = receive();
pk = ici-&gt;decapsulate();
</pre>
</TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> <tt>op_pk_send(... )</tt>
</TD> <TD align=left>
<pre>
send( msg, "out-gate");
send( msg, "gate-vector'', index);
send( msg, gate_id );
</pre>
</TD></TR>
<TR> <TD align=left> 
<tt>op_pk_send_delayed(... )</tt> </TD> <TD align=left> <tt>sendDelayed(... )</tt></TD></TR>
<TR> <TD align=left> <tt>op_pk_deliver(... )</tt> </TD> <TD align=left> <tt>sendDirect(... )</tt></TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
<tt>op_pk_schedule_self(... )</tt> </TD> <TD align=left> <tt>scheduleAt( simTime()+timeout, msg );</tt></TD></TR>
<TR> <TD align=left> <tt>op_ev_cancel(... )</tt> </TD> <TD align=left> <tt>cancelEvent( msg );</tt></TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
<tt>op_dist_load(... ) <br>
  op_dist_outcome(... )</tt>
</TD> <TD align=left>
To generate random numbers from analytical distributions, use:
<pre>
uniform(... )
intuniform(... )
exponential(... )
normal(... )
truncnormal(... )
</pre>

<p>For custom distributions you can use the histogram classes. Histograms
can load distribution data from file.
<pre>
cDoubleHistogram hist;
FILE *f = fopen("distribution.dat");
hist.loadFromFile( f );
fclose(f);

double rnd = hist.random();
</pre>
</TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
output vectors
</TD> <TD align=left>
The <tt>cOutVector</tt> class can be used.
<pre>
cOutVector eed("End-to-end delay");

double d = msg-&gt;creationTime()
             - simTime();
eed.record( d );
</pre>
</TD></TR>
<TR> <TD align=left> 
output scalars
</TD> <TD align=left>
Output scalar file exists. You can write into it with <tt>recordScalar()</tt>:
<pre>
recordScalar("average delay",
             avg_delay);
</pre>
</TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
<tt>op_topo_parent()</tt> </TD> <TD align=left> <tt>cModule *parent = parentModule();</tt></TD></TR>
<TR> <TD align=left> <tt>op_topo_child_... (... )</tt> </TD> <TD align=left> <tt>cSubModuleIterator</tt></TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
<tt>op_topo_.._assoc_(... )</tt>
</TD> <TD align=left>
<pre>
gate(i)/gate(name),
gate-&gt;toGate()/fromGate()
gate-&gt;destinationGate()/sourceGate()
gate-&gt;ownerModule()
</pre>
</TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
<tt>op_pro_create(... )</tt>
</TD> <TD align=left>
See dynamic module creation. Note that this is a more powerful
tool than OPNET's dynamic processes in that you can also create
compound modules. </TD></TR>
<TR> <TD align=left> 
Prohandle
</TD> <TD align=left>
Module ID. Given the module pointer, you can obtain module ID
by
<pre>
int id = mod-&gt;id();
</pre>

<p>And you can obtain module pointer from the ID:
<pre>
cModule *mod = simulation.module(id);
</pre>
An invalid ID is negative. </TD></TR>
<TR> <TD align=left> 
<tt>op_pro_invoke(... )</tt>
</TD> <TD align=left>
Dynamically created modules do not need to be invoked, they
live their own life. To dispatch messages to them, you can use <tt>sendDirect(... )</tt></TD></TR>
<TR> <TD align=left> 
<pre>
op_pro_destroy(... )
op_pro_destroy( self )
</pre>
</TD> <TD align=left>
<pre>
deleteModule( module );
deleteModule();
</pre>
</TD></TR>
<TR> <TD align=left> 
module memory, parent-to-child memory, argument memory to dynamic processes
</TD> <TD align=left>
 Parent module can set pointers (void* data members) in the dynamically
created module object any time, thus also right after creating
it ( parent-to-child memory), right before sending a packet to it
( argument memory), and the pointer can refer to memory managed
by the parent module ( module memory).  <br>
An example for argument memory. Suppose the child module class
has a public data member named argmem:
<pre>
class ChildModule :
        public cSimpleModule {
  ...
  public
  void *argmem;
  ...
};
</pre>

<p>The parent module code would be:
<pre>
childmod-&gt;argmem = argument_memory_ptr;
sendDirect( msg, childmod, 0.0, "in" );
</pre>
Child module code would be:
<pre>
msg = receive();
argument_memory_ptr = argmem;
</pre>
</TD></TR>
<TR> <TD align=left> 
<tt>op_pro_valid(... )</tt>
</TD> <TD align=left>
Given the module id:
<pre>
int valid = (id&gt;=0) </TD> <TD align=left></TD> <TD align=left>
            simulation.exist(id);
</pre>
</TD></TR>
<TR> <TD align=left> 
<fontmaroon><em> Unknown LaTeX command </em> \mc </font>2<fontmaroon><em>  </em>  </font>c</TD></TR>
<TR> <TD align=left> 
Environment files
</TD> <TD align=left>
Configuration files. Default is <tt>omnetpp.ini</tt>. Multiple ini files
and ini file inclusion are also supported.</TD></TR>
<TR> <TD align=left> 
Process Editor </TD> <TD align=left> Your favourite text editor. Or <EM>vi</EM> :-).</TD></TR>
<TR> <TD align=left> 
Network Editor, Node Editor
</TD> <TD align=left>
 Any editor to write NED files. <br>
GNED. Not very sophisticated yet though. </TD></TR>
<TR> <TD align=left> 
Simulation Tool </TD> <TD align=left>
 Use the <tt>[Run 1]</tt>, <tt>[Run 2]</tt> etc. sections
in <tt>omnetpp.ini</tt> do describe several runs with different
parameters. <br>
To create loops on different variables, you can use a shell script
that creates a short ini file with the variable parameters, and
include that file in <tt>omnetpp.ini</tt>. </TD></TR>
<TR> <TD align=left> 
probes, Probe Editor </TD> <TD align=left>
From the ini file, you can turn on/off <tt>cOutVector</tt> objects individually
as well as assign result collection interval to them. </TD></TR>
<TR> <TD align=left> 
Analysis Tool </TD> <TD align=left>  Plove </TD></TR>
<TR> <TD align=left> 
EMA </TD> <TD align=left>
 Where you would normally use EMA, OMNeT++ NED files with parameterized
topology are often enough. <br>
 Otherwise, you have two choices: <br>
 a) write a program to generate NED files. Text-processing languages
like <tt>perl</tt> and <tt>awk</tt> are great tools for that. <br>
b) write the network-building code in C++. You can look at the
output of nedc for some idea how to do it.</TD></TR>
</table>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb  4 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec352"/>14. <FONTgreen>PARSEC and OMNeT++</FONT></H1></font></hr>
<a name="cha:parsec-and-omnet"/>

<p>
<hr><font color="#006f00"><H2><A NAME="sec353"/>14.1. <FONTblue>What is PARSEC?</FONT></H2></font></hr>

<p>PARSEC is a very successful simulation language, with
strong support for parallel simulation. PARSEC bears some similarity
to OMNeT++ in that it is also based on threads and coroutines. The
language and the software has been developed at the Parallel Computing
Laboratory of the University of California at Los Angeles (UCLA),
under the leadership of Prof. Rajive Bagrodia. PARSEC has been used in
a number of simulation projects, for example in simulation of mobile
radio networks in a military environment.

<p>
It is best to quote the PARSEC User Manual, Release 1.1 (August
1998):

<p>
<EM>PARSEC (for PARallel Simulation Environment for Complex
  programs) is a C-based discrete event simulation language. It adopts
  the process interaction approach to discrete event simulation. An
  object (also referred to as a physical process) or a set of objects
  in the physical system is represented by a logical process</EM> [a
thread - roughly equivalent to an OMNeT++ simple module
-Andras]<EM>. Interactions among physical processes (events) are
  modeled by timestamped message exchanges among the corresponding
  logical  processes.<br>
  One of the important distinguishing features of PARSEC is its
  ability to execute a discrete-event simulation model using several
  different asynchronous parallel simulation protocols on a variety of
  parallel architectures. [...] Thus, with few modifications, a PARSEC
  program may be executed using the traditional sequential (Global
  Event List) simulation protocol or one of many parallel
  [...] protocols.<br>
  In addition, PARSEC provides powerful message receiving constructs
  that result in shorter and more natural simulation programs.
  [...]<br>
  The PARSEC language has been derived from the Maisie language, but
  with several improvements, both in the syntax of the language
  and in its execution environment.</EM>

<p>The PARSEC web site is at <a href="http://pcl.cs.ucla.edu/">http://pcl.cs.ucla.edu/</a>.

<p>
PARSEC is <STRONG><EM>not</EM></STRONG> open source. It seems that the source code
is only available to research collaborators.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec354"/>14.2. <FONTblue>What is inside the PARSEC package?</FONT></H2></font></hr>

<p>When you download and install the PARSEC distribution, basically
you find:
<UL>
<li><strong></strong>pcc (the PARSEC compiler), and
<li><strong></strong>2 variants of the PARSEC runtime library
</UL>

<p>
This shows that PARSEC is strictly a simulation (and parallel
programming) language which is restricted to the area of entities,
messages, and the tasks centered around message sending and receiving.
It is difficult to compare to OMNeT++ which is more of a complete
simulation environment. (The OMNeT++ simulation library alone
covers a much wider range of functionality than PARSEC as a whole.)

<p>
The primary strength of PARSEC is its parallel simulation support.
The manual only describes conservative PDES, but optimistic algorithms
are also supported. However, the distribution of Parallel PARSEC
is limited to research collaborators (personal communication
from Richard A. Meyer, Nov. 2001).

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec355"/>14.3. <FONTblue>PARSEC vs. the OMNeT++ simulation kernel</FONT></H2></font></hr>

<p>This section gives a brief overview of PARSEC, with special attention
to the differences compared to OMNeT++.

<p>PARSEC is compared against the core functionality of the OMNeT++
simulation kernel, that is, message sending/receiving and the
coroutines (<tt>activity()</tt>). Other parts of the OMNeT++ simulation
kernel (e.g. statistics classes) and other parts of the OMNeT++
package have no equivalent in PARSEC.

<p>
<STRONG>Sample PARSEC code</STRONG>

<p>
The PARSEC is a programming language based on C (<EM>not</EM> C++!).
PARSEC programs, in addition to normal C code, contain special
syntactic constructs, so they do not compile as C. One has to
invoke the PARSEC compiler (<tt>pcc</tt>) on the source code in order
to translate it into C code that uses the PARSEC runtime library.

<p>
The main advantage of this solution is that the PARSEC language
is clean and really elegant.

<p>
Let us see a bit of PARSEC code:

<pre>
#include &lt;stdio.h&gt;
...

message job {
   int id;
   int count;
};

message add_to_your_sorc {
   ename id;
};
...

entity driver(int argc, char **argv) {
...
}
</pre>
<p>
<STRONG>Entities and messages</STRONG>

<p>
In the above PARSEC code fragment, two constructs stand out at
once: <tt>message</tt> and <tt>entity</tt>.

<p>The <tt>message</tt> constructs define message types, and they are translated
to C structs by pcc.

<p>
Entities correspond to OMNeT++'s simple modules.
(PARSEC has no equivalent of OMNeT++'s compound
modules.) The body of the entity contains the algorithm. Entities are
implemented with coroutines or threads much like OMNeT++'s
<tt>activity()</tt>-based simple modules; the
entity body is equivalent to the <tt>activity()</tt> function.  (PARSEC
has no equivalent of <tt>handleMessage()</tt>-based
simple modules.)

<p>
<tt>ename</tt> is a data type that holds entity references.

<p>
<STRONG>Problems with splitting up the entity body</STRONG>

<p>
During programming, the code of an entity may become so large
that it is no longer feasible to keep it within a single function
body. In OMNeT++ you can solve the problem by distributing the
simple module class's <tt>activity()</tt> code into new member functions
which are called from <tt>activity()</tt>, and moving the some local variables
of <tt>activity()</tt> into the module class so that they can also be
accessed by the new member functions.

<p>The above approach doesn't work in PARSEC, because PARSEC is
C-based and entities are not C++ classes. Of course one may call
ordinary C functions from the entity body, but the necessary
parameters must be passed in the argument list (or as pointers
to data structures).

<p>Another solution in PARSEC is to use a construct called <EM>friend</EM> <EM>functions</EM>
(not to be confused with C++ friend functions). PARSEC's friend
functions may access the local variables of the entity (quite
strange in C, but much like an inner procedure in Pascal...).
However, the PARSEC documentation does not recommend using friend
functions (they are slow); it says they are provided for Maisie
compatibility.

<p>
<STRONG>The driver entity</STRONG>

<p>
The driver entity is special; in a way it is similar to the C <tt>main()</tt>
function. PARSEC starts the simulation by creating and running
a driver entity. The main task of the driver is to create all
other entities in the simulation and provide them with information
they need (parameter values, etc). The latter is done by sending
out messages with the necessary parameters to all entities that
need it.

<p>
PARSEC does not have a high-level topology description language
like NED in OMNeT++; instead, the driver entity is hand-coded
most of the time. (There was no mention of tools that could generate
the driver entity based on some higher-level description.).

<p>
OMNeT++ compound modules have no equivalent in PARSEC. All entities are
at the same level, there's no way to express hierarchy.

<p>
PARSEC has no notion of module gates, and there are no connections
(in the OMNeT++ sense) among the entities. This means that when
sending messages, the receiving entity must be explicitly named.
Since the program contains no explicit topology information,
an entity initially has no information about its communication
partners (it knows no enames except its own). The usual practice
is that the driver entity sends the necessary enames in an initialization
message to each entity. (For illustration, see the add_to_your_sorc
message type from the above code fragment. The message name itself
is quite descriptive.)

<p>The consequence of the lack of compound modules and module gates is
that it is a complicated and tricky task to set up networks with but
the most trivial topology. It is also very difficult to write reusable
simulation components without well-defined interfaces and structuring
(compound modules).

<p>
<STRONG>C++ syntax not allowed</STRONG>

<p>
It is not possible to use <EM>any</EM> C++ constructs in PARSEC programs.
This means it is also impossible to use any C++ class libraries
in PARSEC programs; only C libraries can be used.

<p>This limitation comes from pcc itself: the parser inside pcc
is written for C, and as such, it cannot parse C++ syntax. It
is irrelevant whether you use a C or C++ compiler to compile
pcc's output. One exception is that pcc accepts //-style comments.

<p>
<STRONG>Message sending</STRONG>

<p>
Messages can be sent to other entities with the <EM>send</EM> construct:

<p><pre>
<STRONG>send</STRONG> <EM>message</EM> <STRONG>to</STRONG> <EM>dest-entity</EM> <STRONG>after</STRONG> <EM>delay</EM>;
</pre>

<p>For example, creating a new message of type Request with the
parameters 10 and self (the current entity) and sending it to entity2
entity after a delay looks like this:

<p><pre>
<STRONG>send</STRONG> Request{10,<STRONG>self</STRONG>} <STRONG>to</STRONG> entity2 <STRONG>after</STRONG> 5;
</pre>

<p>This PARSEC construct is totally equivalent in functionality
to OMNeT++'s sendDirect( <EM>message</EM>, <EM>delay</EM>, <EM>dest</EM>-<EM>module</EM> [,<EM>dest</EM>-<EM>gate</EM>])
call. Since PARSEC has no equivalent of OMNeT++ gates, OMNeT++'s
other <tt>send()</tt> functions which send messages through a gate are
not present in PARSEC.

<p>
<STRONG>Message receiving constructs </STRONG>

<p>
PARSEC entities accept messages with the <EM>receive</EM> construct. <EM>Receive</EM>
has many forms: the elegance and power of the PARSEC language
stems from the <EM>receive</EM> construct. Some illustrative examples:

<p><pre>
<STRONG>receive</STRONG> (Request req) {
...
} <STRONG>or</STRONG> <STRONG>receive</STRONG> (Release rel) {<br>
...
} <STRONG>or</STRONG> <STRONG>timeout</STRONG> <STRONG>in</STRONG> (5) { /*"<STRONG>in</STRONG>": timeout with high priority*/
...
}
</pre>

<p>
It is possible to add guards to the receive branches:

<p><pre>
<STRONG>receive</STRONG> (Request req) <STRONG>when</STRONG> (req.units&lt;=units) {
...
} <STRONG>or</STRONG> <STRONG>timeout</STRONG> <STRONG>after</STRONG> (5) { /*"<STRONG>after</STRONG>": timeout with low priority*/
...
}
</pre>

<p>
These constructs have to be explicitly programmed in OMNeT++
using while loops with <tt>receive()</tt> calls and if/switch statements
in its body. The reason OMNeT++ doesn't have this sort of syntax
and functionality is that it is impossible to express with plain
C/C++: one cannot avoid the need for a special precompiler. Having
to use a precompiler, however, causes some inconvenience during
program development, and in practice, there isn't as much need
for this sort of complex receive constructs that would justify
making it mandatory to use a precompiler for every source file.

<p>
One may wonder what happens to the messages which have arrived
already but have not been accepted by the entity yet because
they had no matching <EM>receive</EM> branch. PARSEC stores those
messages in what it calls the <EM>message buffer</EM> of the entity.
PARSEC's message buffer is practically the same as the put-aside
queue in OMNeT++.

<p><p>
Guards may contain the special expressions
<tt>qhead(<EM>msgtype</tt>)</EM>,
<tt>qempty(<EM>msgtype</tt>)</EM>,
<tt>qlength(<EM>msg\-type</tt>)</EM> which refer to the
messages in the message buffer. The programmer perceives as if each
message type had a separate message buffer:
</p>

<pre>
receive (Request req) when (qhead(Request).units&lt;=units);
receive (Request req) when (qempty(Release) && req.units&lt;=units);
</pre>
<p>

<p>Note that the <tt>qhead()</tt>, <tt>qempty()</tt> and <tt>qlength()</tt>
operations seem to be all you can do with the message buffer, while in
OMNeT++ you have free access to the put-aside queue through the
<tt>cQueue</tt> member functions.

<p>PARSEC also has a <EM>hold</EM> statement which is functionally equivalent
to OMNeT++'s <tt>wait()</tt>:

<pre>
hold(5);
</pre>
<p>
<STRONG>Cancelling messages</STRONG>

<p>
PARSEC has no support for cancelling messages, that is, there
is no equivalent to OMNeT++'s <tt>cancelEvent()</tt> method. The reason
is probably that message cancellation is difficult to handle
in certain parallel simulation algorithms. However, this doesn't
relieve the pain that such functionality would often be needed
in practice (e.g. when implementing timeouts).

<p>
The PARSEC team recommends various workarounds like keeping a
list of valid (or cancelled) timers and checking messages against
that.

<p>
<STRONG>Simulation clock</STRONG>

<p>
The PARSEC simulation clock is of integer type: optionally, unsigned
int or long long (long long is <EM>not</EM> a standard ANSI C/C++ type).
The time unit is not specified by PARSEC: 1 may mean 1 nanosecond,
1 second or 1 hour. OMNeT++ uses double, with the time value
to be interpreted as seconds.

<p>It is probably application-specific which is the better choice,
but in the case of a large simulation model put together from
components written with different time granularity in mind, double
seems a better choice because it is relatively insensitive to
the choice of the time unit.

<p>
<STRONG>Random number generation</STRONG>

<p>
PARSEC provides platform-independent random number generators
via the <tt>pc_erand()</tt>, <tt>pc_nrand()</tt>, etc. library functions.

<p>
<STRONG>Thread/coroutine handling</STRONG>

<p>
Symbol names in the PARSEC runtime library give the impression
that the thread/coroutine implementation is quite similar in
OMNeT++ and the single-processor implementation of PARSEC. Both
simulators use a setjmp/longjmp-based coroutine library. (Although
it's possible that future versions of OMNeT++ will use the Fibers
API on Win32 platforms.)

<p>
The worst problem with coroutines/threads is that if you create
too many of them, you'll need a lot of memory. With the current
engineering workstations, it is practically impossible to create
more than a few times ten thousand entities in PARSEC (this is
requires a few hundred megabytes of memory).

<p>It is possible to specify coroutine stack sizes in both PARSEC
and OMNeT++. One advantage of OMNeT++ is that it can measure
how much stack space a module actually uses during its operation
(<tt>stackUsage()</tt> function), so it is relatively easy to find the
optimal stack size. In PARSEC, this can only be done by trial
and error (if the program crashes, a stack size was too small).

<p>If memory requirements would grow too high due to the large number
of coroutines, in OMNeT++ it is possible to rewrite modules to
use <tt>handleMessage()</tt>, thus eliminating the need for a separate
coroutine stack. PARSEC has no equivalent of <tt>handleMessage()</tt>,
so coroutine stacks cannot be eliminated.

<p>
<STRONG>Comparison of PARSEC and OMNeT++ as parallel simulation tools</STRONG>

<p>
PARSEC was created to be a parallel simulation (and parallel
programming) language. It provides strong support for a wide
range of conservative and optimistic PDES algorithms.

<p>
In contrast, OMNeT++ was created to be a generic simulation package,
and as such, it offers <EM>some</EM> support for conservative PDES
and Statistical Synchronization.

<p>
PARSEC runs on both shared memory multiprocessors and distributed
memory systems. On a multiprocessor, NT native threads are used
on Win32 platforms and the pthread library on Unix systems. MPI
is used for communication between nodes on a distributed memory
system.

<p>
OMNeT++ only supports distributed memory systems, using PVM or
MPI for communication.

<p>Only the sequential version of PARSEC is available for the public;
the distribution of Parallel PARSEC is limited to research collaborators.

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec356"/>14.4. <FONTblue>Feature summary</FONT></H2></font></hr>

<p>
<table border>
<TR> <TD align=left>

<STRONG>Feature</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG> </TD> <TD align=left> <STRONG>PARSEC</STRONG></TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>3<fontmaroon><em>  </em>  </font>|c|<STRONG><EM>Programs, components:</EM></STRONG></TD></TR>
<TR> <TD align=left> graphical model editor </TD> <TD align=left> GNED </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> result analysis/plotting </TD> <TD align=left> Plove </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> interactive execution, tracing </TD> <TD align=left> Tkenv </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> parameter file </TD> <TD align=left> omnetpp.ini </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> random numbers support </TD> <TD align=left> Seedtool </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>3<fontmaroon><em>  </em>  </font>|c|<STRONG><EM>Model structure</EM></STRONG> </TD></TR>
<TR> <TD align=left> encapsulation/ grouping </TD> <TD align=left> compound modules </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> connections </TD> <TD align=left> yes (optionally: delay, data rate, bit error rate) </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> topology description </TD> <TD align=left> via NED, nedc </TD> <TD align=left> - (manually from the driver entity) </TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>3<fontmaroon><em>  </em>  </font>|c|<STRONG><EM>Simulation methodology</EM></STRONG> </TD></TR>
<TR> <TD align=left> Precompiler </TD> <TD align=left> - (no need, code is standard C++) </TD> <TD align=left> pcc (PARSEC compiler) </TD></TR>
<TR> <TD align=left> C++ support </TD> <TD align=left> based on C++ </TD> <TD align=left> - (language based on C) </TD></TR>
<TR> <TD align=left> alternative to coroutines/threads </TD> <TD align=left> handleMessage() </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> complex message receiving constructs </TD> <TD align=left> - (timeout only) </TD> <TD align=left> yes: filter by message type, timeout, guards, etc. </TD></TR>
<TR> <TD align=left> message types </TD> <TD align=left> via subclassing <tt>cMessage</tt> or via <tt>cMessage</tt> + pars </TD> <TD align=left> via the message construct </TD></TR>
<TR> <TD align=left> module gates, sending via gates </TD> <TD align=left> yes </TD> <TD align=left> - (direct sending only) </TD></TR>
<TR> <TD align=left> module parameters </TD> <TD align=left> yes </TD> <TD align=left> -</TD></TR>
<TR> <TD align=left> dynamic module (entity) creation </TD> <TD align=left> yes (also compound modules) </TD> <TD align=left> yes </TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>3<fontmaroon><em>  </em>  </font>|c|<STRONG><EM>Simulation library</EM></STRONG> </TD></TR>
<TR> <TD align=left> statistics/histogram classes </TD> <TD align=left> yes (<tt>cStdDev</tt>, 3 histogram classes, $P^22$ , k-split) </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> routing support </TD> <TD align=left> yes (<tt>cTopology</tt>) </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> FSM support </TD> <TD align=left> yes (FSM macros) </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> support for output files </TD> <TD align=left> yes (<tt>cOutVector</tt>, recordScalar(),...) </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> container classes </TD> <TD align=left> yes (<tt>cQueue</tt>, <tt>cArray</tt>,...) </TD> <TD align=left> - </TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mc </font>3<fontmaroon><em>  </em>  </font>|c|<STRONG><EM>Parallel simulation</EM></STRONG> </TD></TR>
<TR> <TD align=left> conservative </TD> <TD align=left> yes </TD> <TD align=left> yes</TD></TR>
<TR> <TD align=left> optimistic </TD> <TD align=left> - </TD> <TD align=left> yes </TD></TR>
<TR> <TD align=left> statistical synchronization </TD> <TD align=left> yes </TD> <TD align=left> possible, but no support</TD></TR>
</table>

<p>

<p>

<p>

<p><hr><font color="#006f00"><H2><A NAME="sec357"/>14.5. <FONTblue>Correspondence between PARSEC and OMNeT++</FONT></H2></font></hr>

<p>
<table border>
<TR> <TD align=left>

<STRONG>PARSEC</STRONG> </TD> <TD align=left> <STRONG>OMNeT++</STRONG></TD></TR>
<TR> <TD align=left>
entity </TD> <TD align=left> simple module (<tt>cSimpleModule</tt>)</TD></TR>
<TR> <TD align=left> message </TD> <TD align=left> message (<tt>cMessage</tt>, <tt>cPacket</tt>,...)</TD></TR>
<TR> <TD align=left> message buffer of the entity </TD> <TD align=left> put-aside queue</TD></TR>
<TR> <TD align=left> send <EM>message</EM> to <EM>entity</EM> after <EM>delay</EM> </TD> <TD align=left>
<tt>sendDirect( <EM>message</EM>, <EM>delay</EM>, <EM>module</EM> [,<EM>destgate</EM>])</tt></TD></TR>
<TR> <TD align=left> send <EM>message</EM> to self after <EM>delay</EM>
</TD> <TD align=left>
<tt>scheduleAt( <EM>message</EM>, simTime()+<EM>delay</EM>)</tt></TD></TR>
<TR> <TD align=left> <fontmaroon><em> Unknown LaTeX command </em> \mbox </font>n/a<fontmaroon><em>  </em>  </font> <br>
(PARSEC has no equivalent of OMNeT++ gates)
</TD> <TD align=left>
<tt>send(<EM>message</EM>,<EM>gate</EM>)</tt> <br>
<tt>sendDelayed(<EM>message</EM>,<EM>gate</EM>,<EM>delay</EM>)</tt></TD></TR>
<TR> <TD align=left> hold( <EM>delay</EM> ) </TD> <TD align=left> <tt>wait(<EM>delay</EM>)</tt></TD></TR>
<TR> <TD align=left> receive (<EM>msgtype</EM> <EM>msg</EM>) {... } </TD> <TD align=left> <tt><EM>msg</EM> = receive()</tt></TD></TR>
<TR> <TD align=left>  receive (<EM>msgtype</EM> <EM>msg</EM>) {... }</TD></TR>
<TR> <TD align=left> or timeout after (<EM>delay</EM>) {... }
</TD> <TD align=left>
<tt><EM>msg =</EM> receive( <EM>delay</EM> )</tt></TD></TR>
<TR> <TD align=left> more complex <EM>receive</EM> constructs </TD> <TD align=left> <tt>while { <EM>msg=</EM>receive()<EM>;</EM> if (...)... }</tt></TD></TR>
</table>

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb  9 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>
<hr><font color="#006f00"><H1><A NAME="sec358"/>15. <FONTgreen>NED Language Grammar</FONT></H1></font></hr>
<a name="cha:ned-language-grammar"/>

<p>The NED language, the network topology description language of
OMNeT++ will be given using the extended BNF notation.

<p>Space, horizontal tab and new line characters counts as delimiters,
so one or more of them is required between two elements of the
description which would otherwise be unseparable. '//' (two slashes)
may be used to write comments that last to the end of the line.
The language only distinguishes between lower and upper case
letters in names, but not in keywords.

<p>
In this description, the {xxx...} notation stands for one or
more xxx's separated with spaces, tabs or new line characters,
and {xxx,,,} stands for one or more xxx's, separated with a
comma and (optionally) spaces, tabs or new line characters.

<p>
For ease of reading, in some cases we use textual definitions.
The <EM>networkdescription</EM> symbol is the sentence symbol of the
grammar.

<p>
<pre>
        <STRONG>notation    meaning</STRONG>
        [a]         0 or 1 time a
        {a}         a
        {a,,,}      1 or more times a, separated by commas
        {a...}      1 or more times a, separated by spaces
        a|b         a or b
        `a'         the character a
        <STRONG>bold</STRONG>        keyword
        <EM>italic</EM>      identifier

<p>
networkdescription ::=
    { definition... }

<p>definition    ::=
      include
    | channeldefinition
    | simpledefinition
    | moduledefinition
    | networkdefinition

<p>include ::=
    <STRONG>INCLUDE</STRONG> { fileName ,,, } ;

<p>channeldefinition ::=
    <STRONG>CHANNEL</STRONG> <EM>channeltype</EM>
     [ <STRONG>DELAY</STRONG> numericvalue ]
     [ <STRONG>ERROR</STRONG> numericvalue ]
     [ <STRONG>DATARATE</STRONG> numericvalue ] <sup>******</sup>
    <STRONG>ENDCHANNEL</STRONG>

<p>simpledefinition ::=
    <STRONG>SIMPLE</STRONG> <EM>simplemoduletype</EM>
     [ machineblock ]
     [ paramblock ]
     [ gateblock ]
    <STRONG>ENDSIMPLE</STRONG> [ <EM>simplemoduletype</EM> ]

<p>moduledefinition ::=
    <STRONG>MODULE</STRONG> <EM>compoundmoduletype</EM>
     [ machineblock<sup>*</sup> ]
     [ paramblock ]
     [ gateblock ]
     [ submodblock ]
     [ connblock ]
    <STRONG>ENDMODULE</STRONG> [ <EM>compoundmoduletype</EM> ]

<p>moduletype ::=
    <EM>simplemoduletype</EM> | <EM>compoundmoduletype</EM>

<p>machineblock ::=
    <STRONG>MACHINES:</STRONG> { <EM>machine</EM> ,,, } ;

<p>paramblock ::=
    <STRONG>PARAMETERS:</STRONG> { parameter ,,, } ;

<p>parameter ::=
    <EM>parametername</EM>
    | <EM>parametername</EM> : <STRONG>CONST</STRONG> [ <STRONG>NUMERIC</STRONG> ]
    | <EM>parametername</EM> <STRONG>: STRING</STRONG>
    | <EM>parametername</EM> <STRONG>: BOOL</STRONG>
    | <EM>parametername</EM> <STRONG>: CHAR</STRONG>
    | <EM>parametername</EM> <STRONG>: ANYTYPE</STRONG>

<p>gateblock ::=
    <STRONG>GATES:</STRONG>
     [ <STRONG>IN:</STRONG> { gate ,,, } ; ]
     [ <STRONG>OUT:</STRONG> { gate ,,, } ; ]
gate ::=
    <EM>gatename</EM> [ '[]' ]

<p>submodblock ::=
    <STRONG>SUBMODULES:</STRONG> { submodule... }

<p>submodule ::=
    { <EM>submodulename</EM> : <EM>moduletype</EM> [ vector ]
     [ on_block<sup>*</sup>... ]
     [ substparamblock... ]
     [ gatesizeblock... ] }
  | { <EM>submodulename</EM> : <EM>parametername</EM> [ vector ] <STRONG>LIKE</STRONG> <EM>moduletype</EM>
     [ on_block<sup>*</sup>... ]
     [ substparamblock... ]
     [ gatesizeblock... ] }

<p>on_block<sup>*</sup> ::=
    <STRONG>ON</STRONG> [ <STRONG>IF</STRONG> expression ]<STRONG>:</STRONG> { <EM>on_machine</EM> ,,, } ;

<p>substparamblock    ::=
    <STRONG>PARAMETERS</STRONG> [ <STRONG>IF</STRONG> expression ]<STRONG>:</STRONG>
      { <EM>substparamname</EM> = substparamvalue,,, } ;

<p>substparamvalue ::=
    ( [ <STRONG>ANCESTOR</STRONG> ] [ <STRONG>REF</STRONG> ] <EM>name</EM> )
    | parexpression

<p>gatesizeblock ::=
    <STRONG>GATESIZES</STRONG> [ <STRONG>IF</STRONG> expression ]<STRONG>:</STRONG>
      { <EM>gatename</EM> vector ,,, } ;

<p>connblock ::=
    <STRONG>CONNECTIONS</STRONG> [ <STRONG>NOCHECK</STRONG> ]<STRONG>:</STRONG> { connection ,,, } ;

<p>connection ::=
     normalconnection | loopconnection

<p>loopconnection ::=
    <STRONG>FOR</STRONG> { index... } <STRONG>DO</STRONG>
      { normalconnection ,,, } ;
    <STRONG>ENDFOR</STRONG>

<p>index ::=
    <EM>indexvariable</EM> '=' expression ``...'' expression

<p>normalconnection ::=
     { gate { -&gt; | &lt;- } gate [ <STRONG>IF</STRONG> expression ]}
   | {gate -&gt; channel -&gt; gate [ <STRONG>IF</STRONG> expression ]}
   | {gate &lt;- channel &lt;- gate [ <STRONG>IF</STRONG> expression ]}

<p>channel ::=
     <EM>channeltype</EM>
    | [ <STRONG>DELAY</STRONG> expression ] [ <STRONG>ERROR</STRONG> expression ] [ <STRONG>DATARATE</STRONG> expression ]
        <sup>******</sup>

<p>gate ::=
    [ <EM>modulename</EM> [vector]. ] <EM>gatename</EM> [vector]

<p>networkdefinition ::=
    <STRONG>NETWORK</STRONG> <EM>networkname</EM> : <EM>moduletype</EM>
     [ on_block ]
     [ substparamblock ]
    <STRONG>ENDNETWORK</STRONG>

<p>vector ::=    '[' expression ']'

<p>parexpression ::=
    expression | otherconstvalue

<p>expression    ::=
      expression + expression
    | expression - expression
    | expression * expression
    | expression / expression
    | expression  0.000000e+000xpression
    | expression ^ expression
    | expression == expression
    | expression != expression
    | expression <SAMP>&lt;</SAMP> expression
    | expression <SAMP>&lt;</SAMP>= expression
    | expression <SAMP>&gt;</SAMP> expression
    | expression <SAMP>&gt;</SAMP>= expression
    | expression ? expression : expression
    | expression <STRONG>AND</STRONG> expression
    | expression <STRONG>OR</STRONG> expression
    | <STRONG>NOT</STRONG> expression
    | '(' expression ')'
    | <EM>functionname</EM> '(' [ expression ,,, ] ')' <sup>***</sup>
    | - expression
    | numconstvalue
    | inputvalue
    | [ <STRONG>ANCESTOR</STRONG> ] [ <STRONG>REF</STRONG> ] <EM>parametername</EM>
    | <STRONG>SIZEOF</STRONG><sup>****</sup> '(' <EM>gatename</EM> ')'
    | <STRONG>INDEX</STRONG><sup>*****</sup>

<p>numconstvalue ::=
    <EM>integerconstant</EM> | <EM>realconstant</EM> | <EM>timeconstant</EM>

<p>otherconstvalue ::=
      '<EM>characterconstant'</EM>
    | ''<EM>stringconstant</EM>''
    | <STRONG>TRUE</STRONG>
    | <STRONG>FALSE</STRONG>

<p>inputvalue ::=
    <STRONG>INPUT</STRONG> '(' default , ''<EM>prompt-string''</EM> ')'

<p>default ::=
    expression | otherconstvalue
</pre>

<p>
<sup>*</sup> used with distributed execution

<p>
<sup>**</sup> used with the statistical synchronization method<br>
<sup>***</sup> max. three arguments. The function name must be declared
in the C++ sources with the Define_Function macro.<br>
<sup>****</sup> Size of a vector gate.<br>
<sup>*****</sup> Index in submodule vector.<br>
<sup>******</sup> Can appear in any order.

<p>

<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb  3 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>
Unnamed Web page
</TITLE>
</HEAD>
<BODY>

<hr><font color="#006f00"><H1><A NAME="sec359"/>16. <FONTgreen>References</FONT></H1></font></hr>
<a name="cha:references"/>

<p><STRONG>Simulation-related</STRONG>

<p>
[JAIN91]  Jain, Raj: <EM>The Art of Computer Systems Performance
Analysis</EM>. Wiley, New York, 1991.

<p>[BFS86]  Bratley P., Fox, B. L. and Schrage, L. E.: <EM>A Guide
to Simulation</EM>. Springer-Verlag, New York, 1986.

<p>[JCH85]  Jain, Raj and Chlamtac, Imrich: <EM>The P</EM><sup><i>2</i></sup> <EM>Algorithm
for Dynamic Calculation of Quantiles and Histograms without Storing
Observations</EM>, Communications of the ACM, 28(10), 1076-1085, 1985.

<p>[PON91]  Pongor, Gy\"orgy: <EM>OMNET: An Object-Oriented Network
Simulator</EM>. 1991

<p>[PON92]  Pongor, Gy\"orgy: <EM>Statistical Synchronization: A Different
Approach of Parallel Discrete Event Simulation</EM>. Lappeenranta
University of Technology, Data Communications Laboratory, Lappeenranta,
Finland, 1992

<p>[PON93]  Pongor, Gy\"orgy: <EM>On the Efficiency of the Statistical
Synchronization Method</EM>. European Simulation Symposium (ESS'93),
Delft, The Netherlands, Oct. 25-28, 1993

<p>[KOF95]  Kofoed, Stig: <EM>Portable Multitasking in C++</EM>. Dr. Dobb's
Journal, November 1995. <a href="ftp://ftp.mv.com/pub/ddj/1995/1995.11/mtask.zip">ftp://ftp.mv.com/pub/ddj/1995/1995.11/mtask.zip</a>


<STRONG>OMNeT++-related research papers</STRONG>

<p>
[VAR99]  <EM>''Using the OMNeT++ Discrete Event Simulation
System in Education''</EM>. Andr\'as Varga. IEEE Transactions
on Education, November 1999 CD-ROM issue; abstract in vol. 42,
no. 4, pp. 372, November 1999.

<p>[VAR98a]  <EM>''K-split - On-Line Density Estimation for
Simulation Result Collection''</EM>. Andr\'as Varga. In the
Proceedings of the European Simulation Symposium (ESS'98). October
26-28, 1998. Nottingham, UK.

<p>[VAR98b]  <EM>''Parameterized Topologies for Simulation Programs''</EM>.
Andr\'as Varga. In the Proceedings of the Western Multiconference
on Simulation (WMC'98) / Communication Networks and Distributed
Systems (CNDS'98). January 11-14, 1998. San Diego, CA.

<p>[V&amp;F97]  <EM>''The K-Split Algorithm for the PDF Approximation
of Multi-Dimensional Empirical Distributions without Storing
Observations''</EM>. Andr\'as Varga and Babak Fakhamzadeh. In
Proceedings of the 9th European Simulation Symposium (ESS'97),
pp.94-98. October 19-22 1997, Passau, Germany.

<p>[V&amp;P97]  <EM>''Flexible Topology Description Language for
Simulation Programs''</EM>. Andr\'as Varga and Gy\"orgy Pongor.
In Proceedings of the 9th European Simulation Symposium (ESS'97),
pp.225-229. October 19-22 1997, Passau, Germany.

<p>
<STRONG>Former OMNeT++ documents</STRONG>

<p>
[OMN1]  Vass Zolt\'an.: <EM>PVM Extension of OMNeT++ to Support
Statistical Synchronization</EM>. Diploma Thesis, Technical University
of Budapest, 1996 (in Hungarian).

<p>[OMN2]  Andr\'e Maurits, George van Montfort and Gerard van de
Weerd: <EM>OMNeT++ extensions and examples</EM>. Technical University
of Budapest, Dept. of Telecommunications, 1995.

<p>[OMN3]  Jan Heijmans, Alex Paalvast, Robert van der Leij: <EM>Network
simulation using the JAR compiler for the OMNeT++ simulation
system</EM>. Technical University of Budapest, Dept. of Telecommunications,
1995.

<p>[OMN4]  Varga Andr\'as.: <EM>OMNeT++ - Portable User Interface
for the OMNeT++ Simulation System</EM>. Diploma Thesis, Technical
University of Budapest, 1994 (in Hungarian).

<p>[OMN5]  Lencse G\'abor: <EM>Graphical Network Editor for OMNeT++</EM>.
Diploma Thesis, Technical University of Budapest, 1994 (in Hungarian).

<p>[OMN6]  Varga Andr\'as.: <EM>OMNeT++ - Portable Simulation Environment
in C++</EM>. TDK work, Technical University of Budapest, 1992 (in Hungarian).

<p>
<STRONG>Other simulation software</STRONG>

<p>
See web site

<p>
<STRONG>C++ language</STRONG>

<p>
Too many books to list.

<p>
<STRONG>Cygwin</STRONG>

<p>
[CYGWIN]  <a href="http://sourceware.cygnus.com/cygwin/top.html">http://sourceware.cygnus.com/cygwin/top.html</a>



<p><STRONG>PVM</STRONG>

<p>[PVM1]  The Official PVM Home Page. <a href="http://www.epm.ornl.gov/pvm/pvm_home.html">http://www.epm.ornl.gov/pvm/pvm_home.html</a>

<p>[PVM2]  <a href="http://www.sp2.uni-c.dk/PVM/PvmIntro.html">http://www.sp2.uni-c.dk/PVM/PvmIntro.html</a>

<p>[PVM3]  <a href="http://www.cse.ogi.edu/DISC/projects/mist/related-work/pvm.html">http://www.cse.ogi.edu/DISC/projects/mist/related-work/pvm.html</a>



<p><STRONG>Tcl/Tk</STRONG>

<p>[TCLTK1]  Welch, Brent: <EM>Practical Programming in Tcl and Tk</EM>. Prentice-Hall, 1995



<p><STRONG>Gnuplot</STRONG>

<p>
[GPLOT1]  Brief tutorial:<br>
<a href="http://nacphy.physics.orst.edu/DATAVIS/datavis.html">http://nacphy.physics.orst.edu/DATAVIS/datavis.html</a>

<p>
[GPLOT2]  Reference:<br>
<a href="http://www.cm.cf.ac.uk/Latex/Gnuplot/gnuplot.html">http://www.cm.cf.ac.uk/Latex/Gnuplot/gnuplot.html</a>

<p>
[PMTV1]  PlotMTV:<br>
<a href="http://cauchy.math.edu/workshop/Plotmtv/plotmtv.html">http://cauchy.math.edu/workshop/Plotmtv/plotmtv.html</a>

<p>
<STRONG>Xmgr</STRONG>

<p>[XMGR1]  Brief tutorial:<br>
<a href="http://nacphy.physics.orst.edu/DATAVIS/xmgr.html">http://nacphy.physics.orst.edu/DATAVIS/xmgr.html</a>

<p>
<HR>
<font size=+0><EM>[Converted LaTeX --> HTML by <a href="http://www.best.com/~quong/ltoh.html">ltoh</a>]</EM></font><br>
<ADDRESS>
<A href="http://www.best.com/~quong">Russell W. Quong</A>
(<A href="mailto:quong@best.com"><SAMP>quong@best.com</SAMP></A>)
Last modified: <fontmaroon><samp>Feb 15 2003</samp></font>
(LaTeX doc modified: <fontmaroon><samp>Feb 11 2003</samp></font>)<br>
</ADDRESS>
</BODY>
</HTML>


</BODY>
</HTML>
