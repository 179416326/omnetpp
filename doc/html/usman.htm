<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>OMNeT++ - Manual</TITLE>
   <META NAME="Author" CONTENT="Andras Varga">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFE8" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<P><FONT COLOR="#FF0000"><B><FONT SIZE=+4>OMNeT++ </FONT></B>
<I><FONT SIZE=+1>Discrete Event Simulation System</FONT></I></FONT></P>

<H1><B>User Manual</B></H1><H1>Topics</H1>
<B><A HREF="#TOC_0">Introduction</A></B><BR>
<B><A HREF="#TOC_4">Overview</A></B><BR>
<B><A HREF="#TOC_20">An example: the NIM game</A></B><BR>
<B><A HREF="#TOC_25">The NED language</A></B><BR>
<B><A HREF="#TOC_67">Writing simple modules</A></B><BR>
<B><A HREF="#TOC_143">Compiling and running a simulation</A></B><BR>
<B><A HREF="#TOC_159">Running the simulation</A></B><BR>
<B><A HREF="#TOC_171">User interfaces</A></B><BR>
<B><A HREF="#TOC_183">Analyzing simulation results</A></B><BR>
<B><A HREF="#TOC_193">Debugging and profiling</A></B><BR>
<B><A HREF="#TOC_198">Modelling with OMNeT++</A></B><BR>
<B><A HREF="#TOC_210">Parallel execution</A></B><BR>
<B><A HREF="#TOC_217">Appendix A: Statistical synchronisation</A></B><BR>
<B><A HREF="#TOC_220">Appendix B: Comparison of OPNET and
OMNeT++</A></B><BR>
<B><A HREF="#TOC_221">Appendix C: Quick reference for OPNET
users</A></B><BR>
<B><A HREF="#TOC_222">Appendix D: Embedding OMNeT++</A></B><BR>
<B><A HREF="#TOC_225">Appendix E: Internal structure of
the simulation program</A></B><BR>
<B><A HREF="#TOC_235">References</A></B><BR>
<HR><H1>Detailed Table of Contents</H1>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_0"></A><A HREF="#_Toc443041114">Introduction</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_1"></A><A HREF="#_Toc443041115">What is OMNeT++?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_2"></A><A HREF="#_Toc443041116">About the manual</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_3"></A><A HREF="#_Toc443041117">Authors</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_4"></A><A HREF="#_Toc443041118">Overview</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_5"></A><A HREF="#_Toc443041119">Modelling concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_6"></A><A HREF="#_Toc443041120">Hierarchical modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_7"></A><A HREF="#_Toc443041121">Module types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_8"></A><A HREF="#_Toc443041122">Messages, gates, links</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_9"></A><A HREF="#_Toc443041123">Link characteristics</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_10"></A><A HREF="#_Toc443041124">Parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_11"></A><A HREF="#_Toc443041125">Topology description method</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_12"></A><A HREF="#_Toc443041126">Programming the algorithms</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_13"></A><A HREF="#_Toc443041127">Creating simple modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_14"></A><A HREF="#_Toc443041128">Object mechanisms</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_15"></A><A HREF="#_Toc443041129">Derive new classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_16"></A><A HREF="#_Toc443041130">Self-describing objects to ease debugging</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_17"></A><A HREF="#_Toc443041131">Using OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_18"></A><A HREF="#_Toc443041132">Building and running simulations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_19"></A><A HREF="#_Toc443041133">What is what in the directories</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_20"></A><A HREF="#_Toc443041134">An example: the NIM game</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_21"></A><A HREF="#_Toc443041135">Topology</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_22"></A><A HREF="#_Toc443041136">Simple modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_23"></A><A HREF="#_Toc443041137">Running the simulation</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_24"></A><A HREF="#_Toc443041138">Other examples</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_25"></A><A HREF="#_Toc443041139">The NED language</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_26"></A><A HREF="#_Toc443041140">NED overview</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_27"></A><A HREF="#_Toc443041141">Components of a NED description</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_28"></A><A HREF="#_Toc443041142">Reserved words</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_29"></A><A HREF="#_Toc443041143">Case sensitivity</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_30"></A><A HREF="#_Toc443041144">The import statement</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_31"></A><A HREF="#_Toc443041145">Channel definitions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_32"></A><A HREF="#_Toc443041146">Simple module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_33"></A><A HREF="#_Toc443041147">Simple module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_34"></A><A HREF="#_Toc443041148">Simple module gates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_35"></A><A HREF="#_Toc443041149">Compound module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_36"></A><A HREF="#_Toc443041150">Compound module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_37"></A><A HREF="#_Toc443041151">Compound module gates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_38"></A><A HREF="#_Toc443041152">Submodules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_39"></A><A HREF="#_Toc443041153">Module vector as submodule</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_40"></A><A HREF="#_Toc443041154">Module type as parameter</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_41"></A><A HREF="#_Toc443041155">Submodule parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_42"></A><A HREF="#_Toc443041156">Submodule gate sizes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_43"></A><A HREF="#_Toc443041157">Conditional parameter and gatesize
sections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_44"></A><A HREF="#_Toc443041158">Connections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_45"></A><A HREF="#_Toc443041159">Single connections and channels</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_46"></A><A HREF="#_Toc443041160">Loop connections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_47"></A><A HREF="#_Toc443041161">Conditional connections</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_48"></A><A HREF="#_Toc443041162">The nocheck modifier</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_49"></A><A HREF="#_Toc443041163">Compound module examples</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_50"></A><A HREF="#_Toc443041164">A router module</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_51"></A><A HREF="#_Toc443041165">Parametrized module structures</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_52"></A><A HREF="#_Toc443041166">Using const with parametrized topologies</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_53"></A><A HREF="#_Toc443041167">Network definition</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_54"></A><A HREF="#_Toc443041168">Support for parallel execution</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_55"></A><A HREF="#_Toc443041169">Extensions to the compound module
and system definitions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_56"></A><A HREF="#_Toc443041170">Conditional on: sections</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_57"></A><A HREF="#_Toc443041171">Expressions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_58"></A><A HREF="#_Toc443041172">Using parameters in expressions (ref
and ancestor)</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_59"></A><A HREF="#_Toc443041173">Operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_60"></A><A HREF="#_Toc443041174">The sizeof() and index operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_61"></A><A HREF="#_Toc443041175">Time constants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_62"></A><A HREF="#_Toc443041176">Random values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_63"></A><A HREF="#_Toc443041177">Input value</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_64"></A><A HREF="#_Toc443041178">Functions</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_65"></A><A HREF="#_Toc443041179">A complete NED example</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_66"></A><A HREF="#_Toc443041180">GNED - a graphical topology editor</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_67"></A><A HREF="#_Toc443041181">Writing simple modules</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_68"></A><A HREF="#_Toc443041182">Defining simple module types</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_69"></A><A HREF="#_Toc443041183">Writing a simple module</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_70"></A><A HREF="#_Toc443041184">The simple module class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_71"></A><A HREF="#_Toc443041185">The Define_Module() macro</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_72"></A><A HREF="#_Toc443041186">Decomposing the activity</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_73"></A><A HREF="#_Toc443041187">Writing statistics at the end of the
simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_74"></A><A HREF="#_Toc443041188">Using header files</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_75"></A><A HREF="#_Toc443041189">Several modules with the same interface</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_76"></A><A HREF="#_Toc443041190">About the classes in the simulation
class library</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_77"></A><A HREF="#_Toc443041191">Conventions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_78"></A><A HREF="#_Toc443041192">Warnings and errors</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_79"></A><A HREF="#_Toc443041193">Accessing module parameters and gates</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_80"></A><A HREF="#_Toc443041194">Module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_81"></A><A HREF="#_Toc443041195">Gates and gate vectors</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_82"></A><A HREF="#_Toc443041196">Messages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_83"></A><A HREF="#_Toc443041197">The message class: cMessage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_84"></A><A HREF="#_Toc443041198">Attaching parameters and objects to
a  message</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_85"></A><A HREF="#_Toc443041199">Message encapsulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_86"></A><A HREF="#_Toc443041200">Duplicating messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_87"></A><A HREF="#_Toc443041201">The cPacket class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_88"></A><A HREF="#_Toc443041202">Subclassing cMessage and cPacket</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_89"></A><A HREF="#_Toc443041203">Sending and receiving messages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_90"></A><A HREF="#_Toc443041204">Sending messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_91"></A><A HREF="#_Toc443041205">Delayed sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_92"></A><A HREF="#_Toc443041206">Receiving messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_93"></A><A HREF="#_Toc443041207">The wait() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_94"></A><A HREF="#_Toc443041208">Implementing timers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_95"></A><A HREF="#_Toc443041209">An important note about message sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_96"></A><A HREF="#_Toc443041210">Message transmission time</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_97"></A><A HREF="#_Toc443041211">Stopping the simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_98"></A><A HREF="#_Toc443041212">About scheduling and message execution
order</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_99"></A><A HREF="#_Toc443041213">Generating random numbers</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_100"></A><A HREF="#_Toc443041214">Using random number generators directly</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_101"></A><A HREF="#_Toc443041215">Random numbers from distributions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_102"></A><A HREF="#_Toc443041216">Random numbers from histograms</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_103"></A><A HREF="#_Toc443041217">Container classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_104"></A><A HREF="#_Toc443041218">Queue class: cQueue</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_105"></A><A HREF="#_Toc443041219">Expandable array: cArray</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_106"></A><A HREF="#_Toc443041220">Non-object container classes</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_107"></A><A HREF="#_Toc443041221">The parameter class: cPar</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_108"></A><A HREF="#_Toc443041222">Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_109"></A><A HREF="#_Toc443041223">Random number generation through cPar</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_110"></A><A HREF="#_Toc443041224">Storing object and non-object pointers
in cPar</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_111"></A><A HREF="#_Toc443041225">Reverse Polish expressions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_112"></A><A HREF="#_Toc443041226">Using indirection</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_113"></A><A HREF="#_Toc443041227">Statistics and distribution estimation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_114"></A><A HREF="#_Toc443041228">cStatistic and descendants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_115"></A><A HREF="#_Toc443041229">The k-split algorithm</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_116"></A><A HREF="#_Toc443041230">Transient detection and result accuracy</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_117"></A><A HREF="#_Toc443041231">Recording simulation results</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_118"></A><A HREF="#_Toc443041232">Output vectors: cOutVector</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_119"></A><A HREF="#_Toc443041233">Output scalars</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_120"></A><A HREF="#_Toc443041234">Reaching out of simple modules</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_121"></A><A HREF="#_Toc443041235">Object name strings and numeric identifiers
in the network</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_122"></A><A HREF="#_Toc443041236">Accessing other modules in the network</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_123"></A><A HREF="#_Toc443041237">Dynamic module creation and direct
message sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_124"></A><A HREF="#_Toc443041238">Creating connections</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_125"></A><A HREF="#_Toc443041239">Routing support: cTopology</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_126"></A><A HREF="#_Toc443041240">Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_127"></A><A HREF="#_Toc443041241">Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_128"></A><A HREF="#_Toc443041242">Shortest paths</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_129"></A><A HREF="#_Toc443041243">Deriving new classes</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_130"></A><A HREF="#_Toc443041244">Tracing and debugging aids</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_131"></A><A HREF="#_Toc443041245">Displaying information about module
activity</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_132"></A><A HREF="#_Toc443041246">Watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_133"></A><A HREF="#_Toc443041247">Snapshots</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_134"></A><A HREF="#_Toc443041248">Breakpoints</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_135"></A><A HREF="#_Toc443041249">Choosing the correct stack size</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_136"></A><A HREF="#_Toc443041250">An alternative to activity(): handleMessage()</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_137"></A><A HREF="#_Toc443041251">Motivation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_138"></A><A HREF="#_Toc443041252">The handleMessage() mechanism</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_139"></A><A HREF="#_Toc443041253">Using the FSM macros</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_140"></A><A HREF="#_Toc443041254">Tips for speeding up the simulation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_141"></A><A HREF="#_Toc443041255">Message subclassing</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_142"></A><A HREF="#_Toc443041256">Using shared objects</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_143"></A><A HREF="#_Toc443041257">Compiling and running a simulation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_144"></A><A HREF="#_Toc443041258">Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_145"></A><A HREF="#_Toc443041259">Using Unix and gcc</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_146"></A><A HREF="#_Toc443041260">Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_147"></A><A HREF="#_Toc443041261">Producing a makefile with the makemake
script</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_148"></A><A HREF="#_Toc443041262">Multi-directory models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_149"></A><A HREF="#_Toc443041263">Static vs shared OMNeT++ system libraries</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_150"></A><A HREF="#_Toc443041264">Using DOS and Borland C++ 3.1</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_151"></A><A HREF="#_Toc443041265">Very limited memory...</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_152"></A><A HREF="#_Toc443041266">Building the libraries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_153"></A><A HREF="#_Toc443041267">Setting up a project file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_154"></A><A HREF="#_Toc443041268">Switching to another the user interface</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_155"></A><A HREF="#_Toc443041269">Using Windows 95 or NT and Borland
C++ 5.0</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_156"></A><A HREF="#_Toc443041270">Compiling the libraries and nedc</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_157"></A><A HREF="#_Toc443041271">Setting up a project file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_158"></A><A HREF="#_Toc443041272">Starting from scratch</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_159"></A><A HREF="#_Toc443041273">Running the simulation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_160"></A><A HREF="#_Toc443041274">Command line switches</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_161"></A><A HREF="#_Toc443041275">Configuration file</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_162"></A><A HREF="#_Toc443041276">Sections and entries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_163"></A><A HREF="#_Toc443041277">Splitting the configuration file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_164"></A><A HREF="#_Toc443041278">Module parameters in the configuration
file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_165"></A><A HREF="#_Toc443041279">Configuring result collection</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_166"></A><A HREF="#_Toc443041280">Display strings</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_167"></A><A HREF="#_Toc443041281">Random seeds</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_168"></A><A HREF="#_Toc443041282">Specifying seed values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_169"></A><A HREF="#_Toc443041283">Choosing good seed values: the seedtool
utility</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_170"></A><A HREF="#_Toc443041284">Module parameter logging</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_171"></A><A HREF="#_Toc443041285">User interfaces</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_172"></A><A HREF="#_Toc443041286">Detached user interface implementation</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_173"></A><A HREF="#_Toc443041287">Cmdenv: the command-line user interface</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_174"></A><A HREF="#_Toc443041288">Tkenv: graphical user interface on
Unix/NT</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_175"></A><A HREF="#_Toc443041289">Features</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_176"></A><A HREF="#_Toc443041290">Configuring  Tkenv</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_177"></A><A HREF="#_Toc443041291">Simulation running modes in Tkenv</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_178"></A><A HREF="#_Toc443041292">Inspectors</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_179"></A><A HREF="#_Toc443041293">Display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_180"></A><A HREF="#_Toc443041294">Changing the network graphics at run-time</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_181"></A><A HREF="#_Toc443041295">Standalone version</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_182"></A><A HREF="#_Toc443041296">Tvenv: the Turbo Vision user interface</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_183"></A><A HREF="#_Toc443041297">Analyzing simulation results</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_184"></A><A HREF="#_Toc443041298">Plotting output vectors with Plove</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_185"></A><A HREF="#_Toc443041299">Plove features</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_186"></A><A HREF="#_Toc443041300">Usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_187"></A><A HREF="#_Toc443041301">Writing filters</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_188"></A><A HREF="#_Toc443041302">Format of output vector files</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_189"></A><A HREF="#_Toc443041303">Working without Plove</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_190"></A><A HREF="#_Toc443041304">Extracting vectors from the file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_191"></A><A HREF="#_Toc443041305">Using splitvec</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_192"></A><A HREF="#_Toc443041306">Visualization under Unix</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_193"></A><A HREF="#_Toc443041307">Debugging and profiling</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_194"></A><A HREF="#_Toc443041308">Debugging</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_195"></A><A HREF="#_Toc443041309">Stack problems</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_196"></A><A HREF="#_Toc443041310">Memory allocation problems</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_197"></A><A HREF="#_Toc443041311">Factors that affect the speed of the
simulation</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_198"></A><A HREF="#_Toc443041312">Modelling with OMNeT++</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_199"></A><A HREF="#_Toc443041313">Coding conventions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_200"></A><A HREF="#_Toc443041314">Component libraries</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_201"></A><A HREF="#_Toc443041315">Simple module libraries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_202"></A><A HREF="#_Toc443041316">Compound module NED source libraries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_203"></A><A HREF="#_Toc443041317">Precompiled compound module libraries</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_204"></A><A HREF="#_Toc443041318">Problem solving with OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_205"></A><A HREF="#_Toc443041319">Modelling computer networks</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_206"></A><A HREF="#_Toc443041320">Modelling multiprocessor systems</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_207"></A><A HREF="#_Toc443041321">Parameter tuning</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_208"></A><A HREF="#_Toc443041322">Multiple experiments within one simulation
run</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_209"></A><A HREF="#_Toc443041323">Dynamic topology opmization</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_210"></A><A HREF="#_Toc443041324">Parallel execution</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_211"></A><A HREF="#_Toc443041325">Syncpoints</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_212"></A><A HREF="#_Toc443041326">The PVM virtual machine</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_213"></A><A HREF="#_Toc443041327">Mapping logical machines to physical
ones</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_214"></A><A HREF="#_Toc443041328">Configuration of the slaves</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_215"></A><A HREF="#_Toc443041329">Configuration and running</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_216"></A><A HREF="#_Toc443041330">If there are problems...</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_217"></A><A HREF="#_Toc443041331">Appendix A: Statistical synchronisation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_218"></A><A HREF="#_Toc443041332">The description of the statistical
synchronisation method</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_219"></A><A HREF="#_Toc443041333">Using SSM in OMNeT++</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_220"></A><A HREF="#_Toc443041334">Appendix B: Comparison of OPNET and
OMNeT++</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_221"></A><A HREF="#_Toc443041335">Appendix C: Quick reference for OPNET
users</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_222"></A><A HREF="#_Toc443041336">Appendix D: Embedding OMNeT++</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_223"></A><A HREF="#_Toc443041337">Structure of an OMNeT++ simulation
program</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_224"></A><A HREF="#_Toc443041338">Embedding</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_225"></A><A HREF="#_Toc443041339">Appendix E: Internal structure of
the simulation program</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_226"></A><A HREF="#_Toc443041340">The simulation kernel</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_227"></A><A HREF="#_Toc443041341">The central object: cSimulation simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_228"></A><A HREF="#_Toc443041342">Module classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_229"></A><A HREF="#_Toc443041343">Global registration lists</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_230"></A><A HREF="#_Toc443041344">The coroutine package</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_231"></A><A HREF="#_Toc443041345">The user interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_232"></A><A HREF="#_Toc443041346">The main() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_233"></A><A HREF="#_Toc443041347">The cEnvir interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_234"></A><A HREF="#_Toc443041348">Implementation of the user interface:
simulation applications</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_235"></A><A HREF="#_Toc443041349">References</A></B></FONT><BR>
<HR><H1><A NAME="_Toc443041114">Introduction</A></H1>
<H2><A NAME="_Toc443041115">What is OMNeT++?</A></H2>
<P>
OMNeT++ is an object-oriented modular discrete event simulator.
The name itself stands for Objective Modular Network Testbed in
C++. OMNeT++ has its distant roots in OMNeT, a simulator written
in Object Pascal by dr. Gy&ouml;rgy Pongor.
<P>
The simulator can be used for modelling:
<UL>
<LI>communication protocols
<LI>computer networks and traffic modelling
<LI>multi-processor and distributed systems
<LI>administrative systems
<LI>... and any other system where the discrete event approach
is suitable.
</UL>
<P>
An OMNeT++ model consists of hierarchically nested modules. The
depth of module nesting is not limited, which allows the user
to reflect the logical structure of the actual system in the model
structure. Modules communicate with message passing. Messages
can contain arbitrarily complex data structures. Modules can send
messages either directly to their destination or along a predefined
path, through gates and connections.
<P>
Modules can have parameters which are used for three main purposes:
to customize module behaviour; to create flexible model topologies
(where parameters can specify the number of modules, connection
structure etc); and for module communication, as shared variables.
<P>
Modules at the lowest level of the module hierarchy are to be
provided by the user, and they contain the algorithms in the model.
During simulation execution, simple modules appear to run in parallel,
since they are implemented as coroutines (sometimes termed lightweight
processes). To write simple modules, the user does not need to
learn a new programming language, but he/she is assumed to have
some knowledge of C++ programming.
<P>
OMNeT++ simulations can feature different user interfaces for
different purposes: debugging, demonstation and batch execution.
Advanced user interfaces make the inside of the model visible
to the user, allow him/her to start/stop simulation execution
and to intervene by changing variables/objects inside the model.
This is very important in the development/debugging setPhase of
the simulation project. User interfaces also facilitate demonstration
of how a model works.
<P>
Since it was written in C++, the simulator is basically portable;
it should run on most platforms with a C++ compiler. OMNeT++'s
advanced user interfaces support X-window, DOS and are portable
to Win3.1/Win95/WinNT.
<P>
OMNeT++ has been extended to execute the simulation in parallel.
Any kind of synchronisation mechanism can be used. One suitable
synchnonization mechanism is the statistical synchronisation,
for which OMNeT++ provides explicit support.
<P>
OMNeT++ Home Page on the Web: 
<P>
<TT>http://www.hit.bme.hu/phd/vargaa/omnetpp.htm</TT>
<H2><A NAME="_Toc443041116">About the manual</A></H2>
<P>
The material in this manual is organized as follows:
<UL>
<LI>Chapter 2 describes the modelling concepts and the model structure
in general.
<LI>Chapter 3 gives a complete example to demonstrate the concepts.
<LI>Chapter 4 describes the model description language of the
simulator. This chapter also has many examples.
<LI>Chapter 5 deals with the programming of simple modules. Topics
include creating simple module types, sending and receiving messages,
using the simulation class library, debugging etc.
<LI>Chapter 6 deals with practical tasks such as compiling, linking,
running simulations etc.
<LI>Chapter 7 presents the different user interfaces for OMNeT++.
<LI>Chapter 8 describes how to create component libraries, gives
hints for debugging and discusses other miscellaneous topics.
<LI>Chapter 9 describes the parallel execution of OMNeT++ simulations.
<LI>Chapter 10 describes some modelling methodologies and solutions
that can be used with OMNeT++.
<LI>The appendices contain an introduction to the statistical
synchronisation method; a comparison of OMNeT++ and a leading
commercial simulation program, OPNET; and a brief overview of
the internals of OMNeT++.
</UL>
<P>
If you do not find the information you need in this manual, you
can check the reference manual, look into the header files or
the source code directly, or contact the authors.
<H2><A NAME="_Toc443041117">Authors</A></H2>
<P>
OMNeT++ has been developed mostly by Andr<FONT>&aacute;s
Varga at the </FONT>Technical University of Budapest, Department
of Telecommunications (BME-HIT). Here's a list of the people who
have or had anything to do with OMNeT++:
<P>
Author and maintainer of the code:
<P>
 Andr<FONT>&aacute;</FONT>s Varga  BME-HIT
: vandras@sch.bme.hu,vargaa@hit.bme.hu
<P>
Advisor/contributor:
<P>
 Gy<FONT>&ouml;</FONT>rgy Pongor BME-HIT
: pongor@hit.bme.hu
<P>
Co-author (old NED compiler), until 1993:
<P>
 <FONT>&Aacute;k</FONT>os Kun  BME
<P>
JAR compiler (now called NEDC), sample simulations; summer 1995:
<P>
 Jan Heijmans  TU Delft
<P>
 Alex Paalvast  TU Delft
<P>
 Robert van der Leij TU Delft
<P>
New feaures, testing, new examples; fall 1995:
<P>
 Maurits Andr<FONT>&eacute;</FONT> 
TU Delft, M.J.A.Andre@twi.tudelft.nl
<P>
 George van Montfort TU Delft, G.P.R.vanMontfort@twi.tudelft.nl
<P>
 Gerard van de Weerd TU Delft, G.vandeweerd@twi.tudelft.nl
<P>
JAR (NEDC) support for distributed execution; also current user:
<P>
 G<FONT>&aacute;bor Lencse  BME</FONT>-HIT
: lencse@hit.bme.hu
<P>
PVM support (as final project), spring 1996:
<P>
 Zolt<FONT>&aacute;n Vass  BME</FONT>-HIT
<P>
P<SUP>2</SUP>, k-split algorithms and more, from fall 1996:
<P>
 Babak Fakhamzadeh TU Delft
<P>
We have to mention Dr. Leon Rothkranz from the Technical University
of Delft whose work made it possible for the Delft students to
come to Budapest in 1995. 
<P>
The starting point of this manual was the 1995 report of Jan Heijmans,
Alex Paalvast and Robert van der Leij.
<HR><H1><A NAME="_Toc443041118">Overview</A></H1>
<H2><A NAME="_Toc443041119">Modelling concepts</A></H2>
<P>
OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are:
<UL>
<LI>hierarchically nested modules 
<LI>modules are instances of module types 
<LI>modules communicate with messages through channels 
<LI>flexible module parameters 
<LI>topology description language 
</UL>
<H3><A NAME="_Toc443041120">Hierarchical modules</A></H3>
<P>
An OMNeT++ model consists of hierarchically nested modules which
communicate with messages. OMNeT++ models are often referred to
as <I>networks</I>. The top level module is the <I>system module</I>.
The system module contains <I>submodules</I>, which can also contain
submodules themselves (Fig.2.1). The depth of module nesting is
not limited; this allows the user to reflect the logical structure
of the actual system in the model structure.
<P>
<CENTER><IMG SRC="img00002.gif"><BR>
Fig.2.1. Simple and compound modules.</CENTER>
<P>
Modules that contain submodules are termed <I>compound modules</I>,
as opposed <I>simple modules</I> which are at the lowest level
of the module hierarchy. Simple modules contain the algorithms
in the model. The user implements the simple modules in C++, using
the OMNeT++ simulation class library.
<H3><A NAME="_Toc443041121">Module types</A></H3>
<P>
Both simple and compound modules are instances of <I>module types</I>.
While describing the model, the user defines module types; instances
of these module types serve as components for more complex module
types. Finally, the user creates the system module as an instance
of a previously defined module type; all modules of the network
are instantiated as submodules and sub-submodules of the system
module.
<P>
When a module type is used as a building block, there is no distinction
whether it is a simple or a compound module. This allows the user
to split a simple module into several simple modules embedded
into a compound module, or vica versa, aggregate the functionality
of a compound module into a single simple module, without affecting
existing users of the module type.
<P>
Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <I>component libraries</I>. This feature
will be discussed later, in chapter 8.
<H3><A NAME="_Toc443041122">Messages, gates, links</A></H3>
<P>
Modules communicate by exchanging <I>messages</I>. In an actual
simulation, messages can represent frames or packets in a computer
network, jobs or customers in a queueing network or other types
of mobile entities. Messages can contain arbitrarily complex data
structures. Simple modules can send messages either directly to
their destination or along a predefined path, through gates and
connections.
<P>
The &quot;local simulation time&quot; of a module advances when
the module receives a message. The message can arrive from another
module or from the same module (<I>self-messages</I> are used
to implement timers).
<P>
<I>Gates</I> are the input and output interfaces of modules; messages
are sent out through output gates and arrive through input gates.
<P>
Each<I> connection</I> (also called <I>link</I>) is created within
a single level of the module hierarchy: within a compound module,
one can connect the corresponding gates of two submodules, or
a gate of one submodule and a gate of the compound module (Fig.2.2).
<P>
<CENTER><IMG SRC="img00003.gif"><BR>
Fig.2.2. Connections</CENTER>
<P>
Due to the hierarchical structure of the model, messages typically
travel through a series of connections, to start and arrive in
simple modules. Such series of connections that go from simple
module to simple module are called <I>routes</I>. Compound modules
act as 'cardboard boxes' in the model, transparently relaying
messages between their inside and their outside world.
<H3><A NAME="_Toc443041123">Link characteristics</A></H3>
<P>
Connections can be assigned three parameters which facilitate
the modelling of communication networks, but can be useful for
other models too:
<UL>
<LI>propagation delay (sec)
<LI>bit error rate (errors/bit)
<LI>data rate (bits/sec)
</UL>
<P>
Each of these parameters are optional.<A NAME="a"> One can specify
link parameters individually for each connection, or define link
types (also called <I>channel</I> <I>types</I>) once and use them
throughout the whole model.</A>
<P>
The <I>propagation delay</I> is the amount of time the arrival
of the message is delayed by when it travels through the channel.
Propagation delay is specified in seconds.
<P>
The <I>bit error rate</I> has influence on the transmission of
messages through the channel. The bit error rate is the probability
that a bit is incorrectly transmitted. Thus, the probability that
a message of <I>n</I> bits length is transferred correctly is:
<BR>
<P>
P(<I> sent message received properly </I>) = (1 - <I>ber</I>)<I><SUP>n</SUP></I>
<P>
where <I>ber</I> = bit error rate and <I>n</I> = number of bits
in message.<BR>
<P>
The message has an error flag which is set in case of transmission
errors.
<P>
The <I>data rate</I> is specified in bits/second, and it is used
for transmission delay calculation. The sending time of the message
normally corresponds to the transmission of the first bit, and
the arrival time of the message corresponds to the reception of
the last bit:
<P>
<CENTER><IMG SRC="img00004.gif"><BR>
Fig.2.3. Message transmission</CENTER>
<P>
The above model is not applicable for modelling some protocols
like Token Ring and FDDI where the stations repeat the bits of
a frame that arrives on the ring immediately, without waiting
for the whole frame to arrive; in other words, frames &quot;flow
through&quot; the stations, being delayed only a few bits. If
you want to model such networks, the data rate modelling feature
of OMNeT++ cannot be used.
<P>
If a message travels along a route, through successive links and
compound modules, the model behaves as if each module waited until
the last bit of the message arrives and only start its transmission
then:
<P>
<CENTER><IMG SRC="img00005.gif"><BR>
Fig.2.4. Message sending over multiple channels</CENTER>
<P>
Since the above effect is usually not the desired one, typically
you will want to assign data rate to only one connection in the
route.
<H3><A NAME="_Toc443041124">Parameters</A></H3>
<P>
Modules can have parameters. Parameters are used for three purposes:
<OL>
<LI>to parametrize module topology 
<LI>to customize simple module behaviour 
<LI>for module communication, as shared variables 
</OL>
<P>
Parameters can take string, numeric or pointer values; numeric
values include expressions using other parameters and calling
C functions, random variables from different distributions, and
values input interactively by the user.
<P>
Numeric-valued parameters can be used to construct topologies
in a flexible way. Within a compound module, parameters can define
the number of submodules, number of gates, and the way the internal
connections are made.
<P>
Compound modules can pass parameters or expressions of parameters
to their submodules. Parameter passing can be done by value or
by reference. 
<P>
During simulation execution, if a module changes the value of
a parameter taken by reference, the changed value propagates to
other modules. This effect can be used to tune the model or as
a second means of module communication. Pointer-valued parameters
can be used to implement shared memory.
<H3><A NAME="_Toc443041125">Topology description method</A></H3>
<P>
The user defines the structure of the model in NED language descriptions
(NEtwork Description).The NED language will be discussed in detail
in Chapter 4.
<H2><A NAME="_Toc443041126">Programming the algorithms</A></H2>
<P>
The simple modules of a model contain the algorithms as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.
<P>
OMNeT++ supports a process-style description method for describing
activites. During simulation execution, simple module functions
appear to run in parallel, because they are implemented as coroutines
(also termed lightweight processes). Coroutines were chosen because
they allow an intuitive description of the algorithm and they
can also serve as a good basis for implementing other description
methods like state-transition diagrams or Petri nets.
<P>
OMNeT++ has a consistent object-oriented design. One can freely
use OOP concepts (inheritance, polimorphism etc) to extend the
functionality of the simulator.
<P>
Elements of the simulation (messages, modules, queues etc.) are
represented as objects. These classes are part of the simulation
class library:
<UL>
<LI>modules, gates, connections etc. 
<LI>parameters 
<LI>messages 
<LI>container classes (e.g. queue, array) 
<LI>data collection classes 
<LI>statistic and distribution estimation classes (histograms,
P<SUP>2</SUP> algorithm for calculating quantiles etc.) 
<LI>transient detection and result accuracy detection classes
</UL>
<P>
The objects are designed so that they can efficiently work together,
creating a powerful framework for simulation programming.
<H3><A NAME="_Toc443041127">Creating simple modules</A></H3>
<P>
Each simple module type is implemented with a C++ class. Simple
module classes are derived from a simple module base class, by
redefining the virtual function that contains the algorithm. The
user can add other member functions to the class to split up a
complex algorithm; he can also add data members to the class.
<P>
It is also possible to derive new simple module classes from exisiting
ones. For example, if one wants to experiment with retransmission
timeout schemes in a transport protocol, he can implemement the
protocol in one class, create a virtual function for the retransmission
algorithm and then derive a family of classes that implement concrete
schemes. This concept is further supported by the fact that in
the network description, actual module types can be parameters.
<H3><A NAME="_Toc443041128">Object mechanisms</A></H3>
<P>
The use of smart container classes allows the user to build <I>aggregate
data structures</I>. For example, one can add any number of objects
to a message object as parameters. Since the added objects can
contain further objects, complex data structures can be built.
<P>
There is an efficient <I>ownership</I> mechanism built in. The
user can specify an owner for each object; then, the owner object
will have the responsibility of destroying that object. Most of
the time, the ownership mechanism works transparently; ownership
only needs to be explicitly managed when the user wants to do
something non-typical.
<P>
The <I>forEach</I> mechanism allows one to enumerate the objects
inside a container object in a uniform way and do some operation
on them. This feature which makes it possible to handle many objects
together. (The forEach feature is extensively used by the user
interfaces with debugging capability and the snapshot mechanism;
see later.)
<H3><A NAME="_Toc443041129">Derive new classes</A></H3>
<P>
It most cases, the functionality offered by the OMNeT++ classes
is enough for the user. But if it is needed, one can derive new
classes from the exisiting ones or create entirely new classes.
For flexibility, several member functions are declared virtual.
When the user creates new classes, certain rules need to be kept
so that the object can fully work together with other objects.
<H3><A NAME="_Toc443041130">Self-describing objects to ease debugging</A>
</H3>
<P>
The class library is designed so that objects can give textual
information about themselves. This makes it possible to peek into
a running simulation program: through an appropriate user interface,
one can examine (and modify) the internal data structures of a
running simulation. This feature helps the user to get some insight
what is happening inside the model and get hands-on experience.
<P>
A unique feature called <I>snapshot</I> allows the user to dump
the contents of the simulation model or a part of it into a text
file. The file will contain textual reports about every object;
this can be of invaluable help at times of debugging. Ordinary
variables can also be made to appear in the snapshot file. Snapshot
creations can scheduled from within the simulation program or
done from the user interface.
<H2><A NAME="_Toc443041131">Using OMNeT++</A></H2>
<H3><A NAME="_Toc443041132">Building and running simulations</A>
</H3>
<P>
This section gives some idea how to work with OMNeT++ in practice:
issues like model files, compiling and running simulations are
discussed.
<P>
An OMNeT++ model consists of the following parts:
<UL>
<LI>NED language topology description(s) which describe the module
structure with parameters, gates etc. They are files with <TT>.ned</TT>
suffix.
<LI>Simple modules sources. They are C++ files, with <TT>.h/.cc</TT>
suffix.
</UL>
<P>
The simulation system provides the following components:
<UL>
<LI>Simulation kernel. This contains the code that manages the
simulation and the simulation class library. It is written in
C++, compiled and put together to form a library (a file with
<TT>.a</TT> or <TT>.lib</TT> extension)
<LI>User interfaces. OMNeT++ user interfaces are used with simulation
execution, to facilitate debugging, demonstration, or batch execution
of simulations. There are several user interfaces, written in
C++, compiled and put together into libraries (<TT>.a</TT> or
<TT>.lib</TT> files).
</UL>
<P>
Simulation programs are built from the above components. First,
the NED files are compiled into C++ source code, using the NEDC
compiler which is part of OMNeT++. Then all C++ sources are compiled
and linked with the simulation kernel and a user interface to
form a simulation executable.
<P>
<B>Running the simulation and analyzing the results</B>
<P>
The simulation executable is a standalone program; thus, it can
be run on other machines without OMNeT++ or the model files being
present. When the program is started, it reads in a configuration
file (usually called <TT>omnetpp.ini</TT>); it contains settings
that control how the simulation is run, values for model parameters
etc. The configuration file can also prescribe several simulation
runs; in the simplest case, they will be executed by the simulation
program one after another.
<P>
The output of the simulation is textual data files. There are
simple utility programs to process them and the user will typically
use math packages, drawing, analysis or spreadsheet programs to
visualize data series and do further calculations on them. This
manual briefly describes some data plotting programs and how to
use them with OMNeT++.
<P>
<B>User interfaces</B>
<P>
The primary purpose of user interfaces is to make the inside of
the model visible to the user, to start/stop simulation execution,
and possibly allow the user intervene by changing variables/objects
inside the model. This is very important in the development/debugging
setPhase of the simulation project. Just as important, a hands-on
experience allows the user to get a 'feel' about the model's behaviour.
A nice graphical user interface can also be used to demonstrate
how the model works internally.
<P>
The same simulation model can be executed with different user
interfaces, without any change in the model files themselves.
The user would test and debug the simulation with a powerful graphical
user interface, and finally run it with a simple and fast user
interface that supports batch execution.
<P>
<B>Component libraries</B>
<P>
Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create component libraries.
<P>
<B>Universal standalone simulation programs</B>
<P>
A simulation executable can also store several independent models
that use the same set of simple modules. The user can specify
in the configuration file which model he/she wants to run. This
allows one to build one large executable that contains models
of a wide range of systems, and distribute it as a standalone
simulation program. The flexibility of the topology description
language also supports this approach.
<H3><A NAME="_Toc443041133">What is what in the directories</A>
</H3>
<P>
To help you navigate among files in the OMNeT++ distribution,
here's a list what you can find in the different directories.
<P>
The <TT>omnetpp</TT> directory contains the following subdirectories.
<P>
The simulation system itself:
<PRE>
<B><FONT>omnetpp/              </FONT></B><FONT>OMNeT++ root directory
</FONT><B>   bin/               </B>soft links to executables in src/
<B>   lib/               </B>soft links to sim. library files in src/
<B>   doc/               </B>manuals (Word6, HTML), readmes, license etc.
<B>   src/
       nedc/          </B>system description compiler
<B>       sim/           </B>simulation kernel
<B>            std/      </B>files for non-distributed execution
<B>            pvm/      </B>files for distributed execution over PVM
<B>       envir/         </B>common code for user interfaces
<B>            cmdenv/   </B>command-line user interface
<B>            tkenv/    </B>Tcl/Tk user interface
<B>            tvenv/    </B>Turbo Vision user interface
<B>       gned/          </B>graphical NED editor written in Tcl/Tk
<B>       plove/         </B>output vector analyzer and plotting tool
<B>       utils/         </B>makefile-autocreator etc
</PRE>
<P>
Sample simulations are within the <TT>samples</TT> directory.
Each of the sample directories contain a network description (.<TT>ned</TT>
file) and corresponding simple module code (<TT>.h</TT>, <TT>.cc</TT>
files). UNIX makefiles, Borland C++ 5.0 and 3.1 project files
are included.
<PRE>
<B><FONT>omnetpp/
</FONT>   samples/           </B>directories for sample simulations
<B>       nim/           </B>a simple two-player game
<B>       hcube/         </B>hypercube network with deflection routing
<B>       token/         </B>Token-Ring network
<B>       fddi/          </B>an accurate FDDI MAC simulation
<B>       hist/          </B>demo of the histogram classes
<B>       dyna/          </B>dynamic module creation (client-server network)
<B>       pvmex/         </B>demonstrates distributed execution
<B>       fifo1/         </B>single-server queue
<B>       fifo2/         </B>another implementation of a single-server queue
</PRE>
<P>
DOS package contains another directory:
<PRE>
<B><FONT>omnetpp/
</FONT>   gnu/               </B>DOS version of bison and flex
</PRE>
<HR><H1><A NAME="_Toc443041134">An example: the NIM game</A></H1>
<P>
This chapter contains a full example program that can give you
some basic idea of using the simulator. An enhanced version of
the NIM example can be found among the sample programs and is
documented in the Examples Manual.
<P>
Nim is an ancient game with two players and a bunch of sticks.
The players take turns, removing 1, 2, 3 or 4 sticks from the
heap of sticks at each turn. The one who takes the last stick
is the loser. 
<P>
Of course, building a model of the Nim game is not much of a simulation
project, but it nicely demonstrates the modelling approach used
by OMNeT++.
<P>
Describing the model consists of two phases: 
<UL>
<LI>topology description 
<LI>defining the operation of components 
</UL>
<H2><A NAME="_Toc443041135">Topology</A></H2>
<P>
The game can be modelled in OMNeT++ as a network with three modules:
the &quot;game&quot; (a manager module) and two players. The modules
will communicate by exchanging messages. The &quot;game&quot;
module keeps the current number of tokens and organizes the game;
in each turn, the player modules receives the number of tokens
from the Game module and sends back its move.
<P>
<CENTER><IMG SRC="img00006.gif"><BR>
Fig. 3.1. Module structure for the Nim game</CENTER>
<P>
<TT>Player1</TT>, <TT>Player2</TT> and <TT>Game</TT> are simple
modules (e.g. they have no submodules.) Each module is an instance
of a module type. We'll need a module type to represent the <TT>Game</TT>
module; let's call it <TT>Game</TT> too. 
<P>
We can implement two kinds of players: <TT>SmartPlayer</TT>, which
knows the winning algorithm, and  <TT>SimplePlayer</TT>, which
simply takes a random number of sticks. In our example, <TT>Player1</TT>
will be a <TT>SmartPlayer</TT> and  <TT>Player2</TT> will be a
<TT>SimplePlayer</TT> .
<P>
The enclosing module, <TT>Nim</TT> is a compound module (it has
submodules). It is also defined as a module type of which one
instance is created, the system module.
<P>
Modules have input and output gates (that tiny boxes labelled
<TT>in</TT>, <TT>out</TT>, <TT>from_player1</TT>, etc. in the
figure). An input and an output gate can be connected: connections
(or links) are shown as in the figure as arrows. During the simulation,
modules communicate by sending messages through the connections.
<P>
The user defines the topology of the network in NED files.
<P>
We placed the model description in two files; the first file defines
the simple module types and the second one the system module.
<P>
The first file (NED keywords are typed in boldface):
<PRE>
<FONT>//---------------------------------------------------------
// file: nim_mod.ned
//       Simple modules in nim.ned
//---------------------------------------------------------

// Declaration of simple module type Game.
</FONT><B>simple</B> Game
    <B>parameters</B>:
        num_sticks,         // initial number of sticks 
        first_move;         // 1=Player1, 2=Player2
    <B>gates</B>:
        <B>in</B>:  from_player1,  // input and output gates
             from_player2;  // for connecting to Player1/Player2
        <B>out</B>: to_player1,   
             to_player2;
<B>endsimple


</B>// Now the declarations of the two simple module types.
// Any one of the three types can be Player1 or Player2.

// A player that makes random moves
<B>simple</B> SimplePlayer
    <B>gates</B>:
        <B>in</B>: in;         // gates for connecting to Game
        <B>out</B>: out;
<B>endsimple

</B>// A player who knows the winning algorithm
<B>simple</B> SmartPlayer
    <B>gates</B>:
        <B>in</B>: in;         // gates for connecting to Game
        <B>out</B>: out;
<B>endsimple
</B>
</PRE>
<P>
The second file:
<PRE>
<FONT>//-------------------------------------------------------------
</FONT>// file: nim.ned
//       Nim compound module + system module
//-------------------------------------------------------------

<B>import</B> &quot;nim_mod&quot;;

<B>module</B> Nim
    <B>submodules</B>:
        game: Game
            <B>parameters</B>:
                num_sticks = intuniform(21, 31),
                first_move = intuniform(1, 2);
        player1: SmartPlayer;
        player2: SimplePlayer;
    <B>connections</B>:
        player1.out --&gt; game.from_player1,
        player1.in  &lt;-- game.to_player1,

        player2.out --&gt; game.from_player2,
        player2.in  &lt;-- game.to_player2;
<B>endmodule

</B>// system module creation
<B>network</B> 
    nim: Nim
<B>endnetwork
</B>
</PRE>
<H2><A NAME="_Toc443041136">Simple modules</A></H2>
<P>
The module types <TT>SmartPlayer</TT>, <TT>SimplePlayer</TT> and
<TT>Game</TT> are implemented in C++, using the OMNeT++ library
classes and functions. 
<P>
Each simple module type is derived from the C++ class <TT>cSimpleModule</TT>,
with its <TT>activity()</TT> member function redefined. The <TT>activity()</TT>
functions of all simple modules in the network are executed as
coroutines, so they appear as if they were running in parallel.
Messages are instances of the class <TT>cMessage</TT>.
<P>
We present here the C++ sources of the <TT>SmartPlayer</TT> and
<TT>Game</TT> module types.
<P>
The <TT>SmartPlayer</TT> first introduces himself by sendings
its name to the <TT>Game</TT> module. Then it enters an infinite
loop; with each iteration, it receives a message from <TT>Game</TT>
with the number of sticks left, it calculates its move and sends
back a message containing the move. 
<P>
Here's the source:
<PRE>
<FONT>#include &lt;stdio.h&gt;
</FONT>#include &lt;string.h&gt;
#include &lt;time.h&gt;

#include &quot;omnetpp.h&quot;

// derive SmartPlayer from cSimpleModule
class SmartPlayer : public cSimpleModule
{
    Module_Class_Members( SmartPlayer, cSimpleModule, 8192)
       // this is a macro; it expands to constructor definition etc.
       // 8192 is the size for the coroutine stack (in bytes)
                        
    virtual void activity(); 
       // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( SmartPlayer )


// define operations of SmartPlayer
void SmartPlayer::activity()
{
    int move;

    // initialization phase: send module type to Game module
    // create a message with the name &quot;SmartPlayer&quot; and send it to Game

    cMessage *msg = new cMessage(&quot;SmartPlayer&quot;);
    send(msg, &quot;out&quot;);

    // infinite loop to process moves; 
    //     simulation will be terminated by Game
    for (;;)
    {
        // messages have several fields; here, we'll use the message
        // kind member to store the number of sticks
        cMessage *msgin = receive();   // receive message from Game
        int num_sticks = msgin-&gt;kind();// extract message kind (an int)
                                       // this hold the number of sticks
                                       //  still on the stack  
        delete msgin;                  // dispose of the message

        move = (num_sticks + 4) % 5;   // calculate move
        if (move == 0)                 // must be adjusted
             move = 1;                 // seems like we going to lose

        ev &lt;&lt; &quot;Taking &quot; &lt;&lt; move        // some output
           &lt;&lt; &quot; out of &quot;  &lt;&lt; num_sticks
           &lt;&lt; &quot; sticks.\n&quot;;

        cMessage *msgout = new cMessage; // create empty message
        msgout-&gt;setKind( move );         // use message kind as storage
                                         // for move
        send( msgout, &quot;out&quot;);            // send the message to Game
    }
}
</PRE>
<P>
The <TT>Game</TT> module first waits for a message from both players
and extracts the message names that are also the players' names.
Then it enters a loop, with the <TT>player_to_move</TT> variable
alternating between 1 and 2. With each iteration, it sends out
a message with the current number of sticks to the corresponding
player and gets back the number of sticks taken by that player.
When the sticks are out, the module announces the winner and ends
the simulation.
<P>
The source:
<PRE>
<FONT>//-------------------------------------------------------------
</FONT>// file: game.cc
//        (part of NIM - an OMNeT++ demo simulation)
//-------------------------------------------------------------

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;omnetpp.h&quot;

// derive Game from cSimpleModule
class Game : public cSimpleModule
{
     Module_Class_Members(Game,cSimpleModule,8192)
       // this is a macro; it expands to constructor definition etc.
       // 8192 is the size for the coroutine stack (in bytes)

     virtual void activity();
       // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( Game )

// operation of Game:
void Game::activity()
{
	// strings to store player names; player[0] is unused
	char player[3][32];

	// read parameter values
	int num_sticks = par(&quot;num_sticks&quot;);
	int player_to_move = par(&quot;first_move&quot;);

	// waiting for players to tell their names
	for (int i=0; i&lt;2; i++)
	{
		cMessage *msg = receive();
		if (msg-&gt;arrivedOn(&quot;from_player1&quot;))
			strcpy( player[1], msg-&gt;name());
		else
			strcpy( player[2], msg-&gt;name());
		delete msg;
	}

	// ev represents the user interface of the simulator
	ev &lt;&lt; &quot;Let the game begin!\n&quot;;
	ev &lt;&lt; &quot;Player 1: &quot; &lt;&lt; player[1] &lt;&lt; &quot;   Player 2: &quot; &lt;&lt; player[2]
	   &lt;&lt; &quot;\n\n&quot;;

	do
	{
		ev &lt;&lt; &quot;Sticks left: &quot; &lt;&lt; num_sticks &lt;&lt; &quot;\n&quot;;
		ev &lt;&lt; &quot;Player &quot; &lt;&lt; player_to_move &lt;&lt; &quot; (&quot;
		   &lt;&lt; player[player_to_move] &lt;&lt; &quot;) to move.\n&quot;;

		cMessage *msg = new cMessage(&quot;&quot;, num_sticks);
				    // num_sticks will be the msg kind
		if (player_to_move == 1)
			send(msg, &quot;to_player1&quot;);
		else
			send(msg, &quot;to_player2&quot;);

		msg = receive();
		int sticks_taken = msg-&gt;kind();
		delete msg;

		num_sticks -= sticks_taken;

		ev &lt;&lt; &quot;Player &quot; &lt;&lt; player_to_move &lt;&lt; &quot; (&quot;
		   &lt;&lt; player[player_to_move] &lt;&lt; &quot;) took &quot;
		   &lt;&lt; sticks_taken &lt;&lt; &quot; stick(s).\n&quot;;

		player_to_move = 3 - player_to_move;
	}
	while (num_sticks&gt;0);

	ev &lt;&lt; &quot;\nPlayer &quot; &lt;&lt; player_to_move &lt;&lt; &quot; (&quot;
	   &lt;&lt; player[player_to_move] &lt;&lt; &quot;) won!\n&quot;;

	endSimulation();
}
</PRE>
<H2><A NAME="_Toc443041137">Running the simulation</A></H2>
<P>
Once the source files are ready, one needs to compile and link
them into a simulation executable. One can specify the user interface
to be linked.
<P>
Before running the simulation, one can put parameter values and
all sorts of other settings into an initialization file that will
be read when the simulation program starts:
<PRE>
<FONT>;---------------------
</FONT>; file: omnetpp.ini
;---------------------
[General]
network = nim
random-seed = 3
ini-warnings = false

[Cmdenv]
module-messages = yes
verbose-simulation = no<BR>
</PRE>
<P>
Suppose we link the NIM simulation with the command line user
interface. We get the executable  <TT>nim</TT> (or <TT>nim.exe</TT>
under DOS). When we run it, we'll get the following screen output:
<PRE>
<FONT>% <I>./nim</I></FONT>
</PRE>
<P>
Or:
<PRE>
<FONT>C:\OMNETPP\SAMPLES\NIM&gt; <I>nim.exe

</I></FONT>OMNeT++ Discrete Simulation, TUB Dept. of Telecommunications, 1990-97

Preparing for Run #1...
Setting up network `nim'...
Running simulation...
Let the game begin!
Player 1: SmartPlayer   Player 2: SimplePlayer

Sticks left: 29
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 2 out of 29 sticks.
Player 2 (SimplePlayer) took 2 stick(s).
Sticks left: 27
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 1 out of 27 sticks.
Player 1 (SmartPlayer) took 1 stick(s).
Sticks left: 26
[...]
Sticks left: 5
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 4 out of 5 sticks.
Player 1 (SmartPlayer) took 4 stick(s).
Sticks left: 1
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 1 out of 1 sticks.
Player 2 (SimplePlayer) took 1 stick(s).

Player 1 (SmartPlayer) won!
&lt;!&gt; Module nim.game: Simulation stopped with endSimulation().

End run of OMNeT++
</PRE>
<H2><A NAME="_Toc443041138">Other examples</A></H2>
<P>
An enhanced version of the NIM example can be found among the
sample programs and is documented in the Examples Manual. It adds
a third, interactive player and derives specific player types
from a <TT>Player</TT> abstract class. It also adds the possibity
that actual types for <TT>player1</TT> and <TT>player2</TT> can
be specified in the ini file or interactively entered by the user
at the beginning of the simulation.
<P>
Nim does not show very much of how complex algorithms like communication
protocols can be implemented in OMNeT++. To have an idea about
that, look at the Token Ring example. It is also extensively commented,
though you may need to peep into the user manual to fully understand
it.
<P>
Other programs in the example manual are Dyna and FDDI. Dyna models
a simple client-server network and demonstrates dynamic module
creation. The FDDI example is an accurate FDDI MAC simulation
which was written on the basis of the ANSI standard.
<P>
The following table summarizes the sample simulations<SUP>(NEW)</SUP>:<TABLE BORDER=1>
<TR><TD WIDTH=91><B>NAME</B></TD><TD WIDTH=210><B>TOPIC</B></TD>
<TD WIDTH=354><B>DEMONSTRATES</B></TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>nim</FONT></B>
</PRE>

</TD><TD WIDTH=210>a simple two-player game</TD><TD WIDTH=354>module inheritance<P>
module type as parameter
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>hcube</FONT></B>
</PRE>

</TD><TD WIDTH=210>hypercube network with deflection routing</TD>
<TD WIDTH=354>hypercube topology with dimension as parameter<P>
topology templates<P>
output vectors
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>token</FONT></B>
</PRE>

</TD><TD WIDTH=210>Token Ring network</TD><TD WIDTH=354>ring topology with the number of nodes as parameter<P>
using <TT>cQueue</TT>
<P>
<TT>wait()</TT> and the putaside-queue
<P>
output vectors
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>fifo1</FONT></B>
</PRE>

</TD><TD WIDTH=210>single-server queue</TD><TD WIDTH=354>simple module inheritance<P>
decomposing <TT>activity()</TT> into several functions
<P>
using simple statistics and output vectors<P>
printing stack usage info to help optimize memory consumption<P>
using <TT>finish()</TT>
</TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>fifo2</FONT></B>
</PRE>

</TD><TD WIDTH=210>another fifo implementation</TD><TD WIDTH=354>using <TT>handleMessage()</TT>
<P>
decomposing <TT>handleMessage()</TT> into several functions
<P>
the FSM macros<P>
simple module inheritance<P>
using simple statistics and output vectors<P>
using <TT>finish()</TT>
</TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>fddi</FONT></B>
</PRE>

</TD><TD WIDTH=210>FDDI MAC simulation</TD><TD WIDTH=354>using statistics classes<P>
and many other features
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>hist</FONT></B>
</PRE>

</TD><TD WIDTH=210>demo of the histogram classes</TD><TD WIDTH=354>collecting observations into statistics objects<P>
saving statistics objects to file and restoring them<P>
using the <TT>inspect.lst</TT> file in Tkenv
</TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>dyna</FONT></B>
</PRE>

</TD><TD WIDTH=210>a client-server network</TD><TD WIDTH=354>dynamic module creation<P>
using <TT>WATCH()</TT>
<P>
star topology with the number of modules as parameters
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>pvmex</FONT></B>
</PRE>

</TD><TD WIDTH=210>distributed execution</TD><TD WIDTH=354>distributed execution
</TD></TR>
</TABLE>
<P>
<HR><H1><A NAME="_Toc443041139">The NED language</A></H1>
<H2><A NAME="_Toc443041140">NED overview</A></H2>
<P>
The description of model topology is given in the NED language.
The NED language supports modular description of a network. This
means that a network description consists of a number of component
descriptions (channels, simple/compound module types). The channels,
simple modules and compound modules of one network description
can be used in another network description. As a consequence,
the NED language makes it possible for the user to build his own
libraries of network descriptions.
<P>
Files containing network descriptions generally have a <TT>.ned</TT>
suffix. Network descriptions are not used directly: they are translated
into C++ code by the NEDC compiler, then compiled by the C++ compiler
and linked into the simulation executable.
<P>
The EBNF description of the language can be found in the Reference
Manual.
<H3><A NAME="_Toc443041141">Components of a NED description</A>
</H3>
<P>
A NED description can contain the following components, in arbitrary
number or order:
<UL>
<LI>import statements
<LI>channel definitions
<LI>simple and compound module declarations
<LI>system module declarations
</UL>
<P>
The rest of this chapter discusses each of these types in detail.
<H3><A NAME="_Toc443041142">Reserved words</A></H3>
<P>
The writer of the network description has to take care that no
reserved words are used for names. The reserved words of the NED
language are:
<PRE>
<FONT>import include channel endchannel simple endsimple module endmodule error delay datarate const parameters gates submodules connections gatesizes on if machines for do endfor network endnetwork nocheck ref ancestor true false like not and or input numeric string bool char </FONT>
</PRE>
<H3><A NAME="_Toc443041143">Case sensitivity</A></H3>
<P>
The network description and all identifiers in it are case sensitive.
<H2><A NAME="_Toc443041144">The import statement</A></H2>
<P>
Example:
<PRE>
<B><FONT>import</FONT></B><FONT> &quot;tkn_mod&quot;, &quot;tkn2_mod&quot;;
<BR>
</FONT>
</PRE>
<P>
The <TT>import</TT> statement (the word <TT>include</TT> can also
be used with identical meaning) is used to import declarations
from other network description files. After importing a network
description, one can use the components (channels, simple/compound
module types) defined in it.
<P>
From the imported files, only the declaration information is used,
but <I>no C++ code is generated</I>. The consequence is that one
has to compile and link each network description, not only the
top-level ones.
<P>
The user can specify the name of the files with or without the<TT>
.ned</TT> extension. One can also include path in the filenames,
or better, use the NEDC compiler's <TT>-I &lt;path&gt;</TT> command-line
option to name the directories where the imported files reside.
<H2><A NAME="_Toc443041145">Channel definitions</A></H2>
<P>
A channel definition specifies a connection type of given characteristics.
The channel name can be used later in the NED description to create
connections with these parameters.
<P>
Example:
<PRE>
<B><FONT>channel</FONT></B><FONT> DialUpConnection
</FONT>	<B>delay</B><FONT> normal (0.004, 0.0018)
	<B>error</B> 0.00001
	<B>datarate</B> 14400
<B>endchannel
</B></FONT>
</PRE>
<P>
Any of the <TT>delay</TT>, <TT>error</TT> and <TT>datarate</TT>
parameters are optional and they can appear in any order. The
values are NED expressions. This means that they can be constants
(integer or real), random values from various distributions etc.
<H2><A NAME="_Toc443041146">Simple module definitions</A></H2>
<P>
Simple modules are the basic building blocks for other (compound)
modules. A simple module is defined by declaring its parameters
and gates.
<P>
Example:
<PRE>
<B><FONT>simple</FONT></B><FONT> SomeNameForModule
</FONT>	<B>parameters</B><FONT>:
</FONT>		//...
	<B>gates</B>:
		//...
<B>endsimple
</B>
</PRE>
<P>
(This construct can also be used to declare precompiled compound
modules; see later.)
<H3><A NAME="_Toc443041147">Simple module parameters</A></H3>
<P>
Parameters are variables that belong to a module. Simple module
parameters can be queried and used by simple module algorithms.
For example, a parameter called <TT>num_of_messages</TT> can be
used by a module called <TT>MsgSource</TT> to determine how many
messages it has to generate.
<P>
Parameters are declared by listing their names in the <TT>parameters:</TT>
section of a module description. The parameter type can optionally
be specified as <TT>numeric</TT>, <TT>numeric</TT> <TT>const</TT>
(or simply <TT>const</TT>), <TT>bool</TT>, <TT>string</TT>, or
<TT>anytype</TT>:
<P>
Example:
<PRE>
<B><FONT>simple</FONT></B><FONT> MsgSource
</FONT>	<B>parameters</B><FONT>:
</FONT>		interarrival_time, 
           num_of_messages : <B>const,
</B>           address : <B>string</B>;
	<B>gates</B>: //...
<B>endsimple
</B>
</PRE>
<P>
If the parameter type is omitted, <TT>numeric</TT> is assumed.
Practically, this means that you only need to explicitly specify
the type for string, bool or char-valued parameters.
<P>
Note that the actual parameter values are given later, when the
module is used as a building block of a compound module type or
as a system module.
<P>
When the user writes the word <TT>const</TT> before the parameter,
it is converted to constant; that is, the parameter's value is
replaced by its evaluation. This can be important when the original
value was a random number or an expression. One is advised to
write out the <TT>const</TT> keyword for each parameter that should
be constant.
<P>
Beware when using <TT>const</TT> and by-reference parameter passing
(<TT>ref</TT> modifier, see later) at the same time. Converting
the parameter to constant can affect other modules and cause errors
that are difficult to discover.
<H3><A NAME="_Toc443041148">Simple module gates</A></H3>
<P>
Gates are the connection points of modules. The starting and ending
points of the connections between modules are gates. OMNeT++ supports
simplex (one-directional) connections, so there are two kinds
of gates: input and output. Messages are sent through output gates
and received through input gates. 
<P>
Gates are identified with their names. Gate vectors are supported:
a gate vector contains a number of single gates.
<P>
Gates are declared by listing their names in the <TT>gates:</TT>
section of a module description. An empty bracket pair <TT>[]</TT>
denotes a gate vector. Elements of the vector are numbered from
zero.
<P>
Examples:
<PRE>
<B><FONT>simple</FONT></B><FONT> DataLink
</FONT>	<B>parameters</B><FONT>: //..
	<B>gates</B>:
		<B>in</B>:	from_port, from_higher_layer;
		<B>out</B>:	to_port, to_higher_layer;
<B>endsimple

</B></FONT><B>simple</B> RoutingModule
	<B>parameters</B>: //...
	<B>gates</B>:
		<B>in</B>:	output[];
		<B>out</B>:	input[];
<B>endsimple
</B>
</PRE>
<P>
The sizes of gate vectors are given later, when the module is
used as a building block of a compound module type. Thus, every
instance of the module can have gate vectors of different sizes.
<H2><A NAME="_Toc443041149">Compound module definitions</A></H2>
<P>
Compound modules are modules that are composed of one or more
submodules. Compound modules, like a simple modules, can have
parameters and gates, so a compound module definition looks similar
to a simple module definition, except that it also has sections
to specify the submodules and connections within the module.
<P>
Submodules can either be simple or compound modules, they are
equivalent.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> SomeNameForCompoundModule
</FONT>	<B>parameters</B><FONT>:
</FONT>		//...
	<B>gates</B>:
		//...
	<B>submodules</B>:
		//...
	<B>connections</B>:
		//...
<B>endmodule
</B>
</PRE>
<P>
Any of the above sections (parameters, gates, submodules, connections)
is optional.
<H3><A NAME="_Toc443041150">Compound module parameters</A></H3>
<P>
Parameters are declared in the same way as with simple modules.
Please refer to the &quot;Simple module parameters&quot; section.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> Router
</FONT>	<B>parameters</B><FONT>:
</FONT>		rte_processing_delay, rte_buffersize,
		num_of_ports : <B>const</B>;
	<B>gates</B>: //...
	<B>submodules</B>: //...
	<B>connections</B>://...
<B>endmodule<BR>
</B>
</PRE>
<P>
Compound module parameters can be used in two ways:
<UL>
<LI>used in expressions for submodule parameter values
<LI>used in defining the internal topology of the network
</UL>
<P>
For example, a parameter called <TT>num_of_ports</TT> can be used
to construct a router module with the number of ports as a parameter.
<H3><A NAME="_Toc443041151">Compound module gates</A></H3>
<P>
Gates have the same role and are declared in the same way as with
simple modules. Please refer to the &quot;Simple module gates&quot;
section.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> Router
</FONT>	<B>parameters</B><FONT>: //...
	<B>gates</B>:
		<B>in</B>: input_port[];
		<B>out</B>: output_port[];
	<B>submodules</B>: //...
	<B>connections</B>: //...
<B>endmodule
</B></FONT>
</PRE>
<H3><A NAME="_Toc443041152">Submodules</A></H3>
<P>
Submodules are defined in the <TT>submodules:</TT> section of
a module description. For each submodule, there are sections to
define the actual values to be passed to its parameters and the
sizes of its gate vectors.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> NameForCompoundModule
</FONT>	<B>parameters</B><FONT>: //...
	<B>gates</B>: //...
	<B>submodules</B>:
</FONT>		SubModuleName: TypeOfSubModule
			<B>parameters</B>: 
				//...
			<B>gatesizes</B>:	
				//...
		SecondSubModuleName: TypeOfSecondSubModule
			//...
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
In a submodule definition, one has to supply the name of a previously
defined module as the type and a module name. The description
of the module type can occur in the same network description or
in an imported network description.
<H4><A NAME="_Toc443041153">Module vector as submodule</A></H4>
<P>
It is possible to create an array of submodules (a module vector).
This is done with an expression between brackets right behind
the module type name. The expression can refer to module parameters.
A zero value as module count is also allowed.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> BigCompound
</FONT>	<B>parameters</B><FONT>:
		num_of_submods: <B>const</B>;
	<B>submodules</B>:
</FONT>		Submod1: Node[3]
			//...
		Submod2: Node[num_of_submods]
			//...
		Submod3: Node[(num_of_submods+1)/2]
			//...
<B>endmodule
</B>
</PRE>
<H4><A NAME="_Toc443041154">Module type as parameter</A></H4>
<P>
Instead of supplying a concrete module type, one can leave it
as a parameter. At the same time, to let the NED compiler know
what parameters and gates that module has, the user has to supply
the name of an existing module type. This is done with the <TT>like</TT>
phrase. 
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> CompoundModule
</FONT>	<B>parameters</B><FONT>:
           node_type : <B>string</B>;
	<B>gates</B>: //...
	<B>submodules</B>:
		theNode: node_type <B>like</B> GeneralNode
			<B>parameters</B>: 
</FONT>				buffer = 10;
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
The above example means that the type of the submodule <TT>theNode</TT>
is not known in advance; it will be taken from the <TT>node_type</TT>
parameter of <TT>CompoundModule</TT> which must be a string (for
example, &quot;<TT>SwitchingNode</TT>&quot;). The module type
called <TT>GeneralNode</TT> must have appeared earlier in the
NED files; its declaration will be used to check whether <TT>theNode</TT>'s
parameters and gates exist and are used correctly. The <TT>node_type</TT>
parameter will probably be given an <TT>input</TT> value somewhere
higher in the module hierarchy so that the actual module type
can be specified in the ini file or entered interactively.
<P>
The <TT>GeneralNode</TT> module type does not need to be really
implemented in C++, because no instance of it is created; it is
merely used to check the correctness of the NED file. 
<P>
On the other hand, the actual module type that will be substituted
(i.e. <TT>SwitchingNode</TT> in our case) does not need to be
declared in the NED files.
<P>
The <TT>like</TT> phrase encourages the user to create <I>families</I>
of modules that serve similar purposes and implement the same
interface (they have the same gates and parameters) and use them
interchangably in NED files. This scheme directly parallels with
the concept of <I>polimorphism</I> used in object-oriented programming.
<H4><A NAME="_Toc443041155">Submodule parameters</A></H4>
<P>
Right after the declaration, the values for the parameters of
the declared submodules can be specified. 
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> ManyParameters
</FONT>	<B>parameters</B><FONT>:
</FONT>		par1, par2, switch;
	<B>submodules</B>:
		Submod1: Node
			<B>parameters</B>:
				p1 = 10,
				p2 = par1+par2,
				p3 = switch==0 ? par1 : par2;
		//...
<B>endmodule
</B>
</PRE>
<P>
Expressions are mostly C-style, and they can contain parameters
of the compound module being defined. A separate section is dedicated
to expressions. Here, only the modes of parameter passing are
discussed.
<P>
The default parameter passing method is by value. However, the
user can write <TT>ref</TT> or <TT>ancestor</TT> before the parameter
name. Writing <TT>ref</TT> means that the parameter is not passed
by value, but by reference. This means that instead of the value
of the parameter the address of the parameter is passed.
<P>
Writing <TT>ancestor</TT> before the parameter name means that
the parameter will be searched upwards, among the parameters of
all future enclosing modules of the current module. This reference
cannot be resolved or checked by the NEDC compiler; it can only
be done at runtime, when the whole network has been built up.
The parameter which is found first is used; if no such parameter
can be found in any of the enclosing modules, the system will
give an error during runtime. 
<P>
The <TT>ancestor</TT> and <TT>ref</TT> modifiers are independent,
they can be used together.
<P>
For example:
<PRE>
<B><FONT>simple</FONT></B><FONT> sub_sub
</FONT>	<B>parameters</B><FONT>:
</FONT>		s_s_par1, s_s_par2;
<B>endmodule</B> sub_sub<BR>

<B><FONT>module</FONT></B><FONT> sub
</FONT>	<B>parameters</B><FONT>:
</FONT>		s_par;
	<B>submodules</B>:
		child: sub_sub
			<B>parameters</B>:
				s_s_par1 = <B>ref</B> s_par,
				s_s_par2 = <B>ref</B> <B>ancestor</B> m_par2;
<B>endmodule</B> sub

<B>module</B> mod
	<B>parameters</B>:
		m_par1, m_par2;
	<B>submodules</B>:
		child: sub
			<B>parameters</B>:
				s_par = m_par1;
<B>endmodule</B> mod
</PRE>
<P>
Again, note that the network description compiler can check for
the existence of ordinary parameters but not for ancestor parameters
(it cannot predict in what modules the current module will be
embedded in an actual network description).
<P>
Parameters taken by reference can be used as a second means of
module communication, because during simulation execution, if
a module changes the value of a parameter taken be reference,
the changed value propagates to other modules. <TT>ref</TT> parameters
can also be used to implement shared memory (see in Chapter 5).
<H4><A NAME="_Toc443041156">Submodule gate sizes</A></H4>
<P>
The sizes of gate vectors are defined with the <TT>gatesizes:</TT>
keyword. Gate vector sizes can be given as constants, parameters
or expressions.
<P>
An example:
<PRE>
<B><FONT>simple</FONT></B><FONT> SimpleType
</FONT>	<B>gates</B><FONT>:
		<B>in</B>: inputs[]; <B>out</B>: outputs[];
<B>endsimple

module</B> SomeCompound
	<B>parameters</B>:
		num: <B>const</B>;
	<B>submodules</B>:
</FONT>		Submod1: SimpleType
			<B>gatesizes</B>:
				inputs[10], outputs[num];
		//...
<B>endmodule
</B>
</PRE>
<H4><A NAME="_Toc443041157">Conditional parameter and gatesize
sections</A></H4>
<P>
Multiple <TT>parameters:</TT> and <TT>gatesizes:</TT> sections
can exist in a submodule definition and each of them can be tagged
with conditions.
<P>
For example:
<PRE>
<B><FONT>module</FONT></B><FONT> Serial:
</FONT>        <B>parameters</B><FONT>: count: <B>const</B>;
        <B>submodules</B>:
</FONT>                node : Node [count]
                        <B>parameters</B>:
                                position = &quot;middle&quot;;
                        <B>parameters</B> <B>if</B> index==0:
                                position = &quot;beginning&quot;;
                        <B>parameters</B> <B>if</B> index==count-1:
                                position = &quot;end&quot;;
                        <B>gatesizes</B>:
                                in[2], out[2];
                        <B>gatesizes</B> <B>if</B> index==0 or index==count-1:
                                in[1], in[1];
        <B>connections</B>:
                //...
<B>endmodule
</B>
</PRE>
<P>
If the conditions are not disjunct and a parameter value or a
gate size is defined twice, the last definition will take effect,
overwriting the former ones. Thus, values intended as defaults
should appear in the first sections.
<H3><A NAME="_Toc443041158">Connections</A></H3>
<P>
In a compound module definition, the gates of the compound module
and its immediate submodules are connected. In other words, the
NED language does not support connections that would cross &quot;the
walls&quot; of a compound module without using gates of that module.
<P>
More precisely, in an OMNeT++ model:
<OL>
<LI>every input gate of every module is connected to an output
gate at the same level, or to an input gate of the compound module;
<LI>every output gate of every module is connected to an input
gate at the same level, or to an output gate of the compound module;
<LI>an input gate of a compound is connected to an input gate
of one of its submodules;
<LI>an output gate of the compound module is connected to an output
gate of one of its submodules;
</OL>
<P>
Connections are specified in the <TT>Connections:</TT> section
of a compound module definition. It lists the connections, separated
with semicolons.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> SomeCompound:
</FONT>	<B>parameters</B><FONT>: //...
	<B>gates</B>: //...
	<B>submodules</B>: //...
	<B>connections</B>:
</FONT>		node1.output --&gt; node2.input;
		node1.input &lt;-- node2.output;
		//...
<B>endmodule
</B>
</PRE>
<P>
Each connection can be:
<UL>
<LI>direct (that is, no delay, bit error rate or data rate), can
use a named channel, or a channel given with delay, error and
data rate values;
<LI>single or multiple (loop) connection;
<LI>conditional or non-conditional.
</UL>
<P>
These connection types are described in the following sections.
<H4><A NAME="_Toc443041159">Single connections and channels</A>
</H4>
<P>
The source gate can be an output gate of a submodule or an input
gate of the compound module, and the destination gate can be an
input gate of a submodule or an output gate of the compound module.
<P>
If the user does not specify a channel, the connection will have
no propagation delay, no transmission delay and no bit errors;
it is called a <I>direct</I> connection:
<PRE>
<FONT>	Sender.outgate --&gt; Receiver.ingate;
</FONT>
</PRE>
<P>
The arrow can point either left-to-right or right-to-left.
<P>
The user can also specify a channel by its name:
<PRE>
<FONT>	Sender.outgate --&gt; Dialup14400 --&gt; Receiver.ingate;
</FONT>
</PRE>
<P>
In this case, the NED sources moust contain the definition of
the channel.
<P>
One can also specify the channel parameters directly:
<PRE>
<FONT>	Sender.outgate --&gt; error 1e-5 delay 0.001 --&gt; Receiver.ingate;
</FONT>
</PRE>
<P>
Either of the parameters can be omitted and they can be in any
order.
<H4><A NAME="_Toc443041160">Loop connections</A></H4>
<P>
If submodule or gate vectors are used, it is possible to create
more than one connection with one statement. This is termed a
<I>multiple</I> or <I>loop connection</I>.
<P>
A multiple connection is created with the <TT>for</TT> statement:
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..4 <B>do
</B></FONT>	Sender.outgate[i] --&gt; Receiver[i].ingate
<B>endfor
</B>
</PRE>
<P>
The result of the above loop connection can be illustrated as
follows:
<P>
<CENTER><IMG SRC="img00007.gif"><BR>
Fig.4.1 Loop connection</CENTER>
<P>
One can place several connections in the body of the <TT>for</TT>
statement, separated with semicolons.
<P>
More than one indices can be specified in a <TT>for</TT> statement,
with their own lower and upper bounds. This will be interpreted
as nested <TT>for</TT> statements, the leftmost index being the
outermost and the rightmost index being the innermost loop.
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..4, j=0..4 <B>do
</B></FONT>	//...
<B>endfor
</B>
</PRE>
<P>
One can also use an index in the lower and upper bound expressions
of the subsequent indices:
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..3, j=i+1..4 <B>do
</B></FONT>	//...
<B>endfor
</B>
</PRE>
<P>
In the above example, the following <I>(i,j)</I> pairs will be
used for the connections inside the <TT>for</TT> statement:
<P>
<I> (0,1) (0,2) (0,3) (0,4) (1,2) (1,3) (1,4) (2,3) (2,4) (3,4)</I>
<P>
A gate cannot be used in more than one connection and one connection
cannot be made more than once. Consider the following bogus statement:
<PRE>
<B><FONT>for</FONT></B><FONT> i = 0..2, j = 0..2 <B>do
</B></FONT>	module1.out [i] --&gt; module2.in [<I><B>i</B></I><FONT>];
</FONT><B>endfor</B>
</PRE>
<P>
It will cause a runtime error: each connection is made twice,
as the index variable <I>j</I> is not used in the connection.
In general, every connection inside a loop should use all the
index variables at both sides of the connection.
<H4><A NAME="_Toc443041161">Conditional connections</A></H4>
<P>
Connections can be conditional. This is a conditional connection:
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..n <B>do
</B></FONT>	Sender.outgate[i] --&gt; Receiver[i].ingate <B>if</B><FONT> i%2==0;
<B>endfor
</B></FONT>
</PRE>
<P>
This way we connected every second gate.
<H4><A NAME="_Toc443041162">The nocheck modifier</A></H4>
<P>
Conditional connections are especially useful with random numbers
when they can create random connections. Here, a problem can be
that by default, the simulation program checks if all gates are
connected. You can turn off this check by using the <TT>nocheck</TT>
modifier.
<P>
This example generates a random subgraph of a full graph:
<PRE>
<B><FONT>module</FONT></B><FONT> Stochastic:
</FONT><B>	parameters</B>: //..
<B>	gates</B>: //..
<B>	submodules</B>: //..

<B>	connections</B> <B>nocheck</B>:
	<B>	for</B> i=0..9 <B>do
</B>			Sender.outgate[i] --&gt; Receiver[i].ingate
								<B>if</B> uniform(0,1)&lt;0.3;
	<B>	endfor
endmodule
</B>
</PRE>
<P>
When using <TT>nocheck</TT>, it is the simple modules' responsibility
not to send messages on gates that are not connected.
<H3><A NAME="_Toc443041163">Compound module examples</A></H3>
<H4><A NAME="_Toc443041164">A router module</A></H4>
<P>
The following example contains a router module with the number
of ports taken as parameter. The compound module is built using
three module types: <TT>Application</TT>, <TT>RoutingModule</TT>,
<TT>DataLink</TT>. We assume that their definition is in a separate
NED file which we will import.
<PRE>
<B><FONT>import</FONT></B><FONT> &quot;modules&quot;;

</FONT><B>module</B> Router:
	<B>parameters</B>:
		rte_processing_delay, rte_buffersize,
		num_of_ports:<B> const</B>;
	<B>gates</B>:
		<B>in</B>: input_ports[];
		<B>out</B>: output_ports[];
	<B>submodules</B>:
		local_user: Application;
		routing: RoutingModule
			<B>parameters</B>:
				processing_delay = rte_processing_delay,
				buffersize = rte_buffersize;
			<B>gatesizes</B>:
				input[num_of_ports+1],
				output[num_of_ports+1];
		port_if: DataLink[num_of_ports]
			<B>parameters</B>:
				retry_count = 5,
				window_size = 2;
	<B>connections</B>:
		<B>for</B> i=0..num_of_ports-1 <B>do
			</B>routing.output[i] --&gt; port_if[i].from_higher_layer;
<B>			</B>routing.input[i] &lt;-- port_if[i].to_higher_layer;
<B>			</B>port_if[i].to_port --&gt; output_ports[i];
<B>			</B>port_if[i].from_port &lt;-- input_ports[i];
		<B>endfor;
		</B>routing.output[num_of_ports] --&gt; local_user.input;
<B>		</B>routing.input[num_of_ports] &lt;-- local_user.output;
<B>endmodule</B>
</PRE>
<H4><A NAME="_Toc443041165">Parametrized module structures</A>
</H4>
<P>
With the help of conditional parameter and gatesize blocks and
conditional connections, one can create complex topologies.
<P>
For example, one can create a chain of modules like this:
<PRE>
<B><FONT>module</FONT></B><FONT> Serial:
</FONT><B>	parameters</B>: count: <B>const</B>;
	<B>submodules</B>:
		node : Node [count]
<B>			gatesizes</B>:
				in[2], out[2];
			<B>gatesizes</B> <B>if</B> index==0 or index==count-1:
				in[1], out[1];
	<B>connections</B>:
		<B>for</B> i = 0..count-2 <B>do
</B>			node[i].out[i!=0 ? 1 : 0] --&gt; node[i+1].in[0];
			node[i].in[i!=0 ? 1 : 0] &lt;-- node[i+1].out[0];
		<B>endfor
endmodule
</B>
</PRE>
<P>
Building a binary tree is a good example of using conditional
connections:
<PRE>
<B><FONT>simple</FONT></B><FONT> BinaryTreeNode:
</FONT>    <B>gates</B><FONT>:
        <B>in</B>:  from_up, from_downleft, from_downright;
        <B>out</B>: upward,  downleft,      downright;
<B>endsimple

</B></FONT><B>module</B> BinaryTree:
    <B>parameters</B>: height:<B> const</B>;
    <B>submodules</B>: node: BinaryTreeNode [ 2^height-1 ];
                //....
    <B>connections</B>:
        <B>for</B> i = 0..2^height-2, j = 0..2^height-2 <B>do
</B>            node[i].upward --&gt; node[j].from_downleft  <B>if</B> leftchild(i,j);
            node[i].from_up &lt;-- node[j].downleft      <B>if</B> leftchild(i,j);
            node[i].upward --&gt; node[j].from_downright <B>if</B> rightchild(i,j);
            node[i].from_up &lt;-- node[j].downright     <B>if</B> rightchild(i,j);
        <B>endfor
</B>        //....
<B>endmodule
</B>
</PRE>
<P>
The dotted lines should be replaced by modules that close the
tree at its root and the lower edge. The leftchild(i,j) and rightchild(i,j)
functions are:
<P>
leftchild(i,j) = 
<P>
rightchild(i,j) = 
<P>
These formulas can be directly substituted in the NED description,
or alternatively, written in C and linked into the simulation
executable.
<P>
Conditional connections can also be used to generate random topologies.
The following code generates a random subgraph of a full graph:
<PRE>
<B><FONT>module</FONT></B><FONT> RandomGraph:
</FONT>	<B>parameters</B><FONT>:
		count: <B>const</B>,
</FONT>		connectedness; // 0.0&lt;x&lt;1.0
	<B>submodules</B>:
		node: Node [count]
			<B>gatesizes</B>: <B>in</B>[count], <B>out</B>[count];
	<B>connections</B> <B>nocheck</B>:
		<B>for</B> i=0..count-1, j=0..count-1 <B>do
</B>			node[i].out[j] --&gt; node[j].in[i]
				<B>if</B> i!=j and uniform(0,1)&lt;connectedness;
		<B>endfor
endmodule
</B>
</PRE>
<P>
Note that not each gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here
with the <TT>nocheck</TT> modifier. Consequently, it is the simple
modules' responsibility not to send on a gate which is not leading
anywhere.
<H4><A NAME="_Toc443041166">Using const with parametrized topologies</A>
</H4>
<P>
Since parameter values can be used in defining the internal topology
of the module, the <TT>const </TT>modifier has a significant role.
Consider the following example:
<PRE>
<B><FONT>simple</FONT></B><FONT> Sender
</FONT>	<B>parameters</B><FONT>:
</FONT>		num_of_outgates;
	<B>gates</B>:
		<B>out</B>: outgate[num_of_outgates];
<B>endsimple</B> Sender

<B>simple</B> Receiver
	<B>gates</B>:
		<B>in</B>: ingate;
<B>endsimple</B> Receiver

<B>module</B> Network;
	<B>parameters</B>:
		num_of_mods:<B> const</B>;
	<B>submodules</B>:
		sender: Sender
			<B>parameters</B>:
				num_of_outgates = <I>num_of_mods</I>;
		receiver: Receiver [<I>num_of_mods</I>]
	<B>connections</B>:
		<B>for</B> i=1..<I>num_of_mods</I> <B>do
</B>			sender.outgate[i] --&gt; receiver[i].ingate
		<B>endfor</B>;
<B>endmodule

network</B> net: Network
	<B>parameters</B>:
		num_of_mods = normal (5,2);
<B>endnetwork<BR>
</B>
</PRE>
<P>
If parameter <TT>num_of_mods</TT> wasn't <TT>const</TT>, the following
would happen:
<P>
<TT>normal(5,2</TT>) would be substituted for the <TT>num_of_mods</TT>.
There are three places where an evaluation of <TT>num_of_mods</TT>
(that is, <TT>normal (5,2)</TT>) is done (they are typed in italics
in the example). It is likely that these evaluations would not
result in the same value, and consequently, the gate vector sizes
would not match each other and the end value of the <TT>for</TT>
statement. Thus, the loop connection would not be created properly.
<P>
Using <TT>const</TT> for the parameter <TT>num_of_mods</TT> prevents
this from happening: an evaluation of <TT>normal(5,2)</TT> is
substituted for <TT>num_of_mods</TT> and an equal number of gates
are created.
<H2><A NAME="_Toc443041167">Network definition</A></H2>
<P>
A <I>network</I> <I>definition</I> (or <I>system module definition</I>)
specifies the system module. In its syntax, it is very similar
to a submodule declaration. The system definition starts with
keyword <TT>network</TT> and ends with <TT>endnetwork.</TT>
<P>
The system module cannot be multiple (only one system module can
be created).
<P>
An example:
<PRE>
<B><FONT>network</FONT></B><FONT> modellednetwork: SomeModule
</FONT>	<B>parameters</B><FONT>:
</FONT>		par1=10,
		par2=normal(100,20);
<B>endnetwork
</B>
</PRE>
<P>
Here, <TT>SomeModule</TT> is the name of a compound or a simple
module type.
<P>
There can be several system definitions in a network description,
each one defines a different network. The simulation program built
with such a network description is able to run any of them; the
desired one can be specified in the config file (see later).
<H2><A NAME="_Toc443041168">Support for parallel execution</A>
</H2>
<P>
OMNeT++ simulations can be executed in parallel. This means that
different parts of the model execute on different hosts or processors.
(We'll use the term &quot;host&quot; or &quot;machine&quot; in
this sense.) The unit of granularity is the simple module: one
simple module always executes on a single processor.
<P>
Parallel execution is also supported by NED: the language provides
an elegant way of specifying execution hosts for different modules.
We'll discuss this feature in the following sections.
<H3><A NAME="_Toc443041169">Extensions to the compound module
and system definitions</A></H3>
<P>
To support the segmentation of the model for execution of different
modules, the compound module definition was extended with the
<TT>machines:</TT> and the <TT>on:</TT> keywords.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> SomeNameForCompoundModule
</FONT>	<B>machines</B><FONT>: host1, host2, host3, host4;
	<B>parameters</B>: //...
	<B>gates</B>: //...
	<B>submodules</B>: 
</FONT>		submodule1 : submodtype1
			<B>on:</B> host1;
		submodule2 : submodtype2
			<B>on:</B> host2, host3;
		submodule3 : submodtype1
			<B>on:</B> host4;
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
The <TT>machines:</TT> section lists formal host names which are
used in the <TT>on:</TT> lists of the submodules.
<P>
In the example, the second submodule is itself a compound module
that can be further subdivided to run on two separate hosts, so
its definition must have a <TT>machines:</TT> section with two
parameters. You do not have to propagate host names down to simple
module level: you can stop at a compound module which executes
on a single host. In other words, a compound module with no <TT>machines:</TT>
section is equivalent to one with one machine parameter.
<P>
Of course, you can give the same value to several machine parameters,
as to <TT>submodule1</TT>'s in the following example. In this
case, the whole compound module will be placed on a single host,
as if it never had machine parameters at all.
<PRE>
<B><FONT>module</FONT></B><FONT> AnotherCompoundModule
</FONT>	<B>machines</B><FONT>: host1, host2;
	<B>parameters</B>: //...
	<B>gates</B>: //...
	<B>submodules</B>: 
</FONT>		submodule1 : submodtype1
			<B>on:</B> host1, host1, host1;
		//...
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
Host names propagate up to network definition level. Extension
to the network definition:
<PRE>
<B><FONT>network</FONT></B><FONT> distvector: DistVector
</FONT>	on: machine1, machine2, machine3;
<B>endnetwork
</B>
</PRE>
<P>
The <TT>on:</TT> parameters of the network definition can be actual
host names, or alternatively, they can be symbolic names that
are mapped to actual host names in the config file.
<H3><A NAME="_Toc443041170">Conditional on: sections</A></H3>
<P>
Similarly to the <TT>parameters:</TT> and <TT>gatesizes:</TT>
section, multiple <TT>on:</TT> sections can exist for the submodules
if they are tagged with <TT>if</TT> phrases.
<P>
This makes it possible to control the module distribution with
parameters. You can even put different parts of a module vector
on different machines using the <TT>index</TT> operator (see later
in the section describing expressions).
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> DistVector:
</FONT><B>	machines</B>: host1, host2, host3;
	<B>submodules</B>:
		node : Node [count]
			<B>on</B> <B>if</B> index&lt;count*.33: host1;
			<B>on</B> <B>if</B> index&gt;=count*.33 and index&lt;count*.66: host2;
			<B>on</B> <B>if</B> index&gt;=count*.66: host3;
<B>endmodule

network</B> distvector: DistVector
	on machine1, machine2, machine3;
<B>endnetwork
</B>
</PRE>
<H2><A NAME="_Toc443041171">Expressions</A></H2>
<P>
In the NED language there are a number of places where expressions
are expected.
<P>
When such an expression is encountered by the NEDC compiler, it
is compiled and it will be evaluated run-time.
<P>
Expressions have a C-style syntax. They are built with the usual
math operators; they can use parameters taken by value or by reference;
call C functions; contain random and input values etc.
<H3><A NAME="_Toc443041172">Using parameters in expressions (ref
and ancestor)</A></H3>
<P>
Expressions can use the parameters of the compound module being
built. A parameter can be taken by value or by reference. The
default is by value; to select by-reference passing for a parameter,
you have to use the <TT>ref</TT> modifier. Parameters passed by
reference can be used by a module to propagate values (status
info etc.) to other modules.
<P>
The <TT>ancestor</TT> modifier allows one to access parameters
from higher in the module hierarchy.
<PRE>
<B><FONT>module</FONT></B><FONT> Compound
</FONT>	<B>parameter</B><FONT>: nnn;
	<B>submodules</B>:
</FONT>		proc: Processor
			<B>parameters</B>: par1 = <B>ref</B> nnn / 2,
			            par2 = 10 * <B>ancestor</B> par_somewhere_up;
<B>endmodule</B>
</PRE>
<H3><A NAME="_Toc443041173">Operators</A></H3>
<P>
The following operators can be used in expressions, in order of
precedence:<TABLE BORDER=1>
<TR><TD WIDTH=89>
<PRE>
<B><FONT>operator</FONT></B>
</PRE>

</TD><TD WIDTH=277><PRE>
<B>meaning</B>
</PRE>
</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>-, !, ~</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
unary minus, negation, bitwise complement</PRE>

</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>^</FONT>
</PRE>
</TD><TD WIDTH=277><PRE>
power of</PRE>

</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>*, /, %</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
multiply, divide, modulus</PRE>
</TD>
</TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>+, -</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
add, substract</PRE>
</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&lt;&lt;, &gt;&gt;</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
bitwise shifting</PRE>
</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&amp;, |, #</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
bitwise and, or, xor 
  <I>(^ is reserved for power)</I>
</PRE>

</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>==</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
equal</PRE>
</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>!=</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
not equal</PRE>
</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&gt;, &gt;=</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
greater, greater or equal</PRE>
</TD>
</TR>
<TR><TD WIDTH=89><PRE>
<FONT>&lt;, &lt;=</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
less, less or equal</PRE>
</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>?:</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
the C/C++ &quot;inline if&quot;</PRE>
</TD>
</TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&amp;&amp;, ||, ##</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
logical operators and, or, xor</PRE>

</TD></TR>
</TABLE>
<H3><A NAME="_Toc443041174">The sizeof() and index operators</A>
</H3>
<P>
A useful operator is <TT>sizeof()</TT>, which gives the size of
a vector gate. The <TT>index</TT> operator gives the index of
the current submodule in its module vector.
<P>
An example for both:
<PRE>
<B><FONT>module</FONT></B><FONT> Compound
</FONT>	<B>gates</B><FONT>: <B>in</B>: fromgens[];
	<B>submodules</B>:
		proc: Processor[ <B>sizeof</B>(fromgens) ];
			<B>parameters</B>: address = 10*(1+<B>index</B>);
	<B>connections</B>:
		<B>for</B> i = 0 .. <B>sizeof</B>(fromgens)-1 <B>do
</B></FONT>			in[i] --&gt; proc[i].input;
		<B>endfor
endmodule
</B>
</PRE>
<P>
Here, we create as many processors as there are input gates for
this compound module in the network. The <TT>address</TT> parameters
of the processors are 10, 20, 30 etc.
<H3><A NAME="_Toc443041175">Time constants</A></H3>
<P>
Anywhere you would put numeric constants (integer or real) to
mean time in seconds, you can also specify the time in units like
milliseconds, minutes or hours:
<PRE>
<FONT>   ...
</FONT>   <B>parameters</B><FONT>: propagation_delay = 560ms,          // 0.560s
</FONT>               connection_timeout = 6m 30s 500ms,  // 390.5s
               lunchtime = 0.5h;                   // 30 min
</PRE>
<P>
The following units can be used:
<TABLE BORDER=1>
<TR><TD WIDTH=75><CENTER><TT>ns</TT></CENTER></TD><TD WIDTH=150>nanoseconds
</TD><TD WIDTH=93>*10<SUP>-9</SUP></TD></TR>
<TR><TD WIDTH=75><CENTER><TT>us</TT></CENTER></TD><TD WIDTH=150>microseconds
</TD><TD WIDTH=93>*10<SUP>-6</SUP></TD></TR>
<TR><TD WIDTH=75><CENTER><TT>ms</TT></CENTER></TD><TD WIDTH=150>milliseconds
</TD><TD WIDTH=93>*10<SUP>-3</SUP></TD></TR>
<TR><TD WIDTH=75><CENTER><TT>s</TT></CENTER></TD><TD WIDTH=150>seconds
</TD><TD WIDTH=93>*1</TD></TR>
<TR><TD WIDTH=75><CENTER><TT>m</TT></CENTER></TD><TD WIDTH=150>minutes
</TD><TD WIDTH=93>*60</TD></TR>
<TR><TD WIDTH=75><CENTER><TT>h</TT></CENTER></TD><TD WIDTH=150>hours
</TD><TD WIDTH=93>*3600</TD></TR>
<TR><TD WIDTH=75><CENTER><TT>d</TT></CENTER></TD><TD WIDTH=150>days
</TD><TD WIDTH=93>*60*3600</TD></TR>
</TABLE>
<P>
<H3><A NAME="_Toc443041176">Random values</A></H3>
<P>
OMNeT++ has the following predefined distributions:
<UL>
<LI>uniform, uniform integer
<LI>exponential
<LI>normal, truncated normal
</UL>
<P>
Each distribution has one or more parameters. 
<P>
Examples:
<PRE>
<FONT>uniform(0,1)       // uniform in [0,1)
</FONT>intuniform(-2,2)   // uniform int, limits included: -2,-1,0,1,or 2
exponential(5)     // exponential with mean=5 (thus parameter=0.2)
normal(100,5)      // mean 100, variance 5
truncnormal(5,3)   // normal distr, truncated to nonnegative values
</PRE>
<P>
The functions all use the random number generator 0. By using
the <TT>genk_</TT>-prefixed versions of the above functions, you
can specify which generator should be used. The index of the generator
comes as the first argument.
<P>
Example:
<PRE>
<FONT>genk_normal(2,100,5)      // as normal(100,5), using generator 2
</FONT>
</PRE>
<P>
The above distributions are implemented with C functions (see
later in the Functions section). This also means that you can
easily add further ones by writing their code in C++ and using
the <TT>Register_Function</TT> macro. Your distributions will
be treated in the same way as the built-in ones.
<H3><A NAME="_Toc443041177">Input value</A></H3>
<P>
The syntax is:
<PRE>
<B><FONT>input</FONT></B><FONT>( 10, &quot;Number of processors:&quot; )
</FONT>
</PRE>
<P>
Or you can omit the prompt text:
<PRE>
<B><FONT>input</FONT></B><FONT>( 10ms )
</FONT>
</PRE>
<P>
Value for input parameters can be given in the config file. If
they are not there, the user will be offered a prompt to enter
the value.
<H3><A NAME="_Toc443041178">Functions</A></H3>
<P>
In NED expressions, you can use mathematical functions:
<UL>
<LI>many of the C language's <TT>&lt;math.h&gt;</TT> library functions:
<TT>exp()</TT>, <TT>log()</TT>, <TT>sin()</TT>, <TT>cos()</TT>,
<TT>floor()</TT>, <TT>ceil()</TT>, etc. 
<LI>functions that generate random variables: <TT>uniform</TT>,
<TT>exponential</TT>, <TT>normal</TT> and others were already
discussed.
<LI>user defined functions that can implement new functions or
yield random variables of distributions that are originally not
built in.
</UL>
<P>
To use user-defined functions, one has to code the function in
C++.  The C++ function must take 0, 1, 2, or 3 arguments of type
<TT>double</TT> and return a <TT>double</TT>. The function must
be registered in one of the C++ files with the <TT>Define_Function()</TT>
macro. 
<P>
An example function (the following code must appear in one of
the C++ sources):
<PRE>
<FONT>double average(double a, double b)
</FONT>{
  return (a+b)/2;
}

Define_Function(average, 2)<BR>
</PRE>
<P>
The number 2 means that the <TT>average()</TT> function has 2
arguments. After this, the <TT>average()</TT> function can be
used in NED files:
<PRE>
<B><FONT>module</FONT></B><FONT> Compound
</FONT>	<B>parameter</B><FONT>: a,b;
	<B>submodules</B>:
</FONT>		proc: Processor
			<B>parameters</B>: av = average(a,b);
<B>endmodule
</B>
</PRE>
<P>
An important application of this concept is to extend OMNeT++
with new distributions. 
<H2><A NAME="_Toc443041179">A complete NED example</A></H2>
<P>
This section contains an example to clarify the grammar of the
NED language.
<PRE>
<B><FONT>import</FONT></B><FONT> &quot;simmodules&quot;;

</FONT><B>channel</B> Wire
	<B>error</B> = 0.3
	<B>delay</B> = 1
<B>endchannel

module</B> Sender_def
	<B>parameters</B>:
		Packets;
	<B>gates</B>:
		<B>in</B>: AckIn;
		<B>out</B>: POut;
	<B>submodules</B>:
		Source: msgGenerator
			<B>parameters</B>:
				Gap = input,
				MsgLen = 512,
				Packets = Packets;
		Transmitter: msgTransmitter
			<B>parameters</B>:
				TimeOut = input( &quot;Give the timeout length&quot; )
	<B>connections</B>:
		Source.O --&gt; Transmitter.Pi
		Transmitter.Po --&gt; POut
		AckIn --&gt; Transmitter.Ak
<B>endmodule

module</B> Receiver_def
	<B>parameters</B>:
		Packets;
	<B>gates</B>:
		<B>in</B>: PIn;
		<B>out</B>: AckOut;
	<B>submodules</B>:
		Drain: msgDrain
		Receiver: msgReceiver
			<B>parameters</B>:
				Packets = Packets;
	<B>connections</B>:
		Receiver.Po --&gt; Drain.In
		PIn --&gt; Receiver.Pi
		Receiver.Ak --&gt; AckOut
<B>endmodule

module</B> SAW_def
	<B>parameters</B>: Packets;
	<B>submodules</B>:
		Sender: Sender_def
			<B>parameters</B>:
				Packets = Packets;
		Receiver: Receiver_def
			<B>parameters</B>:
				Packets = Packets;
	<B>connections</B>:
		Sender.POut --&gt; Wire --&gt; Receiver.PIn
		Receiver.AckOut --&gt; Wire --&gt; Sender.AckIn
<B>endmodule

network</B> StopAndWait: SAW_def
	<B>parameters</B>:
		Packets = input(10,&quot;Give the number of packets&quot;);
<B>endnetwork
</B>
</PRE>
<P>
This is a network description of a simple Stop-and-Wait system.
<P>
First, the channel <TT>Wire</TT> is defined. After that, three
different modules are defined: <TT>Sender_def</TT>, <TT>Receiver_def</TT>
and <TT>SAW_def</TT>. All these predefined modules are used in
the final system module <TT>StopAndWait</TT>.
<P>
Each module definition contains parameters, gates, submodules
and connections, except the module <TT>SAW_def</TT>, which has
no gates. 
<P>
<TT>Sender_def</TT> and <TT>Receiver_def</TT> both only contain
direct connections, while <TT>SAW_def</TT> contains only connections
of the channel type <TT>Wire</TT> which has been defined at the
beginning of the network description.
<P>
The parameter values which are needed for the submodules are given
explicitly (<TT>Packets = Packets</TT>). In case of the module
<TT>Receiver_def</TT> this means that the submodule <TT>msgReceiver</TT>
needs a value for its parameter called <TT>Packets</TT>; that's
the one on the left side of the equation. This value will be the
value after evaluation of the expression <TT>Packets</TT>, the
one on the right side of the equation.
<H2><A NAME="_Toc443041180">GNED - a graphical topology editor</A>
</H2>
<P>
The GNED editor allows you to design compound modules graphically.
You can save compound modules into files with <TT>.gnd</TT> extension
(one compound module per file). You can generate NED files from
within GNED or with a utility (<TT>gnd2view</TT>). GNED supports
multiple editing windows. A more complete description can be found
in the GNED <TT>readme</TT> file.
<P>
Requirements: Tcl7.6 and Tk4.2
<HR><H1><A NAME="_Toc443041181">Writing simple modules</A></H1>
<P>
The activities of simple modules are implemented by the user.
The algorithms are programmed in C++, using the OMNeT++ class
library. Simple module types are created by deriving a new class
from <TT>cSimpleModule</TT> and redefining the <TT>activity()</TT>
virtual member function. The class library of OMNeT++ offers a
collection of general and simulation related classes.
<P>
The next section contains an overview of the most important functions
and objects you can use to implement simple modules.
<H2><A NAME="_Toc443041182">Defining simple module types</A></H2>
<H3><A NAME="_Toc443041183">Writing a simple module</A></H3>
<P>
A simple module has a C++ source (<TT>.cc</TT> file) and a corresponding
module definition in a NED file (<TT>.ned</TT>). The NED file
definition of a sliding window protocol implementation might look
like this:
<PRE>
<FONT>// file: swp.ned

</FONT><B>simple</B> SlidingWin
        <B>parameters</B>:
                <B>const</B> window_size;
        <B>gates</B>:
                <B>in:</B>  from_net, from_user;
                <B>out:</B> to_net,   to_user;
<B>endsimple
</B>
</PRE>
<P>
The C++ source of the same simple module type might be like that
(at simplest):
<PRE>
<FONT>//------------------------------------
</FONT>// file: swp.cc

#include &quot;omnetpp.h&quot;

class SlidingWin : public cSimpleModule
{
	Module_Class_Members( SlidingWin,cSimpleModule,8192)
	virtual void activity();
};

Define_Module( SlidingWin )

void SlidingWin::activity()
{
     int window_size = par(&quot;window_size&quot;);

     //...
}
</PRE>
<P>
The meaning of the above will be explained in the following sections.
<H3><A NAME="_Toc443041184">The simple module class</A></H3>
<P>
Each simple module type is implemented as a C++ class derived
from <TT>cSimpleModule</TT>. 
<P>
The <TT>activity()</TT> virtual member function should be redefined
to contain the actual algorithm the simple module is supposed
to do.
<P>
The <TT>Module_Class_Members()</TT> line is a macro that expands
to member function definitions (constructor, etc.), hiding the
details from the user. The three arguments it takes are the class
name, the base class (usually <TT>cSimpleModule</TT>), and the
coroutine stack size:
<PRE>
<FONT>Module_Class_Members( <I>moduleclass</I>, <I>baseclass</I>, <I>stacksize</I>)
</FONT>
</PRE>
<P>
Stack size needs some explanation. Module activities are run as
coroutines, so each module needs to have a separate stack. 8 kbytes
is usually a good choice, but you may need more if the module
uses recursive functions or has local variables taking up a lot
of stack space. OMNeT++ has a built-mechanism that will detect
- most of the time - if the module stack is too small and overflows.<SUP>(NEW)</SUP>
<H3><A NAME="_Toc443041185">The Define_Module() macro</A></H3>
<P>
The <TT>Define_Module(SlidingWin)</TT> line is a macro which declares
that you are going to use the <TT>Game</TT> class as a simple
module class. The macro is internally compiled into an object
(class <TT>cModuleType</TT>) which will 'know' how to create a
<TT>SlidingWin</TT> object. This macro allows the creation of
a module (simple or compound) when only its name is avaliable
as a string, so you won't need to include the class declaration
wherever you're creating a module of this type.
<P>
Also, the <TT>Define_Module(SlidingWin)</TT> macro associates
the module class with the <TT>SlidingWin</TT> simple module declaration
in the NED file. Whenever a module of type <TT>SlidingWin</TT>
is created, it will automatically have the parameters and gates
you described in the corresponding NED file.
<P>
The NEDC compiler generates <TT>Define_Module(..)</TT> lines for
all compound modules. However, it is your responsibility to put
<TT>Define_Module(..)</TT> lines into one of the C++ sources for
all your simple module types.
<H3><A NAME="_Toc443041186">Decomposing the activity</A></H3>
<P>
The user can decompose a large <TT>activity()</TT> function into
several smaller functions that would then be declared as other
member functions. At the same time, if you have variables which
you want to access from all member functions (typically state
variables are like that), you can add those variables to the class
as data members. You can also add objects as data members.
<PRE>
<FONT>class SlidingWin : public cSimpleModule
</FONT>{
  public:
    Module_Class_Members( SlidingWin, cSimpleModule,8192)

    int window_size;
    int n_s;   // N(s)
    int n_r;   // N(r)
    cOutVector eedVector;
    cStdDev eedStats;
    //...

    virtual void activity();
    virtual void receive(cMessage *packet);
    virtual void send(cMessage *packet);
    //...
};

Define_Simple_Module( SlidingWin )

void SlidingWin::activity()
{
    window_size = par(&quot;window_size&quot;);
    n_s = n_r = 0;
    eedVector.setName(&quot;End-to-End Delay&quot;);
    eedStats.setName(&quot;eedStats&quot;);

    //...
}

//...
</PRE>
<P>
Unfortunately you won't be able to pass arguments to the constructors
of objects like <TT>eedVector</TT> and <TT>eedStats</TT> above
unless you break up the <TT>Module_Class_Members()</TT> macro
and write the constructor by hand. But most often you don't need
to go as far as that; for example, you can set parameters later
from <TT>activity()</TT>, as shown in the example above.
<P>
If something still needs to be initialized by the constructor,
then the <TT>Module_Class_Members()</TT> macro cannot be used.
 In this case, the code would look like this:
<PRE>
<FONT>class FDDI_MAC : public cSimpleModule
</FONT>{
   public:
    int state;
    cQueue packet_queue;

    FDDI_MAC(char *name, cModule *parentmodule,
                         unsigned stacksize = 8192);
    virtual char *isA() {return &quot;FDDI_MAC&quot;;}

    virtual void activity();
    //... other member functions
};

FDDI_MAC::FDDI_MAC(char *name, cModule *parentmodule, unsigned stksiz) :
  cSimpleModule( name, parentmodule, stksiz),
  packetQueue( &quot;packet-queue&quot; )
{
    state = FDDI_IDLE;
}
</PRE>
<P>
Note the constructor and the <TT>isA()</TT> function in the class
declaration. The <TT>isA()</TT> function of all OMNeT++ classes
return the class name.
<P>
You should not change the number etc. of the arguments to the
constructor, since the simple module is created by the simulation
kernel using this format. 
<P>
The last argument passed to <TT>cSimpleMod</TT>'s constructor
is the stack size.
<H3><A NAME="_Toc443041187">Writing statistics at the end of the
simulation</A></H3>
<P>
When a simulation completes, the simulation kernel calls the <TT>finish()</TT>
member functions of all simple modules. Typical use of <TT>finish()</TT>
is to record summary statistics. An example:
<PRE>
<FONT>class SlidingWin : public cSimpleModule
</FONT>{
  public:
    //...
    cStdDev eedStats;

    //...
    virtual void finish();
};

//...

void SlidingWin::finish()
{
    writeScalar(&quot;Average End-to-End Delay&quot;, eedStats.mean());
}
</PRE>
<H3><A NAME="_Toc443041188">Using header files</A></H3>
<P>
If you want to put your simple module class declarations into
a separate header file (<TT>.h</TT>), go ahead and do it. The
<TT>Define_Module()</TT> line must stay in the <TT>.cc</TT> file,
because the C++ compiler produces code from it which is not supposed
to be replicated in each file where the header is included. 
<P>
Example:
<PRE>
<FONT>//------------------------------------
</FONT>// header file: proc.h

#include &quot;omnetpp.h&quot;

// module class:
class Processor : public cSimpleModule
{
	Module_Class_Members( Processor,cSimpleModule,8192)
	virtual void activity();
};


//------------------------------------
// cc file: proc.cc

Define_Module( Processor )

void Processor::activity()
{
     // simple module activity...
}
</PRE>
<H3><A NAME="_Toc443041189">Several modules with the same interface</A>
</H3>
<P>
You can write several modules that all have a single interface
defined once in a NED file. In this case, you should use the <TT>Define_Module_Like()</TT>
macro instead of the simple <TT>Define_Module()</TT>. An example:
<PRE>
Define_Module_Like( TokenRing_MAC, General_MAC)
Define_Module_Like( Ethernet_MAC, General_MAC)
Define_Module_Like( FDDI_MAC, General_MAC)
</PRE>
<P>
This feature is a natural accessory of the NED language's <TT>like</TT>
phrase.
<H2><A NAME="_Toc443041190">About the classes in the simulation
class library</A></H2>
<H3><A NAME="_Toc443041191">Conventions</A></H3>
<P>
Classes in the OMNeT++ simulation library are derived from <TT>cObject</TT>,
thus they share some features. An object can be assigned a name
(a character string). The name string is the first argument to
the constructor of every class, and it defaults to <TT>NULL</TT>
(no name string). If you supply a name string, the object will
make its own copy (<TT>strdup</TT>). As an example, you can create
a message object like this:
<PRE>
<FONT>cMessage *msg = new cMessage( &quot;object-name&quot; );
</FONT>
</PRE>
<P>
You can also set the name after the object has been created:
<PRE>
<FONT>msg-&gt;setName( &quot;new-name&quot; );
</FONT>
</PRE>
<P>
You can get a pointer to internally stored copy of the <TT>&quot;object-name&quot;</TT>
string like this:
<PRE>
<FONT>char *namestr = msg-&gt;name();
</FONT>// --&gt; returns ptr to internal copy of &quot;object-name&quot;
</PRE>
<P>
For convenience and efficiency reasons, the empty string <TT>&quot;&quot;</TT>
and <TT>NULL</TT> string are regarded as interchangeable by library
objects:  <TT>&quot;&quot;</TT> is stored as <TT>NULL</TT> (so
that it does not consume heap), but it is returned as <TT>&quot;&quot;</TT>
(so that it is easier to print out etc). Thus, if you create a
message object with either <TT>NULL</TT> or <TT>&quot;&quot;</TT>
as name, it will be stored as <TT>NULL</TT> and <TT>name()</TT>
will return a pointer to <TT>&quot;&quot;</TT> (a static string):
<PRE>
<FONT>cMessage *msg = new cMessage(NULL, &lt;additional args&gt;);
</FONT>char *namestr = msg-&gt;name();
//   --&gt; returns ptr to &quot;&quot;
</PRE>
<P>
Member functions that set and query object attributes follow consistent
naming. The setting member function has the form <TT>setSomething(...)</TT>
and its counterpart is <TT>something()</TT>. 
<PRE>
<FONT>msg-&gt;setLength( 1024 );
</FONT>length = msg-&gt;length();
</PRE>
<P>
Classes inherit and redefine several <TT>cObject</TT> member functions;
now we discuss the practically most important ones. For each class,
the <TT>isA()</TT> member function returns the class name as a
string; you can use it in displaying debugging messages etc.
<PRE>
<FONT>char *classname = msg-&gt;isA();
</FONT>//   --&gt; returns &quot;cMessage&quot;
</PRE>
<P>
The <TT>dup()</TT> member function creates an exact copy of the
object, duplicating contained objects also if necessary. This
is especially useful in the case of message objects. <TT>dup()</TT>
returns a pointer of type <TT>cObject *</TT>, so it needs to be
casted to the proper type:
<PRE>
<FONT>cMessage *copyMsg = (cMessage *) msg-&gt;dup();
</FONT>
</PRE>
<P>
<TT>dup()</TT> works through calling the copy constructor, which
in turn relies on the assignment operator between objects. <TT>operator=()
</TT>can be used to copy contents of an object into another object
of the same type. The copying is done properly; object contained
in the object will also be duplicated if necessary. For various
reasons, <TT>operator=()</TT> does not copy the name string; the
copy constructor does it.
<P>
There are several container classes in the library (<TT>cQueue</TT>,
<TT>cArray</TT> etc.) For many of them, there is a corresponding
iterator class that you can use to loop through the objects stored
in the container. For example:
<PRE>
<FONT>cQueue queue;
</FONT>//..
for (cQueueIterator queueIter(queue); !queueIter.end(); queueIter++)
{
    cObject *containedObject = queueIter();
}
</PRE>
<P>
By default, if a container object is destroyed, it destroys the
contained objects too. If you call <TT>dup()</TT>, the contained
objects are duplicated too for the new container. This is done
so because contained objects are owned by the container; ownership
is defined as the right/duty of deallocation. However, there is
a fine-grain ownership control mechanism built in which allows
you to specify on per-object basis whether you want objects to
be owned by the container or not; by calling the <TT>takeOwnership()</TT>
member function with <TT>FALSE</TT>, you tell the container that
you don't want it to become the owner of objects that will be
inserted in the future. You can explicitly select an owner for
any object by calling its <TT>setOwner()</TT> member function.
<H3><A NAME="_Toc443041192">Warnings and errors</A></H3>
<P>
Some container classes and functions suspend the simulation and
issue warning messages in potentially bogus/dangerous situations,
for example when an object is not found and NULL pointer/reference
is about to be returned. Very often this is useful, but sometimes
it is more trouble. You can turn warnings on/off from the ini
file (warnings=yes/no).
<P>
It is a good practice to leave warnings enabled, and temporarily
disable warnings in places where OMNeT++ would normally issue
warnings but you know the code is correct. This is done in the
following way:
<PRE>
<FONT>bool w = simulation.warnings();
</FONT>simulation.setWarnings( FALSE );
...
... // critical code
...
simulation.setWarnings( w );
</PRE>
<P>
If your simulation detects an error condition and wants to stop
the simulation, you can do it with the <TT>error()</TT> member
function of <TT>cModule</TT>. It is used like <TT>printf()</TT>:
<PRE>
<FONT>if (windowSize&lt;1)
</FONT>    error(&quot;Invalid window size %d; must be &gt;=1&quot;, windowSize);
</PRE>
<P>
Do not include a newline (<TT>&quot;\n&quot;</TT>) or punctuation
(period or exclamation mark) in the printed-out text, it will
be added by OMNeT++.
<H2><A NAME="_Toc443041193">Accessing module parameters and gates</A>
</H2>
<H3><A NAME="_Toc443041194">Module parameters</A></H3>
<P>
Module parameters can be accessed with the <TT>par()</TT> member
function of <TT>cModule</TT>:
<PRE>
<FONT>cPar&amp; delay_par = par(&quot;delay&quot;);
</FONT>
</PRE>
<P>
The <TT>cPar</TT> class is a general value-storing object. It
supports type casts to numeric types, so parameter values can
be read like this:
<PRE>
<FONT>int num_tasks = par(&quot;num_tasks&quot;);
</FONT>double proc_delay = par(&quot;proc_delay&quot;);
</PRE>
<P>
If the parameter is a random variable or its value can change
during execution, it is best to store a reference to it and re-read
the value each time it is needed:
<PRE>
<FONT>cPar&amp; wait_time = par(&quot;wait_time&quot;);

</FONT>for(;;)
{
    //...
    wait( (simtime_t)wait_time );
}
</PRE>
<P>
(<TT>simtime_t</TT> is defined as <TT>double</TT>.)
<P>
Parameter values can also be changed during execution. If the
parameter was taken by reference (with a <TT>ref</TT> modifier
in the NED file), other modules will also see the change. Thus,
parameters taken by reference are an alternative means of module
communication.
<P>
An example:
<PRE>
<FONT>par(&quot;wait_time&quot;) = 0.12;
</FONT>
</PRE>
<P>
Or:
<PRE>
<FONT>cPar&amp; wait_time = par(&quot;wait_time&quot;);
</FONT>wait_time = 0.12;
</PRE>
<P>
See <TT>cPar</TT> explanation later in this manual and in the
Reference Manual for further information on how to change a <TT>cPar</TT>'s
value.
<H3><A NAME="_Toc443041195">Gates and gate vectors</A></H3>
<P>
Module gates (single and vector) are stored in a module in an
array. The gate's position in the gate array is called the gate
ID.
<P>
For a module with input gates <TT>from_app</TT> and <TT>in[3]</TT>
and output gates of <TT>to_app</TT> and<TT> status</TT>, the array
may look like this:
<TABLE BORDER=1>
<TR><TD WIDTH=54><CENTER><B>ID</B></CENTER></TD><TD WIDTH=84><CENTER><B>dir</B></CENTER>
</TD><TD WIDTH=162><CENTER><B>name[index]</B></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>0</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>from_app</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>1</CENTER></TD><TD WIDTH=84><CENTER><I>output</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>to_app</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>3</CENTER></TD><TD COLSPAN=2 WIDTH=246><CENTER><I>empty</I></CENTER>
</TD></TR>
<TR><TD WIDTH=54><CENTER>2</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>in[0]</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>3</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>in[1]</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>4</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>in[2]</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>5</CENTER></TD><TD WIDTH=84><CENTER><I>output</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>status</TT></CENTER></TD></TR>
</TABLE>
<P>
<P>
The array may have empty slots. Gate vectors are guaranteed to
occupy contiguous IDs.<FONT> </FONT>
<P>
Message sending and receiving functions accept both gate names
and gate IDs, but the functions using gates IDs are faster. Gate
IDs do not change during execution, so it is often worth retrieving
them in advance and using them instead of gate names.
<P>
Gate IDs can be determined in the following way:
<PRE>
<FONT>int to_app_gate = findGate(&quot;to_app&quot;);
</FONT>
</PRE>
<P>
Or for an element of a vector gate:
<PRE>
<FONT>int in2_gate = findGate(&quot;in&quot;,2);
</FONT>
</PRE>
<P>
The <TT>gate()</TT>member function of <TT>cModule</TT> returns
a pointer to a <TT>cGate</TT> object, the gate itself.
<P>
The size of a vector gate can be obtained by:
<PRE>
<FONT>int in_gate_size = gate(&quot;in&quot;)-&gt;size();
</FONT>
</PRE>
<P>
If the gate is an output gate, the gate to which it is connected
is obtained by the <TT>toGate()</TT> member function:
<PRE>
<FONT>ev &lt;&lt; &quot;gate 'out' connects to &quot; &lt;&lt; gate(&quot;out&quot;)-&gt;toGate()-&gt;fullPath();
</FONT>
</PRE>
<P>
The reverse of <TT>toGate() </TT>is <TT>fromGate()</TT>.
<P>
To find out to which simple module a given output gate leads finally,
you have to walk along the path:
<PRE>
<FONT>cGate *gate = gate(&quot;out&quot;);
</FONT>while (gate-&gt;toGate()!=NULL) gate = gate-&gt;toGate();
cModule *destmod = gate-&gt;ownerModule();
</PRE>
<P>
See the Reference Manual for other <TT>cGate</TT> member functions.
<H2><A NAME="_Toc443041196">Messages</A></H2>
<H3><A NAME="_Toc443041197">The message class: cMessage</A></H3>
<P>
A <TT>cMessage</TT> message has name, kind, length, priority,
error flag and time stamp members. The <TT>cMessage</TT> object
can be created in the following way:
<PRE>
<FONT>cMessage *msg = new cMessage( &quot;msg-name&quot;, kind, length, priority, errorflag);
</FONT>
</PRE>
<P>
The <TT>kind</TT>, <TT>length</TT>, and <TT>priority</TT> are
integers, and <TT>errorflag</TT> is boolean. All arguments have
default values, so the following initializations are also valid:
<PRE>
<FONT>cMessage *msg1 = new cMessage;
</FONT>cMessage *msg2 = new cMessage(&quot;data-packet&quot;, DATAPACKET_KIND, 8*1500 );
</PRE>
<P>
The message members:
<UL>
<LI>The <I>message kind</I> field is supposed to carry some mesage
type information. Zero and positive values can be freely used
for any purpose. Negative values are reserved for use by the OMNeT++
simulation library; especially, <TT>MK_PACKET</TT> (-1) and <TT>MK_INFO</TT>
(-2) are used to denote that the message is a network packet (see
the <TT>cPacket</TT> class later).<SUP>(NEW)</SUP>
<LI>The <I>length</I> field (understood in bits) is used to compute
transmission delay when the message travels through a connection
that has an assigned data rate. 
<LI>The <I>error flag</I> field is set to <TT>TRUE</TT> with a
probability of 1-(1-<I>ber</I>)<I><SUP>length</SUP></I> when the
message is sent through a connection that has an assigned bit
error rate (<I>ber</I>).
<LI>The <I>time stamp</I> field is not used by the simulation
kernel; you can use it for any purpose. 
<LI>The <I>priority</I> field is used by the simulation kernel
to order messages in the message queue (FES) that have the same
arrival time values.
</UL>
<P>
Once a message has been created, its data members can be changed
by the following functions:
<PRE>
<FONT>msg-&gt;setKind( kind );
</FONT>msg-&gt;setLength( length );
msg-&gt;setPriority( priority );
msg-&gt;setError( err );
msg-&gt;setTimestamp();
msg-&gt;setTimestamp( simtime );
</PRE>
<P>
With these functions the user can set the message kind, the message
length, the priority, the error flag and the time stamp. The <TT>setTimeStamp()</TT>
function without any argument sets the time stamp to the current
simulation time. Other functions that manipulate messages can
be found in the OMNeT++ class library reference manual.
<P>
The values can be obtained by the following functions:
<PRE>
<FONT>int k = msg-&gt;kind();
</FONT>int p = msg-&gt;priority();
int l = msg-&gt;length();
bool b = msg-&gt;isbad();
bool g = msg-&gt;isgood();
simtime_t t = msg-&gt;timestamp();
</PRE>
<P>
The message's creation time can be obtained by: 
<PRE>
<FONT>simtime_t t = msg-&gt;creationTime();</FONT>
</PRE>
<H3><A NAME="_Toc443041198">Attaching parameters and objects to
a  message</A></H3>
<P>
A <TT>cMessage</TT> object can be attached a list of parameters.
Parameters are objects of <TT>cPar</TT> type. You add a new parameter
to the message with the <TT>addPar()</TT> member function: 
<PRE>
<FONT>msg-&gt;addPar(&quot;dest_addr&quot;);
</FONT>
</PRE>
<P>
You can get back the reference to the parameter object with the
<TT>par()</TT> member function, and because <TT>cPar</TT> supports
typecasting and assignment, it is easy to read and set the value
of a parameter:
<PRE>
<FONT>long dest_addr = msg.par(&quot;dest_addr&quot;);
</FONT>msg.par(&quot;dest_addr&quot;) = 168;
</PRE>
<P>
The <TT>addPar()</TT> function also returns a reference to the
added <TT>cPar</TT> object, so you can set the value of the new
parameter at the same place:
<PRE>
<FONT>msg-&gt;addPar(&quot;dest_addr&quot;) = 168;
</FONT>
</PRE>
<P>
You can use the <TT>findPar()</TT> function to see if the message
has a given parameter or not. <TT>findPar()</TT> returns -1 if
the parameter cannot be found:
<PRE>
<FONT>if (msg-&gt;findPar(&quot;dest_addr&quot;) &lt; 0) 
</FONT>{
   msg-&gt;addPar(&quot;dest_addr&quot;);
}
</PRE>
<P>
See the Reference Manual for other member functions to manipulate
message parameters.
<P>
Message parameters are stored in a object of type <TT>cArray</TT>
which can store any object type not only <TT>cPar</TT>s. The <TT>parList()</TT>
member function lets you directly access the internal <TT>cArray</TT>,
so by calling <TT>cArray's</TT> member functions, you can attach
any object to the message. An example:
<PRE>
<FONT>cLongHistogram *pklen_distr = new cLongHistogram(&quot;pklen_distr&quot;);
</FONT>msg-&gt;parList().add( *pklen_distr );
...
cLongHistogram *pklen_distr = 
           (cLongHistogram *) &amp; msg-&gt;parList().get(&quot;pklen_distr&quot;);
</PRE>
<P>
You should take care that names of the attached objects do not
clash with parameter names.
<P>
You can attach non-object types and non-OMNeT++ objects to the
message by using <TT>cPar</TT>'s <TT>void*</TT> pointer (<TT>'P'</TT>)
type. An example:
<PRE>
<FONT>struct conn_t *conn = new conn_t; // a C struct
</FONT>msg-&gt;addPar(&quot;conn&quot;) = (void *) conn;
msg-&gt;par(&quot;conn&quot;).configPointer(NULL,NULL,sizeof(struct conn_t));
</PRE>
<P>
If you do not add parameters to the message and do not call the
<TT>parList()</TT> function, the internal <TT>cArray</TT> object
will not be created. This saves you both storage and execution
time.
<H3><A NAME="_Toc443041199">Message encapsulation</A></H3>
<P>
Message encapsulation is often necessary when you're modelling
layered protocols of computer networks. Although you can encapsulate
messages by adding them to the parameter list, there's a more
straightforward way.  
<P>
The <TT>encapsulate()</TT> function encapsulates a message into
another one. The length of the message will grow by the length
of the encapsulated message:
<PRE>
<FONT>cMessage *userdata = new cMessage(&quot;userdata&quot;);
</FONT>userdata-&gt;setLength(8*2000);
cMessage *tcpseg = new cMessage(&quot;tcp&quot;);
tcpseg-&gt;setLength(8*24);
tcpseg-&gt;encapsulate(userdata);
ev &lt;&lt; tcpseg-&gt;length() &lt;&lt; endl;   // --&gt; 8*2024 = 16192
</PRE>
<P>
Only one message can be encapsulated at a time. If the message
isn't owned by the module function, you'll get an error message.
<P>
You can get back the encapsulated message by <TT>decapsulate()</TT>:
<PRE>
<FONT>cMessage *userdata = tcpseg-&gt;decapsulate();
</FONT>
</PRE>
<P>
<TT>decapsulate()</TT> will decrease the length of the message
accordingly, exept if it was zero. If the length would become
negative, an error occurs.
<P>
The <TT>encapsulatedMsg()</TT> function returns a pointer to the
encapsulated message, or <TT>NULL</TT> if no message was encapsulated.
<H3><A NAME="_Toc443041200">Duplicating messages</A></H3>
<P>
It is often needed to duplicate a message (for example, send one
and keep a copy). This can be done in one of the two ways:
<PRE>
<FONT>cMessage *copy1 = (cMessage *) msg-&gt;dup();
</FONT>cMessage *copy2 = new cMessage( *msg );
</PRE>
<P>
The two are equivalent. The resulting message is an exact copy
of of the original, including message parameters (<TT>cPar</TT>
or other object types). 
<P>
Nearly all object types can be duplicated in the above way, not
only <TT>cMessage</TT> objects.
<H3><A NAME="_Toc443041201">The cPacket class</A></H3>
<P>
The <TT>cPacket</TT> class<SUP>(NEW)</SUP> is derived from <TT>cMessage</TT>.
It is indended as a base for all messages that model packets or
frames in a telecommunications network.
<P>
<TT>cPacket</TT> adds two new data members to <TT>cMessage</TT>:
<I>protocol</I> and <I>PDU</I> type (packet/frame type). Both
are short integers, and are handled by the following member functions:
<PRE>
<FONT>short protocol();
</FONT>short pdu();
setProtocol(short p);
setPdu(short p);
</PRE>
<P>
Acceptable message kind values are:
<UL>
<LI><TT>MK_PACKET </TT>
<LI><TT>MK_INFO</TT>
</UL>
<P>
The default is <TT>MK_PACKET</TT>. Both values are defined as
negative integers. (Remember, negative message kind values are
reserved for the simulation library.)
<P>
The protocol and PDU fields would ideally take a value from the
<TT>protocol.h</TT> header in the simulation library. The contents
of <TT>protocol.h</TT> is currently experimental; comments and
contributions are welcome.
<H3><A NAME="_Toc443041202">Subclassing cMessage and cPacket</A>
</H3>
<P>
&#133;
<H2><A NAME="_Toc443041203">Sending and receiving messages</A>
</H2>
<H3><A NAME="_Toc443041204">Sending messages</A></H3>
<P>
Once the message has been created, it can be sent through an output
gate using one of these functions:
<PRE>
<FONT>send(cMessage *msg, char *gate_name, int index);
</FONT>send(cMessage *msg, int gate);
</PRE>
<P>
For the first function, the argument <TT>gate_name</TT> is the
name of the gate the message has to be sent through. If this gate
is a vector gate, <TT>index</TT> determines though which particular
output gate this has to be done; otherwise, the <TT>index</TT>
argument is not needed.
<P>
The second function uses the gate number and because it does not
have to search through the gate array, it is faster than the first
one.
<P>
Examples:
<PRE>
<FONT>send( new cMessage(&quot;token&quot;), &quot;out-gate&quot;);
</FONT>send( new cMessage(&quot;token&quot;), &quot;vectorgate&quot;, i);

int out_gate_id = findGate(&quot;out-gate&quot;);
for (i=0; i&lt;n; i++)
{
   send( new cMessage(&quot;packet&quot;), out_gate_id);
   wait(in_time);
}
</PRE>
<P>
There is also a direct message sending function:
<PRE>
<FONT>sendDirect(cMessage *msg, simtime_t delay, cModule *module, char *gate);
</FONT>
</PRE>
<P>
With the <TT>sendDirect()</TT> function, you can send messages
to modules to which there is no connection. This is especially
useful for communicating with dynamically created modules (see
later).
<P>
All message sending functions check that you actually own the
message you are about to send. If the message is with another
module, currently scheduled or in a queue etc., you'll get a runtime
error. (The feature does not increase runtime overhead significantly,
because it uses the object ownership management; it merely checks
that the owner of the message is the module which wants to send
it.)
<H3><A NAME="_Toc443041205">Delayed sending</A></H3>
<P>
It is often needed to model a delay (processing time etc) immediately
followed by message sending. In OMNeT++, it is possible to implement
it like this:
<PRE>
<FONT>wait( some_delay );
</FONT>send( msg, &quot;outgate&quot; );
</PRE>
<P>
If the module needs to react to messages that arrive during the
delay, <TT>wait()</TT> cannot be used and the timer mechanism
described under <I>Implementing timers</I> would need to be employed.
<P>
However, there is a more straightforward method than the above
two, and this is delayed sending. Delayed sending can be done
with one of these functions:
<PRE>
<FONT>sendDelayed(cMessage *msg, double delay, char *gate_name, int index);
</FONT>sendDelayed(cMessage *msg, double delay, int gate);
</PRE>
<P>
The arguments are the same as for <TT>send()</TT>, except for
the extra <TT>delay</TT> parameter. The effect of the function
is the same as if the module had keept the message for the delay
interval and sent it afterwards. That is, the sending time of
the message will be the current simulation time (time at the <TT>sendDelayed()</TT>
call) plus the delay. The delay value must be nonnegative.
<P>
Example:
<PRE>
<FONT>sendDelayed( new cMessage(&quot;token&quot;), 0.005, &quot;out-gate&quot;);
</FONT>
</PRE>
<H3><A NAME="_Toc443041206">Receiving messages</A></H3>
<P>
A message can be received by a number of  functions, the most
general one is the <TT>receive()</TT> function:
<PRE>
<FONT>cMessage *msg = receive();
</FONT>
</PRE>
<P>
Simple module objects contain a built-in queue object called <TT>putAsideQueue</TT>.
The put-aside queue is used by some of the message-receiving functions.
<P>
There are two groups of functions that receive messages:
<UL>
<LI><TT>receive(), receiveOn()</TT>
<LI><TT>receiveNew(), receiveNewOn()</TT>
</UL>
<P>
The functions <TT>receive()/receiveOn()</TT>check the put-aside
queue first and try to return a message from it. Only if they
do not find an appropriate message in the put-aside queue, will
wait for new messages.
<P>
The functions <TT>receiveNew()/receiveNewOn()</TT> wait for new
messages, ignoring the put-aside queue.
<P>
Furthermore, the <TT>...On()</TT> functions expect messages to
arrive on a specific gate. Messages that arrive on another gate
are inserted the put-aside queue. The <TT>On</TT>-less versions
accept any message.
<P>
Since the <TT>receive()</TT> and <TT>receiveOn()</TT> return messages
also from the put-aside queue, the arrival times of messages they
return can be less than the current simulation time. A na&iuml;ve
(and also incorrect) approach to check whether a message is a
new one or it has been retrived from the putaside-queue could
be the following:
<PRE>
<FONT>cMessage *msg = receive();
</FONT>if (msg-&gt;arrivalTime()&lt;simTime())  // not correct! many events can occur
                                   // at the same simulation time
{
   // handle msg as an old message
}
</PRE>
<P>
The correct way to do this is to check the putaside-queue:
<PRE>
<FONT>bool queue_was_empty = putAsideQueue.empty();
</FONT>cMessage *msg = receive();
if (!queue_was_empty) 
{
   // handle msg as an old message
}
</PRE>
<P>
To discard the contents of the put-aside queue, one could use
the following code:
<PRE>
<FONT>while (!putAsideQueue.empty())
</FONT>   delete receive();
</PRE>
<P>
To demonstrate <TT>receiveOn()</TT>, the following code fragment
waits for a message on one specific input gate and discards all
messages that arrived on other gates in the meanwhile:
<PRE>
<FONT>cMessage *msg = receiveNewOn(&quot;important-input-gate&quot;);
</FONT>while (!putAsideQueue.empty())
   delete receive();
</PRE>
<P>
The above code is almost equivalent to the following, except that
it preserves the previous contents of the put-aside queue:
<PRE>
<FONT>cMessage *msg;
</FONT>for(;;) 
{
     msg = receiveNew();
     if (msg-&gt;arrivedOn(&quot;important-input-gate&quot;)) 
         break;
     delete msg;
}
</PRE>
<P>
All message receiving functions can be given a timeout value.
(This is a <I>delta</I>, not an absolute simulation time.) If
an appropriate message doesn't arrive within the timeout period,
the function returns a <TT>NULL</TT> pointer. An example:
<PRE>
<FONT>simtime_t timeout = 3.0; 
</FONT>cMessage *msg = receive( timeout );
if (msg=NULL)
    // timeout expired without any messages
else
    // process message
</PRE>
<H3><A NAME="_Toc443041207">The wait() function</A></H3>
<P>
There <TT>wait()</TT> function suspends the execution of the module
for a given amount of simulation time (a <I>delta</I>), regardless
whether messages arrive at the module in the meanwhile or not:
<PRE>
<FONT>wait( delay_interval );
</FONT>
</PRE>
<P>
In other simulation software, <TT>wait()</TT> is often called
<TT>hold</TT>. Internally, the <TT>wait()</TT> function is implemented
by a <TT>scheduleAt()</TT> followed by a <TT>receive()</TT>. The
<TT>wait()</TT> function is very convenient in modules that do
not need to be prepared for arriving messages, for example message
generators. An example:
<PRE>
<FONT>for(;;)
</FONT>{
    wait( par(&quot;interarrival-time&quot;) );
    // generate and send message
}
</PRE>
<P>
The messages that arrived during the <TT>wait()</TT> call will
accumulate in the putaside-queue. The putaside-queue can be examined
directly (an example was shown in the previous section), and its
contents is also retrieved by the <TT>receive()</TT> or <TT>receiveOn()</TT>
functions.
<H3><A NAME="_Toc443041208">Implementing timers</A></H3>
<P>
The module can send a message to itself using the <TT>scheduleAt()</TT>
function:
<PRE>
<FONT>scheduleAt( time, message );
</FONT>
</PRE>
<P>
<TT>scheduleAt()</TT>accepts an <I>absolute</I> simulation time
(usually <TT>simTime()+</TT><I>something</I>). This function,
along with the <TT>cancelEvent()</TT> function which removes the
given message from the future event set can be used to implement
timers:
<PRE>
<FONT>cMessage *timeout_msg = new cMessage;
</FONT>scheduleAt( simTime()+10.0, timeout_msg );
//...
cMessage *msg = receive();
if (msg == timeout_msg)  
{
   // timeout expired
}
else
{
   // other message has arrived: timer can be cancelled now:
   delete cancelEvent( timeout_msg );
}
</PRE>
<P>
<TT>cancelEvent()</TT> does nothing when the message is not in
the future event set, thus you can use it safely even if you're
not sure whether the message is currently scheduled or not.<SUP>(NEW)</SUP>
<H3><A NAME="_Toc443041209">An important note about message sending</A>
</H3>
<P>
Message sending is implemented in the following way: the arrival
time and the error flag of a message are calculated at once, when
the <TT>send()</TT> (or similar) function is invoked. That is,
if the message travels through several links until it reaches
its destination, it is <I>not</I> scheduled individually for each
link, but rather, every calculation is done once, within the <TT>send()</TT>
call. This implementation was chosen because of its run-time efficiency.
<P>
The implementation has the following consequence. If you change
the delay (or the bit error rate, or the data rate) of a link
during simulation, the modelling of messages sent &quot;just before&quot;
the parameter change will not be accurate. Namely, if link parameters
change while a message is &quot;under way&quot; in the model,
that message will not be affected by the parameter change, although
it should. However, all subsequent messages will be modelled correctly.
<H3><A NAME="_Toc443041210">Message transmission time</A></H3>
<P>
If data rate is specified for a connection, a message will have
a certain nonzero transmission time, depending on its length.
This means that when a message is sent out through an output gate,
the message &quot;reserves&quot; the gate for a given period (&quot;it
is being transmitted&quot;).
<P>
<CENTER><IMG SRC="img00008.gif"><BR>
Fig.5.1 Connection with a data rate</CENTER>
<P>
While a message is under transmission, other messages have to
wait until the transmission finishes. You can still use <TT>send()</TT>
while the gate is busy, but the message's arrival will be delayed;
just like the gate had an internal queue for the messages waiting
to be transmitted.
<P>
You may have reasons to check whether a certain output gate is
transmitting or to learn when it finishes transmission. This is
done with gate object's <TT>isBusy()</TT> and <TT>transmissionFinishes()</TT>
member functions. The latter function, <TT>transmissionFinishes()</TT>
returns the time when the gate will finish its current transmission
or (if it is currently free) when it finished its last transmission.
<P>
An example:
<PRE>
<FONT>cMessage *packet = new cMessage(&quot;DATA&quot;);
</FONT>packet-&gt;setLength( 1000 );

if (gate(&quot;TxGate&quot;).isBusy())   // if gate is busy, wait until it
{                              //       becomes free
   wait( gate(&quot;TxGate&quot;).transmissionFinishes() - simTime());
}
send( packet, &quot;TxGate&quot;);
</PRE>
<P>
If the connection with a data rate is not immediately the one
connected to the simple module's output gate but the second one
in the route, you have to check the second gate's busy condition.
You would use the following code:
<PRE>
<FONT>if (gate(&quot;mygate&quot;)-&gt;toGate()-&gt;isBusy())
</FONT>   //...
</PRE>
<P>
In the actual implementation of queuing the messages at busy gates
and modelling the transmission delay, messages do not actually
queue up in gates; gates do not have internal queues. Instead,
as the time when each gate will finish transmission is known at
the time of sending the message, the arrival time of the message
can be calculated in advance. Then the message will be stored
in the event queue (FES) until the simulation time advances to
its arrival time and it is retrieved by its destination module.
The note made in the previous section is also true here: if data
rates change during the simulation, the changes will affect only
the messages that are <I>sent</I> after the change. If it is important
to model gates and channels with changing properties, you can
schedule events for when the gate finishes its current transmission
and send then; alternatively, you can implement channels with
simple modules (active channels).
<H3><A NAME="_Toc443041211">Stopping the simulation</A></H3>
<P>
You can finish the simulation with the <TT>endSimulation()</TT>
function:
<PRE>
<FONT>endSimulation();
</FONT>
</PRE>
<P>
The use of <TT>endSimulation()</TT> is optional. There are also
other ways to stop the simulation, for example after a certain
simulation time or after a certain CPU time. Simulation- and CPU
time limits can be specified in the ini file.
<H3><A NAME="_Toc443041212">About scheduling and message execution
order</A></H3>
<P>
What if two messages' schedule times are equal? In OMNeT++, the
one with smaller priority value is executed first. If priorities
are the same too, than the one scheduled or sent earlier comes
first.
<P>
This is pretty clean. However, practice shows that the problem
lies in the <I>&quot;schedule times are equal&quot;</I> phrase.
Simulation time is stored in doubles, and due to finite machine
precision, two doubles calculated in two different ways are rarely
equal even if they theoretically should be. Well, that's life
and OMNeT++ cannot do much against that.
<P>
If the question is of importance to you, you can take care to
calculate simulation times which should be equal in exactly the
same way. Alternatively, the FDDI model does some magic by adding/substracting
small values to schedule times to ensure specific execution order
(<I>inorder_epsilon</I>). 
<P>
We also thought about some <I>simtime_precision</I> parameter
in the simulation kernel that would force t<SUB>1</SUB> and t<SUB>2</SUB>
to be regarded equal if they are &quot;very close&quot; (if threy
differ less than <I>simtime_precision</I>). However, it is not
at all clear how small <I>simtime_precision</I> should be; the
mechanism incurs some run-time overhead; and all in all I'm not
sure the whole thing would be of more benefit than trouble.
<H2><A NAME="_Toc443041213">Generating random numbers</A></H2>
<P>
Random number generation is considered to be an important issue.
The random number generator used in OMNeT++ is a linear congruential
generator (LCG) with a cycle length of 2<SUP>31</SUP>-2. The startup
code of OMNeT++ contains code that checks if the random number
generator works OK, so you do not have to worry about this if
you port the simulator to a new architecture or use a different
compiler.
<P>
If a simulation program uses random numbers for more than one
purpose, the numbers should come from different random number
generators. OMNeT++ provides several independent random number
generators (by default 32; this number can be changed in <TT>defs.h</TT>).
<P>
To avoid unwanted correlation, it is also important that different
simulation runs and different random number sources within one
simulation run use non-overlapping series of random numbers, so
the generators should be started with seeds well apart. For selecting
good seeds, the <TT>seedtool</TT> program can be used (it is documented
later).
<P>
The random number generator was taken from [JAIN91, pp. 441-444,455].
It has the following properties:
<UL>
<LI>Range:  1 ... 2<SUP>31</SUP>-2
<LI>Period length:  2<SUP>31</SUP>-2
<LI>Method:  x := (x * 7<SUP>5</SUP>) mod (2<SUP>31</SUP>-1)
<LI>To check:  if  x[0]=1  then  x[10000]=1,043,618,065
<LI>Required hardware:  exactly 32-bit integer aritmetics
</UL>
<P>
The concrete implementation:
<PRE>
<FONT>long intrand()
</FONT>{
     const long int a=16807, q=127773, r=2836;
     seed=a*(seed%q) - r*(seed/q);
     if (seed&lt;=0) seed+=INTRAND_MAX;
     return seed;
}
</PRE>
<H3><A NAME="_Toc443041214">Using random number generators directly</A>
</H3>
<P>
The generator is directly accessible through the <TT>intrand()</TT>
 function:
<PRE>
<FONT>long rnd = intrand();    // in the range 1..INTRAND_MAX-1
</FONT>
</PRE>
<P>
The random number seed can be specified in the ini file (<TT>random-seed=</TT>)
or set directly from within simple modules with the <TT>randseed()</TT>
function:
<PRE>
<FONT>randseed( 10 );          // set seed to 10
</FONT>long seed = randseed();  // current seed value
</PRE>
<P>
Zero is not allowed as a seed.
<P>
The <TT>intrand()</TT> and <TT>randseed()</TT> functions use generator
0. They have another variant which uses a specified generator:
<PRE>
<FONT>long rnd = genk_intrand(6);   // like intrand(), using generator 6
</FONT>genk_randseed( k, 167 );      // set seed of generator k to 167
<BR>
</PRE>
<P>
The <TT>intrand(n)</TT> and <TT>dblrand()</TT> functions are based
on <TT>intrand()</TT>:
<PRE>
<FONT>int dice = 1 + intrand(6); // result of intrand(6) is in the range 0..5  
</FONT>                           // (it is calculated as intrand()%6)
double prob = dblrand();   // in the range 0.0..1.0
                           // calculated as intrand()/(double)INTRAND_MAX
</PRE>
<P>
They also have their counterparts that use generator <I>k</I>:
<PRE>
<FONT>int dice = 1 + genk_intrand(k,6);   // uses generator k
</FONT>double prob = genk_dblrand(k);      //       &quot;&quot;
</PRE>
<H3><A NAME="_Toc443041215">Random numbers from distributions</A>
</H3>
<P>
The following functions are based on <TT>dblrand()</TT> and return
random variables of different distributions:
<PRE>
<FONT>double uniform(double lower_limit, double upper_limit);
</FONT>double intuniform(double lower_limit, double upper_limit);
double exponential(double mean);
double normal(double mean, double deviation);
double truncnormal(double mean, double deviation);
</PRE>
<P>
They are the same functions that can be used in NED files. <TT>intuniform()</TT>
generates integers including both the lower and upper limit, so
for example the outcome of tossing a coin could be written as
<TT>intuniform(1,2)</TT>. <TT>truncnormal()</TT> is the normal
distribution truncated to nonnegative values; its implementation
generates a number with normal distribution and if the result
is negative, it keeps generating other numbers until the outcome
is nonnegative.
<P>
The counterparts of the above functions using generator <I>k</I>:
<PRE>
<FONT>double genk_uniform(double k, double lower_limit, double upper_limit);
</FONT>double genk_intuniform(double k, double lower_limit, double upper_limit);
double genk_exponential(double k, double mean);
double genk_normal(double k, double mean, double deviation);
double genk_truncnormal(double k, double mean, double deviation);
</PRE>
<P>
Note that they take the number of the generator as a <TT>double</TT>;
it is so because these functions are designed so that they can
be used in the parameter class <TT>cPar</TT>. You will find more
information about this in the section describing <TT>cPar</TT>.
<P>
If the above distributions do not suffice, you can write your
own functions. If you register your functions with the <TT>Register_Function()</TT>
macro, you can use them in NED files and ini files too. You can
find the implementation of many distributions in the class library
of GNU C++.
<H3><A NAME="_Toc443041216">Random numbers from histograms</A>
</H3>
<P>
You can also specify your distribution as a histogram. The classes
<TT>cLongHistogram</TT>, <TT>cDoubleHistogram</TT> or <TT>cPSquare</TT>
are there to generate random numbers from equidistant-cell or
equiprobable-cell histograms. This feature is documented later,
with the statistical classes.
<H2><A NAME="_Toc443041217">Container classes</A></H2>
<H3><A NAME="_Toc443041218">Queue class: cQueue</A></H3>
<P>
<TT>cQueue</TT> is a container class that acts as a queue. <TT>cQueue</TT>
can hold objects of type derived from <TT>cObject</TT> (almost
all classes from the OMNeT++ library), such as <TT>cMessage</TT>,
<TT>cPar</TT>, etc. Internally, <TT>cQueue</TT> uses a double-linked
list to store the elements.
<P>
As an example of use, the simple modules' put-aside queues (<TT>putAsideQueue</TT>
member) are <TT>cQueue</TT>s which store <TT>cMessage</TT> objects.
(However, the global message queue [or future event set, FES]
is not a <TT>cQueue</TT>; it is implemented with heap [class <TT>cMessageHeap</TT>]
because it is a lot more efficient.)
<P>
A queue object has a head and a tail. Normally, new elements are
inserted at its head and elements are removed at its tail. 
<P>
<CENTER><IMG SRC="img00009.gif"><BR>
Fig.5.2. What is what with <TT>cQueue</TT></CENTER>
<P>
The basic <TT>cQueue</TT> member functions dealing with insertion
and removal are <TT>insertHead()</TT> and <TT>getTail()</TT>.
They are used like this:
<PRE>
<FONT>cQueue queue(&quot;my-queue&quot;);
</FONT>cMessage *msg;

// insert messages
for (int i=0; i&lt;10; i++) 
{ 
    msg = new cMessage;
    queue.insertHead( msg );
}<BR>

<FONT>// remove messages
</FONT>while( ! queue.empty() )
{ 
    msg = (cMessage *)queue.getTail();
    delete msg;
}
</PRE>
<P>
The<TT> length()</TT> member function returns the number of items
in the queue, and <TT>empty()</TT> tells whether there's anything
in the queue.
<P>
<TT>cQueue</TT> can act as a priority queue, that is, it can keep
the inserted objects ordered. If you want to use this feature,
you have to provide a function that compares two objects (see
the reference manual for details). (By default, <TT>cQueue</TT>
implements a FIFO.) An example of setting up an ordered <TT>cQueue</TT>:
<PRE>
<FONT>cQueue queue(&quot;sorted-q&quot;, cObject::cmpbyname, TRUE ); 
</FONT>                                     // sorted by object name, ascending
</PRE>
<P>
If the queue object is set up as an ordered queue, the <TT>insertHead()</TT>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there. 
<P>
There are other functions dealing with insertion and removal.
The <TT>insertBefore()</TT> and <TT>insertAfter()</TT> functions
insert a new item exactly before and after a specified one, regardless
of the ordering function. The <TT>peekTail()</TT> and <TT>peekHead()</TT>
functions return pointers to the objects at the tail and head
of the queue, without affecting queue contents. The <TT>getTail()</TT>
and <TT>getHead()</TT> functions can be used to remove items from
either end of the queue, and the <TT>get()</TT> function can be
used to remove any item known by its pointer from the queue.
<P>
Normally, you can only access the objects at the head or tail
of the queue. However, if you use an iterator class, <TT>cQueueIterator</TT>,
you can examine each object in the queue.
<P>
For example:
<PRE>
<FONT>for( cQueueIterator iter(queue,1); !iter.end(), iter++) 
</FONT>  // second arg to cQueueIterator: start at tail or head? tail=0, head=1
{
    cMessage *msg = (cMessage *) iter();
    //...
}<BR>
</PRE>
<H3><A NAME="_Toc443041219">Expandable array: cArray</A></H3>
<P>
<TT>cArray</TT> is a container class that holds objects derived
from <TT>cObject</TT>. <TT>cArray</TT> stores the pointers of
the objects inserted instead of making copies. <TT>cArray</TT>
works as an array, but if it gets full, it grows automatically.
Internally, <TT>cArray</TT> is implemented with an array of pointers;
if the array gets full, it is reallocated.
<P>
Creating an array:
<PRE>
<FONT>cArray array(&quot;my-par-array&quot;);
</FONT>
</PRE>
<P>
Adding an object at the first free index:
<PRE>
<FONT>cPar *pp = new cPar(&quot;my-pp-object&quot;);
</FONT>int index = array.add( *pp );
</PRE>
<P>
Adding an object at a given index (if the index is occupied, you'll
get an error message):
<PRE>
<FONT>cPar *pp = new cPar(&quot;my-pp-object&quot;);
</FONT>int index = array.addAt( 5, *pp );
</PRE>
<P>
Finding an object in the array:
<PRE>
<FONT>int index = array.find( *pp );
</FONT>
</PRE>
<P>
Getting a pointer to an object at a given index:
<PRE>
<FONT>cPar *rr = (cPar *) &amp;array[ index ]; 
</FONT>
</PRE>
<P>
You can also search the array or get a pointer to an object by
the object's name:
<PRE>
<FONT>int index = array.find( &quot;my-par-array&quot; );
</FONT>Par *rr = (cPar *) &amp;array[ &quot;my-par-array&quot; ];
</PRE>
<P>
You can remove an object from the array:
<PRE>
<FONT>array.remove( index ); 
</FONT>
</PRE>
<P>
The removal does not deallocate the object. If you also want to
deallocate it, say this:
<PRE>
<FONT>delete &amp;array.remove( index );
</FONT> 
</PRE>
<P>
<TT>cArray</TT> objects are used in OMNeT++  to store parameters
attached to messages, and internally, for storing module parameters
and gates. You can access to a message's parameter array and directly
handle it:
<PRE>
<FONT>cMessage *msg = receive();
</FONT>cArray&amp; array = msg-&gt;parList();
for (int i=0; i&lt;array.items(); i++)
{
      cPar&amp; p = (cPar&amp;) array[i];
      //...
}
</PRE>
<H2><A NAME="_Toc443041220">Non-object container classes</A></H2>
<P>
There are two container classes to store non-object items:<TT>
cLinkedList</TT> and <TT>cBag</TT>. The first one parallels with
<TT>cQueue</TT>, the second one with <TT>cArray</TT>. They can
be useful if you have to deal with C structs or objects that are
not derived from <TT>cObject</TT>.
<P>
See the Reference Manual for more info about them.
<H2><A NAME="_Toc443041221">The parameter class: cPar</A></H2>
<H3><A NAME="_Toc443041222">Basic usage</A></H3>
<P>
<TT>cPar</TT> is a class that was designed to hold a value. The
value is numeric in the first place, but string, pointer and other
types are also supported.
<P>
<TT>cPar</TT> is used in OMNeT++ in the following places:
<UL>
<LI>as module parameters
<LI>as message parameters
</UL>
<P>
There are many ways to set a <TT>cPar's</TT> value. With the constructor
call:
<PRE>
<FONT>cPar p(&quot;my-par&quot;, 'D', 1.0 );
</FONT>
</PRE>
<P>
Here, <TT>'D'</TT> means the type (double) and <TT>1.0</TT> is
the value.
<P>
The value can also be set using the <TT>setValue()</TT> member
function:
<PRE>
<FONT>cPar pp(&quot;my-par&quot;);
</FONT>pp.setValue( 'D', 1.0 );
</PRE>
<P>
or by using overloaded operators:
<PRE>
<FONT>cPar pp;
</FONT>pp = 1.0;
</PRE>
<P>
For reading its value, it is best to use overloaded type cast
operators:
<PRE>
<FONT>double d1 = (double)pp;
</FONT>// or simply:
double d2 = pp;
</PRE>
<P>
The <TT>'L'</TT> type character means long integer:
<PRE>
<FONT>pp = 89363L;  // or:
</FONT>pp.setValue('L', 89363L );
</PRE>
<P>
The<TT> 'S'</TT> type is character string:
<PRE>
<FONT>pp = &quot;hi there&quot;;  // or:
</FONT>pp.setValue('S', &quot;hi there&quot; );
</PRE>
<P>
The <TT>cPar</TT> object makes its own copy of the string, so
the original one does not need to be preserved. Short strings
(less than ~20 chars) are handled more efficiently because they
are stored in the object's memory space (and are not dynamically
allocated).
<P>
There are several other types <TT>cPar</TT> can store, such as
<TT>'B'</TT> (boolean); <TT>'P' </TT>(pointer to void* items);
<TT>'O' </TT>(pointer to objects derived from <TT>cObject</TT>);
<TT>'F'</TT> (function with constant args) will be mentioned in
the next section.
<P>
For numeric and string types, an input flag can be set. In this
case, when the object's value is first used, the parameter value
will be searched for in the configuration (ini) file; if it is
not found there, the user will be given a chance to enter the
value interactively.
<P>
Examples:
<PRE>
<FONT>cPar inp(&quot;input-parameter&quot;);
</FONT>inp.setPrompt(&quot;Enter my value:&quot;);
inp.setInput( TRUE );      // make it an input parameter
double a = (double)inp;    // NOW the user will be prompted for the value
</PRE>
<H3><A NAME="_Toc443041223">Random number generation through cPar</A>
</H3>
<P>
The <TT>'F'</TT> (function with constant arguments) type of <TT>cPar</TT>
can be used to make the object return random variables of different
distributions:
<PRE>
<FONT>cPar rnd(&quot;random-variable&quot;);
</FONT>rnd.setValue('F', intuniform, -10.0, 10.0);// uniform distr.
rnd.setValue('F', normal, 100.0, 5.0);     // normal distr. (mean,dev)
rnd.setValue('F', exponential, 10.0);      // exponential distr. (mean)
</PRE>
<P>
<TT>intuniform</TT>, <TT>normal</TT> etc. are ordinary C functions
taking <TT>double</TT> arguments and returning <TT>double</TT>.
Each time you read the value of a <TT>cPar</TT> containing a function
like above, the function will be called with the given constant
arguments (e.g. <TT>normal(100.0,5.0)</TT>) and its return value
used.
<P>
The above functions use number 0 from the several random number
generators. To use another generator, use the <TT>genk_xxx</TT>
versions of the random functions:  
<PRE>
<FONT>rnd.setValue('F', genk_normal, 3, 100.0, 5.0);  // uses generator 3
</FONT>
</PRE>
<P>
A <TT>cPar</TT> object can also be set to return a random variable
from a distribution collected by a statistical data collection
object; this is selected by type <TT>'T'</TT>:
<PRE>
<FONT>cDoubleHistogram hist = ....;   // the distribution
</FONT>cPar rnd2(&quot;from-distribution&quot;, 'T', hist);
</PRE>
<H3><A NAME="_Toc443041224">Storing object and non-object pointers
in cPar</A></H3>
<P>
<TT>cPar</TT> can store pointers to OMNeT++ objects ('O' type)
. You can use both assignment and the <TT>setValue()</TT> member
function:
<PRE>
<FONT>cQueue *queue = new cQueue(&quot;queue&quot;);  // just an example
</FONT>cPar par1, par2;
par1 = (cObject *) queue;
par2.setValue( queue );
</PRE>
<P>
To get the store pointer back, you can use typecast or the <TT>objectValue()</TT>
member function:
<PRE>
<FONT>cQueue *q1 = (cQueue *)(cObject *)par1;
</FONT>cQueue *q2 = (cQueue *)par2.objectValue();
</PRE>
<P>
Whether the <TT>cPar</TT> object will own the other object or
not is controlled by the <TT>takeOwnership()</TT> member function,
just as with container classes. This is documented in detail in
the Reference Manual. By default, <TT>cPar</TT> will own the object.
<P>
<TT>cPar</TT>'s 'P' type (<TT>void*</TT> pointer) can be used
to store non-object pointers (for example C structs) or non-OMNeT++
object types in the parameter object. It works very similarly
to the above mechanism. An example:
<PRE>
<FONT>double *mem = new double[15];
</FONT>cPar par1, par2;
par1 = (void *) mem;
par2.setValue( (void *)mem );
...
double *m1 = (double *)(void *)par1;
double *m2 = (double *)par2.pointerValue();
</PRE>
<P>
Memory management can be specified by <TT>cPar's</TT> <TT>configPointer()</TT>
member function. It takes three arguments: a pointer to a user-supplied
deallocation function, a pointer to a user-supplied duplication
function and an item size. If all three are 0 (<TT>NULL</TT>),
no memory management is done, that is, the pointer is treated
as a mere pointer. This is the default behaviour. If you supply
only the item size (and both function pointers are <TT>NULL</TT>),
<TT>cPar</TT> will use the <TT>delete</TT> operator to deallocate
the memory area when the <TT>cPar</TT> object is destructed, and
it will use <TT>new char[size]</TT> followed by a <TT>memcpy()</TT>
to duplicate the memory area whenever the <TT>cPar</TT> object
is duplicated. If you need more sophisticated memory management,
you can supply your own deallocation and duplication functions.
All this is documented in detail in the Reference Manual. An example
for simple memory management:
<PRE>
<FONT>double *mem = new double[15];
</FONT>cPar par;
par.setValue((void *) mem);
par.configPointer(NULL, NULL, 15*sizeof(double));
// -&gt; now if par goes out of scope, it will delete the 15-double array.
</PRE>
<P>
The <TT>configPointer()</TT> setting only affects what happens
when the <TT>cPar</TT> is deleted, duplicated or copied, but does
<I>not</I> apply to assigning new pointers. That is, if <I>you</I>
assign a new <TT>void*</TT> to the <TT>cPar</TT>, you simply overwrite
the pointer - the block denoted by the old pointer is <I>not</I>
deleted. This fact can be used to extract some dynamically allocated
block out of the <TT>cPar</TT>: carring on the previous example,
you would extract the array of 15 <TT>double</TT>s from the <TT>cPar</TT>
like this:
<PRE>
<FONT>double *mem2 = (double *)par.pointerValue();
</FONT>par.setValue( (void *)0 );
// -&gt; now par has nothing to do with the double[15] array 
</PRE>
<P>
However, if you assign some non-pointer value to the <TT>cPar</TT>,
beware: this <I>will</I> activate the memory management for the
block. If you temporarily use the same <TT>cPar</TT> object to
store other than <TT>void*</TT> ('P') values, <TT>the configPointer()</TT>
setting is lost.
<H3><A NAME="_Toc443041225">Reverse Polish expressions</A></H3>
<P>
This feature is rarely needed by the user, it is more used internally.
A <TT>cPar</TT> object can also store expressions. In this case,
the expression must be given in reversed Polish form. An example:
<PRE>
<FONT>sXElem *expression = new sXElem[5];
</FONT>expression[0] = &amp;par( &quot;count&quot; );  // pointer to module parameter
expression[1] = 1;
expression[2] = '+';
expression[3] = 2;
expression[4] = '/';
cPar pp(&quot;expression-valued-param&quot;, 'X',expression,5);
</PRE>
<P>
The <TT>cPar</TT> object created above contains the <I>(count+1)/2</I>
expression where <I>count</I> is a module parameter. Each time
the <TT>cPar</TT> is evaluated, it recalculates the expression,
using the current value of <TT>count</TT>. Note the <TT>&amp;</TT>
sign in front of <TT>par(&quot;count&quot;)</TT> expression: if
it was not there, the parameter would be taken by value, evaluated
once and then the resulting constant would be used.
<P>
Another example is a distribution with mean and standard deviation
given by module parameters: 
<PRE>
<FONT>sXElem *expression = new sXElem[3];
</FONT>expression[0] = &amp;par(&quot;mean&quot; );
expression[1] = &amp;par(&quot;stddev&quot;);
expression[2] = normal;    // pointer to the normal(double,double) func.
cPar pp(&quot;expression-valued-param&quot;, 'X',expression,3);
</PRE>
<P>
For more information, see the reference manual and the code NEDC
generates for parameter expressions.
<H3><A NAME="_Toc443041226">Using indirection</A></H3>
<P>
A <TT>cPar</TT> object can be set to stand for a value actually
stored in another <TT>cPar</TT> object. This is called <I>indirect</I>
or <I>redirected</I> value. When using indirection, every operation
on the value (i.e. reading or changing it) will be actually done
to the other <TT>cPar</TT> object:
<P>
<CENTER><IMG SRC="img00010.gif"><BR>
Fig.5.3 <TT>cPar</TT> indirection</CENTER>
<P>
Indirection is how module parameters taken by reference are implemented.
The indirection does not include name strings. That is, if you
say <TT>A-&gt;setName(&quot;newname&quot;)</TT> in the above example,
<TT>A</TT>'s name will be changed as the name member is not redirected.
(This is natural if you consider parameters taken by reference:
a parameter should/can have different name than the value it refers
to.)
<P>
You create an indirection with the <TT>'I'</TT> type character:
<PRE>
<FONT>cPar *bb = new cPar(&quot;background value&quot;, 'L', 10);
</FONT>cPar a(&quot;redirected object&quot;);

a.setValue('I', bb);  // create indirection
</PRE>
<P>
Or:
<PRE>
<FONT>cPar *bb = new cPar(&quot;background value&quot;, 'L', 10);
</FONT>cPar a(&quot;redirected object&quot;, 'I', bb);   // create indirection immediately
</PRE>
<P>
Now every operation you do on <TT>a</TT>'s value will be done
to <TT>bb</TT>:
<PRE>
<FONT>long x = a;    // returns bb's value, so x=10
</FONT>a = 5;         // bb's value changes to 5
</PRE>
<P>
Even when you read back the type character, it will not return
<TT>'I'</TT>; it will return the type of the <TT>cPar</TT> object
it refers to:
<PRE>
<FONT>char type = a.type();   // returns 'L', bb's type!
</FONT>
</PRE>
<P>
The <I>only</I> legal way to determine whether <TT>a</TT> is really
holding the value or it is redirected to another <TT>cPar</TT>
is to use the <TT>indirection()</TT> member function:
<PRE>
<FONT>cPar *indir = a.indirection();  // returns bb's pointer
</FONT>if (indir != NULL)
     ev &lt;&lt; &quot;a is redirected to &quot; &lt;&lt; indir-&gt;name() &lt;&lt; '\n';
</PRE>
<P>
To break the link between the two objects, use the <TT>cancelIndirection()</TT>
member function. (No other method will work, including assigning
<TT>a</TT> the value of another <TT>cPar</TT> object.) The <TT>cancelIndirection()</TT>
function gives the <TT>(long)0</TT> value to the redirected object
(the other will be unaffected). If you want to cancel the indirection
but keep the old value, you can do something like this:
<PRE>
<FONT>cPar *value = a.indirection();    // bb's pointer
</FONT>a.cancelIndirection();            // break the link; value of a becomes 0
a = *value;                       // copy the contents of bb into a
</PRE>
<H2><A NAME="_Toc443041227">Statistics and distribution estimation</A>
</H2>
<H3><A NAME="_Toc443041228">cStatistic and descendants</A></H3>
<P>
There are several statistic and result collection classes: <TT>cStdDev</TT>,
<TT>cWeightedStdDev</TT>, <TT>LongHistogram</TT>, <TT>cDoubleHistogram</TT>,
<TT>cVarHistogram</TT>, <TT>cPSquare</TT> and <TT>cKSplit</TT>.
They are all derived from the abstract base class <TT>cStatistic.</TT>
<UL>
<LI><TT>cStdDev</TT> keeps number of samples, mean, standard deviation,
minimum and maximum value etc. 
<LI><TT>cWeightedStdDev</TT> is similar to <TT>cStdDev</TT>, but
accepts weighted observations. <TT>cWeightedStdDev</TT>  can be
used for example to calculate time average. It is the only weighted
statistics class.
<LI><TT>cLongHistogram</TT> and <TT>cDoubleHistogram</TT> are
descendants of <TT>cStdDev</TT> and also keep an approximation
of the distribution of the observations using equidistant (equal-sized)
cell histograms.
<LI><TT>cVarHistogram</TT> implements a histogram where cells
do not need to be the same size. You can manually add the cell
(bin) boundaries, or alternatively, automatically have a partitioning
created where each bin has the same number of observations (or
as close to that as possible). 
<LI><TT>cPSquare</TT> is a class that uses the P<SUP>2</SUP> algorithm
described in [JCH85]. The algorithm calculates quantiles without
storing the observations; one can also think of it as a histogram
with equiprobable cells. 
<LI><TT>cKSplit</TT> uses a novel, experimental method, based
on an adaptive histogram-like algorithm. (Published papers about
<I>k-split</I> can be downloaded from the OMNeT++ Web site; just
go one level up in the directories: http://www.hit.bme.hu/phd/vargaa).
Because k-split is not very well known, we'll devote a section
to it.
</UL>
<P>
One can insert an observation into a statistic object with the
<TT>collect()</TT> function or the <TT>+=</TT> operator (they
are equivalent). <TT>cStdDev</TT> has the following methods for
getting statistics out of the object: <TT>samples()</TT>, <TT>min()</TT>,
<TT>max()</TT>, <TT>mean()</TT> , <TT>stddev()</TT>, <TT>variance()</TT>
with the obvious meanings. An example usage for <TT>cStdDev</TT>:
<PRE>
<FONT>cStdDev stat(&quot;stat&quot;);
</FONT>for (int i=0; i&lt;10; i++)  stat.collect( normal(0,1) );
long   num_samples = stat.samples();
double smallest = stat.min(),
       largest  = stat.max();
double mean = stat.mean(),
       standard_deviation = stat.stddev(),
       variance = stat.variance();
</PRE>
<P>
The distribution estimation classes (the histogram classes, <TT>cPSquare</TT>
and <TT>cKSplit</TT>)  are derived from <TT>cDensityEstBase</TT>.
Distribution estimation classes (except for <TT>cPSquare</TT>)
 assume that the observations are within a range. You may specify
the range explicitly (based on some a-priori info about the distribution)
or you may let the object collect the first few observations and
determine the range from them. Methods which let you specify range
settings are part of <TT>cDensityEstBase</TT>. The following member
functions exist:
<PRE>
<FONT>setRange(lower,upper);
</FONT>setRangeAuto(num_firstvals, range_ext_factor);
setRangeAutoLower(upper, num_firstvals, range_ext_factor);
setRangeAutoUpper(lower, num_firstvals, range_ext_factor);

setNumFirstVals(num_firstvals);
</PRE>
<P>
The following example creates a histogram with 20 cells and automatic
range estimation:
<PRE>
<FONT>cDoubleHistogram histogram(&quot;histogram&quot;, 20);
</FONT>histogram.setRangeAuto(100,1.5);
</PRE>
<P>
Here, 20 is the number of cells (not including the underflow/overflow
cells, see later), and 100 is the number of observations to be
collected before setting up the cells. 1.5 is the range extension
factor. It means that the actual range of the initial observations
will be expanded 1.5 times and this expanded range will be used
to lay out the cells. This method increases the chance that further
observations fall in one of the cells and not outside the histogram
range.
<P>
<CENTER><IMG SRC="img00011.gif"><BR>
Fig.5.4. Setting up a histogram's range</CENTER>
<P>
After the cells have been set up, collecting can go on. 
<P>
The <TT>transformed()</TT> function returns TRUE when the cells
have already been set up. You can force range estimation and setting
up the cells by calling the <TT>transform()</TT> function.
<P>
The observations that fall outside the histogram range will be
counted as underflows and overflows. The number of underflows
and overflows are returned by the <TT>underflowCell()</TT> and
<TT>overflowCell()</TT> member functions.
<P>
<CENTER><IMG SRC="img00012.gif"><BR>
Fig.5.5. Histogram structure after setting up the cells</CENTER>
<P>
You create a P<SUP>2</SUP> object by specifying the number of
cells:
<PRE>
<FONT>cPSquare psquare(&quot;interarrival-times&quot;, 20);
</FONT>
</PRE>
<P>
Afterwards, a <TT>cPSquare</TT> can be used with the same member
functions as a histogram.
<P>
There are three member functions to explicitly return cell boundaries
and the number of observations is each cell. <TT>cells()</TT>
returns the number of cells, <TT>basepoint(int k)</TT> returns
the <I>k</I>th base point, <TT>cell(int k)</TT> returns the number
of observations in cell <I>k</I>, and <TT>cellPDF(int k)</TT>
returns the PDF value in the cell. These functions work for both
histogram types, <TT>cPSquare</TT> and <TT>cKSplit</TT>.
<P>
<CENTER><IMG SRC="img00013.gif"><BR>
Fig.5.6. base points and cells</CENTER>
<P>
An example:
<PRE>
<FONT>long n = histogram.samples();
</FONT>for (int i=0; i&lt;histogram.cells(); i++)
{
    double cellWidth = histogram.basepoint(i+1) - histogram.basepoint(i);
    int count = histogram.cell(i);
    double pdf = histogram.cellPDF(i);
    //...
}
</PRE>
<P>
The <TT>pdf(x)</TT> and <TT>cdf(x)</TT> member functions return
the value of the probability density function and the cumulated
density function at a given <I>x</I>, respectively.
<P>
There are two ways of generating random numbers from the distribution
stored by the object. One way is to use the <TT>random()</TT>
member function:
<PRE>
<FONT>double rnd = histogram.random();
</FONT>
</PRE>
<P>
<TT>cStdDev</TT> assumes normal distribution.
<P>
The second, indirect way to get a random number is to use a parameter
object, <TT>cPar</TT>:
<PRE>
<FONT>cPar rnd_par1(&quot;disTribution&quot;, 'T', &amp;histogram);
</FONT>cPar rnd_par2(&quot;disTribution&quot;, 'T', &amp;pisquare);
</PRE>
<P>
The <TT>cPar</TT> object stores the pointer to the histogram (or
P<SUP>2</SUP> object), and whenever it is asked for the value,
calls the histogram object's <TT>random()</TT> function:
<PRE>
<FONT>double d = rnd_par2;  // random number from the cPSquare
</FONT>
</PRE>
<P>
The statistic classes have <TT>loadFromFile()</TT> member functions
that read the histogram data from a text file. If you need a custom
distribution that cannot be written (or it is inefficient) as
a C function, you can describe it in histogram form stored in
a text file, and use a histogram object with <TT>loadFromFile()</TT>.
<P>
You can also use <TT>saveToFile()</TT>that writes out the distribution
collected by the histogram object.
<P>
Example:
<PRE>
<FONT>FILE *f = fopen(&quot;histogram.dat&quot;,&quot;w&quot;);
</FONT>histogram.saveToFile( f );      // save the distribution
fclose( f );

FILE *f2 = fopen(&quot;histogram.dat&quot;,&quot;r&quot;);
cDoubleHistogram hist2(&quot;Hist-from-file&quot;);
hist2.loadFromFile( f2 );          // load stored distibution
fclose( f2 );
</PRE>
<H3><A NAME="_Toc443041229">The k-split algorithm</A></H3>
<P>
The k-split algorithm is an on-line distribution estimation method.
It was designed for on-line result collection in simulation programs.
The method was proposed by Varga and Fakhamzadeh in 1997. The
primary advantage of k-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size.
The k-split algorithm can be extended to multi-dimensional distributions,
but here we deal with the one-dimensional version only.
<P>
The k-split algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out
with a histogram range <I>[x<SUB>lo</SUB>, x<SUB>hi</SUB>)</I>
with <I>k</I> equal-sized histogram cells with observation counts
<I>n<SUB>1</SUB></I>, <I>n<SUB>2</SUB></I>, ... <I>n<SUB>k</SUB></I>.
Each collected observation increments the corresponding observation
count. When an observation count <I>n<SUB>i</SUB></I> reaches
a <I>split threshold</I>, the cell is split into <I>k</I> smaller,
equal-sized cells with observation counts <I>n<SUB>i,1</SUB></I>,
<I>n<SUB>i,2</SUB></I>, ... <I>n<SUB>i,k</SUB></I> initialized
to zero. The <I>n<SUB>i</SUB></I> observation count is remembered
and is called the <I>mother observation count</I> to the newly
created cells. Further observations may cause cells to be split
further (e.g. <I>n<SUB>i,1,1</SUB>,...n<SUB>i,1,k</SUB></I> etc.),
thus creating a <I>k</I>-order tree of observation counts where
leaves contain live counters that are actually incremented by
new observations, and intermediate nodes contain mother observation
counts for their children. If an observation falls outside the
histogram range, the range is extended in a natural manner by
inserting new level(s) at the top of the tree. The fundamental
parameter to the algorithm is the split factor <I>k</I>. Low values
of k, <I>k</I>=2 and <I>k</I>=3 are to be considered. In this
paper we examine only the <I>k</I>=2 case.
<P>
<CENTER><A NAME="_Ref420721862"><IMG SRC="img00014.gif"><BR>
</A>Figure 5.7. Illustration of the k-split algorithm, <I>k</I>=2.
The numbers in boxes represent the observation count values. </CENTER>
<P>
For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.
<P>
Let <I>n<SUB>...,i</SUB></I> be the (mother) observation count
for a cell, <I>s<SUB>...,i</SUB></I> be the total observation
count in a cell (<I>n<SUB>...,i</SUB></I> plus the observation
counts in all its sub-, sub-sub-, etc. cells), and <I>m<SUB>...,i</SUB></I>
the mother observations propagated to the cell. We are interested
in the <I>&ntilde;<SUB>...,i</SUB></I> = <I>n<SUB>...,i</SUB></I>
+ <I>m<SUB>...,i</SUB></I> estimated amount of observations in
the tree nodes, especially in the leaves. In other words, if we
have <I>&ntilde;<SUB>...,i</SUB></I> estimated observation amount
in a cell, how to divide it to obtain <I>m<SUB>...,i,1</SUB></I>,
<I>m<SUB>...,i,2 </SUB></I>... <I>m<SUB>...,i,k</SUB></I> that
can be propagated to child cells. Naturally, <I>m<SUB>...,i,1
</SUB></I>+ <I>m<SUB>...,i,2 </SUB></I>+...+ <I>m<SUB>...,i,k
</SUB></I>=<I> &ntilde;<SUB>...,i</SUB></I>. 
<P>
Two natural distribution methods are even distribution (when<I>
m<SUB>...,i,1</SUB></I> = <I>m<SUB>...,i,2</SUB></I> =...= <I>m<SUB>...,i,k</SUB></I>)
and proportional distribution (when <I>m<SUB>...,i,1</SUB></I>
: <I>m<SUB>...,i,2</SUB></I> : ... : <I>m<SUB>...,i,k</SUB></I>
= <I>s<SUB>...,i,1</SUB></I> : <I>s<SUB>...,i,2</SUB></I> : ...
: <I>s<SUB>...,i,k</SUB></I>). Even distribution is optimal when
the <I>s<SUB>...,i,j</SUB></I> values are very small, and proportional
distribution is good when the <I>s<SUB>...,i,j</SUB></I> values
are large compared to <I>m<SUB>...,i,j</SUB></I>. In practice,
a linear combination of them seems appropriate, where =0 means
even and =1 means proportional distribution:
<P>
<IMG SRC="img00015.gif">, [0,1]
<P>
<CENTER><IMG SRC="img00016.gif"></CENTER>
<P>
<CENTER>Figure 5.8. Density estimation from the k-split cell tree.
We assume =0, i.e. we distribute mother observations evenly</CENTER>
<P>
Note that while <I>n<SUB>...,i</SUB></I> are integers, <I>m<SUB>...,i</SUB></I>
and thus <I>&ntilde;<SUB>...,i</SUB></I> are typically real numbers.
The histogram estimate calculated from k-split is not exact, because
the frequency counts calculated in the above manner contain a
degree of estimation themselves. This introduces a certain<I>
cell division error</I>; the <I> </I>parameter should be selected
so that it minimizes that error. It has been shown that the cell
division error can be reduced to a more-than-acceptable small
value.
<P>
Strictly speaking, the k-split algorithm is semi-online, because
its needs some observations to set up the initial histogram range.
However, because of the range extension and cell split capabilities,
the algorithm is not very sensitive to the choice of the initial
range, so very few observations are enough for range estimation
(say <I>N<SUB>pre</SUB></I>=10). Thus we can regard k-split as
an on-line method. 
<P>
K-split can also be used in semi-online mode, when the algorithm
is only used to create an optimal partition from a larger number
of <I>N<SUB>pre</SUB></I> observations. When the partition has
been created, the observation counts are cleared and the <I>N<SUB>pre</SUB></I>
observations are fed into k-split once again. This way all mother
(non-leaf) observation counts will be zero and the cell division
error is eliminated. It has been shown that the partition created
by k-split can be better than both the equi-distant and the equal-frequency
partition.
<P>
OMNeT++ contains an experimental implementation of the k-split
algorithm, the <TT>cKSplit</TT> class. Research on k-split is
still under way.
<H3><A NAME="_Toc443041230">Transient detection and result accuracy</A>
</H3>
<P>
There are also objects that can be attached to statistical objects.
They determine the end of the transient period and whether results
are accurate enough. These classes are:
<UL>
<LI><TT>cTransientDetection</TT>: transient detection
<LI><TT>cAccuracyDetection</TT>: result accuracy detection
</UL>
<P>
See the reference manual and the source code for more information.
<H2><A NAME="_Toc443041231">Recording simulation results</A></H2>
<H3><A NAME="_Toc443041232">Output vectors: cOutVector</A></H3>
<P>
Objects of type <TT>cOutVector</TT> are responsible for writing
time series data (referred to as <I>output vectors</I>) to a file.
The <TT>record()</TT> member is used to output a value (or a value
pair) with a timestamp. 
<P>
It can be used like this:
<PRE>
<FONT>cOutVector resp_v( &quot;response time&quot;, 2 );

</FONT>while (...)
{
	double response_time;
	//...
	resp_v.record( response_time );
	//...
}
</PRE>
<P>
All <TT>cOutVect</TT> objects write to the same, common file.
The file is textual; each <TT>record()</TT> call generates a line
in the file. The output file can be processed using Plove, but
otherwise its simple format allows it to be easily processed with
<TT>sed</TT>, <TT>awk</TT>, <TT>grep</TT> and the like, and it
can be imported by spreadsheet programs. The file format is described
later in this manual (in the section about simulation execution).
<P>
You can disable the output vector or specify a simulation time
interval for recording. If the output vector object is disabled
or the simulation time is outside the specified interval, <TT>record()</TT>
does nothing.
<H3><A NAME="_Toc443041233">Output scalars</A></H3>
<P>
While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars are supposed to record a single value per simulation
run. You can use outputs scalars
<UL>
<LI>to record summary data at the end of the simulation run
<LI>to do several runs with different parameter settings/random
seed and determine the dependence of some measures on the parameter
settings. For example, multiple runs and output scalars are the
way to produce <I>Throughput vs. Offered Load</I> plots.
</UL>
<P>
Output scalars are recorded with the <TT>recordScalar()</TT> member
function:
<PRE>
<FONT>double avg_throughput = total_bits / simTime();
</FONT>recordScalar(&quot;Average throughput&quot;, avg_throughput);
</PRE>
<P>
You can record whole statistics objects by calling <TT>recordStats()</TT>:
<PRE>
<FONT>cStdDev *eedstats = new cStdDev;
</FONT>....
recordStats(&quot;End-to-end Statistics&quot;, eedstats);
</PRE>
<P>
Calls to <TT>recordScalar()</TT> and <TT>recordStats()</TT> are
usually placed in the redefined <TT>finish()</TT> member function
of a simple module.
<P>
The above calls write into the (textual) output scalar file. The
output scalar file is preserved across simulation runs, it is
not deleted at the beginning of each run as the output vector
file is. Data are always appended at the end of the file, and
output from different simulation runs are separated by special
lines.
<H2><A NAME="_Toc443041234">Reaching out of simple modules</A>
</H2>
<H3><A NAME="_Toc443041235">Object name strings and numeric identifiers
in the network</A></H3>
<P>
Objects have three member functions returning the object's name.
An example will clarify them.
<P>
Suppose we have a module in the network <TT>university_lan</TT>,
compound module <TT>fddi_ring</TT>, simple module <TT>station[10]</TT>.
The functions will return these values:
<PRE>
<FONT>ev &lt;&lt; module-&gt;name();       // &quot;station&quot;
</FONT>ev &lt;&lt; module-&gt;fullName();   // &quot;station[10]&quot;
ev &lt;&lt; module-&gt;fullPath();   // &quot;university_lan.fddi_ring.station[10]&quot;
</PRE>
<P>
These functions work for other object types too, not only modules.
For example, a local object variable inside the module would produce
results like this:
<PRE>
<FONT>void FDDIStation::activity()
</FONT>{
    cQueue buffer( &quot;buffer&quot; );
    ev &lt;&lt; buffer-&gt;fullPath();	
                       // &quot;university_lan.fddi_ring.station[10].buffer&quot;
    //...
}
</PRE>
<P>
<TT>fullName()</TT> and <TT>fullPath()</TT> can be used for example
to generate informative error messages. 
<P>
If the module is part of a module vector, the <TT>index()</TT>
and <TT>size()</TT> functions can be used to query its index and
the vector size:
<PRE>
<FONT>ev &lt;&lt; &quot;This is module [&quot; &lt;&lt; module-&gt;index() &lt;&lt; 
</FONT>      &quot;] in a vector of size [&quot; &lt;&lt; module-&gt;size() &lt;&lt; &quot;].\n&quot;;
</PRE>
<P>
Each module in the network has a unique ID that is returned by
<TT>id()</TT>. The ID is used internally by the simulation kernel
to identify modules.
<H3><A NAME="_Toc443041236">Accessing other modules in the network</A>
</H3>
<P>
The surrounding compound module can be accessed by the <TT>parentModule()</TT>
member function:
<PRE>
<FONT>cModule *parent = parentModule();
</FONT>
</PRE>
<P>
For example, the parameters of the parent module are accessed
like this:
<PRE>
<FONT>double timeout = parentModule()-&gt;par( &quot;timeout&quot; );
</FONT>
</PRE>
<P>
To access all modules within a compound module, use <TT>cSubModIterator</TT>.
For example:
<PRE>
<FONT>for (cSubModIterator submod(*parentModule()); !submod.end(); submod++)
</FONT>{
	ev &lt;&lt; submod()-&gt;fullName();
}
</PRE>
<P>
(<TT>submod()</TT> is pointer to the current module the iterator
is at.)
<P>
The above method can also be used to iterate along a module vector,
since the <TT>name()</TT> function returns the same for all modules:
<PRE>
<FONT>for (cSubModIterator submod(*parentModule()); !submod.end(); submod++)
</FONT>{
      if (submod()-&gt;isName( name() ))   // if submod() is in the same
                                           //   vector as this module
      {
          int its_index = submod()-&gt;index();
          // do something to it
      }
}
</PRE>
<P>
To determine the module at the other end of a connection, use
<TT>cGate's</TT> <TT>fromGate()</TT>, <TT>toGate()</TT> and <TT>ownerModule()</TT>
functions. For example:
<PRE>
<FONT>cModule *neighbour = gate( &quot;outputgate&quot; )-&gt;toGate()-&gt;ownerModule();
</FONT>
</PRE>
<P>
For input gates, you would use <TT>fromGate()</TT> instead of
<TT>toGate()</TT>.
<H3><A NAME="_Toc443041237">Dynamic module creation and direct
message sending</A></H3>
<P>
If you do not know how many modules you'll need, you can create
modules dynamically and dispose of them when they are no longer
needed. Both simple and compound modules can be created this way.
If you create a compound module dynamically, all its submodules
will be recursively built.
<P>
Let's suppose you are implementing a transport protocol for a
computer network model. It is convenient to have a separate module
to handle each connection. However, there's no way to know how
many connections there'll be simultaneously. The solution is to
create a manager module which receives connection requests and
creates a module for each connection. The Dyna example simulation
does something like this.
<P>
To create a module dynamically, one should follow 5 steps:
<P>
<B> Step 1.  </B>find descriptor object
<P>
<B> Step 2.  </B>create module
<P>
<B> Step 3.  </B>set up parameters and gate sizes (if needed)
<P>
<B> Step 4.  </B>call function that builds out submodules and
finalizes the module
<P>
<B> Step 5.  </B>call function that creates activation message(s)
for the new simple module(s)
<P>
Each step (except for Step 3.) can be done with one line of code.
<P>
See the following example where Step 3. is omitted:
<PRE>
<FONT>// find descriptor object
</FONT>cModuleType *moduleType = findModuleType(&quot;TCP-conn-handler&quot;);

// create (possibly compound) module and build its submodules (if any)
cModule *module = moduleType-&gt;create( &quot;TCPconn&quot;, this );
moduleType-&gt;buildInside( module );

// create activation message
module-&gt;scheduleStart( simTime() );
</PRE>
<P>
If you want to set up parameter values or  gate vector sizes (Step
3.), the code goes between the <TT>create()</TT> and <TT>buildInside()</TT>
calls:
<PRE>
<FONT>cModuleType *moduleType = findModuleType(&quot;TCP-conn-handler&quot;);

</FONT>cModule *module = moduleType-&gt;create( &quot;TCPconn&quot;, this );

// set up parameters and gate sizes before we set up its submodules
module-&gt;par(&quot;window-size&quot;) = 4096;
module-&gt;setGateSize(&quot;to-apps&quot;, 3);

moduleType-&gt;buildInside( module );

module-&gt;scheduleStart( simTime() );
</PRE>
<P>
To delete a module dynamically:
<PRE>
<FONT>module-&gt;deleteModule();
</FONT>
</PRE>
<P>
If the module was a compound module, this involves recursively
destroying all its submodules. A simple module can also delete
itself ; in this case, the <TT>deleteModule()</TT> call does not
return to the caller. Currently, you cannot safely delete a compound
module from a simple module in it; you must delegate the job to
a module outside the compound module. 
<P>
With dynamically created modules, it is often more convenient
to omit connections and use direct message sending. 
<P>
The following example sends a message to the input gate <TT>in</TT>
of the module <TT>mod</TT>:
<PRE>
<FONT>cModule *mod = ...;

</FONT>double delay = truncnormal(0.005, 0.0001);
sendDirect( new cMessage, delay, mod, &quot;in&quot; );
</PRE>
<P>
The receiving module can obtain the message just like as if it
was sent &quot;normally&quot;, through an output gate and connections.
<H3><A NAME="_Toc443041238">Creating connections</A></H3>
<P>
There are two functions that you can use to connect gates. For
a normal user, they are useful for creating connections to dynamically
created modules.
<PRE>
<FONT>connect( cModule *src_module, int src_gatenumber,
</FONT>         cLinkType *channeltype,
         cModule *dest_module, int dest_gatenumber );

connect( cModule *src_module, int src_gatenumber,
         cPar *delay, cPar *error, cPar *datarate,
         cModule *dest_module, int dest_gatenumber );
</PRE>
<P>
Any of the <TT>channeltype</TT>, <TT>delay</TT>, <TT>error</TT>
and <TT>datarate</TT> pointers can be <TT>NULL</TT>.
<P>
An example:
<PRE>
<FONT>connect( this, findGate(&quot;out&quot;),
</FONT>         (cLinkType *)NULL,
         module, module-&gt;findGate(&quot;in&quot;,0) 
       );
</PRE>
<H2><A NAME="_Toc443041239">Routing support: cTopology</A></H2>
<H3><A NAME="_Toc443041240">Overview</A></H3>
<P>
The <TT>cTopology</TT> class  was designed primarily to support
routing in telecommunication or multiprocessor networks.
<P>
A <TT>cTopology</TT> object stores an abstract representation
of the network in graph form. You can specify which modules (either
simple or compound) you want to include in the graph. The graph
will include all connections among the selected modules. In the
graph, all nodes are at the same level, there's no submodule nesting.
Connections which span across compound module boundaries are also
represented as one graph edge. Graph edges are directed, just
as module gates are.
<P>
If you're writing a router or switch model, the <TT>cTopology</TT>
graph can help you determine what nodes are available through
which gate and also to find optimal routes. The <TT>cTopology</TT>
object can calculate shortest paths to any node.
<P>
The mapping between the graph (nodes, edges) and network model
(modules, gates, connections) is preserved so you can easily move
between the topology object and the network.
<H3><A NAME="_Toc443041241">Basic usage</A></H3>
<P>
You can extract the network topology into a <TT>cTopology</TT>
object by a single function call. You have several ways to select
which modules you want to include in the topology. First, you
can specify which node types you want to include. The following
code extracts all modules of type <TT>Router</TT> or <TT>User</TT>.
(<TT>Router</TT> and <TT>User</TT> can be both simple and compound
module types.)
<PRE>
<FONT>cTopology topo;
</FONT>topo.extractByModuleType( &quot;Router&quot;, &quot;User&quot;, NULL );
</PRE>
<P>
Any number of module types (up to 32) can be supplied; the list
must be terminated by <TT>NULL</TT>.
<P>
Second, you can extract all modules which have a certain parameter:
<PRE>
<FONT>topo.extractByParameter( &quot;ip_address&quot; );
</FONT>
</PRE>
<P>
You can also specify that the parameter must have a certain value
for the module to be included in the graph:
<PRE>
<FONT>cPar yes = &quot;yes&quot;;
</FONT>topo.extractByParameter( &quot;include_in_topo&quot;, &amp;yes );
</PRE>
<P>
The third form allows you to pass a function which can determine
for each module whether it should or should not be included. A
<TT>void*</TT> pointer can also be specified which will be passed
to the function when it is called. An example which selects all
top-level modules (and does not use the <TT>void*</TT> pointer):
<PRE>
<FONT>int select_function(cModule *mod, void *)
</FONT>{
    return mod-&gt;parentModule() == simulation.systemModule();
}

topo.extractFromNetwork( select_function, NULL );
</PRE>
<P>
A <TT>cTopology</TT> object uses two types: <TT>sTopoNode</TT>
for nodes and <TT>sTopoLink</TT> for edges. (<TT>sTopoLinkIn</TT>
and <TT>sTopoLinkOut</TT> are 'aliases' for <TT>sTopoLink</TT>;
we'll speak about them later.)
<P>
Once you have the topology, you can start exploring it:
<PRE>
<FONT>for (int i=0; i&lt;topo.nodes(); i++)
</FONT>{
   sTopoNode *node = topo.node(i);
   ev &lt;&lt; &quot;Node i=&quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;

   ev &lt;&lt; &quot;  It has &quot; &lt;&lt; node-&gt;outLinks() &lt;&lt; &quot; conns to other nodes\n&quot;;
   ev &lt;&lt; &quot;  and &quot; &lt;&lt; node-&gt;inLinks() &lt;&lt; &quot; conns from other nodes\n&quot;;

   ev &lt;&lt; &quot;  Connections to other modules are:\n&quot;;
   for (int j=0; j&lt;node-&gt;outLinks(); j++)
   {
      sTopoNode *neighbour = node-&gt;out(i)-&gt;remoteNode();
      cGate *gate = node-&gt;out(i)-&gt;localGate();
      ev &lt;&lt; &quot;     &quot; &lt;&lt; neighbour-&gt;module()-&gt;fullPath() &lt;&lt;
            &quot; through gate &quot; &lt;&lt; gate-&gt;fullName() &lt;&lt; endl;
   }
}
</PRE>
<P>
Explaining the above code, the <TT>nodes()</TT> member function
returns the number of nodes in the graph, and <TT>node(i)</TT>
returns a pointer to the <I>i</I>th, an <TT>sTopoNode</TT> structure.
<P>
The correspondence between a graph node and a module can be obtained
by:
<PRE>
<FONT>sTopoNode *node = topo.nodeFor( module );
</FONT>cModule *module = node-&gt;module();
</PRE>
<P>
The <TT>nodeFor()</TT> member function returns a pointer to the
graph node for a given module. (If the module is not in the graph,
it returns <TT>NULL</TT>). <TT>nodeFor()</TT> uses binary search
so it is fast enough.
<P>
<TT>sTopoNode's</TT> other member functions let you determine
the connections of this node: <TT>inLinks()</TT>, <TT>outLinks()</TT>
return the number of connections, <TT>in(i)</TT> and <TT>out(i)</TT>
return pointers to graph edge objects.
<P>
By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <TT>remoteNode()</TT>
function returns the other end of the connection, and <TT>localGate()</TT>,
<TT>remoteGate()</TT>, <TT>localGateId()</TT> and <TT>remoteGateId()</TT>
return the gate pointers and ids of the gates involved. (Actually,
a graph edge object <TT>sTopoLink</TT> is either returned as <TT>sTopoLinkIn</TT>
or as <TT>sTopoLinkOut</TT> so that &quot;remote&quot; and &quot;local&quot;
can be correctly interpreted for edges of both directions.)
<H3><A NAME="_Toc443041242">Shortest paths</A></H3>
<P>
The real power of <TT>cTopology</TT> is in finding shortest paths
in the network to support optimal routing. <TT>cTopology</TT>
finds shortest paths from <I>all</I> nodes <I>to</I> a target
node. The algorithm is computationally inexpensive. In the simplest
case, all edges have the same weight.
<P>
A real-life example when we have the target module pointer, finding
the shortest path looks like this:
<PRE>
<FONT>sTopoNode *targetnode = topo.nodeFor( targetmodule );
</FONT>topo.unweightedSingleShortestPathsTo( targetnode );
</PRE>
<P>
Walking along the path from our module to the target node:
<PRE>
<FONT>sTopoNode *node = topo.nodeFor( this );

</FONT>if (node == NULL)
{
   ev &lt;&lt; &quot;We (&quot; &lt;&lt; fullPath() &lt;&lt; &quot;) are not included in the topology.\n&quot;;
}
else if (node-&gt;paths()==0)
{
   ev &lt;&lt; &quot;No path to destination.\n&quot;;
}
else
{
   while (node != topo.targetNode())
   {
      ev &lt;&lt; &quot;We are in &quot; &lt;&lt; node-&gt;module-&gt;fullPath() &lt;&lt; endl;
      ev &lt;&lt; node-&gt;distanceToTarget() &lt;&lt; &quot; hops to go\n&quot;;
      ev &lt;&lt; &quot;There are &quot;&lt;&lt; node-&gt;paths() &lt;&lt; 
            &quot; equally good directions, taking the first one\n&quot;;
      sTopoLinkOut *path = node-&gt;path(0);
      ev &lt;&lt; &quot;Taking gate &quot; &lt;&lt; path-&gt;localGate()-&gt;fullName() &lt;&lt;
            &quot; we arrive in &quot; &lt;&lt; path-&gt;remoteNode-&gt;module()-&gt;fullPath() &lt;&lt;
            &quot; on its gate &quot; &lt;&lt; path-&gt;remoteGate()-&gt;fullName() &lt;&lt; endl;
      node = node-&gt;remoteNode();
   }
}
</PRE>
<P>
The purpose of the <TT>distanceToTarget()</TT> member function
of a node is self-explanatory. In the unweighted case, it returns
the number of hops. The <TT>paths()</TT> member function returns
the number of edges which are part of a shortest path, and <TT>path(i)</TT>
returns the <I>i</I>th edge of them as <TT>sTopoLinkOut</TT>.
If the shortest paths were created by the <TT>...SingleShortestPaths()</TT>
function, <TT>paths()</TT> will always return 1 (or 0 if the taget
is not reachable), that is, only one of the several possible shortest
paths are found.  The <TT>...MultiShortestPaths()</TT> functions
find all paths, at increased run-time cost. The <TT>cTopology</TT>'s
<TT>targetNode()</TT> function returns the target node of the
last shortest path search.
<P>
You can enable/disable nodes or edges in the graph. This is done
by calling their <TT>enable()</TT> or <TT>disable()</TT> member
functions. Disabled nodes or edges are ignored by the shortest
paths calculation algorithm. The <TT>enabled()</TT> member function
returns the state of a node or edge in the topology graph.
<P>
One usage of <TT>disable()</TT> is when you want to determine
in how many hops the target node can be reached from our node
<I>through each output gate</I>. To calculate this, you must disable
the current node to prevent shortest paths from going through
it:
<PRE>
<FONT>sTopoNode *thisnode = topo.nodeFor( this );
</FONT>thisnode-&gt;disable();
topo.unweightedSingleShortestPathsTo( targetnode );
thisnode-&gt;enable();

for (int j=0; j&lt;thisnode-&gt;outLinks(); j++)
{
   sTopoLinkOut *link = thisnode-&gt;out(i);
   ev &lt;&lt; &quot;Through gate &quot; &lt;&lt; link-&gt;localGate()-&gt;fullName() &lt;&lt; &quot; : &quot; &lt;&lt;
         1 + link-&gt;remoteNode()-&gt;distanceToTarget() &lt;&lt; &quot; hops&quot; &lt;&lt; endl;
}
</PRE>
<P>
In the future, other shortest path algorithms will also be implemented:
<PRE>
<FONT>unweightedMultiShortestPathsTo(sTopoNode *target);
</FONT>weightedSingleShortestPathsTo(sTopoNode *target);
weightedMultiShortestPathsTo(sTopoNode *target);
</PRE>
<H2><A NAME="_Toc443041243">Deriving new classes</A></H2>
<P>
Nearly all classes in the simulation class library are descendants
of <TT>cObject</TT>. If you want to derive a new class from <TT>cObject</TT>
or a <TT>cObject</TT> descendant, you must redefine some member
functions so that objects of the new type can fully co-operate
with other parts of the simulation system. A more-or-less complete
list of these functions are presented here. Do not be embarrassed
at the length of the list: most functions are not absolutely necessary
to implement. For example, you do not need to redefine <TT>forEach()</TT>
unless your class is a container class.
<UL>
<LI>default constructor, copy constructor. The copy constructor
can simply call the assignment operator.
<LI><TT>operator=():</TT> the assignment operator (copies object
contents from another object)
<LI><TT>dup()</TT>: duplicates the object by creating an exact
copy (uses copy constructor)
<LI><TT>isA()</TT>: returns class name string
<LI><TT>info()</TT>: returns a one-line info about object contents
<LI><TT>writeContents()</TT>: write a more detailed report about
the object into a file
<LI><TT>forEach()</TT>: iterates through all contained objects
if any
<LI><TT>netPack(),netUnpack():</TT> they are needed only if objects
of this type will be sent over PVM from one segment to another.
The <TT>netPack(),netUnpack()</TT>functions of the library classes
are in the <TT>sim/pvm/pvmpack.cc</TT> file.
<LI><TT>inspector():</TT> used by Tkenv and Tvenv to display inspectors
for objects of this type. The <TT>inspector()</TT> functions of
the library classes are implemented as part of the user interface
libraries (Tkenv and Tvenv).
</UL>
<P>
One should also use the <TT>Register_Class()</TT> macro to register
the new class. It is used by the <TT>createOne()</TT> function
and the PVM extension of OMNeT++.
<P>
Let us see a simple example. The header file:
<PRE>
<FONT>// File: cmyclass.h
</FONT>#include &quot;cobject.h&quot;

class cMyClass : public cObject
{
   public:
        int samples;

        cMyClass(cMyClass&amp; myclass);
        cMyClass(char *name=NULL, int k=0);
        virtual ~cMyClass()  {}
        virtual char *isA()  {return &quot;cMyClass&quot;;}
        virtual cObject *dup()  {return new cMyClass(*this);}
        virtual void info(char *buf);
        virtual void writeContents(ostream&amp; os);
        cMyClass&amp; operator=(cMyClass&amp; myclass);
};
</PRE>
<P>
The corresponding <TT>.cc</TT> file:
<PRE>
<FONT>// File: cmyclass.cc
</FONT>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include &quot;cmyclass.h&quot;

Register_Class( cMyClass )

cMyClass::cMyClass(cMyClass&amp; myclass) : cObject()
{
        setName( myclass.name() );
        operator=( myclass );
}

cMyClass::cMyClass(char *name, int k) : cObject( name )
{
        samples = k;
}

void cMyClass::info(char *buf)
{
        cObject::info( buf );
        sprintf( buf+strlen(buf), &quot; samples=%d&quot;, samples);
}

void cMyClass::writeContents(ostream&amp; os)
{
        os &lt;&lt; &quot;  samples:  &quot; &lt;&lt; samples &lt;&lt; '\n';
}

cMyClass&amp; cMyClass::operator=(cMyClass&amp; myclass)
{
        cObject::operator=(myclass);
        samples = myclass.samples;
}
</PRE>
<P>
See the virtual functions of <TT>cObject</TT> in the Reference
Manual for more information.
<H2><A NAME="_Toc443041244">Tracing and debugging aids</A></H2>
<H3><A NAME="_Toc443041245">Displaying information about module
activity</A></H3>
<P>
The global object called <TT>ev</TT> represents the user interface
of the simulation program. You can send data to <TT>ev</TT> using
the C++-style I/O operator (<TT>&lt;&lt;</TT>). 
<PRE>
<FONT>ev &lt;&lt; &quot;started\n&quot;;
</FONT>ev &lt;&lt; &quot;about to send message #&quot; &lt;&lt; i &lt;&lt; endl;
ev &lt;&lt; &quot;queue full, discarding packet\n&quot;;
</PRE>
<P>
The exact way messages are displayed to the user depends on the
user interface. In the command-line user interface (Cmdenv), it
is simply dumped to the standard output. (This output can also
be disabled from the ini file so that it doesn't slow down simulation
when it is not needed.) In windowing user interfaces (Tvenv, Tkenv),
each simple module can have a separate text output window. 
<P>
The above mean that you should <I>not</I> use <TT>printf</TT>,
<TT>cout &lt;&lt;</TT> and the like: with Tkenv, their output
would appear in the <TT>xterm</TT> window behind the graphical
window of the simulation application, or with Tvenv, mess up the
character-graphical Turbo Vision screen.
<P>
The user can also specify a phase string that is displayed at
the top of the text output windows. The phase string can indicate
what the module is currently doing.
<PRE>
<FONT>setPhase(&quot;starting up&quot;);
</FONT>for(;;)
{
   setPhase(&quot;idle&quot;);
   //...
   setPhase(&quot;opening connection&quot;);
   ev &lt;&lt; &quot;connection request from &quot; &lt;&lt; src &lt;&lt; &quot;\n&quot;;
   //..
   setPhase(&quot;connection alive&quot;);
   //..
   setPhase(&quot;closing connection&quot;);
   //...
}
</PRE>
<P>
Writing out informative messages at strategic points of the code
is an effective way of doing high-level debugging.
<H3><A NAME="_Toc443041246">Watches</A></H3>
<P>
You may want some of your <TT>int</TT>, <TT>long</TT>, <TT>double</TT>,
<TT>char</TT>, etc. variables be visible in Tkenv/Tvenv and to
be output into the snapshot file. In this case, you can create
<TT>cWatch</TT> objects for them with the <TT>WATCH</TT> macro:
<PRE>
<FONT>int i; WATCH(i);
</FONT>char c; WATCH(c);
</PRE>
<P>
Tkenv also lets you change the value of the variables for which
a <TT>WATCH</TT> is created.
<P>
The <TT>WATCH()</TT> macro expands to a dynamically  created <TT>cWatch</TT>
object. The object remembers the address and type of your variable.
The macro expands to something like:
<PRE>
<FONT>new cWatch(&quot;i&quot;,i);
</FONT>
</PRE>
<P>
You can also make a <TT>WATCH</TT> for pointers of type <TT>char*</TT>
or <TT>cObject*</TT>, but this may cause a segmentation fault
if the pointer does not point to a valid location when <TT>snapshot()</TT>
is called.
<P>
You can also set watches for variables that are members of the
module class or for structure fields:
<PRE>
<FONT>WATCH( lapbconfig.timeout );
</FONT>
</PRE>
<P>
<B>NOTE</B><I> Do not</I> execute a <TT>WATCH</TT> statement more
than once! The best place for <TT>WATCH</TT> is the top of the
module <TT>activity()</TT> function. If you use <TT>handleMessage()</TT>,
always put the <TT>WATCH</TT> in the <TT>initialize()</TT> function
never in <TT>handleMessage()</TT> itself to avoid creating new
<TT>cWatch</TT> objects with each event.
<H3><A NAME="_Toc443041247">Snapshots</A></H3>
<P>
The <TT>snapshot()</TT> function outputs textual information about
all or selected objects of the simulation (including the objects
created in module functions by the user) into the snapshot file.
<PRE>
<FONT>bool snapshot(cObject *obj = &amp;simulation, char *label = NULL);
</FONT>
</PRE>
<P>
The function can be called from module functions, like this:
<PRE>
<FONT>snapshot();           // dump the whole network
</FONT>snapshot(this);       // dump this simple module and all its objects
snapshot(&amp;putAsideQueue);        // dump queue contents
snapshot(&amp;simulation.msgQueue);  // dump future events
</PRE>
<P>
This will append snapshot information to the end of the snapshot
file. (The snapshot file name has an extension of <TT>.sna</TT>,
default is <TT>omnetpp.sna</TT>. Actual file name can be set in
the config file.)
<P>
The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <TT>snapshot()</TT>, one
can trace how the values of variables, objects changed over the
simulation. The arguments: <TT>label</TT> is a string that will
appear in the output file; <TT>obj</TT> is the object whose inside
is of interest. By default, the whole simulation (all modules
etc) will be written out.
<P>
If you run the simulation with Tvenv or Tkenv, you can also create
a snapshot from the menu.
<P>
An example of a snapshot file:
<PRE>
<FONT>================================================
</FONT>||               SNAPSHOT                     ||
================================================
| Of object:    `simulation'
| Label:        `three-station token ring'
| Sim. time:     0.0576872457 ( 57ms)
| Network:      `token'
| Run no.        1
| Started at:    Mar 13, 1997, 14:23:38
| Time:          Mar 13, 1997, 14:27:10
| Elapsed:       5 sec
| Initiated by:  operator
================================================

(cSimulation) `simulation' begin
  Modules in the network:
    `token' #1 (TokenRing)
        `comp[0]' #2 (Computer)
            `mac' #3 (TokenRingMAC)
            `gen' #4 (Generator)
            `sink' #5 (Sink)
        `comp[1]' #6 (Computer)
            `mac' #7 (TokenRingMAC)
            `gen' #8 (Generator)
            `sink' #9 (Sink)
        `comp[2]' #10 (Computer)
            `mac' #11 (TokenRingMAC)
            `gen' #12 (Generator)
            `sink' #13 (Sink)
end

(cCompoundModule) `token' begin
   #1 params    (cArray) (n=6)
   #1 gates     (cArray) (empty)
   comp[0]         (cCompoundModule,#2)
   comp[1]         (cCompoundModule,#6)
   comp[2]         (cCompoundModule,#10)
end

(cArray) `token.parameters' begin
   num_stations (cModulePar) 3 (L)
   num_messages (cModulePar) 10000 (L)
   ia_time      (cModulePar) truncnormal(0.005,0.003) (F)
   THT          (cModulePar) 0.01 (D)
   data_rate    (cModulePar) 4000000 (L)
   cable_delay  (cModulePar) 1e-06 (D)
end

(cModulePar) `token.num_stations' begin
  Type: L
  Value: 3
end

<I>[...token.num_messages omitted...]

</I>(cModulePar) `token.ia_time' begin
  Type:  F
  Value: truncnormal(0.005,0.003)
end

<I>[...rest of parameters &amp; gates stuff deleted from here...]

</I>(cCompoundModule) `token.comp[0]' begin
   parameters   (cArray) (empty)
   gates        (cArray) (n=2)
   mac             (TokenRingMAC,#3)
   gen             (Generator,#4)
   sink            (Sink,#5)
end

(cArray) `token.comp[0].parameters' begin
end

(cArray) `token.comp[0].gates' begin
   in           (cGate)  &lt;-- comp[2].out
   out          (cGate)  --&gt; D --&gt; comp[1].in
end

(cGate) `token.comp[0].in' begin
  type:  input
  inside connection:  token.comp[0].mac.phy_in
  outside connection: token.comp[2].out
  delay: -
  error: -
  data rate: -
end

(cGate) `token.comp[0].out' begin
  type:  output
  inside connection:  token.comp[0].mac.phy_out
  outside connection: token.comp[1].in
  delay:              (cPar) 1e-06 (D)
  error: -
  data rate: -
end

(TokenRingMAC) `token.comp[0].mac' begin
   parameters   (cArray) (n=2)
   gates        (cArray) (n=4)
   local-objects (cHead)
   class-data-members (cHead)
   putaside-queue (cQueue) (empty)
end

<I>[...comp[0].mac parameters stuff deleted from here...]

</I>(cArray) `token.comp[0].mac.gates' begin
   phy_in       (cGate)  &lt;-- &lt;parent&gt;.in
   from_gen     (cGate)  &lt;-- gen.out
   phy_out      (cGate)  --&gt; &lt;parent&gt;.out
   to_sink      (cGate)  --&gt; sink.in
end

<I>[...detailed gate list deleted from here...]

</I>(cHead) `token.comp[0].mac.local-objects' begin
   sendqueue-length (cOutVector) (single)
   send-queue   (cQueue) (n=11)
end

(cOutVector) `token.comp[0].mac.local-objects.sendqueue-length' begin
end

(cQueue) `token.comp[0].mac.local-objects.send-queue' begin
   0--&gt;1        (cMessage) Tarr=0.0158105774 ( 15ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0163553310 ( 16ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0205628236 ( 20ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0242203591 ( 24ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0300994268 ( 30ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0364005251 ( 36ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0370745702 ( 37ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0387984129 ( 38ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0457462493 ( 45ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0487308918 ( 48ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0514466766 ( 51ms)  Src=#4 Dest=#3
end

(cMessage) `token.comp[0].mac.local-objects.send-queue.0--&gt;1' begin
  #4 --&gt; #3
  sent:      0.0158105774 ( 15ms)
  arrived:   0.0158105774 ( 15ms)
  length:    33536
  kind:      0
  priority:  0
  error:     FALSE
  time stamp:0.0000000  ( 0.00s)
  parameter list:
   dest         (cPar) 1 (L)
   source       (cPar) 0 (L)
   gentime      (cPar) 0.0158106 (D)
end

(cArray) `token.comp[0].mac.local-objects.send-queue.0--&gt;1.par-vector' begin
   dest         (cPar) 1 (L)
   source       (cPar) 0 (L)
   gentime      (cPar) 0.0158106 (D)
end

<I>[...message parameters and the other messages' stuff deleted...]

</I>(cHead) `token.comp[0].mac.class-data-members' begin
end

(cQueue) `token.comp[0].mac.putaside-queue' begin
end

<I>[...comp[0].gen and comp[0].sink stuff deleted from here...]
[...whole comp[1] and comp[2] stuff deleted from here...]

</I>(cMessageHeap) `simulation.message-queue' begin
   1--&gt;0        (cMessage) Tarr=0.0576872457 ( 57ms)  Src=#8 Dest=#7
                (cMessage) Tarr=0.0577201630 ( 57ms)  Mod=#8 (selfmsg)
                (cMessage) Tarr=0.0585677054 ( 58ms)  Mod=#4 (selfmsg)
                (cMessage) Tarr=0.0594939072 ( 59ms)  Mod=#12 (selfmsg)
                (cMessage) Tarr=0.0601010000 ( 60ms)  Mod=#7 (selfmsg)
   1--&gt;2        (cMessage) Tarr=0.0601020000 ( 60ms)  Src=#11 Dest=#13
end

<I>[...detailed list of message queue contents deleted from here...]
</I>
</PRE>
<P>
To reduce the size of the file, you may well decide to make a
snapshot only of a part of the model. This example reports only
about the current simple module's put-aside queue:
<PRE>
<FONT>snapshot(&amp;putAsideQueue);
</FONT>
</PRE>
<H3><A NAME="_Toc443041248">Breakpoints</A></H3>
<P>
In those user interfaces which support debugging, breakpoints
stop execution and the state of the simulation can be examined.
<P>
You can set a breakpoint inserting a <TT>breakpoint()</TT> call
into the source:
<PRE>
<FONT>for(;;)
</FONT>{
   cMessage *msg = receive();
   breakpoint(&quot;before-processing&quot;);
   //..
   breakpoint(&quot;before-send&quot;);
   send( reply_msg, &quot;out&quot; );
   //..
}
</PRE>
<P>
In user interfaces that do not support debugging, <TT>breakpoint()</TT>
calls are simply ignored.
<H3><A NAME="_Toc443041249">Choosing the correct stack size</A>
</H3>
<P>
If is important to choose the correct stack size for modules.
If the stack is too large, it unnecessarily consumes memory; if
it is too small, stack violation occurs.
<P>
From the Feb99 release, OMNeT++ contains a mechanism that detects
stack overflows.<SUP>(NEW)</SUP> It checks the intactness of a
predefined byte pattern (<TT>0xdeadbeef</TT>) at the stack boundary,
and reports &quot;stack violation&quot; if it was overwritten.
The mechanism usually works fine, but occasionally it is fooled
by large -- and not fully used -- local variables (e.g. <TT>char
buffer[256]</TT>): it does not detect the stack violation if the
byte pattern falls in the middle of such a local variable.
<P>
To be able to make a good guess about stack size, you can use
the <TT>stackUsage()</TT> call which tells you how much stack
the module actually uses. It is most conveniently called from
<TT>finish()</TT>:
<PRE>
<FONT>void FooModule::finish()
</FONT>{
   ev &lt;&lt; stackUsage() &lt;&lt; &quot;bytes of stack used\n&quot;;
}
</PRE>
<P>
The value includes the extra stack added by the user interface
library (see <I>extraStackforEnvir</I> in <TT>envir/omnetapp.h</TT>),
which is currently 8K for Cmdenv and 16K for Tkenv.
<P>
<TT>stackUsage()</TT>also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the
above effect with local variables.<BR>
<H2><A NAME="_Toc443041250">An alternative to activity(): handleMessage()</A>
</H2>
<H3><A NAME="_Toc443041251">Motivation</A></H3>
<P>
&quot;Isn't activity() good enough?,&quot; you may ask. <TT>Activity()</TT>
offers an easy programming model and it is the best choice for
most simulations. However, the fact that it uses coroutines can
make it impractical if you have a large number of modules (say
a few thousand). If you have this many modules exisiting <I>at
the same time</I> in the model, coroutine stacks can increase
the memory requirements of your simulation a lot. For example,
if you have 10.000 modules each of which uses 16K stack, then
your simulation will allocate 160MB memory just for coroutine
stacks (In fact, it will even allocate more, because the stack
size you specify is increased by a few K to satisfy the needs
of the user interface library).
<P>
It is important to understand that the above situation is not
special to OMNeT++. The same problem is present in <I>any system</I>
that is based on coroutines or threads. (Just try to create 10.000
NT threads at once.)
<P>
The <TT>handleMessage()</TT> mechanism solves this problem at
the cost of increased complexity in the models. Your simulation
may also run slightly faster than with <TT>activity()</TT>, because
<TT>handleMessage()</TT> does not do context switches.
<P>
Modules written with <TT>activity()</TT> and <TT>handleMessage()</TT>
can be freely mixed within a simulation, so you can choose per-module
basis.
<P>
When should you choose <TT>activity()</TT> and when <TT>handleMessage()</TT>?
Here are few rules of thumb to help decide:
<UL>
<LI>if you're not sure, use <TT>activity()</TT>. It usually allows
a lot easier and more natural coding, and results in a more readable
code.
<LI>if you are going to create very many (more than a few thousand)
co-existing instances of a module type and you're likely to be
faced with memory problems, you should consider using <TT>handleMessage()</TT>
for <I>that</I> module type. Other modules can use <TT>activity()</TT>.
<LI>if you have a protocol whose standard describes it using an
FSM, then <TT>handleMessage()</TT> is probably the better choice.
<LI>if your simple module code has the following structure:
</UL>
<PRE>
<FONT>      // initialization
</FONT>      for (;;) {
        cMessage *msg = receive();
        // code that processes msg and does <B>not</B> do receive() or wait()
      }
</PRE>
<P>
then it is a good candidate for <TT>handleMessage()</TT>.
<P>
It is a good idea to look at both the <TT>fifo1</TT> and <TT>fifo2</TT>
sample simulations and compare them.
<H3><A NAME="_Toc443041252">The handleMessage() mechanism</A>
</H3>
<P>
The idea is that at each event we simply call a user-defined function
instead of switching to a coroutine that has <TT>activity()</TT>
running in it. The &quot;user-defined function&quot; is <TT>the
handleMessage(cMessage *msg)</TT> virtual member function of <TT>cSimpleModule</TT>;
the user has to redefine the function to make it do useful work.
Calls to <TT>handleMessage()</TT> occur in the main stack of the
program -- no coroutine stack is needed and no context switch
is done.
<P>
The idea is not new, most discrete event simulators like OPNET
and NetSim++ have this short of event processing mechanism, maybe
topped with something like a state machine (EFSM).
<P>
To use this mechanism for a simple module, you must 
<UL>
<LI>specify<B> zero stack size</B> for the module. This is important,
because this tells OMNeT++ that you want to use <TT>handleMessage()</TT>
and not <TT>activity()</TT>.
<LI>redefine the <TT>handleMessage(cMessage *msg)</TT> function.
<LI>in all but the simplest cases, you'll also need to redefine
<TT>initalize().</TT>
</UL>
<P>
The <TT>handleMessage()</TT> function will be called for every
message that arrives at the module. The function should process
the message and return immediately after that.
<P>
<TT><B><FONT>Receive...()</FONT></B></TT><B>
and </B><TT><B><FONT>wait()</FONT></B></TT><B>
CANNOT be used in</B><TT><B><FONT> handleMessage()</FONT></B>.</TT>
They are coroutine-based by nature.
<P>
No simulation time elapses within a call to <TT>handleMessage()</TT>.
<P>
A simple example:
<PRE>
<FONT>class Generator : public cSimpleModule
</FONT>{
    Module_Class_Members(Generator,cSimpleModule,0)
               // note the zero stack size here ^^^

    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module( Generator )

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new cMessage(&quot;timer&quot;));
}

void Generator::handleMessage(cMessage *msg)
{
    // generate &amp; send packet
    cMessage *pkt = new cMessage(&quot;packet&quot;);
    send(pkt, &quot;out&quot;);

    // schedule next sending
    scheduleAt(simTime()+exponential(1.0), msg);
}
</PRE>
<P>
This seems easy. Complexity comes because some information (the
&quot;state&quot; of the module) must be preserved across calls
to <TT>handleMessage()</TT>. This information cannot be stored
in local variables of <TT>handleMessage()</TT> because they are
destroyed when the function returns. Also, they cannot be stored
in static variables within the function, because they would be
shared between all modules of this class. Instead, they should
be stored in data members of the module class and be assigned
an initial value in <TT>initialize()</TT>. (Do NOT use the constructor!
The network is not yet fully built when the constructor is called,
so you might get strange results...)
<P>
If you want to put a watch on a state variable, place the <TT>WATCH()</TT>
statement into <TT>initialize()</TT> and <I>never</I> in <TT>handleMessage()</TT>.
<TT>WATCH()</TT> creates a dynamic <TT>cWatch</TT> object, and
we do not want this to happen each time <TT>handleMessage()</TT>
is called.
<P>
As an example, we can rewrite our <TT>Generator</TT> to create
packet bursts, each consisting of <TT>burst_length</TT> packets.
<P>
We add some data members to the class:
<PRE>
<FONT>class BurstyGenerator : public cSimpleModule
</FONT>{
    Module_Class_Members(Generator,cSimpleModule,0)
               // note the zero stack size here ^^^

    int burst_length;
    int burst_ctr;

    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};<BR>
</PRE>
<P>
<TT>Burst_length</TT> will store the parameter that specifies
how many packets a burst must contain, and we'll count in <TT>burst_ctr</TT>
how many packets are left to be sent in the current burst.
<PRE>
<FONT>Define_Module( BurstyGenerator )

</FONT>void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burst_length = par(&quot;burst_length&quot;);
    burst_ctr = burst_length;

    // schedule first packet of first burst
    scheduleAt(simTime(), new cMessage(&quot;timer&quot;));
}

void BurstyGenerator::handleMessage(cMessage *msg)
{
    // generate &amp; send packet
    cMessage *pkt = new cMessage(&quot;packet&quot;);
    send(pkt, &quot;out&quot;);

    // if this was the last packet of the burst
    if (--burst_ctr == 0)
    {
       // schedule next burst
       burst_ctr = burst_length;
       scheduleAt(simTime()+exponential(5.0), msg);
    }
    else
    {
       // schedule next sending within burst
       scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</PRE>
<H3><A NAME="_Toc443041253">Using the FSM macros</A></H3>
<P>
Finite State Machines (FSMs) can make life with <TT>handleMessage()</TT>
easier. OMNeT++ provides a class and a set of macros to build
FSMs. OMNeT++'s FSMs work very much like OPNET's or SDL's.
<P>
The key points are:
<UL>
<LI>There are two kinds of states: <I>transient</I> and <I>steady</I>.
At each event (that is, at each call to <TT>handleMessage()</TT>),
the FSM transitions out of the current (<I>steady</I>) state,
undergoes a series of state changes (runs through a number of
transient states), and finally arrives at another steady state.
Thus between two events, the system is always in some steady state.
Transient states are therefore not really a must - they exist
only to group actions to be taken during a transition in a convenient
way.
<LI>You can assign program code to entering and leaving a state
(known as entry/exit code). Staying in the same state is handled
as leaving and re-entering the state.
<LI>Entry code should not modify the state (this is verified).
State changes (transitions) must be put into the exit code.
</UL>
<P>
As far as implementation goes, the FSM state is basically an integer.
It is stored in an object of type <TT>cFSM</TT>. The possible
states are defined by an <TT>enum</TT>; the <TT>enum</TT> is also
a place to tell which state is transient and which is steady.
The actual FSM is embedded in a switch-like statement, <TT>FSM_Switch()</TT>.
State transitions are simply implemented by assigning a new value
to the integer in <TT>cFSM</TT>. The FSM starts from a special
state INIT which has the numeric 0 code.
<P>
As an example, here's another flavour of a bursty generator. It
has two states, SLEEP and ACTIVE. In the SLEEP state, the module
does nothing; in the ACTIVE state, it sends messages with a given
inter-arrival time. The code was taken from the <TT>fifo2</TT>
sample simulation.
<PRE>
<FONT>#define FSM_DEBUG
</FONT>#include &quot;omnetpp.h&quot;

class BurstyGenerator : public cSimpleModule
{
  public:
    Module_Class_Members(BurstyGenerator,cSimpleModule,0)

    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    cPar *msgLength;

    // FSM and its states
    cFSM fsm;
    enum {
       INIT = 0,
       SLEEP = FSM_Steady(1),
       ACTIVE = FSM_Steady(2),
       SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    cMessage *startStopBurst;
    cMessage *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module( BurstyGenerator )

void BurstyGenerator::initialize()
{
    fsm.setName(&quot;fsm&quot;);

    sleepTimeMean = par(&quot;sleep_time_mean&quot;);
    burstTimeMean = par(&quot;burst_time_mean&quot;);
    sendIATime = par(&quot;send_ia_time&quot;);
    msgLength = &amp;par(&quot;msg_length&quot;);

    i = 0; 
    WATCH(i); // always put watches in initialize()
    startStopBurst = new cMessage(&quot;startStopBurst&quot;);
    sendMessage = new cMessage(&quot;sendMessage&quot;);

    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(cMessage *msg)
{
    FSM_Switch(fsm)
    {
      case FSM_Exit(INIT):
        // transition to SLEEP state
        FSM_Goto(fsm,SLEEP);
        break;

      case FSM_Enter(SLEEP):
        // schedule end of sleep period (start of next burst)
        scheduleAt(simTime()+exponential(sleepTimeMean),
                   startStopBurst);
        break;

      case FSM_Exit(SLEEP):
        // schedule end of this burst
        scheduleAt(simTime()+exponential(burstTimeMean), 
                   startStopBurst);
        // transition to ACTIVE state:
        if (msg!=startStopBurst)
            error(&quot;invalid event in state ACTIVE&quot;);
        FSM_Goto(fsm,ACTIVE);
        break;

      case FSM_Enter(ACTIVE):
        // schedule next sending
        scheduleAt(simTime()+exponential(sendIATime), sendMessage);
        break;

      case FSM_Exit(ACTIVE):
        // transition to either SEND or SLEEP
        if (msg==sendMessage) {
            FSM_Goto(fsm,SEND);
        } else if (msg==startStopBurst) {
            cancelEvent(sendMessage);
            FSM_Goto(fsm,SLEEP);
        } else
            error(&quot;invalid event in state ACTIVE&quot;);
        break;

      case FSM_Exit(SEND):
      {
        // generate and send out job
        char msgname[32];
        sprintf( msgname, &quot;job-%d&quot;, ++i);
        ev &lt;&lt; &quot;Generating &quot; &lt;&lt; msgname &lt;&lt; endl;
        cMessage *job = new cMessage(msgname);
        job-&gt;setLength( (long) *msgLength );
        job-&gt;setTimestamp();
        send( job, &quot;out&quot; );
        
        // return to ACTIVE
        FSM_Goto(fsm,ACTIVE);
        break;
      }
    }
}
</PRE>
<P>
OMNeT++'s FSMs <I>can</I> be nested. This means that any state
(or rather, its entry or exit code) may contain a further full-fledged
<TT>FSM_Switch</TT>. This allows you to structure a large state
space. (OPNET, at least up to version 4.0, does not support FSM
nesting.)
<H2><A NAME="_Toc443041254">Tips for speeding up the simulation</A>
</H2>
<P>
Here are a few tips that can help you make the simulation faster:
<UL>
<LI>Turn off the display of screen messages when you run the simulation.
You can do this in the ini file. Alternatively, you can place
<TT>#ifdef</TT>s around your <TT>ev&lt;&lt;</TT> and <TT>ev.printf()</TT>
calls and turn off the define when compiling the simulation for
speed.
<LI>Store the module parameters in local variables to avoid calling
<TT>cPar</TT> member functions every time.
<LI>Use gate numbers instead of gate names.
<LI>Try to minimize message creations and deletions. Reuse messages
if possible.
<LI>Do not give name strings to objects that are created and deleted
many times (pass <TT>NULL</TT> pointer as name).
<LI>Use numeric index to get an object from a <TT>cArray</TT>,
not the object name. You can do this also with message parameters.
</UL>
<P>
Two techniques are discussed here in detail:
<UL>
<LI>message subclassing, and
<LI>using shared objects
</UL>
<H3><A NAME="_Toc443041255">Message subclassing</A></H3>
<P>
&#133;
<H3><A NAME="_Toc443041256">Using shared objects</A></H3>
<P>
In a complex simulation, a lot of messages are created, sent and
destroyed. Messages typically have more or less parameters attached
to them as <TT>cPar</TT> objects and it frequently happens that
a certain parameter has identical values in all messages (for
example, source address in a frame is the same in all messages
sent by one module). Still, separate parameter objects are created
and destroyed with each message, which is very costly. One could
save significant amount of CPU time and memory if a single object
could serve as a parameter to all existing messages.
<P>
This can be achieved with proper ownership control. See the following
example:
<PRE>
<FONT>void MyComputer::activity()
</FONT>{
   cPar source_addr;    // address of this node
   cPar dest_addrs[3];  // possible destinations

   source_addr.setValue( 'S', &quot;DECnet000728&quot; );
   dest_addrs[0].setValue( 'S', &quot;cisco_F99030&quot; );
   dest_addrs[1].setValue( 'S', &quot;DEC___28E6AD&quot; );
   dest_addrs[2].setValue( 'S', &quot;DECnet000B04&quot; );

   long k=0;
   for(;;)
   {
      cMessage *packet = new cMessage(&quot;DATA&quot;);

      packet-&gt;addPar( *new cPar(&quot;sequence&quot;, 'L', k++) );

      packet-&gt;parList().takeOwnership( FALSE );  // NOTE THIS LINE!!!

      packet-&gt;addPar( source_addr );
      packet-&gt;addPar( dest_addrs[ k%3 ] );

      send(packet, &quot;output-gate&quot;);

      wait( truncnormal(1.5, 0.5) );
   }
}
</PRE>
<P>
The above simple module code models the message generation part
of a computer on a LAN. The module sends out messages (packets)
to different stations in about each 1.5 seconds. The messages
have three parameters: the source address, the destination address
and a sequence number. The source address is the same in each
packet, and there are only three possible destination stations.
The sequence number is different in each packet.
<P>
To avoid the overhead caused by having to create source and destination
address objects for each message, the module creates these objects
only once; they will be shared among all messages. Separate sequence
number objects are created for each message.
<P>
Let us see what happens to the sequence number object when it
is inserted into the message. The message object, by default,
takes the ownership of the object. Ownership means the <I>responsibility</I>
<I>of</I> <I>destruction</I>; that is, when the message is destroyed,
the parameter object will be destroyed as well.
<P>
This is exactly what we need most of the time. But if we just
added the <I>shared</I> source and destination address objects
to a message, then we would have problems when the message is
destroyed. Somehow it must be told to the message object to leave
our shared parameters alone and not to become their owner. This
is exactly what the 
<PRE>
<FONT>packet-&gt;parList().takeOwnership(FALSE);
</FONT>
</PRE>
<P>
line does: it sets a flag that tells the message (to be more precise,
to its internal parameter list object) not to take the ownership
of objects that will be inserted from then on. It does not affect
objects already inserted. As a result, all messages will just
hold pointers to the shared <TT>cPar</TT> objects and never do
any harm to them.
<P>
The above example shows that with CPU-intensive simulations, you
can save a lot of computation time and memory just by using the
ownership mechanism already present in OMNeT++.
<HR><H1><A NAME="_Toc443041257">Compiling and running a simulation</A>
</H1>
<H2><A NAME="_Toc443041258">Overview</A></H2>
<P>
As it was already mentioned, an OMNeT++ model physically consists
of the following parts:
<UL>
<LI>NED language topology description(s). These are files with
the <TT>.ned</TT> suffix.
<LI>Simple modules. These are C++ files, with <TT>.cc</TT> suffix.
</UL>
<P>
Model files are usually placed in the <TT>projects/modelname</TT>
subdirectory of the main OMNeT++ directory.
<P>
The NED files are compiled into C++ using the NEDC compiler which
is part of OMNeT++. The NEDC compiler (source and executable)
is normally located in the <TT>nedc</TT> subdirectory of the main
OMNeT++ directory.
<P>
The simulation system provides the following components that will
be part of the simulation executable:
<UL>
<LI>Simulation kernel with the simulation class library. This
is a library file with <TT>.a</TT> or <TT>.lib</TT> extension,
normally in the <TT>sim</TT> subdirectory of the main OMNeT++
directory. It comes in two versions: <TT>libsim_std.a</TT> (<TT>sim_std.lib</TT>)
is the standard version and <TT>libsim_pvm.a</TT> (<TT>sim_pvm.lib</TT>)
is the one to be used with parallel execution.
<LI>User interfaces. These are also library files (<TT>.a</TT>
or <TT>.lib</TT> file), normally in the <TT>envir</TT> directory
and its subdirectories. The common part of all user interfaces
is <TT>libenvir.a</TT> (<TT>envir.lib</TT>), and the specific
user interfaces are <TT>libcmdenv.a</TT> (<TT>cmdenv.lib</TT>),
<TT>libtvenv.a</TT> (<TT>tvenv.lib</TT>) etc, in the corresponding
subdirectories of <TT>envir</TT>. 
</UL>
<P>
Simulation programs are built from the above components. First,
the NED files are compiled into C++ source code using the NEDC
compiler. Then all C++ sources are compiled and linked with the
simulation kernel and a user interface to form a simulation executable.
<P>
The following figure gives an overview of the process of building
and running simulation programs.<BR>
<P>
<CENTER><IMG SRC="img00017.gif"><BR>
</CENTER>
<P>
This section discusses how to use the simulation system on the
following platforms:
<UL>
<LI>Unix with gcc installed
<LI>DOS with Borland C++ 3.1
<LI>Windows 95 or NT with Borland C++ 5.0
</UL>
<P>
Other feasible alternatives could be DJGPP on DOS, other C++ compilers
on Win95/NT (MSVC, Watcom etc.).
<H2><A NAME="_Toc443041259">Using Unix and gcc</A></H2>
<H3><A NAME="_Toc443041260">Installation</A></H3>
<P>
Installation essentially consists of building NEDC and the necessary
libraries. 
<P>
After you've unpacked the distribution in your home directory,
just type the following commands:
<PRE>
<FONT>cd ~/omnetpp
</FONT>./configure
./makeall
</PRE>
<P>
It will build all the libraries and the example programs for you.
If you have a C++ compiler other then gcc, you'll have to edit
the <TT>configur</TT> script.
<H3><A NAME="_Toc443041261">Producing a makefile with the makemake
script</A></H3>
<P>
The <TT>makemake</TT> script can automatically generate the <TT>makefile</TT>
for your simulation program, based on the source files it finds
in your directory. <TT>makemake</TT> has several options; type
<PRE>
<FONT>makemake -h
</FONT>
</PRE>
<P>
to see them.
<P>
To be able to use <TT>makemake</TT>, you have to collect all your
sources (<TT>.ned</TT>, <TT>.cc</TT>, <TT>.h</TT> files) in one
directory. (Large models which spread across several directories
are covered later in this section.)
<P>
Then type 
<PRE>
<FONT>makemake
</FONT>
</PRE>
<P>
If you already had a makefile in that directory, you'll have to
force makemake to overwrite it:
<PRE>
<FONT>makemake -f
</FONT>
</PRE>
<P>
If you have problems, check the path definitions (locations of
include files and libraries etc.) in the <TT>configure</TT> script
and correct them if necessary. Then re-run <TT>configure</TT>
to commit the changes to all <TT>makefile</TT>s, the <TT>makemake</TT>
script etc.
<P>
You can specify the user interface (Cmdenv/Tkenv/Tvenv) with the
<TT>-u</TT> option (with no <TT>-u</TT>, Tkenv is the default):
<PRE>
<FONT>makemake -u Tkenv<BR>
</FONT>
</PRE>
<P>
The name of the output file is set with the -o option (the default
is the name of the directory):
<PRE>
<FONT>makemake -o fddi-net
</FONT>
</PRE>
<P>
If some of your source files are generated from ther files (for
example, you use machine-generated NED files), write make rule
into a file called <TT>makefrag</TT>. When you run <TT>makemake</TT>,
it will automatically insert <TT>makefrag</TT> into the resulting
<TT>makefile</TT>. (With the <TT>-i</TT> option, you can also
name other files to include into <TT>makefile</TT>).
<H3><A NAME="_Toc443041262">Multi-directory models</A></H3>
<P>
In the case of a large project, your source files may be spread
across several directories. You have to decide whether you want
to use static linking, shared or run-time loaded libraries. Here
we discuss static linking.
<P>
In each subdirectory (say <TT>trafgen/</TT> and <TT>router/</TT>),
run
<PRE>
<FONT>makemake -n
</FONT>
</PRE>
<P>
The <TT>-n</TT> option means no linking is necessary, only compiling
has to be done.
<P>
In your toplevel source directory, run
<PRE>
<FONT>makemake trafgen/ router/
</FONT>
</PRE>
<P>
This results in recursive <TT>makefiles</TT>: when you build the
simulation, <TT>make</TT> will descend into <TT>trafgen/</TT>
and <TT>router/</TT>, run <TT>make</TT> in both, then it will
link an executable with the object files in the two directories.
<P>
You may need to use the <TT>-I</TT> option if you include files
from other directories. The <TT>-I</TT> option is for both C++
and NED files. In our example, you could run
<PRE>
<FONT>makemake -n -I../router
</FONT>
</PRE>
<P>
in the <TT>trafgen/</TT> directory and vica versa.
<P>
If you're willing to play with shared and run-time loaded libraries,
several <TT>makemake</TT> options and the <TT>[General]/load-libs=</TT>
ini file option leave you enough room to do so.
<H3><A NAME="_Toc443041263">Static vs shared OMNeT++ system libraries</A>
</H3>
<P>
Default linking uses the shared libraries. One reason you would
want static linking is that debugging the OMNeT++ class library
is more trouble with shared libraries. Another reason might be
that you want to run the executable on another machine without
having to worry about setting <TT>LD_LIBRARY_PATH</TT>. 
<P>
If you want static linking, find the
<PRE>
<FONT>LIB_SUFFIX='so'
</FONT>
</PRE>
<P>
line in the <TT>configure</TT> script and change it to
<PRE>
<FONT>LIB_SUFFIX='a'
</FONT>
</PRE>
<P>
Then re-run the <TT>configure</TT> script and <TT>makeall</TT>.
This will create the static libraries. To ensure the linker will
actually use them (and not the shared ones), delete the <TT>*.so</TT>
files in the <TT>omnetpp/lib</TT> directory.
<H2><A NAME="_Toc443041264">Using DOS and Borland C++ 3.1</A>
</H2>
<H3><A NAME="_Toc443041265">Very limited memory...</A></H3>
<P>
<B>Borland C++ 3.1 can only compile real mode applications, which
means that from the &lt;640K memory, there won't be much left
for your simulation code. You probably won't be able to run but
the smallest simulations.</B>
<H3><A NAME="_Toc443041266">Building the libraries</A></H3>
<P>
You'll need Borland C++ 3.1. The GNU bison and flex utilities
are also needed, they are in the <TT>gnu</TT> archive among the
OMNeT++ files, or in the <TT>gnu</TT> directory if installed.
Make sure they are in the path (you can even copy them into your
<TT>\borlandc\bin</TT> directory). They also need some environment
variables, run <TT>setenv.bat</TT> to set them:
<PRE>
<FONT>C:\OMNETPP\GNU&gt; setenv c:\omnetpp\gnu
</FONT>
</PRE>
<P>
The directory specified must be the one where the <TT>bison.sim</TT>,
<TT>bison.hai</TT> and <TT>flex.ske</TT> files are. Bison and
flex are only needed to build the NEDC compiler, you can even
remove them afterwards.
<P>
Note that OMNeT++ uses the <TT>.cc</TT> extension for C++ sources
even though <TT>.cpp</TT> is the usual extension under Borland
C++. The <TT>.cc</TT> extension does not cause any trouble, but
one can spare renaming when transporting sources between UNIX
and DOS.
<P>
You can use the <TT>buildlib.bat</TT> batch file in the <TT>utils</TT>
directory to build the NEDC compiler and all necessary libraries.
The batch file provides enough information if you start it, so
we do not discuss its usage. Instead, the following part explains
how to do the same job &quot;by hand&quot;.
<P>
First, build the NEDC compiler:
<PRE>
<FONT>C:\OMNETPP&gt; cd src\nedc
</FONT>C:\OMNETPP\SRC\NEDC&gt; bc3make
</PRE>
<P>
(Or type <TT>bc nedc.prj</TT> and compile it by hand.) <TT>bc3make.bat</TT>
uses the <TT>prj2mak</TT> utility to create the <TT>makefile</TT>
from the project file, thus do not edit the <TT>makefile </TT>(it
will be overwritten). Rather, you should modify the project file
from within the Borland C++ IDE itself. The <TT>bc3make</TT> batch
file will also not work if you do not have the command-line version
of the compiler (<TT>bcc</TT>) installed.
<P>
If you get tons of error messages, you'll need to adjust the Borland
C++ path in the project file (the distribution project files assume
the complier to be in <TT>E:\BORLANDC</TT>.) Start <TT>bc</TT>,
correct the settings in the Options|Directories dialog, then try
compiling again!
<P>
Then build the simulation libraries:
<PRE>
<FONT>C:\OMNETPP&gt; cd src\sim
</FONT>C:\OMNETPP\SRC\SIM&gt; bc3make
</PRE>
<P>
This creates <TT>sim_std.lib</TT>. (Again, you'll probably need
to set the path in the project file.) You'll see a lot of linker
undefined symbols, but that's normal: the <TT>makefile</TT> is
created from the project file and it wants to link an executable
instead of a library.
<P>
You can build the user interface libraries in the same way. Go
to each of the <TT>envir</TT>, <TT>envir</TT>\<TT>cmdenv</TT>
and <TT>envir</TT>\<TT>tvenv</TT> directories and type <TT>bc3make</TT>.
This way you can build the <TT>envir.lib</TT>, <TT>cmdenv.lib</TT>,
and <TT>tvenv.lib</TT> files.
<H3><A NAME="_Toc443041267">Setting up a project file</A></H3>
<P>
It is worth starting by copying an example simulation's project
file to a different name and modify that. What you will need to
have in your project file:
<UL>
<LI>the OMNeT++ libraries: <TT>sim_std.lib</TT>, <TT>envir.lib</TT>,
plus <TT>cmdenv.lib</TT> or <TT>tvenv.lib</TT>, depending on which
user interface you want to link in. If you are using Tvenv, remember
to select the Turbo Vision library in Options|Linker|Libraries
and include the path to <TT>tv.lib</TT> (usually something like
<TT>e:\borlandc\tvision\lib</TT>) in Options|Directories|Library
directories.
<LI>your simple module C++ sources;
<LI>your NED files;
<LI>for each NED file, the C++ file it will compile into (the
<TT>_n.cc</TT> file)
<LI>whatever else you want.
</UL>
<P>
After you've put together the project in the Borland C++ IDE,
your project window should look like this:
<HR>
<PRE>
  File name     Location                      Lines    Code    Data
</PRE>
<HR>
<HR>
<PRE>
  MYSIM.CC      .                               241    2362     947
</PRE>
<HR>
<PRE>
  MYSIM.NED     .                               n/a     n/a     n/a
  MYSIM_N.CC    .                               510    5584    2267
  SIM_STD.LIB   ..\..\SRC\SIM                   n/a     n/a     n/a
  ENVIR.LIB     ..\..\SRC\ENVIR                 n/a     n/a     n/a
</PRE>
<HR>
<PRE>
  TVENV.LIB     ..\..\SRC\ENVIR\TVENV           n/a     n/a     n/a
</PRE>
<HR>


<P>
You are not done yet, because the NED files need special treatment.
Pop up the Local Options dialog box for the NED file (position
on it in the project window and press Ctrl-O). 
<OL>
<LI>for &quot;Command line options&quot;, type the file name (e.g.
<TT>mysim.ned</TT>)
<LI>for &quot;Output path&quot;, type its C++ output file (e.g.
<TT>mysim_n.cc</TT>)
<LI>for translator (&quot;Project file translators&quot; checkbox),
choose NEDC. If NEDC is not listed, you have to register it as
a translator in Options|Transfer.
<LI>check the &quot;Exclude from link&quot; option.
</OL>
<P>
Now if you press F9, your simulation program should compile and
build.
<P>
If there are problems, check the following:
<UL>
<LI>the Options|Compiler|C++ Options|C++ always option should
be checked, otherwise the <TT>.cc</TT> files will be treated as
ordinary C files, producing a lot of compile errors.
<LI>you should be using large model (Options|Compiler|Code generation
dialog).
</UL>
<H3><A NAME="_Toc443041268">Switching to another the user interface</A>
</H3>
<P>
To change the user interface from Cmdenv to Tvenv or vica versa:
<OL>
<LI>remove the existing user interface (e.g. <TT>cmdenv.lib</TT>)
from the project
<LI>add another one (e.g. <TT>tvenv.lib</TT>)
<LI>press F9 to re-link the program
</OL>
<P>
Again, if you are using Tvenv, the Turbo Vision library should
be selected in Options|Linker|Libraries.
<H2><A NAME="_Toc443041269">Using Windows 95 or NT and Borland
C++ 5.0</A></H2>
<H3><A NAME="_Toc443041270">Compiling the libraries and nedc</A>
</H3>
<P>
IDE files are provided for all OMNeT++ libraries (Sim, Envir,
Cmdenv, Tkenv; Tvenv is not really supported). You should be able
to build the .lib files from the Borland C++ IDE without problem.
You may need to adjust the include and lib paths in Options|Project
--&gt; Directories.
<P>
Tkenv needs special treatment. You need to get the Tcl and Tk
sources (I tried with 8.0 patchlevel 2: <TT>tcl80p2.zip</TT> and
<TT>tk80p2.zip</TT>), build the libraries and install them properly.
Tkenv includes the Tk header files so before compiling Tkenv,
you may need to adjust the paths in Options|Project --&gt; Directories.
<P>
The default location of Tkenv's TCL script parts and the bitmaps
directory is passed to the Tkenv as a compile-time external define.
(At run-time, they can be overridden be the OMNETPP_TKENV_DIR
and OMNETPP_BITMAP_PATH environment variables.) You'll probably
need to adjust those paths too: they are in Options|Project --&gt;
Compiler --&gt; Defines.
<P>
To compile nedc, you'll need to get a bison/flex pair that works
in the Win95/NT command box. Alternatively, you can compile it
in DOS with Borland C++ 3.1 and with bison/flex from the DJGPP
package.
<H3><A NAME="_Toc443041271">Setting up a project file</A></H3>
<P>
It is best starting by copying an example simulation's project
file to a different name and modify that. What you will need to
have in your project file:
<UL>
<LI>your simple module C++ sources;
<LI>your NED files;
<LI>for each NED file, the C++ file it will compile into (the
<TT>_n.cc</TT> file). Place the <TT>.ned</TT> file under the <TT>_n.cc</TT>
file in the project tree hieararchy.
<LI>the OMNeT++ libraries: <TT>sim_std.lib</TT>, <TT>envir.lib</TT>,
plus <TT>cmdenv.lib</TT> or <TT>tkenv.lib</TT>, depending on which
user interface you want to link in. You also need the Tcl and
Tk libraries if you're using Tkenv. 
</UL>
<P>
If you started out from a project file in the distribution, you
can easily switch from one user interface to another by selecting
the Exclude From Parent option for exactly of the <TT>omnetpp-cmdenv</TT>
and <TT>omnetpp-tkenv</TT> source pools (right click --&gt; Edit
Local Options --&gt; Topics/Build Attributes --&gt; Exclude from
parent).
<P>
If you're going to build a LARGE model, be sure to increase the
stack size in Options|Project options|Linker|32-bit Linker|Reserved
stack size. The default is 0x1000000 (1MB), which is hardly enough
for OMNeT++ simulations. Increase it to 64MB for example: 0x40000000.
If the simulation exceeds the stack size configured here, you'll
get nice exceptions, General Protection Faults and the like.
<H3><A NAME="_Toc443041272">Starting from scratch</A></H3>
<P>
If you want to make your own project files (maybe for porting
to another compiler?), here are some hints:
<UL>
<LI>Compile as a 32-bit flat console application. None of the
special libraries (OWL, MFC, Class Library,  OCF etc) are needed.
<LI>You have to turn off exception handling, it conflicts with
the coroutine library somehow. In the IDE: Options|Project --&gt;
C++ Options --&gt; Exception Handling/RTTI --&gt; clear [ ] Enable
exceptions. It must be done both when compiling the libraries
and when compiling simulation applications.
<LI>Borland C++ does not recognize the .cc extension as C++. You
have to teach it: Options|Tools --&gt; select CppCompile --&gt;
Edit --&gt; Advanced --&gt; add the .cc extension to the Translate
From and Default For entries. Do the same with the EditText tool.
<LI>You also have to teach Borland C++ how to handle .ned files.
Select Options|Tools --&gt; New. Fill in the dialog as follows:
</UL>
<P>
Name: NEDCompile
<P>
Path: ..\..\src\nedc\nedc.exe
<P>
Command Line: $NOSWAP $CAP MSG(BORL2MSG) $EDNAME
<P>
Menu Text: NED Compile
<P>
Help Hint: OMNeT++ NED compiler
<P>
Select Advanced, and fill in the dialog:
<P>
Type: Translator
<P>
Translate From: .ned
<P>
Translate To: .cc
<P>
Default For: .ned
<HR><H1><A NAME="_Toc443041273">Running the simulation</A></H1>
<H2><A NAME="_Toc443041274">Command line switches</A></H2>
<P>
An OMNeT++ executable accepts the following command line switches:
<P>
<TT>-h</TT> The program prints a short help message and the networks
contained in the executable and exits.
<P>
<TT>-f&lt;</TT><I>fileName&gt;</I> Specify the name of the configuration
file. The default is <TT>omnetpp.ini</TT>. Multiple <TT>-f</TT>
switches can be given; this allows you to partition your configuration
file. For example, one file can contain your general settings,
another one most of the module parameters, another one the module
parameters you change often.
<P>
<TT>-l&lt;</TT><I>fileName&gt;</I> Load a shared object (<TT>.so</TT>
file on Unix). Multiple <TT>-l</TT> switches are accepted. Your
<TT>.so</TT> files may contain module code etc. By dynamically
loading all simple module code and compiled network description
(<TT>_n.o</TT> files on Unix) you can even eliminate the need
to re-link the simulation program after each change in a source
file. (Shared objects can be created with <TT>gcc -shared ...</TT>)
<P>
<TT>-r&lt;</TT><I>runs&gt;</I> Only recognized by simulations
linked with Cmdenv. It specifies which runs should be executed
(e.g. <TT>-r2,4,6-8</TT>). This option overrides the<TT> runs-to-execute=</TT>
option in the <TT>[Cmdenv]</TT> section of the ini file (see later).
<P>
All other options are read from the configuration file.
<P>
An example of running an OMNeT++ executable with the <TT>-h</TT>
flag:
<PRE>
<FONT>C:\OMNETPP\PROJECTS\FDDI&gt;fddi.exe -h

</FONT>OMNeT++ Discrete Simulation, TUB Dept. of Telecommunications, 1990-97

Networks in this program:
  1. NRing
  2. FDDI1

End run of OMNeT++
</PRE>
<H2><A NAME="_Toc443041275">Configuration file</A></H2>
<H3><A NAME="_Toc443041276">Sections and entries</A></H3>
<P>
The configuration file (also called ini file, because it has an
<TT>.ini</TT> extension) contains options that control how the
simulation is executed and can also contain settings of model
parameters. The ini file is a text file consisting of entries
grouped into different sections. The following sections can exist:
<PRE>
<B><FONT>[General]
</FONT>[Cmdenv], [Tvenv], [Tkenv],...
[Parameters]
[OutVectors]
[DisplayStrings]
[Machines]
[Slaves]
[Run 1], [Run 2], [Run 3],...
</B>
</PRE>
<P>
'<TT>#</TT>' and  '<TT>;</TT>' denote comments. A sample ini file:
<PRE>
<FONT># omnetpp.ini

</FONT><B>[General]
</B>ini-warnings = false
network = token
distributed = no
snapshot-file = token.sna
output-vector-file = token.vec
log-parchanges = no
parchange-file = token.pch
random-seed = 1
sim-time-limit = 1000ms
cpu-time-limit = 180s
total-stack-kb = 2048

<B>[Cmdenv]
</B>runs-to-execute = 1-3,5
module-messages = yes
verbose-simulation = no
display-update = 100ms

<B>[Parameters]
</B>token.num_stations = 3
token.num_messages = 10000

<B>[Run 1]
</B>token.wait_time = 10ms

<B>[Run 2]
</B>token.wait_time = 30ms
</PRE>
<P>
Parameters that were set to <TT>input</TT> value in the NED file
are searched for in the ini file.
<P>
OMNeT++ can execute several simulation runs automatically one
after another. If multiple runs are selected, option settings
and parameter values can be given either individually for each
run, or together for all runs, depending in which section the
option or parameter appears.
<P>
This is summarized in the following table:
<TABLE BORDER=1>
<TR><TD WIDTH=221>What</TD><TD WIDTH=221>If set for all runs together
</TD><TD WIDTH=221>If set for individual runs</TD></TR>
<TR><TD WIDTH=221>general settings</TD><TD WIDTH=221><TT>[General]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>user interface-specific settings</TD><TD WIDTH=221><TT>[Cmdenv]</TT>, <TT>[Tvenv]</TT> etc.
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>module parameter values</TD><TD WIDTH=221><TT>[Parameters]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>output vector configuration</TD><TD WIDTH=221><TT>[OutVectors]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>graphical appearance</TD><TD WIDTH=221><TT>[DisplayStrings]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>logical - physical machine mappings</TD><TD WIDTH=221><TT>[Machines]</TT>
</TD><TD WIDTH=221>not possible</TD></TR>
<TR><TD WIDTH=221>with distributed execution: settings for slave processes
</TD><TD WIDTH=221><TT>[Slaves]</TT></TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.
</TD></TR>
</TABLE>
<P>
<P>
The most important options of the <TT>[General]</TT> section are
the following. The <TT>ini-warnings </TT>option can be used for
&quot;debugging&quot; ini files: if enabled, it lists which options
were searched for but not found. The <TT>network</TT> option selects
the model to be set up and run. The length of the simulation can
be set with the <TT>sim-time-limit</TT> and the <TT>cpu-time-limit</TT>
options (the usual time units such as <TT>ms</TT>, <TT>s</TT>,
<TT>m</TT>, <TT>h</TT>, etc. can be used). The <TT>warnings</TT>
option enables/disables run-time warnings; it is recommended to
be turned on while debugging. The <TT>distributed</TT> flag selects
between normal and parallel execution. The output file names can
be set with the following options: <TT>snapshot-file</TT>, <TT>output-vector-file</TT>,
<TT>output-scalar-file</TT>, <TT>parchange-file.</TT> (For the
last file to be written, one must explicitly enable parameter
change logging with the <TT>log-parchanges</TT> option). The <TT>load-libs</TT>
entry can be used to load shared objects (containing simple modules,
compiled NED code etc) at run-time. Each setting has a meaningful
default value.
<P>
Almost any of the above options can also be specified individually
for each run. Per-run settings (if they exist) have priority over
globally set one.
<P>
See the User Interfaces chapter to see what ini file options Cmdenv,
Tkenv and Tvenv recognizes.
<P>
You can find a more complete description of the ini file settings
in the Reference Manual.
<H3><A NAME="_Toc443041277">Splitting the configuration file</A>
</H3>
<P>
OMNeT++ supports file inclusion in ini files. This feature allows
you to partition large ini files to logical units, fixed and varying
part etc.
<P>
An example:
<PRE>
<FONT># omnetpp.ini
</FONT>...
include parameters.ini
include per-run-pars.ini
...
</PRE>
<H3><A NAME="_Toc443041278">Module parameters in the configuration
file</A></H3>
<P>
Values for module parameters go into the <TT>[Parameters]</TT>
or the <TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc. sections of the
ini file. The run-specific settings take precedence over the overall
settings. Parameters that were assigned a (non-<TT>input</TT>)
value in the NED file are not influenced by ini file settings.
<P>
Wildcards (*,?) can be used to supply values to several model
parameters at a time. Filename-style (glob) and not regex-style
pattern matching is used. Character range (normally written like
<TT>[a-zA-Z]</TT>) uses curly braces to avoid interference with
module vectors: <TT>{a-zA-Z}</TT>. If a parameter name matches
several wildcards-patterns, the first matching occurrence is used.
<P>
An example ini file:
<PRE>
<FONT># omnetpp.ini

</FONT><B>[Parameters]
</B>token.num_stations = 3
token.num_messages = 10000

<B>[Run 1]
</B>token.stations[*].wait_time = 10ms

<B>[Run 2]
</B>token.stations[0].wait_time = 5ms
token.stations[*].wait_time = 1000ms
</PRE>
<H3><A NAME="_Toc443041279">Configuring result collection</A>
</H3>
<P>
As a simulation program is evolving, it is becoming capable of
collecting more and more statistics. The size of output vector
files can easily reach a magnitude of several 10 or 100 MB, although
very often, only some of the recorded statistics are interesting
to the analyst. 
<P>
In OMNeT++, you can control how <TT>cOutVector</TT> objects record
data to disk. You can turn output vectors on/off or you can assign
a result collection interval. Output vector configuration is given
in the <TT>[OutVectors]</TT> section of the ini file, or in the
<TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc sections individually for
each run. By default, all output vectors are turned on.
<P>
Entries configuring output vectors can be like that:
<PRE>
<I><FONT>module-pathname</FONT></I><FONT>.<I>objectname</I>.enabled = yes/no
</FONT><I>module-p</I>athname.<I>objectname</I>.interval = <I>start</I>..<I>stop
module-pathname</I>.<I>objectname</I>.interval = ..<I>stop
module-pathname</I>.<I>objectname</I>.interval = <I>start</I>..
</PRE>
<P>
The object name is the string passed to <TT>cOutVector</TT> in
its constructor or with the <TT>setName()</TT> member function.
<PRE>
<FONT>cOutVector eed(&quot;End-to-End Delay&quot;,1);
</FONT>
</PRE>
<P>
Start and stop values can be any time specification accepted in
NED and config files (e.g. <I>10h 30m 45.2s</I>). 
<P>
As with parameter names, wildcards are allowed in the object names
and module path names.
<P>
An example:
<PRE>
<FONT>#
</FONT># omnetpp.ini
#

[OutVectors]
*.interval = 1s..60s
*.End-to-End Delay.enabled = yes
*.Router2.*.enabled = yes
*.enabled = no
</PRE>
<P>
The above configuration limits collection of all output vectors
to the 1s..60s interval, and disables collection of output vectors
except all end-to-end delays and the ones in any module called
<TT>Router2</TT>.
<H3><A NAME="_Toc443041280">Display strings</A></H3>
<P>
Display strings control the modules' graphical appearance in the
Tkenv user interface. Display strings can be assigned to modules,
submodules and gates (a connection's display string is stored
in its &quot;from&quot; gate). Display strings can be hardcoded
into the NED file or specified in the configuration file. (Hardcoded
display strings take precedence over the ones given in ini files.)
Format of display string are documented in the User Interfaces
chapter.
<P>
Display strings can appear in the <TT>[DisplayStrings]</TT> section
of the ini file. They are expected as entries in one of the following
forms:
<PRE>
<I><FONT>moduletype</FONT></I><FONT> = &quot;...&quot;
</FONT><I>moduletype.submodulename</I> = &quot;...&quot;

<I>moduletype.inputgatename</I> = &quot;...&quot;
<I>moduletype.submodulename.outputgatename</I> = &quot;...&quot;
</PRE>
<P>
As with parameter names, wildcards are allowed in module types,
submodule and gate names.
<H2><A NAME="_Toc443041281">Random seeds</A></H2>
<H3><A NAME="_Toc443041282">Specifying seed values</A></H3>
<P>
As is was pointed out earlier, it is of great importance that
different simulation runs and different random number sources
within one simulation run use non-overlapping sequences of random
numbers.
<P>
In OMNeT++, you have three choices:
<OL>
<LI>Automatic seed selection. 
<LI>Specify seeds in the ini file.
<LI>Manually set the seed from within the program.
</OL>
<P>
If you decide for automatic seed selection, do not specify any
seed value in the ini file. For the random number generators,
OMNeT++ will automatically select seeds that are 1,000,000 values
apart in the sequence. If you have several runs, each run is started
with a fresh set of seeds that are 1,000,000 values apart from
the seeds used for previous runs. Since the generation of new
seed values is costly, OMNeT++ has a table of precalculated seeds
(256 values); if they are all used up, OMNeT++ starts from the
beginning of the table again.
<P>
Automatic seed selection may not be appropriate for you for several
reasons. First, you may need more than 256 seeds values; or, if
you use variance reduction techniques, you may want to use the
same seeds for several simulation runs. In this case, there is
a standalone program to generate appropriate seed values (<TT>seedtool</TT>
will be discussed in the next section), and you can specify the
seeds explicitly in the ini file.
<P>
The following ini file explicitly initializes two of the random
number generators, and uses different seed values for each run:
<PRE>
<FONT>[Run 1]
</FONT>gen0-seed = 1768507984
gen1-seed = 33648008

[Run 2]
gen0-seed = 1082809519
gen1-seed = 703931312
...
</PRE>
<P>
If you want the same seed values for all runs, you will write
something like this:
<PRE>
<FONT>[General]
</FONT>gen0-seed = 1768507984
gen1-seed = 33648008
</PRE>
<P>
All other random number generators (2,3,...) will have their seeds
automatically assigned.
<P>
As a third way, you can also set the seed values from the code
of a simple module using <TT>genk_randseed()</TT>, but I see no
reason why you would want to do so.
<H3><A NAME="_Toc443041283">Choosing good seed values: the seedtool
utility</A></H3>
<P>
For selecting good seeds, the <TT>seedtool</TT> program can be
used (it is in the <TT>utils</TT> directory). When started without
command-line arguments, the program prints out the following help:
<PRE>
<FONT>seedtool - part of the OMNeT++ Simulation System, BME-HIT 1997
</FONT>A tool to help select good random number generator seed values.
Usage:
  seedtool i seed         - index of 'seed' in cycle
  seedtool s index        - seed at index 'index' in cycle
  seedtool d seed1 seed2  - distance of 'seed1' and 'seed2' in cycle
  seedtool g seed0 dist   - generate seed 'dist' away from 'seed0'
  seedtool g seed0 dist n - generate 'n' seeds 'dist' apart, starting at
                            'seed0'
  seedtool t              - generate hashtable
  seedtool p              - print out hashtable
</PRE>
<P>
The last two options, <TT>p</TT> and <TT>t</TT> were used internally
to generate a hash table of pre-computed seeds that greatly speeds
up the tool. For practical use, the <TT>g</TT> option is the most
important. Suppose you have 4 simulation runs that need two independent
random number generators each and you want to start their seeds
at least 10,000,000 values apart. The first seed value can be
simply 1. You would type the following command:
<PRE>
<FONT>C:\OMNETPP\UTILS&gt; seedtool g 1 10000000 8
</FONT>
</PRE>
<P>
The program outputs 8 numbers that can be used as random number
seeds:
<PRE>
<FONT>1768507984
</FONT>33648008
1082809519
703931312
1856610745
784675296
426676692
1100642647
</PRE>
<P>
You would specify these seed values in the ini file.
<H2><A NAME="_Toc443041284">Module parameter logging</A></H2>
<P>
It is possible to log all the changes to module parameters into
a text file. This can be useful when the simulation contains run-time
tuning of one or more module parameters and one wants to have
the trajectory documented.
<P>
Module parameter logging must be explicitly enabled from the header
file if one wants to use it:
<PRE>
<FONT>[General]
</FONT>log-parchanges = yes
parchange-file = token.pch
</PRE>
<P>
The format of the parameter change file is similar to the that
of the output vector file. 
<P>
If a parameter is taken by reference by several modules, any change
to the parameter will appear in the file under the name of the
top-level parameter, no matter which module actually changed it
and under what name.
<HR><H1><A NAME="_Toc443041285">User interfaces</A></H1>
<P>
OMNeT++ user interfaces are used with simulation execution. Their
primary purpose is to make the inside of the model visible to
the user, to start/stop simulation execution, and possibly allow
the user intervene by changing variables/objects inside the model.
This is very important in the development/debugging phase of the
simulation project. Just as important, a hands-on experience allows
the user to get a 'feel' about the model's behaviour.
<P>
A nice graphical user interface can also be used to demonstrate
how the model works internally.
<H2><A NAME="_Toc443041286">Detached user interface implementation</A>
</H2>
<P>
The user interface is separated from the simulation kernel; the
two parts interact through a well-defined interface. This construction
makes it possible to implement several types of user interfaces,
without changing the simulation kernel. Also, the same simulation
model can be executed with different user interfaces, without
any change in the model files themselves. The user would test
and debug the simulation with a powerful graphical user interface,
and finally run it with a simple and fast user interface that
supports batch execution.
<P>
User interfaces takes the form of libraries (<TT>.a</TT> file
or <TT>.so</TT> on UNIX, <TT>.lib</TT> or <TT>.dll</TT> file on
NT). The libraries are interchangeable. When the user creates
a simulation executable, he can pick one of the user interface
libraries that he links in.
<P>
Three user interfaces have been implemented:
<UL>
<LI>Cmdenv: command-line user interface for batch execution 
<LI>Tkenv: graphical, windowing user interface (Tcl/Tk) 
</UL>
<UL>
<LI>Tvenv: character-based, windowing user interface (DOS, Turbo
Vision) 
</UL>
<P>
The following sections contain more detailed descriptions about
each user interface.
<H2><A NAME="_Toc443041287">Cmdenv: the command-line user interface</A>
</H2>
<P>
The command line user interface is a small, portable and fast
user interface that compiles and runs on all platforms whether
it is UNIX, DOS, or WinNT console. Cmdenv is designed primarily
for batch execution.
<P>
Cmdenv uses simply executes all simulation runs that are described
in the configuration file. If one run stops with an error message,
subsequent ones will still be executed.
<P>
Cmdenv recognizes the following ini file options:
<PRE>
<FONT>[Cmdenv]
</FONT>runs-to-execute = 1,4-6,8
module-messages = no
verbose-simulation = no
display-update = 100ms
</PRE>
<P>
The first one specifies which runs (described in the <TT>[Run
1]</TT>, <TT>[Run 2]</TT> etc. sections) should be executed. If
the value is missing, Cmdenv executes all runs that have ini file
sections; if no runs are specified in the ini file, Cmdenv does
one run. The <TT>-r</TT> command line option overrides this ini
file setting.
<P>
The second and the third are yes/no settings and control the amount
of screen output during simulation. The fourth one is in effect
when the other two are disabled (that is, there would be no display
at all from the simulation execution); it prints out progress
messages at the specified frequency.
<P>
<U>Portability:</U> all platforms.
<H2><A NAME="_Toc443041288">Tkenv: graphical user interface on
Unix/NT</A></H2>
<H3><A NAME="_Toc443041289">Features</A></H3>
<P>
Tkenv is a portable graphical windowing user interface. Tkenv
supports interactive execution of the simulation, tracing and
debugging. Tkenv is recommended in the development stage of a
simulation or for presentation and educational purposes, since
it allows one to get a detailed picture of the state of simulation
at any point of execution and to follow what happens inside the
network. The most important feaures are: 
<UL>
<LI>message flow animation
<LI>graphical display of statistics (histograms etc.) and output
vectors during simulation execution
<LI>separate window for each module's text output 
<LI>scheduled messages can be watched in a window as simulation
progresses 
<LI>event-by-event, normal and fast execution 
<LI>labelled breakpoints 
<LI>inspector windows to examine and alter objects and variables
in the model 
<LI>simulation can be restarted 
<LI>snapshots (detailed report about the model: objects, variables
etc.) 
</UL>
<P>
Tkenv makes it possible to view simulation results (output vectors
etc.) during execution. Results can be displayed as histograms
and time-series diagrams. This can speed up the process of verifying
the correct operation of the simulation program and provides a
good environment for experimenting with the model during execution.
When used together with gdb or xxgdb, Tkenv can speed up debugging
a lot.
<P>
<U>Portability:</U> Tkenv is built with Tcl/Tk. Tkenv should work
on all platforms that Tcl/Tk has been ported to: Unix/X, Win3.1,
Win95, WinNT, Macintosh, OS/2 etc.
<P>
You can get more information about Tcl/Tk in the Web pages listed
in the Reference.
<H3><A NAME="_Toc443041290">Configuring  Tkenv</A></H3>
<P>
In case of nonstandard installation, it may be necessary to set
the <TT>OMNETPP_TKENV_DIR</TT> environment variable so that Tkenv
can find its parts written in Tcl script.
<P>
The default path from where the icons are loaded can be changed
with the <TT>OMNETPP_BITMAP_PATH</TT> variable.
<P>
The ini file options accepted by Tkenv are:
<PRE>
<FONT>[Tkenv]
</FONT>use-mainwindow = yes
print-banners = yes
breakpoints-enabled = yes
update-freq-fast = 10
update-freq-express = 500
animation-delay = 0.3s
</PRE>
<P>
The above options can also be set from within Tkenv itself, from
a configuration dialog box.
<H3><A NAME="_Toc443041291">Simulation running modes in Tkenv</A>
</H3>
<P>
Tkenv has the following modes for running the simulation :
<UL>
<LI>Step
<LI>Run
<LI>Fast run
<LI>Express run
</UL>
<P>
The running modes have their corresponding buttons on Tkenv's
toolbar.
<P>
In <B>Step</B> mode, you can execute the simulation event-by-event.
<P>
In <B>Run</B> mode, the simulation runs with all tracing aids
on. Message animation is active and inspector windows are updated
after each event. Output messages are displayed in the main window
and midule output windows. You can stop the simulation with the
Stop button on the toolbar. You can fully interact with the user
interface while the simulation is running: you can open inspectors
etc.
<P>
In <B>Fast</B> mode, animation is turned off. The inspectors and
the message output windows are updated after each 10 events (the
actual number can be set in Options|Simulation options and also
in the ini file). Fast mode is several times faster than the Run
mode; the speedup can get close to 10 (or the configured event
count).
<P>
In <B>Express</B> mode, the simulation runs at about the same
speed as with Cmdenv, all tracing disabled. Module output is not
recorded in the output windows any more. You can interact with
the simulation only once in a while (1000 events is the default
as I recall), thus the run-time overhead of the user interface
is minimal. You have to explicitly push the Update inspectors
button if you want an update.
<H3><A NAME="_Toc443041292">Inspectors</A></H3>
<P>
In Tkenv, objects can be viewed through inspectors. To start,
choose Inspect|Network from the menu. Usage should be obvious;
just use double-clicks and popup menus that are brought up by
right-clicking. In Step, Run and Fast Run modes, inspectors are
updated automatically as the simulation progresses. To make ordinary
variables (<TT>int</TT>, <TT>double</TT>, <TT>char</TT> etc.)
appear in Tkenv, use the <TT>WATCH()</TT> macro in the C++ code.
<P>
In list dialogs, entries begin with text like <TT>ptr0x8000ab7e</TT>.
Yes, it is really the object pointer; knowing it is exremely useful
if you're running the simulation under a debugger such as gdb.
<H3><A NAME="_Toc443041293">Display strings</A></H3>
<P>
Display strings specify the arrangement and appearance of modules
in Tkenv's network graphics windows. Display strings occur in
NED descriptions's <TT>display:</TT> phrases and control how the
objects (compound module, its submodules and connections) are
displayed in Tkenv.
<P>
The graphical editor (GNED) will eventually read/write pure NED
descriptions and manipulate the display strings in them. No special
graphic format (like <TT>.gnd</TT> now) will be needed. Auto-layouting
is also planned.
<P>
The display string format is a colon-separated list of tags. Each
tag consists of a key (usually one letter), an equal sign and
a comma-separated list of parameters, like:
<PRE>
<FONT>  &quot;p=100,100;b=rect,60,10;o=blue,black,2&quot;
</FONT>
</PRE>
<P>
Parameters may be omitted also at the end and also inside the
parameter list, like:
<PRE>
<FONT>  &quot;p=100,100;b=rect;o=,,2&quot;
</FONT>
</PRE>
<P>
Module/submodule parameters can be included with the <TT>$name</TT>
notation:
<PRE>
<FONT>  &quot;p=$xpos,$ypos;b=rect,60,10;o=$fillcolor,black,2&quot;
</FONT>
</PRE>
<P>
Objects that may have display strings are:
<UL>
<LI>compound modules (as the enclosing module in the drawing),
<LI>submodules
<LI>connections
</UL>
<P>
<P>
<B>Tags used in submodule display strings:</B>
<P>
<TT><B><FONT>&quot;p=&quot;</FONT></B></TT><B>
 position</B>
<PRE>
<FONT>&quot;p=100,80&quot;</FONT>
</PRE>
<P>
Submodule is centered at (100,80) position.
<PRE>
<FONT>&quot;p=100,80,row,40&quot;
</FONT>&quot;p=100,80,col,40&quot;
</PRE>
<P>
Used for module vectors. Submodules will be arranged in a row/column
starting at (100,80), spacing 40.
<PRE>
<FONT>&quot;p=100,80,matrix,5,40,30&quot;</FONT>
</PRE>
<P>
Used for module vectors. Submodules will be arranged in matrix
starting at (100,80), 5 elems per row, x spacing 40, y spacing
30.
<PRE>
<FONT>&quot;p=100,80,ring,200,150&quot;</FONT>
</PRE>
<P>
Used for module vectors. Submodules will be arranged in a ring
centered at (100+200,80+150), x and y radius of 200 and 150. Custom
layouts can be implemented with module parameters: <TT>&quot;p=$xpos,$ypos&quot;</TT>
where the module has two parameters called xpos and ypos that
store the actual coordinates. Default: <TT>&quot;p=,,matrix,8,,&quot;</TT>
(missing parameters will be assigned a meaningful value)<BR>
<P>
<TT><B><FONT>&quot;b=&quot;</FONT></B></TT><B>
 display as a box</B>
<PRE>
<FONT>&quot;b=60,30,rect&quot;</FONT>
</PRE>
<P>
Rectangle with x size 60, y size 30.
<PRE>
<FONT>&quot;b=60,30,oval&quot;</FONT>
</PRE>
<P>
An oval shape.
<P>
Default: &quot;b=50,30,oval&quot;<BR>
<P>
<TT><B><FONT>&quot;i=&quot; </FONT></B></TT><B>
display as icon</B>
<PRE>
<FONT>&quot;i=workstation&quot;</FONT>
</PRE>
<P>
Use the icon named &quot;workstation&quot;. No default (if no
<TT>&quot;i=&quot;</TT> is given, a rectangle will be drawn)<BR>
<P>
<TT><B><FONT>&quot;o=&quot;</FONT></B></TT><B>
options</B>
<PRE>
<FONT>&quot;o=blue,black,3&quot;</FONT>
</PRE>
<P>
Parameters are: fill color, outline color, border width<BR>
<P>
<B>Tags used in enclosing module display strings:</B>
<P>
<TT><B><FONT>&quot;b=&quot;</FONT></B></TT><B>
and </B><TT><B><FONT>&quot;o=&quot; </FONT></B></TT>
<P>
They can be used like in submodule display strings. The defaults
are different however: <TT>&quot;b=rect,300,200;o=grey3,black,3&quot;
<BR>
</TT>
<P>
<B>Tags used in connection display strings:</B>
<P>
<TT><B><FONT>&quot;m=&quot;</FONT></B></TT><B>
drawing mode</B>
<P>
The drawing mode specifies the exact placement of the connection
arrow. Mode can be: <TT>manual, auto, east, west, north, south</TT>.
They can be abbreviated as <TT>m,a,e,w,n,s</TT>. The last five
modes take no parameter, like
<P>
<TT>&quot;m=a&quot;</TT> 
<P>
The manual mode takes four parameters that explicitly specify
anchoring of the ends of the arrow: src_px, src_py, dest_px, dest_py.
Each value is a percentage of the width/height of the source/destination
module's enclosing rectangle, with the upper-left corner being
the origin. Thus,
<P>
  <TT> &quot;m=m,50,50,50,50&quot;</TT>
<P>
connects the centers of the two module rectangles.<BR>
<P>
<TT><B><FONT>&quot;o=&quot;</FONT></B></TT><B>
drawing options</B>
<PRE>
<FONT>&quot;o=black,2&quot;</FONT>
</PRE>
<P>
Parameters are the draw color and width of the arrow. Default:
<TT>&quot;o=black,2&quot;</TT>
<H3><A NAME="_Toc443041294">Changing the network graphics at run-time</A>
</H3>
<P>
Sometimes it is useful to change the appearance of some components
in the network graphics, such as the color of the modules, color/width
of connection arrows etc. 
<P>
The appearance of nodes and connections is determined by the display
strings. Display strings are initially taken from the NED description
(stuff like: <TT>display: &quot;p=100,10;i=pc&quot;</TT> ). The
format of the display string is documented in doc/dispstr.txt.
You can change the display string of a module or connection arrow
at run-time by calling <TT>setDisplayString()</TT>. The display
string of a connection arrow is stored in its source gate. Display
string changes will immediately take effect. 
<P>
Examples:
<PRE>
<FONT>  setDisplayString(dispSUBMOD,&quot;p=100,100;b=60,30,rect;o=red,black,3&quot;);
</FONT>  parentModule()-&gt;setDisplayString(dispSUBMOD,&quot;p=100.....&quot;);
  gate(&quot;out&quot;)-&gt;setDisplayString(&quot;o=yellow,3&quot;);
</PRE>
<H3><A NAME="_Toc443041295">Standalone version</A></H3>
<P>
A significant part of Tkenv is written in TCL, in several <TT>.tcl</TT>
script files. The default location of the scripts is passed compile-time
to <TT>tkapp.cc</TT>, or it can be overridden at run-time by the
<TT>OMNETPP_TKENV_DIR</TT> environment variable. The existence
of a separate script library can be inconvenient if you want to
carry standalone simulation executables to different machines.
To solve the problem, there is a possibility to compile the script
parts into Tkenv as a large string constant. 
<P>
The details: the tcl2c program (its C source is there in the Tkenv
directory) is used to translate the <TT>.tcl</TT> files into C
code (<TT>tclcode.cc</TT>), which gets included into <TT>tkapp.cc</TT>.
On Unix, this feature is enabled in Tkenv's <TT>makefile</TT>;
it is documented there exactly how. On Win95/NT, one has to manually
compile <TT>tcl2c.c</TT> into <TT>tcl2c.exe</TT>, run it to produce
<TT>tclcode.cc</TT> and then compile <TT>tkapp.cc</TT> without
providing the <TT>OMNETPP_TKENV_DIR</TT> external define. The
latter will cause <TT>tkapp.cc</TT> to include and use <TT>tclcode.cc</TT>.
<H2><A NAME="_Toc443041296">Tvenv: the Turbo Vision user interface</A>
</H2>
<P>
The Turbo Vision user interface, Tvenv is a character-based, windowing
user interface (mouse, menu, overlapping windows etc.) that is
very similar to Tkenv in its features. Tvenv was developed prior
to Tkenv; it is maintained but no longer actively developed.
<P>
An example screenshot of Tvenv can be found in the Token Ring
chapter of the Examples Manual.
<P>
The ini file options accepted by Tvenv are:
<PRE>
<FONT>[Tvenv]
</FONT>update-inspectors=yes
animation-delay=1s
breakpoints-enabled=yes
</PRE>
<P>
The first one enables/disables continuous refreshing of inspector
windows while the simulation is running.
<P>
<U>Portability:</U> Tvenv is built with Borland's Turbo Vision
C++ class library. Although the original Turbo Vision was copyrighted
by Borland and was tightly bound to Borland C++ and DOS, things
have changed. TV (and so Tvenv) now compiles with many compilers
and runs on many platforms.
<HR><H1><A NAME="_Toc443041297">Analyzing simulation results</A></H1>
<H2><A NAME="_Toc443041298">Plotting output vectors with Plove</A>
</H2>
<H3><A NAME="_Toc443041299">Plove features</A></H3>
<P>
Typically, you'll get output vector files as a result of a simulation.
Data written to <TT>cOutVect</TT> objects from simple modules
go to output vector files. Normally, you use Plove to look into
output vector files and plot vectors in it.
<P>
Plove is a handy tool for plotting OMNeT++ output vectors. It
uses gnuplot to do the actual work. You can specify the drawing
style (lines, dots etc) for each vector as well as set the most
frequent drawing options like axis bounds, scaling, titles and
labels etc. You can save the gnuplot graphs to files (postscript,
latex, pbm etc) with a click. Plove can also generate standalone
shell scripts that plot output vectors in much the same way Plove
does itself. These scripts can be used for batch processing or
to debug filters (see later). Plove does not take away any of
gnuplot's flexibility -- you can embed your own gnuplot commands
to customize the output.
<P>
Filtering the results before plotting is possible. Filters can
do averaging, truncation of extreme values, smoothing, they can
do density estimation by calculating histograms etc. Some filters
are built in, and you can easily create new filters or modify
the existing ones. Filters can be incorporated in one of three
ways: as awk expressions, as awk programs and as external filter
programs. Filters can be parameterized. Multiple filters for the
same vector is not currently supported; also, you cannot currently
feed several vectors into a single filter.
<P>
Plove does not create temporary files, so you don't need to worry
about disk space: if the output vector is there, Plove can plot
it for you. Moreover, it can also work with gzipped vector files
without extracting them -- just make sure you have <TT>zcat</TT>.
<P>
Plove never modifies the output vector files themselves. 
<P>
On startup, Plove automatically reads the <TT>.ploverc</TT> file
in your home directory. The file contains general gnuplot settings,
the filter configuration etc. (that is, the stuff from the Options
menu).
<P>
<U>Portability:</U> Plove works fine on Unix and (with some limitations)
on Win95/NT. Windows users should make a shortcut to the <TT>plove</TT>
file and associate it with the <TT>wish</TT> application.
<H3><A NAME="_Toc443041300">Usage</A></H3>
<P>
First, you load an output vector file (<TT>.vec</TT>) into the
left pane. You can also load gzipped vector files (<TT>.vec.gz</TT>)
without having to decompress them. You can copy vectors from the
left pane to the right pane by clicking the right arrow icon in
the middle. The large PLOT button will plot the <I>selected</I>
vectors in the right pane. Selection works as in Windows: dragging
and shift+left click selects a range, and ctrl+left click selects/deselects
individual items. To adjust drawing style, change vector title
or add filter, push the Options... button. This works for several
selected vectors too. Plove accepts nc/mc-like keystrokes: F3,
F4, F5, F6, F8, grey '+' and grey '*'.
<P>
The left pane works as a general storage for vectors you're working
with. You can load several vector files, delete vectors you don't
want to deal with, rename them etc. All this will not affect the
vector files on disk. In the right pane, you can duplicate vectors
if you want to filter the vector and also keep the original. If
you set the right options for a vector but temporarily do not
want it to hang around in the right pane, you can put it back
into the left pane for storage.
<H3><A NAME="_Toc443041301">Writing filters</A></H3>
<P>
Filters get an output vector on their standard input (as plain
text, with the timestamp being the second and the value being
the third field on each line), do some processing to it and write
the result to the standard output.
<P>
Filters can be incorporated in one of three ways: as <TT>awk</TT>
expressions, as <TT>awk</TT> programs or  as external programs.
An <TT>'awk</TT> expression' filter means assembling and launching
a command like this:
<PRE>
<FONT>cat foobar.vec | awk '{$3 = <I>&lt;expression&gt;</I>; print}' | ...
</FONT>
</PRE>
<P>
An <TT>awk</TT> program filter means running the following command:
<PRE>
<FONT>cat foobar.vec | awk '<I>&lt;program&gt;</I>' | ...
</FONT>
</PRE>
<P>
The third type of filters is used like this:
<PRE>
<FONT>cat foobar.vec | <I>&lt;program&gt;</I> <I>&lt;parameters&gt;</I> | ...
</FONT>
</PRE>
<P>
Before the filter pipeline is launched, the following substitutions
are performed on the <TT>awk</TT> scripts:
<PRE>
<FONT>  t --&gt; $2
</FONT>  x --&gt; $3
</PRE>
<P>
The parameters of the form <TT>$(paramname)</TT> are also replaced
with their actual value.
<P>
Thus, if you want to add 1 to all value, you can use the awk expression
filter <TT>x+1</TT>. It will turn into:
<PRE>
<FONT>  awk '{$3 = $3+1}; print'.
</FONT>
</PRE>
<P>
When you want to shift the vector by a used-defined <TT>DT</TT>
time, you can create the following <TT>awk</TT> program filter:
<PRE>
<FONT>{t += $(DT); print}
</FONT>
</PRE>
<P>
Do not forget the print statement, or your filter will not output
anything and the gnuplot graph will be empty.
<H2><A NAME="_Toc443041302">Format of output vector files</A>
</H2>
<P>
An output vector file contains several series of data produced
during simulation. The file is textual, it looks like this:
<PRE>
<B><FONT>mysim.vec:
</FONT></B>vector  1  &quot;subnet[4].term[12]&quot;  &quot;response time&quot;  1
1  12.895  2355.66666666
1  14.126  4577.66664666
vector 2  &quot;subnet[4].srvr&quot;  &quot;queuelen+queuingtime&quot;  2
2  16.960  2.00000000000  .63663666
1  23.086  2355.66666666
2  24.026  8.00000000000  .44766536
</PRE>
<P>
There are label lines (beginning with <TT>vector</TT>) and data
lines.
<P>
A <TT>vector</TT> line introduces a new vector. Its columns are:
vector ID, module of creation, name of <TT>cOutVector</TT> object,
multiplicity of data (single numbers or pairs will be written).
<P>
Lines beginning with numbers are data lines. The columns: vector
ID, current simulation time, and one or two double values.
<H2><A NAME="_Toc443041303">Working without Plove</A></H2>
<H3><A NAME="_Toc443041304">Extracting vectors from the file</A>
</H3>
<P>
You can use the <TT>grep</TT> program to extract a particular
vector from the file. As the first step, you must find out the
ID of the vector. You can find the appropriate vector line with
a text editor or you can use <TT>grep</TT> for this purpose: 
<PRE>
<FONT>% grep &quot;queuelen+queuingtime&quot; vector.vec
</FONT>
</PRE>
<P>
Or, you can get the list of all vectors in the file by typing:
<PRE>
<FONT>% grep ^vector vector.vec
</FONT>
</PRE>
<P>
This will output the appropriate vector line:
<PRE>
<FONT>vector 6  &quot;subnet[4].srvr&quot;  &quot;queuelen+queuingtime&quot;  2
</FONT>
</PRE>
<P>
Pick the vector ID, which is 6 in this case, and <TT>grep</TT>
the file for the vector's data lines:
<PRE>
<FONT>grep ^6 vector.vec &gt; vector6.vec
</FONT>
</PRE>
<P>
Now, <TT>vector6.vec</TT> contains the appropriate vector. The
only potential problem is that the vector ID is there at the beginning
of each line and this may be hard to explain to some programs
that you use for post-processing and/or visualization. This problem
is eliminated by <TT>splitvec</TT>, to be discussed in the next
section.
<H3><A NAME="_Toc443041305">Using splitvec</A></H3>
<P>
The <TT>splitvec</TT> script (part of OMNeT++) breaks the vector
file into several files which contain one vector each:
<PRE>
<B><FONT>% </FONT></B><FONT>splitvec mysim.vec
</FONT>
</PRE>
<P>
creates several files: <TT>mysim1.vec</TT>,<TT> mysim2.vec</TT>
etc.
<PRE>
<B><FONT>mysim1.vec:
</FONT></B># vector  1  &quot;subnet[4].term[12]&quot;  &quot;response time&quot;  1
12.895  2355.66666666
14.126  4577.66664666
23.086  2355.66666666

<B>mysim2.vec:
</B># vector 2  &quot;subnet[4].srvr&quot;  &quot;queuelen+queuingtime&quot;  2
16.960  2.00000000000  .63663666
24.026  8.00000000000  .44766536
</PRE>
<P>
As you can see, the vector ID is gone.
<P>
The files can be further processed with math packages, or read
by analysis or spreadsheet programs which provide numerous ways
to display data as diagrams, do calculations on them etc. One
could use for example Gnuplot, Matlab, Excel, etc.
<H3><A NAME="_Toc443041306">Visualization under Unix</A></H3>
<P>
Two programs are in common use: Gnuplot and Xmgr. Both are free
and both have their good and bad sides; will briefly discuss them.
There are innumerable tutorials and documentation about them on
the Web; some of them you will find among the References.
<P>
Both programs can eat files produced by <TT>splitvec</TT>. Both
programs can produce output in various forms: on screen, in Postscript
format, printer files, Latex output etc. For DTP purposes, Postscript
seems to be the most appropriate.
<P>
Gnuplot has an interactive command interface. To get the vectors
in <TT>mysim1.vec</TT> and <TT>mysim4.vec</TT> plotted in the
same graph, you can type:
<PRE>
<FONT>plot &quot;mysim1.vec&quot; with lines, &quot;mysim4.vec&quot; with lines
</FONT>
</PRE>
<P>
To adjust the <I>y</I> range, you would type:
<PRE>
<FONT>set yrange [0:1.2]
</FONT>replot
</PRE>
<P>
There are several commands to adjust ranges, plotting style, labels,
scaling etc. Gnuplot can also plot 3D graphs. Gnuplot is also
available for DOS, Windows and other platforms. Gnuplot also has
a simple graphical interactive user interface called PlotMTV.
However, we recommend that you use OMNeT++'s Plove tool, described
in an earlier section.
<P>
Xmgr is an X/Motif based program, with a menu-driven graphical
interface. You load the appropriate file by selecting in a dialog
box. The icon bar and menu commands can be used to customise the
graph. Some say that Xmgr can produce nicer output that Gnuplot
and it is easier to use. Xmgr cannot do 3D and only runs on Unixes
with X and Motif installed. Xmgr also has a batch interface so
you can use it from scripts too.
<HR><H1><A NAME="_Toc443041307">Debugging and profiling</A></H1>
<H2><A NAME="_Toc443041308">Debugging</A></H2>
<H3><A NAME="_Toc443041309">Stack problems</A></H3>
<P>
<TT><B><FONT>&quot;Stack violation (<I><B>FooModule</B></I><B>
stack too small?) in module <I>bar.foo</I>&quot;</B></FONT></B></TT>
<P>
OMNeT++ detected that the module has used more stack space than
it has allocated.<SUP>(NEW)</SUP> You should increase the stack
for <TT>FooModule</TT>. You can call the <TT>stackUsage()</TT>
from <TT>finish()</TT> to find out actually how much stack the
module used. See also the chapter on<BR>
<P>
<TT><B><FONT>&quot;Error: Cannot allocate <I><B>nn</B></I><B>
bytes stack for module <I>foo.bar&quot;</I></B></FONT></B></TT>
<P>
If you get the above message, you have to increase the total stack
size (the sum of all coroutine stacks). You can do so in <TT>omnetpp.ini</TT>:
<PRE>
<FONT>[General]
</FONT>total-stack-kb = 2048  # 2MB
</PRE>
<P>
There is no<I> </I>penalty if you set <TT>total-stack-kb</TT>
too high. I recommend to set it to a few K less than the maximum
process stack size allowed by the operating system (<TT>ulimit
-s</TT>; see next section).<BR>
<P>
<TT><B><FONT>&quot;Segmentation fault&quot;</FONT></B></TT>
<P>
On Unix, if you set the total stack size higher, you may get a
segmentation fault during network setup (or during execution if
you use dynamically created modules) for exceeding the operating
system limit for maximum stack size. For example, in Linux 2.0.x,
the stack can be at most 8192K (that is, 8MB). The <TT>ulimit</TT>
syscall and utility program can be used to set the resource limits,
but you can only increase if you're root. Furthermore, resource
limits are inherited by child processes. The following statement
worked out for me under Linux to get a shell with a 64M stack
limit:
<PRE>
<FONT>$ su root
</FONT>Password:
% ulimit -s 65536
% su andras
$ ulimit -s
65536 
</PRE>
<P>
If you do not want to go through the above process at each login,
you can change the limit in the PAM configuration files. In Redhat
Linux (maybe other systems too), add the following line to <TT>/etc/pam.d/login</TT>:
<PRE>
<FONT>session    required     /lib/security/pam_limits.so
</FONT>
</PRE>
<P>
and the following to <TT>/etc/security/limits.conf</TT>:
<PRE>
<FONT>*  hard  stack  65536
</FONT>
</PRE>
<P>
A more drastic solution is to recompile the kernel with a larger
stack limit. Edit <TT>/usr/src/linux/include/linux/sched.h</TT>
and increase <TT>_STK_LIM</TT> from <TT>(8*1024*1024)</TT> to
<TT>(64*1024*1024)</TT>.
<P>
Finally, it you're tight with memory, you can switch to Cmdenv.
Tkenv increases the stack size of each module by about 32K so
that user interface code that is called from a simple module's
context can be safely executed. Cmdenv does not need that much
extra stack.
<H3><A NAME="_Toc443041310">Memory allocation problems</A></H3>
<P>
For investigating memory allocation problems, try using Cmdev,
and uncomment the <TT>#defines</TT> in <TT>src/envir/cmdenv/heap.cc</TT>:
<P>
<TT>HEAPCHECK</TT> checks heap on <TT>new</TT>/<TT>delete</TT>
<P>
<TT>COUNTBLOCKS</TT> counts blocks on heap and tells it if none
left
<P>
<TT>ALLOCTABLE</TT> remembers pointers and reports heap contents
if only <TT>LASTN</TT> blocks remained
<P>
<TT>DISPLAYALL</TT>  reports every <TT>new</TT>/<TT>delete</TT>
<P>
<TT>DISPSTRAYS</TT> reports deleting of pointers that were not
registered by <TT>operator</TT> <TT>new</TT> or that were deleted
since then
<P>
<TT>BKPT</TT> calls a function at a specified <TT>new</TT>/<TT>delete</TT>;
you can set a breakpoint to that function
<P>
If <TT>COUNTBLOCKS</TT> is turned on, you should see the <TT>[heap.cc-DEBUG:ALL
BLOCKS FREED OK]</TT> message at the end of the simulation. If
you do not see it, it means that some blocks have not been freed
up properly, that is, your simulation program is likely to have
memory leaks.
<H2><A NAME="_Toc443041311">Factors that affect the speed of the
simulation</A></H2>
<P>
If your simulation program is tested and runs OK, you'll probably
want to run it as fast as possible. Here's a table that could
help where to begin optimizing.
<P>
The measurements were made on one version of the FDDI model (you
can find it in the <TT>samples</TT> directory); we simulated 10
milliseconds. We used Cmdenv. The machine was a 100Mhz Intel Pentium
with 32MB RAM. The simulation program was compiled with Borland
C++ 3.1 (no particular optimization) and run on DOS 6.22. Disk
caching was installed (SmartDrive read/write caching, 8MB cache).
<BR>

<TABLE BORDER=1>
<TR><TD WIDTH=153><B>Settings</B></TD><TD WIDTH=99><B>Execution time</B>
</TD><TD WIDTH=373><B>Details</B></TD></TR>
<TR><TD WIDTH=153>all screen output on; full heapcheck</TD><TD WIDTH=99>7 min 50 sec
</TD><TD WIDTH=373>Setting in <TT>omnetpp.ini</TT>:
<P>
<TT>verbose-simulation = yes<BR>
<FONT>module-messages = yes</FONT></TT>
<P>
The <TT>#defines</TT> in <TT>envir/cmdenv/heap.cc</TT> were all enabled. This means full heapcheck with each allocation, tracking of all allocated blocks etc.
</TD></TR>
<TR><TD WIDTH=153>no screen output at all;<BR>
full heapcheck
</TD><TD WIDTH=99>5 min 50 sec</TD><TD WIDTH=373>All screen output were <TT>#ifdef</TT>'ed out from source; also, the <TT>omnetpp.ini</TT> contained the 
<P>
<TT>verbose-simulation = no</TT>
<P>
line. The heapcheck defines were turned on.
</TD></TR>
<TR><TD WIDTH=153>all screen output on;<BR>
no heapcheck</TD>
<TD WIDTH=99>2 min</TD><TD WIDTH=373>We turned off heapcheck (we commented out the defines in <TT>heap.cc</TT>) and turned back on the screen output. We used the same <TT>omnetpp.ini</TT>: setting as with first case.
</TD></TR>
<TR><TD WIDTH=153>screen output redirected to file;<BR>
no heapcheck
</TD><TD WIDTH=99>15.5 sec</TD><TD WIDTH=373>Same as previous configuration, except that we run the program with<P>
<TT>fddi &gt; output.txt</TT>
</TD></TR>
<TR><TD WIDTH=153>screen output redirected to NUL;<BR>
no heapcheck
</TD><TD WIDTH=99>13 sec</TD><TD WIDTH=373>Same as previous configuration, except that we run the program with<P>
<TT>fddi &gt; NUL</TT>
</TD></TR>
<TR><TD WIDTH=153>screen output turned off from ini file;<BR>
no heapcheck
</TD><TD WIDTH=99>7.5 sec</TD><TD WIDTH=373>We did not only redirect but also disabled screen output. Setting in <TT>omnetpp.ini</TT>:
<P>
<TT>verbose-simulation = no<BR>
<FONT>module-messages = no</FONT></TT>
</TD></TR>
<TR><TD WIDTH=153>no screen output generation;<BR>
no heapcheck
</TD><TD WIDTH=99>4.5 sec</TD><TD WIDTH=373><FONT>We <TT>#ifdef</TT></FONT>'ed out all printouts from the simple module sources and also turned off any messages from <TT>omnetpp.ini</TT>.
</TD></TR>
</TABLE>
<P>
<P>
The moral is that heap checks and screen output greatly influences
speed, so once you do not need them (debugging is over), throw
them out. You also gain a lot by putting <TT>#ifdef</TT> lines
around your debugging code. And of course, program with care.
<HR><H1><A NAME="_Toc443041312">Modelling with OMNeT++</A></H1>
<H2><A NAME="_Toc443041313">Coding conventions</A></H2>
<P>
Here's a bunch of advice on how to write OMNeT++ models. Some
of them are &quot;rules of thumb&quot;, saying if you program
like that, you're likely to have less trouble; other conventions
are aimed at making the models produced by the OMNeT++ community
more consistent.
<P>
Conventions for writing simple modules:
<OL>
<LI>Put the NED description, the C++ class declaration and the
implementation into three separate files. Do not put two or more
modules' code into the same file unless they are build upon one
another - do not be afraid of small files! Thus, for a simple
module called Foobar, you should have Foobar.ned, Foobar.h and
Foobar.cc. This reduces coupling of module sources and makes your
code more reusable. You may choose file names not longer than
8 chars and lower case, in case someone wants to look at your
stuff on DOS.
<LI>Please write a legible C++ code! Choose your favourite indentation
style and keep to it consistently. (I would prefer the style in
which the OMNeT++ sources are written.) Use <TT>//</TT> comments
and never <TT>/* */</TT> ones. Never write more than one statements
on the same line. Avoid putting comments at the end of the line
- place them <I>above</I> the code on a separate line instead!
Always use blank lines to break the code into not-very-long logical
blocks; above each block, put a few-word comment what that block
does. Always put at least two blank lines between two (member)
functions. Remember: the structure of your code should be obvious
at the first glance!
<LI>Identifiers: Begin module type names with a capital letter,
and capitalize the beginning of each word, like in <TT>TokenRingMAC</TT>.
Do not use underscore '_' in module names. Use the C++-style naming
on member functions: beginning of each word is capitalized (except
for the first one) and no underscores: <TT>sendUnnumberedFrame()</TT>.
On parameter names, you may use C-style (<TT>window_size</TT>)
or C++-style (<TT>windowSize</TT>) naming, whichever you prefer.
<LI>Put state variables into the class declaration as data members
instead of local variables to <TT>activity()</TT>. This enables
referencing them in <TT>finish()</TT> as well as splitting up
<TT>activity()</TT>.
<LI>Objects like <TT>cQueues</TT>, <TT>cOutVectors</TT>, <TT>cStdDevs</TT>
also go into the class declaration. You can assign names to them
with <TT>setName()</TT> and otherwise initialize them at the top
of the <TT>activity()</TT> function. This way you can avoid having
to write the simple module constructor explicitly. 
<LI>Never put code that's supposed to do simulation-related things
into the simple module destructor; put them into <TT>finish()</TT>
instead. In fact, you almost never need to write a destructor
since OMNeT++ keeps track of objects you create (dynamically,
as local variables or as class members) and disposes of them automatically.
However it cannot track non-OMNeT++ objects so they may need to
be deleted manually from the destructor.
<LI>You need to write the simple module constructor exlicitly
if you have dynamic data structures in the class that need to
be freed by the destructor. Even in this case, make the constructor
as simple as possible (e.g. simply NULL out the data structure
pointers) and leave real work to the <TT>activity()</TT> function.
<LI>Especially, do not put simulation-related code into the simple
module constructor. For example, modules often need to investigate
their surroundings (maybe the whole network) at the beginning
of the simulation and save the collected info into internal tables.
Code like that cannot be placed into the constructor since the
network is still being set up when the constructor is called.
<LI>Do not hesitate to split up the <TT>activity()</TT> function
to several  member functions, as this generally improves code
readability. For example, if you're implementing a state machine,
you can put the general logic into <TT>activity()</TT> and the
code implementing the actual states into separate member functions.
As a rule of thumb, one member function shouldn't be more than
one screen page (about 25 lines) unless really necessary. 
<LI>Make the functions virtual. Maybe someone who reuses your
code will need a different behavior than what you thought of.
<LI>Use inheritance if you're writing a very complex simple module:
create a basic simple module class and build upon it deriving
new module classes. This will make your code more readable and
easier to manage/reuse. Unfortunately, inheritance is not supported
in NED so you actually have to make distinct NED descriptions
for each simple module class. Even if you have an abstract classes,
prepare a NED desctiption for it: it is useful as a reference
to others who might derive a different simple module class from
your abstract class. Inheritance in NED is planned in later releases
of OMNeT++.
<LI>Avoid global variables (and what's the same, static class
members). They are not reset to their initial value (zero) when
you run the simulation, stop it and rebuild the network. This
can cause several problems when you use Cmdenv to execute several
runs one after another, or in Tkenv when you rebuild the network
from the menu.
<LI>Query the values of parameters into state variables (--&gt;class
members) of the <I>same</I> name at the top of the <TT>activity()</TT>
function. If you know the value of a parameter is a random value
(like uniform 0..10) or it can change during simulation, then
to avoid having to look it up by name each time (like <TT>d=par(&quot;delay&quot;)</TT>)
you may query its pointer into a <TT>cPar*</TT> state variable
with the same name prepended with 'p' (like <TT>pDelay=&amp;par(&quot;delay&quot;)</TT>).
<LI>Use <TT>ev.printf()</TT> and <TT>ev&lt;&lt;...</TT> generously
to print out information on what the module is doing. Doing so
will pay out several times when it comes to debugging. Use a parameter
and a state variable called <TT>debug</TT>. Surround your debugging
output (<TT>ev&lt;&lt;...</TT> and <TT>ev.printf()</TT> calls)
with <TT>if(debug)</TT>. You may introduce more specific debug
switches (like <TT>debug_queuing</TT> etc.)
<LI>Put a <TT>WATCH() </TT>on the state variables (including <TT>debug</TT>)
at the top of the activity function. They cause no run-time overhead,
consume little memory and can be invaluable during debugging.
<LI>Reuse messages wherever possible, as this can result in a
tremendous gain in execution speed! For example, if you implement
timers, you can create a message once and then schedule the same
message again and again each time the timer is restarted. Look
at the Fifo example about how to do it.
</OL>
<H2><A NAME="_Toc443041314">Component libraries</A></H2>
<P>
Because of the structure of the simulation system, one can create
libraries of reusable elements in several ways. The three basic
types are:
<UL>
<LI>simple module libraries
<LI>NED source libraries
<LI>precompiled compound module libraries
</UL>
<P>
The elegant thing is that the user of the library does not need
to know which kind of library he/she is using; the three types
of libraries are equivalent in terms of usage.
<H3><A NAME="_Toc443041315">Simple module libraries</A></H3>
<P>
Simple modules that can be used in more than simulations can form
an object library. Good candidates for module libraries are simple
modules that implement:
<UL>
<LI>Physical/Data-link protocols: Ethernet, Token Ring, FDDI,
LAPB etc.
<LI>Higher layer protocols: IP, TCP, X.25 L2/L3, etc.
<LI>Network application types: E-mail, NFS, X, audio etc.
<LI>Basic elements: message generator, sink, concentrator/simple
hub, queue etc.
<LI>Modules that implement routing algorithms in a multiprocessor
or network
<LI>...
</UL>
<P>
To create a library, you compile the simple module C++ sources
and collect the object files in one directory. You'll also need
to the provide the NED descriptions:
<PRE>
<FONT>library/generator.ned
</FONT>        generator.o
        sink.ned
        sink.o
        ethernet.ned
        ethernet.o
</PRE>
<P>
The NED files contain the interfaces of the simple modules. For
example:
<PRE>
<FONT>// generator.ned
</FONT><B>simple</B> Generator
    <B>parameters</B>: 
       interarrival time, message_length, message_kind;
    <B>gates</B>:
       <B>out</B>: output;
<B>endsimple
</B>
</PRE>
<P>
The user of the library would include <TT>generator.ned</TT> in
his/her NED files, and link the executable with <TT>generator.o</TT>.
This is more or less the same concept as conventional C/C++ header
files and libraries. The basic advantage is the same as with C/C++:
you save compilation time and hide concrete implementation. The
latter also means that you can give the module library to others
without having to share the C++ source.
<P>
It could also be meaningful to provide the C++ header files with
the module class declarations. This would enable the user to directly
call the member functions of the module object from the simulation
program and derive new module classes by redefining the virtual
functions.
<P>
You do not need to have a separate NED file for each module: you
could merge all of them into a single <TT>library.ned</TT> that
contains the NED declarations of all modules without all side
effects. However, it is not recommended to put all object files
into one library (<TT>.a</TT> or <TT>.lib</TT>), because then
every simple module would be present in simulation programs linked
with the library, regardless whether the simulation uses them
or not.
<H3><A NAME="_Toc443041316">Compound module NED source libraries</A>
</H3>
<P>
The NED sources of reusable compound modules can also be placed
in a library. Candidates are:
<UL>
<LI>network nodes such as hubs, bridges, routers
<LI>different workstation/computer types: file server, X terminal
etc.
<LI>node of a massively parallel multiprocessor (used in testing
different topologies)
<LI>topology templates: parametrized ring, mesh, hypercube, torus
etc. topologies, with the sizes (shapes etc) and the actual node
types to be left as parameters
<LI>...
</UL>
<P>
The NED sources are used through the import mechanism; the corresponding
simple module object files still to be linked in the executable.
<P>
The user does not necessarily notice that he/she is using a compound
module library and not a simple module library. In NED files,
the user imports and uses the compound module sources in exactly
the same way as he/she used the simple module interface declarations.
Linking also goes in the same way; if the simple modules objects
necessary for a certain compound module are aggregated into a
library (<TT>.a</TT> or <TT>.lib</TT>), the user does not even
notice the difference from the number of files he/she has to link
in.
<H3><A NAME="_Toc443041317">Precompiled compound module libraries</A>
</H3>
<P>
If you share a compound module with others, you do not necessarily
have to share the NED source and reveal the internals of the compound
module. You can turn the compound module into something that very
much looks like a simple module.
<P>
Suppose you have the following compound module:
<PRE>
<FONT>// router-compound.ned
</FONT><B>module</B> Router:
	<B>parameters</B>:
		processing_delay, buffersize;
	<B>gates</B>:
		<B>in</B>: input_ports[];
		<B>out</B>: output_ports[];
	<B>submodules</B>:
		routing: RoutingModule
			<B>parameters</B>:
                      //...
			<B>gatesizes</B>:
				//...
		datalink: DataLink[num_of_ports]
			<B>parameters</B>:
				retry_count = 5,
				window_size = 2;
           //...
	<B>connections</B>:
           // ...
<B>endmodule
</B>
</PRE>
<P>
First, you would compile this NED file with the NEDC compiler
and the resulting C++ code with the C++ compiler. Then you would
aggregate this object file with the simple module object files
into a single library (<TT>.a</TT> or <TT>.lib</TT>). Also, you
would write a separate NED file that declares the interface of
the new &quot;simple&quot; module:
<PRE>
<FONT>// router-simple.ned
</FONT><B>simple</B> Router:
	<B>parameters</B>:
		processing_delay, buffersize;
	<B>gates</B>:
		<B>in</B>: input_ports[];
		<B>out</B>: output_ports[];
<B>endsimple
</B>
</PRE>
<P>
The method produced a <I>precompiled compound module</I>. The
resulting two files can be placed into a simple module library
and can be used identically to ordinary simple modules.
<P>
Using precompiled compound modules you can hide the internal complexity
of your model from direct inspection. However, nothing can prevent
a user from building a simulation executable with it and  exploring
the structure of your compound module using OMNeT++ simulation
kernel functions. Consequently, using precompiled compound modules
is more useful as a structuring tool.
<H2><A NAME="_Toc443041318">Problem solving with OMNeT++</A></H2>
<H3><A NAME="_Toc443041319">Modelling computer networks</A></H3>
<P>
The hierarchical module structure of OMNeT++ allows you to organize
the model around different level:
<P>
Physical topology:
<OL>
<LI>Top-level network
<LI>Subnetwork (site)
<LI>LAN
<LI>node
</OL>
<P>
Within a node:
<OL>
<LI>OSI layers. The Data-Link, Network, Transport, Application
layers are of greater importance.
<LI>Applications/protocols within a layer.
</OL>
<P>
The advantage of OMNeT++ over many existing simulators is that
the depth of the module nesting is not limited, and, what is in
connection with the previous one, that a simple module can be
transformed into a compound module by splitting the code into
several simple modules <I>without affecting exisiting users</I>
of the module and vica versa. The latter means that the programmer
of the model is not under pressure from possibly incorrect early
design decisions about what to implement with a single module
and what with a compound module.
<H3><A NAME="_Toc443041320">Modelling multiprocessor systems</A>
</H3>
<P>
One can make use of flexible model topologies. It is straightforward
to create ring, mesh, butterfly, torus, hypercube, tree, fat tree
and other topologies with conditional loop connections.
<P>
Furthermore, general &quot;topology templates&quot; (e.g. mesh
or hypercube) can be created, where the types of the actual nodes
left as parameters. The actual node types are substituted as parameter
values for each concrete simulation. Topology templates could
be placed in a library and imported from there if needed.
<H3><A NAME="_Toc443041321">Parameter tuning</A></H3>
<P>
Tuning means finding the parameter values which produce optimal
operation of the system. In OMNeT++, you can tune the model during
runtime. The code that monitors performance and changes parameter
values can be placed:
<UL>
<LI>inside the model. In this case, the code does not necessarily
form separate module(s); you can add the extra code to any already
exisiting module.
<LI>outside the model of the actual system. If you choose this
method, you will create new modules that monitor and control the
model.
</UL>
<P>
OMNeT++ supports the model tuning concept by providing reference
parameters. Parameters that influence the model performance and
need to be tuned will be declared at the highest layer and taken
by both the model and the monitor part.
<P>
An example of model tuning is how one can determine the critical
throughput of a communication network by changing the offered
load according to performance measures of the network (queueing
times etc.)
<H3><A NAME="_Toc443041322">Multiple experiments within one simulation
run</A></H3>
<P>
One might need to perform a large number of simulation runs where
the model parameters are not known in advance. This can be the
case when one wants to optimize a system and parameter tuning
cannot be used because 
<OL>
<LI>for each experiment, he wants to start the model from a well-defined
initial state, or
<LI>he wants to change the model topology from one simulation
run to the other
</OL>
<P>
In this case, the following solution be followed. The network
would consist of only one simple module that would organize the
simulation runs by creating, running and destroying the actual
models with each experiment. The simple module's code would look
like this:
<PRE>
<FONT>void SimulationManager::activity()
</FONT>{
    determine parameters for the first run;
    for(;;)
    {
        dynamically create a model with the current run parameters;
        run the model for a desired period;
        delete future events that belong to the model;
        get statistics out of the model;
        destroy the model;
        if (simulation is done) 
           break;
        calculate parameters for the next run;
    }
    write out results
}
</PRE>
<P>
The solutions built into OMNeT++ (flexible module topologies,
dynamic creation of compound modules etc.) strongly support this
concept.
<H3><A NAME="_Toc443041323">Dynamic topology opmization</A></H3>
<P>
Dynamic topology optimization is the generalization of the &quot;parameter
tuning&quot; and &quot;multiple experiments within one simulation
run&quot; concepts. If one wants to simulate large systems, it
is possible that one part of the model needs its topology to be
optimized (optimal number of servers, optimal interconnection
etc.) while other parts of the model have reached their steady
state and should not be bothered.
<P>
This can be achieved by modifying the previous scheme. Parts of
the model that do not need topology optimization can be created
once and left running for the whole duration of the simulation;
other parts are examined and their structure is modified from
time to time.<BR>
<HR><H1><A NAME="_Toc443041324">Parallel execution</A></H1>
<P>
OMNeT++ supports parallel execution of large simulations. To make
use of parallel execution, the model is to be partitioned to several
segments that will be simulated independently on different hosts
or processors.
<P>
The simulation kernel makes it possible to send messages from
one segment to another. A message can contain arbitrarily complex
data structures; these are transferred transparently, even between
hosts of different architectures. The simulation kernel provides
a simple synchronisation mechanism (<I>syncpoints</I>, available
through the <TT>syncpoint()</TT> call) that can ensure that causality
is kept when sending messages between segments. Syncpoints correspond
to <I>null messages</I> found in the literature.
<P>
Message sending and syncpoints enable one to implement conservative
PDES and also a novel and less-known paradigm, Statistical Synchronisation.
The simulation class library contains objects that explicity support
the implementation of models using Statistical Synchronisation.
<P>
High level debugging is supported by saving the textual output
from remote segments to a log file and/or relaying them to a single
console.
<P>
OMNeT++ supports flexible partitioning of the model. In the NED
language, by using <I>machine parameters</I> you can specify <I>logical
hosts</I> for different modules at any level of the module hierarchy
of the network. You map logical hosts to physical ones in the
ini file; if you map several logical hosts into the same physical
machine, they will be merged into a single OMNeT++ process.
<P>
The PVM3 (Parallel Virtual Machine Version 3) library is used
for communication between hosts. PVM is portable and it is widely
used in university and research environment. You can find PVM
readings in the Reference.
<H2><A NAME="_Toc443041325">Syncpoints</A></H2>
<P>
When running a simulation in parallel, different segments of the
model execute as independent UNIX processes, typically on separate
hosts. Since the hosts can be of different speed and the simulated
model segments can be of different complexity, at a given moment
the model times of different segments will differ: some segments
are ahead of the others and some lag behind. Suppose that a message
is sent from segment A to segment B which is ahead of A in model
time. If B processed the message, causality would break. This
should never happen.
<P>
The solution built in OMNeT++ is the following. Segment A must
know in advance when it will send the next message to segment
B and announce it with the <TT>syncpoint()</TT> call. The simulation
kernel sends the syncpoint to segment B. When segment B's model
time reaches the specified time, segment B's simulation kernel
blocks execution until the promised message arrives from A. Then
the simulation continues, typically but not necessarily with the
message that has just been received from A.
<P>
In the reverse case when A is ahead of B, A's message arrived
at B before it has reached the syncpoint. In this case, there
is no problem and the syncpoint is just an unnecessary precaution.
B just inserts the message in its future event set, clears the
syncpoint and continues execution.
<P>
The <TT>syncpoint()</TT> call takes two arguments. The first is
the model time when (or more precisely: when of after when) the
simple module will send a message to another simple module in
a different segment. The second argument is a gate given with
its number or its name. The gate implicitly specifies the destination
segment to synchronize with.
<PRE>
<FONT>syncpoint(t, &quot;outgate&quot;);
</FONT>
</PRE>
<P>
Details of the syncpoint implementation. If the destination module
is in the same segment, the call is ignored. (This makes it possible
to run models designed to execute in parallel as a single process,
without any modification.) Each segment keeps a list of syncpoints
sent to it (time + gate), ordered by time. Simulation executes
normally until it comes to an event that has a time <I>definitely</I>
<I>past</I> the first syncpoint in the list. That event is not
processed, but the segment goes into a blocked state. While the
segment is blocked, it listens for messages arriving from other
segments. (In the actual implementation, passive wait is used
so a blocked segment doesn't use much CPU time.) Each message
that arrives deletes the first syncpoint in the list that matches
its gate. The segment goes out of the blocked state when -- because
of deletions -- the first syncpoint in the list is no longer past
the event in question. Then the simulation goes on normally, either
with the newly arrived message (or the earliest of them) or the
original event. A message that arrives outside of the blocked
state also causes deletion of the first matching syncpoint in
the list; this case corresponds to the reverse case when the sender
segment is ahead of the reveiving segment in model time.
<P>
It is possible to cause deadlock with carelessly placed breakpoints.
Suppose that segment A declares a syncpoint at 10s with segment
B, but it will actually send a message only at 10.5s. If segment
B does the same to segment A, a nice deadlock is created. OMNeT++
makes no effort to detect or prevent such deadlocks; it is entirely
the simulation programmer's task to take care that deadlocks do
not occur.
<H2><A NAME="_Toc443041326">The PVM virtual machine</A></H2>
<P>
The <TT>pvmhosts</TT> file is used by PVM to describe what computers
will participate in the virtual machine, where the executables
(in our case, the OMNeT++ programs) are located on each computer,
what working directories should be set etc.
<P>
It is advisable to have a common, shared directory mounted on
all participating hosts; this eliminates the tedious work of having
to copy files to all hosts again and again.
<P>
If using OMNeT++, it is a good idea to write separate <TT>pvmhosts</TT>
files for each simulation program. Since simulation programs are
typically in separate directories, the <TT>pvmhosts</TT> file
in each directory can name that directory as executables directory
and working directory for each host. This way, there is no need
to create soft links or explicitly name directories in the OMNeT++
ini files.
<P>
Each line in the <TT>pvmhosts</TT> file describes one host. An
example line (this all should be a <I>single line</I>!):
<PRE>
<FONT>whale  ip=whale.hit.bme.hu  lo=andras
</FONT>   ??=/home/andras/pvm/pvm
   ep=/home/andras/omnetpp/projects/fddi
   wd=/home/andras/omnetpp/projects/fddi
</PRE>
<P>
To start PVM with this configuration:
<PRE>
<FONT>cd ~/omnetpp/projects/fddi
</FONT>pvm pvmhosts
</PRE>
<H2><A NAME="_Toc443041327">Mapping logical machines to physical
ones</A></H2>
<P>
The <TT>on:</TT> phrases in the NED descriptions specify the logical
machine(s) on which the module is run. The machine parameters
are mapped to physical machines in the <TT>[Machines]</TT> section
of the configuration file:
<PRE>
<FONT>; file: omnetpp.ini
</FONT><B>;...
[Machines]
</B>node1 = whale.hit.bme.hu
node4 = whale.hit.bme.hu
node2 = puppis.hit.bme.hu
node3 = dolphin.hit.bme.hu
;...
</PRE>
<H2><A NAME="_Toc443041328">Configuration of the slaves</A></H2>
<P>
Slave processes can be configured in the <TT>[Slaves]</TT> section
of the configuration file:
<PRE>
<FONT>; file: omnetpp.ini
</FONT><B>[Slaves]
</B>write-slavelog=
slavelog-file=
module-messages=
errmsgs-to-console=
infomsgs-to-console=
modmsgs-to-console=
</PRE>
<P>
Screen input/output of the slaves is re-routed to the console.
However, any file I/O is done in the local file system of each
host.
<H2><A NAME="_Toc443041329">Configuration and running</A></H2>
<P>
The user must have PVM installed on the hosts he is going to run
segments on.
<P>
To set up a simulation for distributed execution, the user must:
<OL>
<LI>set the <TT>PVM_ROOT</TT> environment variable
<LI>link the simulation executable with <TT>sim_pvm.a</TT> instead
of <TT>sim_std.a </TT>(You can do it by setting <TT>PVM_SUPPORT</TT>
to <TT>yes</TT> in a <TT>jar_mkmk</TT>-generated <TT>makefile</TT>.)
<LI>set <TT>distributed=TRUE </TT>in the <TT>[General]</TT> section
of the configuration file.
<LI>specify the logical-hosts-to-physical-machines mapping in
the <TT>[Machines]</TT> section
<LI>copy the simulation executable and the configuration file
to each host if they have physically different disks
<LI>start <TT>pvm</TT> with an appropriate <TT>pvmhosts</TT> file
<LI>start the simulation executable on the host which is supposed
to be the console. That process will start up the program on the
other hosts too and do the simulation.
</OL>
<P>
The first machine is called &quot;console&quot; or &quot;master&quot;,
the others are called &quot;slaves&quot;.
<H2><A NAME="_Toc443041330">If there are problems...</A></H2>
<P>
PVM programs in general are more difficult to get running than
ordinary programs. Wrong settings in the PVM configuration files
can cause various problems, for example. Also, parallel programs
are a lot harder to test and debug.
<P>
What can you do if your distributed OMNeT++ simulation won't work?
<UL>
<LI>First of all, check the <TT>pvmhosts</TT> file to see if PVM
looks for the executables in the right directories on all hosts
and the working directories are right (typically, the same directory
as the executable's). 
<LI>In the ini file, enable writing the <TT>slave.log</TT> files
for the slave processes and check what is written into them.
<LI>You can try enabling the <TT>SINGLE_HOST </TT>define in the
<TT>sim/pvm/pvmmod.cc</TT> source file. This will make OMNeT++
run all segments of the distributed simulation on the local host,
making things a lot easier to manage. 
<LI>Also, try the defining <TT>PVM_DEBUG</TT> at the same place:
it enables a lot of <TT>ev.printf()</TT>s in the code interfacing
with PVM, so it is easier to spot where the problems are.
<LI>PVM itself also has an environment variable which, if set,
causes the PVM library to print out debugging information. However,
this is very low-level information, it will rarely be useful.
</UL>
<HR><H1><A NAME="_Toc443041331">Appendix A: Statistical synchronisation</A>
</H1>
<H2><A NAME="_Toc443041332">The description of the statistical
synchronisation method</A></H2>
<P>
The short summary of the Statistical Synchronization Method follows.
Similarly to other parallel discrete event simulation methods,
the model to be simulated - which is more or less a precise representation
of a real system - is divided into segments, where the segments
usually describe the behaviour of functional units of  the real
system. The communication of the segments can be represented by
sending and receiving various messages. The simulators of  the
segments are executed by separate processors.
<P>
The communication of  these segments is simulated with appropriate
interfaces. The messages generated in a given segment and to be
processed in a different segment are not  transmitted there, but
the output interfaces collect the statistical data of them.  If
the input interfaces generate messages for the segments according
to the statistical characteristics of the messages collected by
the proper output interfaces, the segments with their input- and
output  interfaces can be simulated separately, giving statistically
correct results. The events in one segment have not the same effect
 in other segments as in the original model,  so the results collected
during the SSM are not exact. The precision depends on the segmentation,
on the accuracy of statistics collection and regeneration, and
on the frequency of the statistics exchange among the processors.
<P>
<B>Segmentation</B>
<P>
The segments of the simulator are executed by separate processors,
they have their own, independent virtual times. Because the interactions
among segments are performed by the statistical parameters of
 these interactions, the segmentation should be done so, that
the overwhelming majority of the interactions should happen within
the segments and not among them. This speeds up the so-called
inter-segment transients and improves the accuracy as well.
<P>
<B>Timing of statistics exchange</B>
<P>
Asynchronous statistics exchange means, that whenever a statistical
result collection in an output interface is ready, it is applied
- after mapping and correction - in the proper input interface.
This is clearly more efficient, than the so-called synchronous
statistics exchange, which means, that we delay the application
of collected values until all the output interfaces get ready
with the result collection. Frequent statistics exchange makes
the inter-segment transient faster, but the lower sample numbers
makes the estimation - and the whole simulation - less precise.
<BR>
<P>
To learn more about SSM, see [PON92] and [PON93].
<H2><A NAME="_Toc443041333">Using SSM in OMNeT++</A></H2>
<P>
OMNeT++ directly supports the implementation of statistical interface
with the following classes:
<P>
<TT>cLongHistogram</TT>, <TT>cDoubleHistogram</TT>, <TT>cPSquare</TT>,
<TT>cPar</TT>.
<HR><H1><A NAME="_Toc443041334">Appendix B: Comparison of OPNET and
OMNeT++</A></H1>
<P>
OPNET (from MIL3 Inc.) is a state-of-the art commercial simulation
program for the modelling of communication systems. OPNET is designed
to enable full-detail modelling: every tool is given to implement
nonstandard protocols or behaviour.
<P>
A quote from the OPNET brochure:<BR>
<P>
<I>&quot; OPNET presents an advanced graphical user interface
that supports multi-windowing, makes use of menus and icons, and
runs under X Windows. Supported platforms include popular engineering
workstations from SUN, DEC, HP and Silicon Graphics. (Windows
NT version also exists.)</I>
<P>
<I> Graphical object-oriented editors for defining topologies
and architectures directly parallel actual systems, allowing an
intuitive mapping between a system and its model. OPNET's hierarchical
approach simplifies the specification and representation of large
and complex systems. </I>
<P>
<I> The process editor provides a powerful and flexible language
to design models of protocols, resources, applications, algorithms,
queuing policies, and other processes. Specification is performed
in the Proto-C language, which combines a graphical state-transition
diagram approach with a library of more than 300 communication-
and simulation-specific functions. The full generality and power
of the C language is also available.</I>
<P>
<I> OPNET simulations generate user-selected performance and behavioral
data. Simulation results can be plotted as time series graphs,
scatter plots, histograms, and probability functions. Standard
statistics and confidence intervals are easily generated and additional
insight can be obtained by applying mathematical operators to
the collected data. </I>
<P>
<I> OPNET provides an advanced animation capability for visualising
simulation events. Both automatic and user-customised animations
can be displayed interactively during or after a simulation. Animations
can depict messages flowing between objects, control flow in a
process, paths of mobile nodes, and dynamic values such as queue
size or resource status. </I>
<P>
<I> OPNET provides open system features including: interfaces
to standard languages; the ability to take advantage of third-party
libraries; an application program interface; access to databases
and data files such as those generated by network analysers; and
PostScript and TIFF export for desktop publishing. OPNET users
are guided by a comprehensive documentation set and are backed
by outstanding technical support.&quot;</I>
<P>
OPNET is a very well designed and built commercial simulation
software. The author of OMNeT++ has worked for the Hungarian distributor
of OPNET for over three years and he has gained significant experience
with the software. He has taken part in several computer network
simulation projects for major Hungarian companies and also delivered
OPNET training. He has also written simulation models for a VSAT
system in OPNET. 
<P>
Following is a comparison of the features that concern general-purpose
computer systems simulation (and are not specific to computer
network simulation) and that are present both in OMNeT++ and OPNET.
<P>
<I><B>Model hierarchy levels</B></I><TABLE BORDER=1>
<TR><TD WIDTH=296><B>OPNET</B></TD><TD WIDTH=280><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=296>network level (subnetwork nesting possible)
<P>
node level (no nesting)<P>
process level (no nesting)
</TD><TD WIDTH=280>arbitrary levels of submodule nesting</TD>
</TR>
</TABLE>
<P>
<P>
<I><B>Topology description method</B></I>
<P>
OPNET provides two tools for defining module topology: graphical
editors to design network and node level models, and EMA (External
Model Access), an API for building model files from C programs.
These tools correspond to OMNeT++'s tools in the following way:
<BR>

<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Graphical</B></TD><TD WIDTH=192>graphical editor within the IDE
</TD><TD WIDTH=192>graphical editor: GNED</TD></TR>
<TR><TD WIDTH=192><B>High-level</B></TD><TD WIDTH=192>-</TD><TD WIDTH=192>NED language
</TD></TR>
<TR><TD WIDTH=192><B>Low-level</B></TD><TD WIDTH=192>EMA</TD>
<TD WIDTH=192>C++ output of NED compilation</TD></TR>
</TABLE>
<P>
<P>
The OPNET graphical model editor is a good tool, however it can
only create fixed (unparametrized) topologies. It also it lacks
efficient support for building large, regular topologies, which
is present in OMNeT++'s NED language.
<P>
There is no high-level textual model description in OPNET (like
NED is in OMNeT++). This means that one has either to use the
graphical editor or write lengthy C code using the EMA API.
<P>
There's a significant difference between how EMA and OMNeT++'s
NED are used. OPNET's EMA generates model files. EMA applications
are standalone programs: one writes the EMA C code, compiles and
runs it, and the EMA executable will generate a model file that
can be read into the graphical editor or loaded by simulation
programs. EMA cannot be used from within a simulation program.
In contrast, the compiled NED code of OMNeT++ becomes part of
the simulation program and it builds the model without having
to run external programs; this means that you can have a single
simulation executable that can be used to perform simulation studies
on networks with different topologies.
<P>
<I><B>Module parameters</B></I>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Expressions</B></TD><TD WIDTH=192>no expressions are allowed: only literals or exact copy of another parameter
</TD><TD WIDTH=192>arbitrary expressions using other parameters
</TD></TR>
<TR><TD WIDTH=192><B>Parameter passing</B></TD><TD WIDTH=192>by value
</TD><TD WIDTH=192>parameters can be passed by value or by reference, and be changed during simulation
</TD></TR>
<TR><TD WIDTH=192><B>Usage</B></TD><TD WIDTH=192>by process models only
</TD><TD WIDTH=192>by process models; also to define flexible topologies 
</TD></TR>
</TABLE>
<P>
<P>
In OPNET, module parameter values can be passed only &quot;as
is&quot;.
<P>
<I><B>Packet streams or gates</B></I>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Identification</B></TD><TD WIDTH=192>Packet streams are numbered from 0; no names can be assigned.
</TD><TD WIDTH=192>Gates are identified by names. Gate vectors are supported.
<P>
In the code, gates can be referenced by ID for greater speed.
</TD></TR>
<TR><TD WIDTH=192><B>Directionality</B></TD><TD WIDTH=192>Packet streams are uni-directional.
</TD><TD WIDTH=192>Gates are uni-directional.</TD></TR>
</TABLE>
<P>
<I><B>Flexible topologies</B></I>
<TABLE BORDER=1>
<TR><TD WIDTH=296><B>OPNET</B></TD><TD WIDTH=279><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=296>not really supported*</TD><TD WIDTH=279>in the NED file, parameters can define submodule types, count of submodules, gates and describe connections
</TD></TR>
</TABLE>
<P>
<P>
* If really necessary, it can be done through C programming (writing
EMA code) and running external program to create a separate model
file for each case.
<P>
<I><B>Tracing, animation and interactive simulation</B></I>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Tracing and debugging</B></TD><TD WIDTH=192>powerful command line debugger (ODB)
</TD><TD WIDTH=192>separate window for each module's output, single-steps, run until, inspectors, snapshot, etc. (Tkenv/Tvenv)
</TD></TR>
<TR><TD WIDTH=192><B>Animation</B></TD><TD WIDTH=192>essentially off-line (through animation probes and animation history files)
</TD><TD WIDTH=192>Interactive execution with message-flow anination, statistics animation etc. (Tkenv/Tvenv)
</TD></TR>
<TR><TD WIDTH=192><B>Interactive simulation</B></TD><TD WIDTH=192>not supported
</TD><TD WIDTH=192>strongly supported via object inspectors and watches. (Tkenv/Tvenv)
</TD></TR>
</TABLE>
<P>
<I><B>Random numbers</B></I><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Distributions provided</B></TD><TD WIDTH=192>many built-in distributions (through algorithms)
</TD><TD WIDTH=192>four built-in distributions, as C functions
</TD></TR>
<TR><TD WIDTH=192><B>Additional distributions</B></TD><TD WIDTH=192>through histograms
</TD><TD WIDTH=192>as C functions (algorithms); or through histograms
</TD></TR>
<TR><TD WIDTH=192><B>Random number generation</B></TD><TD WIDTH=192>one random number generator, no support for seed selection
</TD><TD WIDTH=192>several independent random number generators;
<P>
tool to support selecting good seed values
</TD></TR>
</TABLE>
<P>
<P>
OPNET has many built-in distributions implemented with algorithms
(C functions). Additional distributions are supported as histograms.
There is only one common source of random numbers. OPNET has no
aid for selecting seed values that produce long non-overlapping
random number sequences.
<P>
OMNeT++, only four basic distributions are provided. They are
implemented as C functions. Additional distributions can be added
by the user easily, and they are treated exactly in the same way
as built-in ones. Defining and using distributions in histogram
form is also supported. OMNeT++ provides several random number
generators, and also a tool for selecting good seed values.
<P>
<I><B>Process description method</B></I>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Method</B></TD><TD WIDTH=192>finite state machine
</TD><TD WIDTH=192>both process-style (coroutine-based) and finite state machine
</TD></TR>
</TABLE>
<P>
<P>
<I><B>Direct (non-scheduled) process interaction</B></I>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Method</B></TD><TD WIDTH=192>&quot;forced interrupt&quot;
</TD><TD WIDTH=192>member function call of other module</TD></TR>
</TABLE>
<P>
<P>
<I><B>Dynamic module creation</B></I><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>What can be created</B></TD><TD WIDTH=192>only processes within an exisiting module
</TD><TD WIDTH=192>simple modules;
<P>
connections;<P>
compound modules with arbitrarily complex, parametrized topologies
</TD></TR>
</TABLE>
<P>
<P>
<I><B>Object-oriented concepts</B></I><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Language</B></TD><TD WIDTH=192>C</TD><TD WIDTH=192>C++
</TD></TR>
<TR><TD WIDTH=192><B>Objects</B></TD><TD WIDTH=192>C API functions operating on object-like data structures; 
<P>
no support for inheritance*, polimorphism or the like 
</TD><TD WIDTH=192>full flexibility of C++: inheritance, polimorphism etc; <P>
built-in object-oriented mechanisms
</TD></TR>
</TABLE>
<P>
<P>
* The graphical user interface of OPNET (from version 3.0) contains
an &quot;inheritance mechanism&quot; for models. This is no real
inheritance in the object-oriented sense because it just means
that parameter values can be changed or fixed down, parameters
renamed, merged etc. There is no mention about changing the behaviour
of a module (that is, anything like C++'s virtual functions).
<P>
<I><B>Statistics collection and run-time analysis</B></I><TABLE BORDER=1>
<TR><TD WIDTH=295><B>OPNET</B></TD><TD WIDTH=281><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=295>writing observations to output file; &quot;probes&quot; to select statistics to be collected;
<P>
only off-line analysis (analysis of output files) is supported
</TD><TD WIDTH=281>writing observations to output files (roughly equivalent to OPNET's solution);<P>
run-time processing: basic measures (mean etc); distribution estimation with histograms; quantiles (P<SUP>2</SUP> algorithm);
<P>
support for detecting the end of the transient period and sufficient result accuracy
</TD></TR>
</TABLE>
<P>
<P>
<I><B>Parallel execution</B></I>
<TABLE BORDER=1>
<TR><TD WIDTH=295><B>OPNET</B></TD><TD WIDTH=281><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=295>not supported</TD><TD WIDTH=281>supported over PVM; arbitrary synchronisation can be used
</TD></TR>
</TABLE>
<P>
<P>
<I><B>Openness</B></I><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Input file formats</B></TD><TD WIDTH=192>binary model files*;<BR>
textual parameter files
</TD><TD WIDTH=192>text files</TD></TR>
<TR><TD WIDTH=192><B>Output file formats</B></TD><TD WIDTH=192>binary files**
</TD><TD WIDTH=192>text files</TD></TR>
<TR><TD WIDTH=192><B>Availability of source</B></TD><TD WIDTH=192>not available (only the source of the shipped models is available)
</TD><TD WIDTH=192>avaliable</TD></TR>
<TR><TD WIDTH=192><B>Embedding simulations into other software product</B>
</TD><TD WIDTH=192>not supported and also not possible (the main() function cannot be supplied by the user etc.)
</TD><TD WIDTH=192>supported.
<P>
Embedding application becomes a new &quot;user interface&quot; based on Envir (1); or embedding application replaces Envir (2).
</TD></TR>
</TABLE>
<P>
<P>
* Can be read and analyzed by EMA programs.
<P>
** Can be exported to text files from the main OPNET program.
<HR><H1><A NAME="_Toc443041335">Appendix C: Quick reference for OPNET
users</A></H1>
<P>
This section is intended to help OPNET users learn OMNeT++ faster.
<BR>
<TABLE BORDER=1>
<TR><TD WIDTH=253><B>OPNET</B></TD><TD WIDTH=411><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=253>network, subnetwork, node</TD><TD WIDTH=411>Compound modules
</TD></TR>
<TR><TD WIDTH=253>module, process</TD><TD WIDTH=411>An OMNeT++ simple module corresponds to an OPNET module with its process.
</TD></TR>
<TR><TD WIDTH=253>interrupts, invocations, states</TD><TD WIDTH=411>OMNeT++ works with coroutines, which means a little different way of thinking from OPNET's. In OMNeT++, you write a simple module as you would write an operating system process or a thread, thus there's no need to distinguish 'states' or speak about 'invocations'.
<P>
An OMNeT++ module accepts messages (and simulation time advances) within <TT>receive&#133;(&#133;)</TT> calls; <TT>wait()</TT> is just a <TT>scheduleAt()</TT> followed by a <TT>receive()</TT>.
<P>
An OPNET interrupt is the event being processed. In this sense, OMNeT++ messages returned by <TT>receive()</TT> correspond to OPNET interrupts.
</TD></TR>
<TR><TD WIDTH=253>endsim interrupt</TD><TD WIDTH=411>The <TT>finish()</TT> virtual member functions of the simple modules are called at the end of the simulation run. You can redefine <TT>finish()</TT> to write statistics etc.
</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>
<PRE>
<FONT>op_ima_obj_attr_get(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
foo = par(&quot;foo&quot;);
foo = module-&gt;par(&quot;foo&quot;);</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_ima_sim_attr_get(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>There are no simulation attributes. You can use the parameters of the top-level module instead:<PRE>
<FONT>foo = simulation.systemModule()-&gt;par(&quot;foo&quot;);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_prg_odb_print_minor(&#133;)
</FONT>op_prg_odb_print_major(&#133;)
</PRE>

</TD><TD WIDTH=411><PRE>
ev &lt;&lt; &quot;hello!&quot; &lt;&lt; endl;
ev.printf(&#133;);</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_sim_end(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
simulation.error(&quot;Your fault! error %d&quot;,ec);</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_subq_....()</FONT>
</PRE>

</TD><TD WIDTH=411>Create a queue object and then manipulate it with its member functions.<PRE>
<FONT>cQueue queue;
</FONT>queue.insertHead( msg );
if (!queue.empty())
   msg = queue.getTail();</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>List
</FONT>op_prg_list_...()
</PRE>

</TD><TD WIDTH=411><PRE>
cLinkedList list;
list.insertHead( ptr );
if (!list.empty())
   ptr = list.getTail();</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>Topology
</FONT>op_rte_...()
</PRE>

</TD><TD WIDTH=411>The <TT>cTopology</TT> class offers similar functionality, and you can expect greater speed than with OPNET's routing funtions.
</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>
<PRE>
<FONT>Packet
</FONT>op_pk_create()
op_pk_destroy()</PRE>

</TD><TD WIDTH=411>Use the <TT>cMessage</TT> class.
<PRE>
<FONT>cMessage *msg = new cMessage;
</FONT>delete msg;
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
packet fields
op_pk_nfd_set(&#133;)
op_pk_nfd_get_(&#133;)
op_pk_fd_set(&#133;)
op_pk_fd_get(&#133;)</PRE>

</TD><TD WIDTH=411>Message parameters. A parameter has both name and index.<PRE>
<FONT>msg-&gt;par(&quot;foo&quot;) = foo;
</FONT>msg-&gt;addPar(&quot;new-foo&quot;) = foo;
int foo = msg-&gt;par(&quot;foo&quot;);

int fooindex = msg-&gt;parList().find(&quot;foo&quot;);
msg-&gt;par(fooindex) = foo;</PRE>

</TD></TR>
<TR><TD WIDTH=253>packet field modelled size</TD><TD WIDTH=411>Message parameters do not have associated modelled bit sizes. Message length can be used instead.<PRE>
<FONT>msg-&gt;addPar(&quot;dest_addr&quot;) = dest_addr;
</FONT>msg-&gt;addLength( 32 );
</PRE>

</TD></TR>
<TR><TD WIDTH=253>packet formats</TD><TD WIDTH=411>There are no explicit packet formats in OMNeT++. However, you can write function to create messages with specific fields and length:<PRE>
<FONT>cMessage *createEthernetFrame()
</FONT>{
   cMessage *msg = new cMessage;
   msg-&gt;setKind(PACKET);
   msg-&gt;addPar(&quot;source&quot;);
   msg-&gt;addPar(&quot;destination&quot;);
   msg-&gt;addPar(&quot;protocol&quot;);
   msg-&gt;setLength( 8*16 );
   return msg;
}</PRE>

</TD></TR>
<TR><TD WIDTH=253>packet encapsulation</TD><TD WIDTH=411>As in OPNET, message parameters can be assigned object pointers, thus also message pointers. <P>
However, there is also direct support encapsulation:<PRE>
<FONT>msg-&gt;encapsulate(innermsg)
</FONT>innermsg = msg-&gt;encapsulatedMsg();
innermsg = msg-&gt;decapsulate();</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>ICI</FONT>
</PRE>
</TD>
<TD WIDTH=411>ICIs are also represented by <TT>cMessage</TT> objects, naturally with zero length. 
<P>
If it is important to distinguish between packets and ICIs, you can use the message kind field:<PRE>
<FONT>#define PACKET  0
</FONT>#define ICI     1

cMessage *pk = new cMessage;
pk-&gt;setKind(PACKET);

cMessage *ici = new cMessage;
ici-&gt;setKind(ICI);</PRE>

</TD></TR>
<TR><TD WIDTH=253>ICI formats</TD><TD WIDTH=411>See packet formats.
</TD></TR>
<TR><TD WIDTH=253>ICI attributes</TD><TD WIDTH=411>See packet fields.
</TD></TR>
<TR><TD WIDTH=253>packet and ICI in the same interrupt</TD><TD WIDTH=411>You can use encapsulation. At the sender side:<PRE>
<FONT>cMessage *ici, *pk;
</FONT>ici-&gt;encapsulate(pk);
send(ici,&quot;out-gate&quot;);
</PRE>
<P>
The receiver side:<PRE>
<FONT>ici = receive();
</FONT>pk = ici-&gt;decapsulate();
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_send(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
send( msg, &quot;out-gate&quot;);
send( msg, &quot;gate-vector&quot;, index);
send( msg, gate_id );</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_send_delayed(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
sendDelayed(&#133;)</PRE>
</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_deliver(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
sendDirect(&#133;)</PRE>
</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_schedule_self(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
scheduleAt( simTime()+timeout, msg );</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_ev_cancel(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
cancelEvent( msg );</PRE>
</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_dist_load(&#133;)
</FONT>op_dist_outcome(&#133;)
</PRE>

</TD><TD WIDTH=411>To generate random numbers from analytical distributions, use:<PRE>
<FONT>uniform(&#133;)
</FONT>intuniform(&#133;)
exponential(&#133;)
normal(&#133;)
truncnormal(&#133;)
</PRE>
<P>
For custom distributions you can use the histogram classes. Histograms can load distribution data from file.<PRE>
<FONT>cDoubleHistogram hist;
</FONT>FILE *f = fopen(&quot;distribution.dat&quot;);
hist.loadFromFile( f );
fclose(f);

double rnd = hist.random();</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>output vectors</TD><TD WIDTH=411>The <TT>cOutVector</TT> class can be used.
<PRE>
<FONT>cOutVector eed(&quot;End-to-end delay&quot;);

</FONT>double d = msg-&gt;creationTime() - simTime();
eed.record( d );</PRE>

</TD></TR>
<TR><TD WIDTH=253>output scalars</TD><TD WIDTH=411>Output scalar file exists. You can write into it with <TT>recordScalar()</TT>:
<PRE>
<FONT>recordScalar(&quot;average delay&quot;, avg_delay);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_topo_parent()</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
cModule *parent = parentModule();</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_topo_child_&#133;(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
cSubModuleIterator</PRE>
</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_topo_.._assoc_(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
gate(i)/gate(name), 
gate-&gt;toGate()/fromGate()
gate-&gt;destinationGate()/sourceGate()
gate-&gt;ownerModule()</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pro_create(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>See dynamic module creation. Note that this is a more powerful tool than OPNET's dynamic processes in that you can also create compound modules.
</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>Prohandle</FONT>
</PRE>

</TD><TD WIDTH=411>Module ID. Given the module pointer, you can obtain module ID by<PRE>
<FONT>int id = mod-&gt;id();
</FONT>
</PRE>
<P>
And you can obtain module pointer from the ID:<PRE>
<FONT>cModule *mod = simulation.module(id);
</FONT>
</PRE>
<P>
An invalid ID is negative.
</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pro_invoke(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>Dynamically created modules do not need to be invoked, they live their own life. To dispatch messages to them, you can use <TT>sendDirect(&#133;)</TT>
</TD></TR>
<TR><TD WIDTH=253>
<PRE>
<FONT>op_pro_destroy(&#133;)
</FONT>op_pro_destroy( self )
</PRE>

</TD><TD WIDTH=411><PRE>
deleteModule( module );
deleteModule();</PRE>

</TD></TR>
<TR><TD WIDTH=253>module memory, parent-to-child memory, argument memory to dynamic processes
</TD><TD WIDTH=411>Parent module can set pointers (<TT>void* </TT>data members) in the dynamically created module object any time, thus also right after creating it ( parent-to-child memory), right before sending a packet to it ( argument memory), and the pointer can refer to memory managed by the parent module ( module memory). 
<P>
An example for argument memory. Suppose the child module class has a public data member named <TT>argmem</TT>:
<PRE>
<FONT>class ChildModule : public cSimpleModule {
</FONT>   &#133;
   public:
      void *argmem;
   &#133;
};
</PRE>
<P>
The parent module code would be:<PRE>
<FONT>childmod-&gt;argmem = argument_memory_ptr;
</FONT>sendDirect( msg, childmod, 0.0, &quot;in&quot; );
</PRE>
<P>
Child module code would be:<PRE>
<FONT>msg = receive();
</FONT>argument_memory_ptr = argmem;
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pro_valid(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>Given the module id:<PRE>
<FONT>int valid = (id&gt;=0) &amp;&amp; simulation.exist(id);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>Environment files</TD><TD WIDTH=411>Configuration files. Default is <TT>omnetpp.ini</TT>. Multiple ini files and ini file inclusion are also supported.
</TD></TR>
<TR><TD WIDTH=253>Process Editor</TD><TD WIDTH=411>Your favourite text editor. Or <I>vi</I> :-).
</TD></TR>
<TR><TD WIDTH=253>Network Editor, Node Editor</TD><TD WIDTH=411>Any editor to write NED files.
<P>
GNED. Not very sophisticated yet though.
</TD></TR>
<TR><TD WIDTH=253>Simulation Tool</TD><TD WIDTH=411>Use the <TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc. sections in <TT>omnetpp.ini</TT> do describe several runs with different parameters.
<P>
To create loops on different variables, you can use a shell script that creates a short ini file with the variable parameters, and include that file in <TT>omnetpp.ini</TT>.
</TD></TR>
<TR><TD WIDTH=253>probes, Probe Editor</TD><TD WIDTH=411>From the ini file, you can turn on/off <TT>cOutVector</TT> objects individually as well as assign result collection interval to them.
</TD></TR>
<TR><TD WIDTH=253>Analysis Tool</TD><TD WIDTH=411>Plove</TD></TR>
<TR><TD WIDTH=253>EMA</TD><TD WIDTH=411>Where you would normally use EMA, OMNeT++ NED files with parametrized topology are often enough.
<P>
Otherwise, you have two choices:<P>
a) write a program to generate NED files. Text-processing languages like perl and awk are great tools for that.<P>
b) write the network-building code in C++. You can look at the output of nedc for some idea how to do it.
</TD></TR>
</TABLE>
<HR><H1><A NAME="_Toc443041336">Appendix D: Embedding OMNeT++</A>
</H1>
<H2><A NAME="_Toc443041337">Structure of an OMNeT++ simulation
program</A></H2>
<P>
Consider the following diagram: 
<P>
<CENTER><IMG SRC="img00018.gif"></CENTER>
<P>
A simulation program contains the simulated network (with its
simple and compound modules etc.), SIM, ENVIR and exactly one
of CMDENV, TKENV and TVENV. SIM contains the simulation class
library and the simulation kernel. The model only interacts with
SIM. ENVIR contains code that's common for all user interfaces,
and provides infrastructure like ini file handling for them. <TT>main()</TT>
is also in ENVIR. Specific user interface code is contained in
CMDENV, TKENV and TVENV. The above components are also physically
separated: they are in separate source directories and form separate
library files (<TT>libsim_std.a</TT>, <TT>libenvir.a</TT> etc.)
<P>
The simulation program may contain several linked-in model components:
networks, simple module types, compound module types, channel
types etc. Any network (but only one at a time) can be set up
for simulation which has all necessary components linked in.
<H2><A NAME="_Toc443041338">Embedding</A></H2>
<P>
Embedding is a special issue. You probably do not want to keep
the appearance of the simulation program, so you do not want Cmdenv,
Tkenv or Tvenv. You may or may not want to keep ENVIR.
<P>
What you'll absolutely need for a simulation to run is the SIM
package. You can keep ENVIR if its philosophy and the infrastructure
it provides (<TT>omnetpp.ini</TT>, certain command-line options
etc.) fit into your design. Then the embedding program will take
the place of Cmdenv, Tkenv or Tvenv.
<P>
If  ENVIR does not fit your needs (for example, you want the model
parameters to come from a database not from <TT>omnetpp.ini</TT>),
then you have replace it. Your ENVIR replacement (the embedding
program, practically) must implement the <TT>cEnvir</TT> member
functions from <TT>envir/cenvir.h</TT>, but you have full control
over the simulation.
<P>
Normally, code that sets up a network or builds the internals
of a compound module comes from compiled NED source. You may not
like the restriction that your simulation program can only simulate
networks whose setup code is linked in. No problem; your program
can contain pieces of code like what is generated by nedc and
then it can build any network whose components (primarily the
simple modules) are linked in. It is even possible to write an
integrated environment where you can put together a network using
a graphical editor and right after that you can run it, without
intervening NED compilation and linkage.
<HR><H1><A NAME="_Toc443041339">Appendix E: Internal structure of
the simulation program</A></H1>
<H2><A NAME="_Toc443041340">The simulation kernel</A></H2>
<P>
The source code for the simulation kernel of OMNeT++ and the library
classes reside in the <TT>sim</TT> directory.
<P>
Almost all objects are derived from <TT>cObject</TT> which provides
a common interface for them.
<H3><A NAME="_Toc443041341">The central object: cSimulation simulation</A>
</H3>
<P>
The <TT>cSimulation</TT> class stores a network and manages simulation.
There is only one instance, a global object called <TT>simulation</TT>.
The object has two basic roles:
<UL>
<LI>as a vector of modules
<LI>holds global variables (for example, the message queue).
</UL>
<H3><A NAME="_Toc443041342">Module classes</A></H3>
<P>
Base class for module classes: <TT>cModule</TT>. Two derived classes:
<TT>cCompoundModule</TT>, <TT>cSimpleModule</TT>. User simple
modules are derived from <TT>cSimpleModule</TT>.
<P>
A <TT>cModule</TT> has: array of parameters, array of gates +
member functions to set up and query parameters and gates.
<P>
<TT>cSimpleModule</TT> adds: put-aside queue, list of local objects
+ the virtual function <TT>activity()</TT> + member functions
like <TT>send()</TT>, <TT>receive()</TT> etc.
<P>
Gates are represented by the <TT>cGate</TT> objects. Connections
are not real objects: their attributes (delay, error, datarate)
are managed by the connection's source gate.
<H3><A NAME="_Toc443041343">Global registration lists</A></H3>
<P>
There are global objects holding lists of components available
in an OMNeT++ executable. These lists are:<TABLE BORDER=1>
<TR><TD WIDTH=115>List object</TD><TD WIDTH=174>Macro that creates a member.
<P>
Class of members
</TD><TD WIDTH=372>Function</TD></TR>
<TR><TD WIDTH=115><PRE>
<FONT>cHead 
 networks;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
Define_Network()

cNetworkType</PRE>

</TD><TD WIDTH=372>List of avaliable networks. <P>
A <TT>cNetworkType</TT> object holds a pointer to a function that can build up the network. 
<P>
<TT>Define_Network()</TT> macros occur in the code generated by the NEDC compiler.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 modtypes;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
Define_Simple_Module(),
Define_Simple_Module_Like(), Define_Compound_Module()

cModuleType</PRE>

</TD><TD WIDTH=372>List of available module types.<P>
A <TT>cModuleType</TT> object knows how to create a module of a specific type. If is compound, it holds a pointer to a function that can build up the inside. 
<P>
<TT>Define_Compound_Module()</TT> macros occur in the code generated by the NEDC compiler. <TT>Define_Simple_Module()</TT> macros are written by the user.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 classes;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
Register_Class()

ClassRegister</PRE>

</TD><TD WIDTH=372>List of avaliable classes of which the user can create an instance.<P>
A <TT>cClassRegister</TT> object knows how to create an (empty) object of a specific class.
<P>
The list is used by the <TT>createOne()</TT> function that can create an object of any (registered) type from a string containing the class name. (E.g. <TT>ptr = createOne( &quot;cArray&quot;)</TT> creates an empty array.) <TT>createOne()</TT> is used by the PVM extension.
<P>
<TT>Register_Class()</TT> macros are present in the simulation source files for existing classes; has to be written by the user for new classes.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 functions;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
Define_Function()

cFunctionType</PRE>

</TD><TD WIDTH=372>List of mathematical functions.<P>
A <TT>cFunctionType</TT> object holds a pointer to the function and knows how many arguments it takes.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 linktypes;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
Define_Link()

cLinkType</PRE>
</TD>
<TD WIDTH=372>List of link types.<P>
A <TT>cLinkType</TT> object knows how to create <TT>cPar</TT> objects representing the delay, error and datarate attributes for a channel.
<P>
<TT>Define_Link()</TT> macros occur in the code generated by the NEDC compiler, one for each channel definition.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 locals;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
-

any object</PRE>
</TD><TD WIDTH=372>This is only  'dummy' object, it stands for the current module's local object list
</TD></TR>
<TR><TD WIDTH=115><PRE>
<FONT>cHead
 superhead;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
-

cHead</PRE>
</TD><TD WIDTH=372>List of all other lists.
</TD></TR>
</TABLE>
<H3><A NAME="_Toc443041344">The coroutine package</A></H3>
<P>
The coroutine package is in fact two coroutine packages.
<P>
There is a platform-independent coroutine package that creates
all coroutine stacks inside the main stack. It was taken from
[KOF85].  It allocates stack by deep-deep recursions and then
plays with <TT>setjmp()</TT> and <TT>longjmp()</TT> to switch
from one another. Its drawback is that under 16-bit Intel platforms
(DOS real mode and Win16), stack is limited to 64K which is not
very much.
<P>
The other package allocates stack by<TT> malloc()</TT> and uses
a short assembly code to initialize it for the first use. Then
it also uses <TT>setjmp()</TT> and <TT>longjmp()</TT>. This is
implemented under DOS + BC3.1, and also RISC6000 where the original
<TT>setjmp()</TT> /<TT> longjmp()</TT> behaved in an unfriendly
way and the portable coroutine package could not be used.
<P>
The coroutines are represented by the <TT>cCoroutine</TT> class.
<TT>cSimpleModule</TT> has <TT>cCoroutine</TT> as one a base class.
<H2><A NAME="_Toc443041345">The user interface</A></H2>
<P>
The source code for the user interface of OMNeT++ resides in the
<TT>envir</TT> directory (common part) and its subdirectories
(<TT>cmdenv</TT>, <TT>tvenv</TT>, <TT>xenv</TT>, etc. specific
parts).
<P>
The classes in the user interface are <I>not</I> derived from
<TT>cObject</TT>, they are completely separated form the simulation
kernel.
<H3><A NAME="_Toc443041346">The main() function</A></H3>
<P>
The <TT>main()</TT> function of OMNeT++ simply sets up the user
interface and runs it. Actual simulation is done in <TT>cEnvir::run()
</TT>(see later).
<H3><A NAME="_Toc443041347">The cEnvir interface</A></H3>
<P>
The <TT>cEnvir</TT> class has only one instance, a global object
called <TT>ev</TT>:
<PRE>
<FONT>cEnvir ev;
</FONT>
</PRE>
<P>
<TT>cEnvir</TT> basically is only an interface, its member functions
hardly contain any code. <TT>cEnvir</TT> maintains a pointer to
a dynamically allocated simulation application object (derived
from <TT>TOmnetApp</TT>, see later) which does all actual work.
<P>
<TT>cEnvir</TT> member functions deal with four basic tasks:
<UL>
<LI>I/O for module activities; actual implementation is different
for each user interface (e.g. stdin/stdout for Cmdenv, windowing
in Tvenv and Xenv)
<LI>setting up and running the simulation application
<LI>provides functions called by simulation kernel objects to
get information (for example, get module parameter settings from
the configuration file)
<LI>provides functions called by simulation kernel objects to
notify the user interface of some events. This is especially important
for windowing user interfaces (Tvenv, Xenv), because the events
are like this: an object was deleted so its inspector window should
be closed; a message was sent so it can be displayed; a breakpoint
was hit.
</UL>
<H3><A NAME="_Toc443041348">Implementation of the user interface:
simulation applications</A></H3>
<P>
The base class for simulation application is <TT>TOmnetApp</TT>.
Specific user interfaces such as <TT>TCmdenv</TT>, <TT>TOmnetTVApp</TT>,
<TT>TOmnetXApp</TT> are derived from <TT>TOmnetApp</TT>.
<P>
<TT>TOmnetApp's</TT> member functions are almost all virtual.
<UL>
<LI>Some of them implement the <TT>cEnvir</TT> functions (described
in the previous section)
<LI>Others implement the common part of all user interfaces (for
example: reading options from the configuration files; making
the options effective within the simulation kernel)
<LI>The <TT>run()</TT> function is pure virtual (it is different
for each user interface).
</UL>
<P>
<TT>TOmnetApp</TT>'s data members:
<UL>
<LI>a pointer to the object holding configuration file contents
(type <TT>cInifile</TT>);
<LI>the options and switches that can be set from the configuration
file (these members begin with <TT>opt_</TT>)
</UL>
<P>
Concrete simulation applications:
<UL>
<LI>add new configuration options
<LI>provide a <TT>run()</TT> function
<LI>implement functions left empty in <TT>TOmnetApp</TT> (like
<TT>breakpointHit()</TT>, <TT>objectDeleted()</TT>).
</UL>
<HR><H1><A NAME="_Toc443041349">References</A></H1>
<P>
<I><B>Simulation-related:</B></I>
<P>
[JAIN91] Jain, Raj: <I>The Art of Computer Systems Performance
Analysis</I>. Wiley, New York, 1991.
<P>
[BFS86] Bratley P., Fox, B. L. and Schrage, L. E.: <I>A Guide
to Simulation</I>. Springer-Verlag, New York, 1986.
<P>
[JCH85] Jain, Rain and Chlamtac, Imrich: <I>The P<SUP>2</SUP>
Algorithm for Dynamic Calculation of Quantiles and Histograms
without Storing Observations</I>, Communications of the ACM, 28(10),
1076-1085, 1985.
<P>
[PON91] Pongor, Gy<FONT>&ouml;rgy</FONT>:
<I>OMNET: An Object-Oriented Network Simulator</I>. 1991 ??
<P>
[PON92] Pongor, Gy<FONT>&ouml;rgy</FONT>:
<I>Statistical Synchronisation: A Different Approach of Parallel
Discrete Event Simulation</I>. Lappeenranta University of Technology,
Data Communications Laboratory, Lappeenranta, Finland, 1992
<P>
[PON93] Pongor, Gy<FONT>&ouml;rgy</FONT>:
<I>On the Efficiency of the Statistical Synchronisation Method</I>.
European Simulation Symposium (ESS'93), Delft, The Netherlands,
Oct. 25-28, 1993
<P>
[KOF95] Kofoed, Stig: <I>Portable Multitasking in C++</I>. Dr.
Dobb's Journal, November 1995.  <TT>ftp://ftp.mv.com/pub/ddj/1995/1995.11/mtask.zip</TT>
<P>
<I><B>OMNeT++-related research papers:</B></I>
<P>
[VAR98a] <I>&quot;K-split - On-Line Density Estimation for Simulation
Result Collection&quot;</I>. Andr&aacute;s Varga. To appear in
the Proceedings of the European Simulation Symposium (ESS'98).
October 26-28, 1998. Nottingham, UK.
<P>
[VAR98b] <I>&quot;Parametrized Topologies for Simulation Programs&quot;</I>.
Andr&aacute;s Varga. In the Proceedings of the Western Multiconference
on Simulation (WMC'98) / Communication Networks and Distributed
Systems (CNDS'98). January 11-14, 1998. San Diego, CA.
<P>
[V&amp;F97] <I>&quot;The K-Split Algorithm for the PDF Approximation
of Multi-Dimensional Empirical Distributions without Storing Observations&quot;</I>.
Andr&aacute;s Varga and Babak Fakhamzadeh. In Proceedings of the
9th European Simulation Symposium (ESS'97), pp.94-98. October
19-22 1997, Passau, Germany.
<P>
[V&amp;P97] <I>&quot;Flexible Topology Description Language for
Simulation Programs&quot;</I>. Andr&aacute;s Varga and Gy&ouml;rgy
Pongor. In Proceedings of the 9th European Simulation Symposium
(ESS'97), pp.225-229. October 19-22 1997, Passau, Germany.
<P>
<I><B>Former OMNeT++ documents:</B></I>
<P>
[OMN1] Vass Zolt&aacute;n.: <I>PVM Extension of OMNeT++ to Support
Statistical Synchronisation</I>. Diploma Thesis, Technical University
of Budapest, 1996 (in Hungarian).
<P>
[OMN2] Andr&eacute; Maurits, George van Montfort and Gerard van
de Weerd: <I>OMNeT++ extensions and examples</I>. Technical University
of Budapest, Dept. of Telecommunications, 1995.
<P>
[OMN3] Jan Heijmans, Alex Paalvast, Robert van der Leij: <I>Network
simulation using the JAR compiler for the OMNeT++ simulation system</I>.
Technical University of Budapest, Dept. of Telecommunications,
1995.
<P>
[OMN4] Varga Andr<FONT>&aacute;s</FONT>.:
<I>OMNeT++ - Portable User Interface for the OMNeT++ Simulation
System</I>. Diploma Thesis, Technical University of Budapest,
1994 (in Hungarian).
<P>
[OMN5] Lencse G&aacute;bor: <I>Graphical Network Editor for OMNeT++</I>.
Diploma Thesis, Technical University of Budapest, 1994 (in Hungarian).
<P>
[OMN6] Varga Andr<FONT>&aacute;s</FONT>.:
<I>OMNeT++ - Portable Simulation Environment in C++</I>. TDK work,
Technical University of Budapest, 1992 (in Hungarian).
<P>
<I><B>C++ language</B></I>
<P>
Too many books to list.
<P>
<I><B>Cyg-Win32</B></I>
<P>
[CYGWIN] <TT>http://sourceware.cygnus.com/cygwin/top.html</TT>
<P>
<I><B>DJGPP</B></I>
<P>
[DJGPP1] Official DJGPP Home Page: <TT>http://www.delorie.com/djgpp</TT>
<P>
<I><B>PVM</B></I>
<P>
[PVM1] The Official PVM Home Page. <TT>http://www.epm.ornl.gov/pvm/pvm_home.html</TT>
<P>
[PVM2] <TT>http://www.sp2.uni-c.dk/PVM/PvmIntro.html</TT>
<P>
[PVM3] <TT>http://www.cse.ogi.edu/DISC/projects/mist/related-work/pvm.html</TT>
<P>
<I><B>Turbo Vision</B></I>
<P>
[TV1] <I>Borland C++ 3.1 Manuals</I>. Borland International, 1992.
<P>
[TV2] The TVPlus Archieve. <TT>http://wvnvm.wvnet.edu/~u6ed4/tvhome.htm</TT>
<P>
[TV3] Sierwald, Joern: 32-bit Portable Turbo Vision. <TT>http://wvnvm.wvnet.edu/~u6ed4/tvptsier.htm</TT>
<P>
<I><B>TCL/TK</B></I>
<P>
[TCLTK1] Welch, Brent: <I>Practical Programming in Tcl and Tk</I>.
Prentice-Hall, 1995
<P>
[TCLTK2] HyperTcl. <TT>http://web.cs.ualberta.ca/~wade/HyperTcl/</TT>
<P>
[TCLTK3] TCL WWW Info. <TT>http://www.sco.com/Technology/tcl/Tcl.html</TT>
<P>
<I><B>Gnuplot</B></I>
<P>
[GPLOT1] Brief tutorial:<BR>
<TT>http://nacphy.physics.orst.edu/DATAVIS/datavis.html</TT>
<P>
[GPLOT2] Reference:<BR>
<TT>http://www.cm.cf.ac.uk/Latex/Gnuplot/gnuplot.html</TT>
<P>
[PMTV1] PlotMTV:<BR>
<TT>http://cauchy.math.edu/workshop/Plotmtv/plotmtv.html</TT>
<P>
<I><B>Xmgr</B></I>
<P>
[XMGR1] Brief tutorial:<BR>
<TT>http://nacphy.physics.orst.edu/DATAVIS/xmgr.html<BR>
<BR>
</TT>


</BODY>
</HTML>
