<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE>OMNeT++ - Manual</TITLE>
   <META NAME="Author" CONTENT="Andras Varga">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFE8" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">

<P><FONT COLOR="#FF0000"><B><FONT SIZE=+4>OMNeT++ </FONT></B>
<I><FONT SIZE=+1>Discrete Event Simulation System</FONT></I></FONT></P>

<H1><B>User Manual</B></H1><H1>Topics</H1>
<B><A HREF="#TOC_0">Introduction</A></B><BR>
<B><A HREF="#TOC_6">Overview</A></B><BR>
<B><A HREF="#TOC_22">An example: the NIM game</A></B><BR>
<B><A HREF="#TOC_27">The NED language</A></B><BR>
<B><A HREF="#TOC_61">Simple Modules</A></B><BR>
<B><A HREF="#TOC_91">The Simulation Library</A></B><BR>
<B><A HREF="#TOC_153">Building Simulation Programs</A></B><BR>
<B><A HREF="#TOC_165">Running The Simulation</A></B><BR>
<B><A HREF="#TOC_186">Analyzing simulation results</A></B><BR>
<B><A HREF="#TOC_196">Parallel execution</A></B><BR>
<B><A HREF="#TOC_208">The Design of OMNeT++</A></B><BR>
<B><A HREF="#TOC_222">Appendix A: OPNET and OMNeT++</A></B><BR>
<B><A HREF="#TOC_225">Appendix B: Parsec and OMNeT++</A></B><BR>
<B><A HREF="#TOC_231">Appendix C: NED Language Grammar</A></B><BR>
<B><A HREF="#TOC_232">Appendix D: Class Library Reference</A></B><BR>
<B><A HREF="#TOC_297">References</A></B><BR>
<HR><H1>Detailed Table of Contents</H1>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_0"></A><A HREF="#_Toc473901673">Introduction</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_1"></A><A HREF="#_Toc473901674">What is OMNeT++?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_2"></A><A HREF="#_Toc473901675">Where is OMNeT++ in the world of simulation
tools?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_3"></A><A HREF="#_Toc473901676">Organization of this manual</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_4"></A><A HREF="#_Toc473901677">History</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_5"></A><A HREF="#_Toc473901678">Authors</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_6"></A><A HREF="#_Toc473901679">Overview</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_7"></A><A HREF="#_Toc473901680">Modelling concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_8"></A><A HREF="#_Toc473901681">Hierarchical modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_9"></A><A HREF="#_Toc473901682">Module types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_10"></A><A HREF="#_Toc473901683">Messages, gates, links</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_11"></A><A HREF="#_Toc473901684">Link characteristics</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_12"></A><A HREF="#_Toc473901685">Parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_13"></A><A HREF="#_Toc473901686">Topology description method</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_14"></A><A HREF="#_Toc473901687">Programming the algorithms</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_15"></A><A HREF="#_Toc473901688">Creating simple modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_16"></A><A HREF="#_Toc473901689">Object mechanisms</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_17"></A><A HREF="#_Toc473901690">Derive new classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_18"></A><A HREF="#_Toc473901691">Self-describing objects to ease debugging</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_19"></A><A HREF="#_Toc473901692">Using OMNeT++</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_20"></A><A HREF="#_Toc473901693">Building and running simulations</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_21"></A><A HREF="#_Toc473901694">What is what in the directories</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_22"></A><A HREF="#_Toc473901695">An example: the NIM game</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_23"></A><A HREF="#_Toc473901696">Topology</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_24"></A><A HREF="#_Toc473901697">Simple modules</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_25"></A><A HREF="#_Toc473901698">Running the simulation</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_26"></A><A HREF="#_Toc473901699">Other examples</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_27"></A><A HREF="#_Toc473901700">The NED language</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_28"></A><A HREF="#_Toc473901701">NED overview</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_29"></A><A HREF="#_Toc473901702">Components of a NED description</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_30"></A><A HREF="#_Toc473901703">Reserved words</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_31"></A><A HREF="#_Toc473901704">Case sensitivity</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_32"></A><A HREF="#_Toc473901705">The import statement</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_33"></A><A HREF="#_Toc473901706">Channel definitions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_34"></A><A HREF="#_Toc473901707">Simple module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_35"></A><A HREF="#_Toc473901708">Simple module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_36"></A><A HREF="#_Toc473901709">Simple module gates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_37"></A><A HREF="#_Toc473901710">Compound module definitions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_38"></A><A HREF="#_Toc473901711">Compound module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_39"></A><A HREF="#_Toc473901712">Compound module gates</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_40"></A><A HREF="#_Toc473901713">Submodules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_41"></A><A HREF="#_Toc473901714">Connections</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_42"></A><A HREF="#_Toc473901715">Parameterized compound modules</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_43"></A><A HREF="#_Toc473901716">Examples</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_44"></A><A HREF="#_Toc473901717">Using const with parametrized topologies</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_45"></A><A HREF="#_Toc473901718">Design patterns for compound modules</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_46"></A><A HREF="#_Toc473901719">Topology templates</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_47"></A><A HREF="#_Toc473901720">Network definition</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_48"></A><A HREF="#_Toc473901721">Support for parallel execution</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_49"></A><A HREF="#_Toc473901722">Extensions to the compound module
and system definitions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_50"></A><A HREF="#_Toc473901723">Conditional 'on' sections</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_51"></A><A HREF="#_Toc473901724">Expressions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_52"></A><A HREF="#_Toc473901725">Using parameters in expressions (ref
and ancestor)</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_53"></A><A HREF="#_Toc473901726">Operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_54"></A><A HREF="#_Toc473901727">The sizeof() and index operators</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_55"></A><A HREF="#_Toc473901728">Time constants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_56"></A><A HREF="#_Toc473901729">Random values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_57"></A><A HREF="#_Toc473901730">Input value</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_58"></A><A HREF="#_Toc473901731">Functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_59"></A><A HREF="#_Toc473901732">Display strings</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_60"></A><A HREF="#_Toc473901733">GNED -- Graphical NED Editor</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_61"></A><A HREF="#_Toc473901734">Simple Modules</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_62"></A><A HREF="#_Toc473901735">Simulation concepts</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_63"></A><A HREF="#_Toc473901736">Discrete Event Simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_64"></A><A HREF="#_Toc473901737">The event loop</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_65"></A><A HREF="#_Toc473901738">Simple modules in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_66"></A><A HREF="#_Toc473901739">Events in OMNeT++</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_67"></A><A HREF="#_Toc473901740">FES implementation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_68"></A><A HREF="#_Toc473901741">Defining simple module types</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_69"></A><A HREF="#_Toc473901742">Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_70"></A><A HREF="#_Toc473901743">The module declaration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_71"></A><A HREF="#_Toc473901744">Several modules, single NED interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_72"></A><A HREF="#_Toc473901745">The class declaration</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_73"></A><A HREF="#_Toc473901746">Decomposing activity() or handleEvent()
and inheritance</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_74"></A><A HREF="#_Toc473901747">Adding functionality to cSimpleModule</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_75"></A><A HREF="#_Toc473901748">activity()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_76"></A><A HREF="#_Toc473901749">handleMessage()</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_77"></A><A HREF="#_Toc473901750">initialize() and finish()</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_78"></A><A HREF="#_Toc473901751">Finite State Machines in OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_79"></A><A HREF="#_Toc473901752">Message transmission modeling</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_80"></A><A HREF="#_Toc473901753">Coding conventions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_81"></A><A HREF="#_Toc473901754">Component libraries</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_82"></A><A HREF="#_Toc473901755">Simple module libraries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_83"></A><A HREF="#_Toc473901756">Compound module NED source libraries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_84"></A><A HREF="#_Toc473901757">Precompiled compound module libraries</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_85"></A><A HREF="#_Toc473901758">Some simulation techniques</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_86"></A><A HREF="#_Toc473901759">Modelling computer networks</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_87"></A><A HREF="#_Toc473901760">Modelling multiprocessor systems</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_88"></A><A HREF="#_Toc473901761">Parameter tuning</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_89"></A><A HREF="#_Toc473901762">Multiple experiments within one simulation
run</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_90"></A><A HREF="#_Toc473901763">Dynamic topology optimization</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_91"></A><A HREF="#_Toc473901764">The Simulation Library</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_92"></A><A HREF="#_Toc473901765">Class library conventions</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_93"></A><A HREF="#_Toc473901766">Utilities</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_94"></A><A HREF="#_Toc473901767">Messages and packets</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_95"></A><A HREF="#_Toc473901768">The cMessage class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_96"></A><A HREF="#_Toc473901769">Attaching parameters and objects to
a message</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_97"></A><A HREF="#_Toc473901770">Message encapsulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_98"></A><A HREF="#_Toc473901771">Information about the last sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_99"></A><A HREF="#_Toc473901772">The cPacket class</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_100"></A><A HREF="#_Toc473901773">Subclassing cMessage and cPacket</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_101"></A><A HREF="#_Toc473901774">Sending and receiving messages</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_102"></A><A HREF="#_Toc473901775">Sending messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_103"></A><A HREF="#_Toc473901776">Delayed sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_104"></A><A HREF="#_Toc473901777">Direct message sending</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_105"></A><A HREF="#_Toc473901778">Receiving messages</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_106"></A><A HREF="#_Toc473901779">The wait() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_107"></A><A HREF="#_Toc473901780">Implementing timers</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_108"></A><A HREF="#_Toc473901781">Querying the state of an output gate</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_109"></A><A HREF="#_Toc473901782">Stopping the simulation</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_110"></A><A HREF="#_Toc473901783">Accessing module parameters and gates</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_111"></A><A HREF="#_Toc473901784">Module parameters</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_112"></A><A HREF="#_Toc473901785">Gates and links</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_113"></A><A HREF="#_Toc473901786">Walking the module hierarchy</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_114"></A><A HREF="#_Toc473901787">Dynamic module creation</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_115"></A><A HREF="#_Toc473901788">Routing support: cTopology</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_116"></A><A HREF="#_Toc473901789">Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_117"></A><A HREF="#_Toc473901790">Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_118"></A><A HREF="#_Toc473901791">Shortest paths</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_119"></A><A HREF="#_Toc473901792">Generating random numbers</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_120"></A><A HREF="#_Toc473901793">Using random number generators directly</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_121"></A><A HREF="#_Toc473901794">Random numbers from distributions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_122"></A><A HREF="#_Toc473901795">Random numbers from histograms</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_123"></A><A HREF="#_Toc473901796">Container classes</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_124"></A><A HREF="#_Toc473901797">Queue class: cQueue</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_125"></A><A HREF="#_Toc473901798">Expandable array: cArray</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_126"></A><A HREF="#_Toc473901799">Non-object container classes</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_127"></A><A HREF="#_Toc473901800">The parameter class: cPar</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_128"></A><A HREF="#_Toc473901801">Basic usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_129"></A><A HREF="#_Toc473901802">Random number generation through cPar</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_130"></A><A HREF="#_Toc473901803">Storing object and non-object pointers
in cPar</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_131"></A><A HREF="#_Toc473901804">Reverse Polish expressions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_132"></A><A HREF="#_Toc473901805">Using indirection</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_133"></A><A HREF="#_Toc473901806">Summary</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_134"></A><A HREF="#_Toc473901807">Statistics and distribution estimation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_135"></A><A HREF="#_Toc473901808">cStatistic and descendants</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_136"></A><A HREF="#_Toc473901809">Distribution estimation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_137"></A><A HREF="#_Toc473901810">The k-split algorithm</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_138"></A><A HREF="#_Toc473901811">Transient detection and result accuracy</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_139"></A><A HREF="#_Toc473901812">Recording simulation results</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_140"></A><A HREF="#_Toc473901813">Output vectors: cOutVector</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_141"></A><A HREF="#_Toc473901814">Output scalars</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_142"></A><A HREF="#_Toc473901815">Deriving new classes</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_143"></A><A HREF="#_Toc473901816">Tracing and debugging aids</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_144"></A><A HREF="#_Toc473901817">Displaying information about module
activity</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_145"></A><A HREF="#_Toc473901818">Watches</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_146"></A><A HREF="#_Toc473901819">Snapshots</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_147"></A><A HREF="#_Toc473901820">Breakpoints</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_148"></A><A HREF="#_Toc473901821">Disabling warnings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_149"></A><A HREF="#_Toc473901822">Getting coroutine stack usage</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_150"></A><A HREF="#_Toc473901823">Changing the network graphics at run-time</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_151"></A><A HREF="#_Toc473901824">Tips for speeding up the simulation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_152"></A><A HREF="#_Toc473901825">Using shared objects</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_153"></A><A HREF="#_Toc473901826">Building Simulation Programs</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_154"></A><A HREF="#_Toc473901827">Overview</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_155"></A><A HREF="#_Toc473901828">Using Unix and gcc</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_156"></A><A HREF="#_Toc473901829">Installation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_157"></A><A HREF="#_Toc473901830">Producing a makefile with the makemake
script</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_158"></A><A HREF="#_Toc473901831">Multi-directory models</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_159"></A><A HREF="#_Toc473901832">Static vs shared OMNeT++ system libraries</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_160"></A><A HREF="#_Toc473901833">Using Win32 with Borland C++ 5.0</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_161"></A><A HREF="#_Toc473901834">Compiling the libraries and nedc</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_162"></A><A HREF="#_Toc473901835">Setting up a project file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_163"></A><A HREF="#_Toc473901836">Starting from scratch</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_164"></A><A HREF="#_Toc473901837">Using Win32 with MSVC</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_165"></A><A HREF="#_Toc473901838">Running The Simulation</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_166"></A><A HREF="#_Toc473901839">Command line switches</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_167"></A><A HREF="#_Toc473901840">The configuration file</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_168"></A><A HREF="#_Toc473901841">Sections and entries</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_169"></A><A HREF="#_Toc473901842">Splitting up the configuration file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_170"></A><A HREF="#_Toc473901843">Module parameters in the configuration
file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_171"></A><A HREF="#_Toc473901844">Configuring output vectors</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_172"></A><A HREF="#_Toc473901845">Module parameter logging</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_173"></A><A HREF="#_Toc473901846">Display strings</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_174"></A><A HREF="#_Toc473901847">Specifying seed values</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_175"></A><A HREF="#_Toc473901848">List of all ini file options</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_176"></A><A HREF="#_Toc473901849">Choosing good seed values: the seedtool
utility</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_177"></A><A HREF="#_Toc473901850">Repeating or iterating simulation
runs</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_178"></A><A HREF="#_Toc473901851">User interfaces of simulation executables</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_179"></A><A HREF="#_Toc473901852">Cmdenv: the command-line user interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_180"></A><A HREF="#_Toc473901853">Tkenv: graphical user interface on
Unix/NT</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_181"></A><A HREF="#_Toc473901854">In Memoriam&#133;</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_182"></A><A HREF="#_Toc473901855">Typical problems</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_183"></A><A HREF="#_Toc473901856">Stack problems</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_184"></A><A HREF="#_Toc473901857">Memory allocation problems</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_185"></A><A HREF="#_Toc473901858">Execution speed</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_186"></A><A HREF="#_Toc473901859">Analyzing simulation results</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_187"></A><A HREF="#_Toc473901860">Plotting output vectors with Plove</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_188"></A><A HREF="#_Toc473901861">Plove features</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_189"></A><A HREF="#_Toc473901862">Usage</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_190"></A><A HREF="#_Toc473901863">Writing filters</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_191"></A><A HREF="#_Toc473901864">Format of output vector files</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_192"></A><A HREF="#_Toc473901865">Working without Plove</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_193"></A><A HREF="#_Toc473901866">Extracting vectors from the file</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_194"></A><A HREF="#_Toc473901867">Using splitvec</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_195"></A><A HREF="#_Toc473901868">Visualization under Unix</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_196"></A><A HREF="#_Toc473901869">Parallel execution</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_197"></A><A HREF="#_Toc473901870">Support for parallel execution</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_198"></A><A HREF="#_Toc473901871">Overview</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_199"></A><A HREF="#_Toc473901872">Syncpoints</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_200"></A><A HREF="#_Toc473901873">The PVM virtual machine</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_201"></A><A HREF="#_Toc473901874">Mapping logical machines to physical
ones</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_202"></A><A HREF="#_Toc473901875">Configuration of the slaves</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_203"></A><A HREF="#_Toc473901876">Configuration and running</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_204"></A><A HREF="#_Toc473901877">If there are problems...</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_205"></A><A HREF="#_Toc473901878">Statistical synchronisation</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_206"></A><A HREF="#_Toc473901879">The description of the Statistical
Synchronisation Method (SSM)</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_207"></A><A HREF="#_Toc473901880">Using SSM in OMNeT++</A><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_208"></A><A HREF="#_Toc473901881">The Design of OMNeT++</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_209"></A><A HREF="#_Toc473901882">Structure of an OMNeT++ executable</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_210"></A><A HREF="#_Toc473901883">Embedding OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_211"></A><A HREF="#_Toc473901884">The simulation kernel</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_212"></A><A HREF="#_Toc473901885">The central object: cSimulation simulation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_213"></A><A HREF="#_Toc473901886">Module classes</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_214"></A><A HREF="#_Toc473901887">Global registration lists</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_215"></A><A HREF="#_Toc473901888">The coroutine package</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_216"></A><A HREF="#_Toc473901889">Object ownership/contains relationships</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_217"></A><A HREF="#_Toc473901890">The user interface</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_218"></A><A HREF="#_Toc473901891">The main() function</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_219"></A><A HREF="#_Toc473901892">The cEnvir interface</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_220"></A><A HREF="#_Toc473901893">Implementation of the user interface:
simulation applications</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_221"></A><A HREF="#_Toc473901894">Writing inspectors for TkEnv</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_222"></A><A HREF="#_Toc473901895">Appendix A: OPNET and OMNeT++</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_223"></A><A HREF="#_Toc473901896">Comparison of OPNET and OMNeT++</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_224"></A><A HREF="#_Toc473901897">Quick reference for OPNET users</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_225"></A><A HREF="#_Toc473901898">Appendix B: Parsec and OMNeT++</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_226"></A><A HREF="#_Toc473901899">What is PARSEC?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_227"></A><A HREF="#_Toc473901900">What is inside the Parsec package?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_228"></A><A HREF="#_Toc473901901">Parsec vs. the OMNeT++ simulation
kernel</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_229"></A><A HREF="#_Toc473901902">Feature summary</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_230"></A><A HREF="#_Toc473901903">Correspondence between Parsec and
OMNeT++</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_231"></A><A HREF="#_Toc473901904">Appendix C: NED Language Grammar</A></B></FONT><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_232"></A><A HREF="#_Toc473901905">Appendix D: Class Library Reference</A></B></FONT><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_233"></A><A HREF="#_Toc473901906">What is documented here?</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_234"></A><A HREF="#_Toc473901907">Constants, types, simple functions</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_235"></A><A HREF="#_Toc473901908">Constants, types</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_236"></A><A HREF="#_Toc473901909">Function typedefs</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_237"></A><A HREF="#_Toc473901910">Simulation time conversion functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_238"></A><A HREF="#_Toc473901911">Value-added string functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_239"></A><A HREF="#_Toc473901912">Basic random number generation</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_240"></A><A HREF="#_Toc473901913">Random numbers from different distributions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_241"></A><A HREF="#_Toc473901914">Miscellaneous</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_242"></A><A HREF="#_Toc473901915">String class</A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_243"></A><A HREF="#_Toc473901916">Declaration/registration macros</A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_244"></A><A HREF="#_Toc473901917">Common properties for all classes:
<TT><FONT SIZE=5>cObject</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_245"></A><A HREF="#_Toc473901918">class <TT><FONT SIZE=4>cObject</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_246"></A><A HREF="#_Toc473901919">Module classes: <TT><FONT SIZE=5>cModule</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cCompoundModule</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cSimpleModule</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_247"></A><A HREF="#_Toc473901920">class <TT><FONT SIZE=4>cModule</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_248"></A><A HREF="#_Toc473901921">class <TT><FONT SIZE=4>cCompoundModule</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_249"></A><A HREF="#_Toc473901922">class <TT><FONT SIZE=4>cSimpleModule</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_250"></A><A HREF="#_Toc473901923">Message classes: <TT><FONT SIZE=5>cMessage
</FONT></TT><FONT SIZE=5>and</FONT><TT><FONT SIZE=5> cPacket</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_251"></A><A HREF="#_Toc473901924">Message base class: <TT><FONT SIZE=4>cMessage</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_252"></A><A HREF="#_Toc473901925">Network packet class: <TT><FONT SIZE=4>cPacket</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_253"></A><A HREF="#_Toc473901926">Module gate class: <TT><FONT SIZE=5>cGate</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_254"></A><A HREF="#_Toc473901927">class <TT><FONT SIZE=4>cGate</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_255"></A><A HREF="#_Toc473901928">Value holding class: <TT><FONT SIZE=5>cPar</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_256"></A><A HREF="#_Toc473901929">class <TT><FONT SIZE=4>cPar</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_257"></A><A HREF="#_Toc473901930">Overloaded arithmetic operators for
<TT><FONT SIZE=4>cPar</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_258"></A><A HREF="#_Toc473901931">struct <TT><FONT SIZE=4>sXElem</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_259"></A><A HREF="#_Toc473901932">Object container classes: <TT><FONT SIZE=5>cArray</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cQueue</FONT></TT><FONT SIZE=5>, </FONT><TT><FONT SIZE=5>cHead</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_260"></A><A HREF="#_Toc473901933">class <TT><FONT SIZE=4>cArray</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_261"></A><A HREF="#_Toc473901934">class <TT><FONT SIZE=4>cQueue</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_262"></A><A HREF="#_Toc473901935">class <TT><FONT SIZE=4>cQueueIterator</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_263"></A><A HREF="#_Toc473901936">Inline functions</A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_264"></A><A HREF="#_Toc473901937">class <TT><FONT SIZE=4>cHead</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_265"></A><A HREF="#_Toc473901938">struct <TT><FONT SIZE=4>cIterator</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_266"></A><A HREF="#_Toc473901939">Non-object container classes: <TT><FONT SIZE=5>cLinkedList</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cBag</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_267"></A><A HREF="#_Toc473901940">class <TT><FONT SIZE=4>cLinkedList</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_268"></A><A HREF="#_Toc473901941">class <TT><FONT SIZE=4>cLinkedListIterator</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_269"></A><A HREF="#_Toc473901942">class <TT><FONT SIZE=4>cBag</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_270"></A><A HREF="#_Toc473901943">Class <TT><FONT SIZE=4>cWatch</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_271"></A><A HREF="#_Toc473901944">Output vector class: <TT><FONT SIZE=5>cOutVector</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_272"></A><A HREF="#_Toc473901945">class <TT><FONT SIZE=4>cOutVect</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_273"></A><A HREF="#_Toc473901946">class <TT><FONT SIZE=4>cOutFileMgr</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_274"></A><A HREF="#_Toc473901947">Statistical data collection: <TT><FONT SIZE=5>cStatistic</FONT></TT><FONT SIZE=5>
and derived classes</FONT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_275"></A><A HREF="#_Toc473901948">class <TT><FONT SIZE=4>cStatistic</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_276"></A><A HREF="#_Toc473901949">class <TT><FONT SIZE=4>cStdDev</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_277"></A><A HREF="#_Toc473901950">class <TT><FONT SIZE=4>cWeightedStdDev</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_278"></A><A HREF="#_Toc473901951">class <TT><FONT SIZE=4>cDensityEstBase</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_279"></A><A HREF="#_Toc473901952">Class <TT><FONT SIZE=4>cHistogramBase</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_280"></A><A HREF="#_Toc473901953">Class <TT><FONT SIZE=4>cVarHistogram</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_281"></A><A HREF="#_Toc473901954">Class <TT><FONT SIZE=4>cEqdHistogramBase</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_282"></A><A HREF="#_Toc473901955">class <TT><FONT SIZE=4>cLongHistogram</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_283"></A><A HREF="#_Toc473901956">class <TT><FONT SIZE=4>cDoubleHistogram</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_284"></A><A HREF="#_Toc473901957">The P<SUP>2</SUP> and k-split algorithms:
<TT><FONT SIZE=5>cPSquare, cKSplit</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_285"></A><A HREF="#_Toc473901958">class <TT><FONT SIZE=4>cPSquare</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_286"></A><A HREF="#_Toc473901959">class <TT><FONT SIZE=4>cKSplit</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_287"></A><A HREF="#_Toc473901960">Transient and result accuracy detection</A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_288"></A><A HREF="#_Toc473901961">class <TT><FONT SIZE=4>cTransientDetection</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_289"></A><A HREF="#_Toc473901962">class <TT><FONT SIZE=4>cTDExpandingWindows</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_290"></A><A HREF="#_Toc473901963">class <TT><FONT SIZE=4>cAccuracyDetection</FONT></TT></A><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_291"></A><A HREF="#_Toc473901964">class <TT><FONT SIZE=4>cADByStddev</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_292"></A><A HREF="#_Toc473901965">Finite State Machine: <TT><FONT SIZE=5>cFSM</FONT></TT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_293"></A><A HREF="#_Toc473901966">Routing support: <TT><FONT SIZE=5>cTopology</FONT></TT></A></B><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_294"></A><A HREF="#_Toc473901967">The user interface: <TT><FONT SIZE=5>cEnvir</FONT></TT><FONT SIZE=5>
and </FONT><TT><FONT SIZE=5>ev</FONT></TT></A></B><BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_295"></A><A HREF="#_Toc473901968">class <TT><FONT SIZE=4>cEnvir</FONT></TT></A><BR>
<B>&nbsp;&nbsp;&nbsp;&nbsp;<A NAME="TOC_296"></A><A HREF="#_Toc473901969">Classes not described in this reference</A></B><BR>
<BR><FONT SIZE=+1><B>&nbsp;&nbsp;<A NAME="TOC_297"></A><A HREF="#_Toc473901970">References</A></B></FONT><BR>
<HR><H1><A NAME="_Toc473901673">Introduction</A></H1>
<H2><A NAME="_Toc473901674">What is OMNeT++?</A></H2>
<P>
OMNeT++ is an object-oriented modular discrete event simulator.
The name itself stands for Objective Modular Network Testbed in
C++. OMNeT++ has its distant roots in OMNeT, a simulator written
in Object Pascal by dr. Gy&ouml;rgy Pongor.
<P>
The simulator can be used for modelling:
<UL>
<LI>communication protocols
<LI>computer networks and traffic modelling
<LI>multi-processor and distributed systems
<LI>administrative systems
<LI>... and any other system where the discrete event approach
is suitable.
</UL>
<P>
An OMNeT++ model consists of hierarchically nested modules. The
depth of module nesting is not limited, which allows the user
to reflect the logical structure of the actual system in the model
structure. Modules communicate with message passing. Messages
can contain arbitrarily complex data structures. Modules can send
messages either directly to their destination or along a predefined
path, through gates and connections.
<P>
Modules can have parameters which are used for three main purposes:
to customize module behaviour; to create flexible model topologies
(where parameters can specify the number of modules, connection
structure etc); and for module communication, as shared variables.
<P>
Modules at the lowest level of the module hierarchy are to be
provided by the user, and they contain the algorithms in the model.
During simulation execution, simple modules appear to run in parallel,
since they are implemented as coroutines (sometimes termed lightweight
processes). To write simple modules, the user does not need to
learn a new programming language, but he/she is assumed to have
some knowledge of C++ programming.
<P>
OMNeT++ simulations can feature different user interfaces for
different purposes: debugging, demonstation and batch execution.
Advanced user interfaces make the inside of the model visible
to the user, allow him/her to start/stop simulation execution
and to intervene by changing variables/objects inside the model.
This is very important in the development/debugging setPhase of
the simulation project. User interfaces also facilitate demonstration
of how a model works.
<P>
Since it was written in C++, the simulator is basically portable;
it should run on most platforms with a C++ compiler. OMNeT++'s
advanced user interfaces support X-window, DOS and are portable
to Win3.1/Win95/WinNT.
<P>
OMNeT++ has been extended to execute the simulation in parallel.
Any kind of synchronisation mechanism can be used. One suitable
synchnonization mechanism is the statistical synchronisation,
for which OMNeT++ provides explicit support.
<P>
OMNeT++ Home Page on the Web: 
<P>
<TT>http://www.hit.bme.hu/phd/vargaa/omnetpp.htm</TT>
<H2><A NAME="_Toc473901675">Where is OMNeT++ in the world of simulation
tools?</A></H2>
<P>
There are numerous network simulation tools on the market today,
both commercial and non-commercial. In this section I will try
to give an overview by picking some of the most important or most
representative ones in both categories and comparing them to OMNeT++:
Parsec, SMURPH, NS, Ptolemy, NetSim++, C++SIM, CLASS as non-commercial,
and OPNET, COMNET III as commercial tools. (The OMNeT++ Home Page
contains a list of Web sites with collections of references to
network simulation tools where the reader can get a more complete
list.) In the commercial category, OPNET is widely held to be
the state of the art in network simulation. OMNeT++ is targeted
at roughly the same segment of network simulation as OPNET.&nbsp;
<P>
Seven issues are examined to get an overview about the network
simulation tools:
<P>
<B>Detail Level</B>. <I>Does the simulation tool have the necessary
power to express details in the model?</I> In other words, can
the user implement arbitrary new building blocks like in OMNeT++
or he is confined to the predefined blocks implemented by the
supplier? Some tools like COMNET III are not programmable by the
user to this extent therefore they cannot be compared to OMNeT++.
Specialized network simulation tools like NS (for IP) and CLASS
(for ATM) also rather fall into this category. 
<P>
<B>Available Models.</B> <I>What protocol models are readily available
for the simulation tool?</I> On this point, non-commercial simulation
tools cannot compete with some commercial ones (especially OPNET)
which have a large selection of ready-made protocol models. OMNeT++
is no exception. 
<P>
<B>Defining Network Topology</B>. <I>How does the simulation tool
support defining the network topology?</I> Is it possible to create
some form of hierarchy (nesting) or only &quot;flat&quot; topologies
are supported? Network simulation tools naturally share the property
that a model (network) consists of &quot;nodes&quot; (blocks,
entities, modules, etc.) connected by &quot;links&quot; (channels,
connections, etc.). Many commercial simulators have graphical
editors to define the network; however, this is only a good solution
if there is an alternative form of topology description (e.g.
text file) which allows one to generate the topology by program.
OPNET follows a unique way: the network topology is stored in
a proprietary binary file format which can be generated (and read)
by the graphical editor and C programs linked against a special
library. On the other hand, most non-commercial simulation tools
do not provide explicit support for topology description: one
must program a &quot;driver entity&quot; which will boot the model
by creating the necessary nodes and interconnecting them (Parsec,
SMURPH, NS). Finally, a large part of the tools that do support
explicit topology description supports only flat topologies (CLASS).
OMNeT++ probably uses the most flexible method: it has a human-readable
textual topology description format (the NED language) which is
easy to create with any text-processing tool (perl, awk, etc.),
and the same format is used by the graphical editor. It is also
possible to create a &quot;driver entity&quot; to build a network
at run-time by program. OMNeT++ also supports submodule nesting.
<P>
<B>Programming Model.</B> <I>What is the programming model supported
by the simulation environment?</I> Network simulators typically
use either thread/coroutine-based programming (such as activity()
in OMNeT++), or FSMs built upon a handleMessage()-like function.
For example, OPNET, SMURPH and NetSim++ use FSMs (with underlying
handleMessage()), Parsec and C++SIM use threads. OMNeT++ supports
both programming models; the author does not know of another simulation
tool that does so. 
<P>
<B>Debugging and Tracing Support.</B> <I>What debugging or tracing
facilities does the simulation tool offer?</I> Simulation programs
are infamous for long debugging periods. C++-based simulation
tools rarely offer much more than printf()-style debugging; often
the simulation kernel is also capable of dumping selected debug
information on the standard output. Animation is also often supported,
either off-line (record&amp;playback) or in some client-server
architecture, where the simulation program is the &quot;server&quot;
and it can be viewed using the &quot;client&quot;. Off-line animation
naturally lacks interactivity and is therefore little use in debugging.
The client-server solution typically has limited power because
the simulation and the viewer run as independent operating system
processes, and the viewer has limited access to the simulation
program's internals and/or it does not have enough control over
the course of simulation execution. OPNET has a very good support
for command-line debugging and provides both off-line and client-server
style animation. NetSim++ and Ptolemy use the client-server method
of animation. OMNeT++ goes a different way by linking the GUI
library with the debugging/tracing capability into the simulation
executable. This architecture enables the GUI to be very powerful:
every user-created object is visible (and modifiable) in the GUI
via inspector windows and the user has tight control over the
execution. To the author's best knowledge, the tracing feature
OMNeT++ provides is unique among the C++-based simulation tools.
<P>
<B>Performance.</B> <I>What performance can be expected from the
simulation?</I> Simulation programs typically run for several
hours. Probably the most important factor is the programming language;
almost all network simulation tools are C/C++-based. Performance
is a particularly interesting issue with OMNeT++ since the GUI
debugging/tracing support involves some extra overhead in the
simulation library. However, in a reported case, an OMNeT++ simulation
was only 1.3 slower than its counterpart implemented in plain
C (i.e. one containing very little administration overhead), which
is a very good showing. A similar result was reported in a performance
comparison with a Parsec simulation. 
<P>
<B>Source Availability.</B> <I>Is the simulation library available
in source?</I> This is a trivial question but it immediately becomes
important if one wants to examine or teach the internal workings
of a simulation kernel, or one runs into trouble because some
function in the simulation library has a bug and/or it is not
documented well enough. In general it can be said that non-commercial
tools (like OMNeT++) are open-source and commercial ones are not.
This is also true for OPNET: the source for simulation kernel
is not available (although the ready-made protocol models come
with sources).
<P>
In conclusion, it can be said that OMNeT++ has enough features
to make it a good alternative to most network simulation tools,
and it has a strong potential to become one of the most widely
used network simulation packages in academic and research environments.
The most serious shortcoming is the lack of available protocol
models, but since this is mostly due to the fact that it is a
relatively new simulation tool, with the help of the OMNeT++ user
community the situation is likely to become much better in the
future.
<H2><A NAME="_Toc473901676">Organization of this manual</A></H2>
<P>
The manual is organized around the following topics:
<UL>
<LI>The chapters 1, 2 and 3 contain introductory material: some
overview and an example simulation.
<LI>The second group of chapters, 4, 5 and 6 are the programming
guide. They present the NED language, the simulation concepts
and their implementation in OMNeT++, explain how to write simple
modules and describe the class library.
<LI>The following chapters, 7, 8 and 9 deal with practical issues
like building and running simulations and analyzing results, and
present the tools OMNeT++ has to support these tasks.
<LI>Chapter 10 is devoted to the support for distributed execution.
<LI>Finally, Chapter 11 explains the architecture and the internals
of OMNeT++. This chapter will be useful to those who want to extend
the capabilities of the simulator or want to embed it into a larger
application.
<LI>The first two Appendices contain a comparison of OMNeT++ and
two other important and well-known simulation tools, OPNET and
PARSEC.
<LI>Further Appendices provide reference of the NED language and
the simulation library.
</UL>
<H2><A NAME="_Toc473901677">History</A></H2>
<P>
TBD
<H2><A NAME="_Toc473901678">Authors</A></H2>
<P>
OMNeT++ has been developed mostly by Andr<FONT>&aacute;s
Varga at the </FONT>Technical University of Budapest, Department
of Telecommunications (BME-HIT). Here's a list of the people who
have or had anything to do with OMNeT++:
<P>
Author and maintainer of the code:
<P>
 Andr<FONT>&aacute;</FONT>s Varga  BME-HIT
: andras@metechnology.com, andras@whale.hit.bme.hu
<P>
Advisor/contributor:
<P>
 Gy<FONT>&ouml;</FONT>rgy Pongor BME-HIT
: pongor@hit.bme.hu
<P>
Co-author (old NED compiler), until 1993:
<P>
 <FONT>&Aacute;k</FONT>os Kun  BME
<P>
JAR compiler (now called NEDC), sample simulations; summer 1995:
<P>
 Jan Heijmans  TU Delft
<P>
 Alex Paalvast  TU Delft
<P>
 Robert van der Leij TU Delft
<P>
New feaures, testing, new examples; fall 1995:
<P>
 Maurits Andr<FONT>&eacute;</FONT> 
TU Delft, M.J.A.Andre@twi.tudelft.nl
<P>
 George van Montfort TU Delft, G.P.R.vanMontfort@twi.tudelft.nl
<P>
 Gerard van de Weerd TU Delft, G.vandeweerd@twi.tudelft.nl
<P>
JAR (NEDC) support for distributed execution; also current user:
<P>
 G<FONT>&aacute;bor Lencse  BME</FONT>-HIT
: lencse@hit.bme.hu
<P>
PVM support (as final project), spring 1996:
<P>
 Zolt<FONT>&aacute;n Vass  BME</FONT>-HIT
<P>
P<SUP>2</SUP>, k-split algorithms and more, from fall 1996:
<P>
 Babak Fakhamzadeh TU Delft
<P>
We have to mention Dr. Leon Rothkranz from the Technical University
of Delft whose work made it possible for the Delft students to
come to Budapest in 1995. 
<P>
The starting point of this manual was the 1995 report of Jan Heijmans,
Alex Paalvast and Robert van der Leij.
<HR><H1><A NAME="_Toc473901679">Overview</A></H1>
<H2><A NAME="_Toc473901680">Modelling concepts</A></H2>
<P>
OMNeT++ provides efficient tools for the user to describe the
structure of the actual system. Some of the main features are:
<UL>
<LI>hierarchically nested modules 
<LI>modules are instances of module types 
<LI>modules communicate with messages through channels 
<LI>flexible module parameters 
<LI>topology description language 
</UL>
<H3><A NAME="_Toc473901681">Hierarchical modules</A></H3>
<P>
An OMNeT++ model consists of hierarchically nested modules which
communicate with messages. OMNeT++ models are often referred to
as <I>networks</I>. The top level module is the <I>system module</I>.
The system module contains <I>submodules</I>, which can also contain
submodules themselves (Fig.2.1). The depth of module nesting is
not limited; this allows the user to reflect the logical structure
of the actual system in the model structure.
<P>
<CENTER><IMG SRC="img00002.gif"><BR>
Fig.2.1. Simple and compound modules.</CENTER>
<P>
Modules that contain submodules are termed <I>compound modules</I>,
as opposed <I>simple modules</I> which are at the lowest level
of the module hierarchy. Simple modules contain the algorithms
in the model. The user implements the simple modules in C++, using
the OMNeT++ simulation class library.
<H3><A NAME="_Toc473901682">Module types</A></H3>
<P>
Both simple and compound modules are instances of <I>module types</I>.
While describing the model, the user defines module types; instances
of these module types serve as components for more complex module
types. Finally, the user creates the system module as an instance
of a previously defined module type; all modules of the network
are instantiated as submodules and sub-submodules of the system
module.
<P>
When a module type is used as a building block, there is no distinction
whether it is a simple or a compound module. This allows the user
to split a simple module into several simple modules embedded
into a compound module, or vica versa, aggregate the functionality
of a compound module into a single simple module, without affecting
existing users of the module type.
<P>
Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create <I>component libraries</I>. This feature
will be discussed later, in chapter 8.
<H3><A NAME="_Toc473901683">Messages, gates, links</A></H3>
<P>
Modules communicate by exchanging <I>messages</I>. In an actual
simulation, messages can represent frames or packets in a computer
network, jobs or customers in a queueing network or other types
of mobile entities. Messages can contain arbitrarily complex data
structures. Simple modules can send messages either directly to
their destination or along a predefined path, through gates and
connections.
<P>
The &quot;local simulation time&quot; of a module advances when
the module receives a message. The message can arrive from another
module or from the same module (<I>self-messages</I> are used
to implement timers).
<P>
<I>Gates</I> are the input and output interfaces of modules; messages
are sent out through output gates and arrive through input gates.
<P>
Each<I> connection</I> (also called <I>link</I>) is created within
a single level of the module hierarchy: within a compound module,
one can connect the corresponding gates of two submodules, or
a gate of one submodule and a gate of the compound module (Fig.2.2).
<P>
<CENTER><IMG SRC="img00003.gif"><BR>
Fig.2.2. Connections</CENTER>
<P>
Due to the hierarchical structure of the model, messages typically
travel through a series of connections, to start and arrive in
simple modules. Such series of connections that go from simple
module to simple module are called <I>routes</I>. Compound modules
act as 'cardboard boxes' in the model, transparently relaying
messages between their inside and their outside world.
<H3><A NAME="_Toc473901684">Link characteristics</A></H3>
<P>
Connections can be assigned three parameters which facilitate
the modelling of communication networks, but can be useful for
other models too:
<UL>
<LI>propagation delay (sec)
<LI>bit error rate (errors/bit)
<LI>data rate (bits/sec)
</UL>
<P>
Each of these parameters are optional.<A NAME="a"> One can specify
link parameters individually for each connection, or define link
types (also called <I>channel</I> <I>types</I>) once and use them
throughout the whole model.</A>
<P>
The <I>propagation delay</I> is the amount of time the arrival
of the message is delayed by when it travels through the channel.
Propagation delay is specified in seconds.
<P>
The <I>bit error rate</I> has influence on the transmission of
messages through the channel. The bit error rate is the probability
that a bit is incorrectly transmitted. Thus, the probability that
a message of <I>n</I> bits length is transferred correctly is:
<BR>
<P>
P(<I> sent message received properly </I>) = (1 - <I>ber</I>)<I><SUP>n</SUP></I>
<P>
where <I>ber</I> = bit error rate and <I>n</I> = number of bits
in message.<BR>
<P>
The message has an error flag which is set in case of transmission
errors.
<P>
The <I>data rate</I> is specified in bits/second, and it is used
for transmission delay calculation. The sending time of the message
normally corresponds to the transmission of the first bit, and
the arrival time of the message corresponds to the reception of
the last bit:
<P>
<CENTER><IMG SRC="img00004.gif"><BR>
Fig.2.3. Message transmission</CENTER>
<P>
The above model is not applicable for modelling some protocols
like Token Ring and FDDI where the stations repeat the bits of
a frame that arrives on the ring immediately, without waiting
for the whole frame to arrive; in other words, frames &quot;flow
through&quot; the stations, being delayed only a few bits. If
you want to model such networks, the data rate modelling feature
of OMNeT++ cannot be used.
<P>
If a message travels along a route, through successive links and
compound modules, the model behaves as if each module waited until
the last bit of the message arrives and only start its transmission
then:
<P>
<CENTER><IMG SRC="img00005.gif"><BR>
Fig.2.4. Message sending over multiple channels</CENTER>
<P>
Since the above effect is usually not the desired one, typically
you will want to assign data rate to only one connection in the
route.
<H3><A NAME="_Toc473901685">Parameters</A></H3>
<P>
Modules can have parameters. Parameters are used for three purposes:
<OL>
<LI>to parametrize module topology 
<LI>to customize simple module behaviour 
<LI>for module communication, as shared variables 
</OL>
<P>
Parameters can take string, numeric or pointer values; numeric
values include expressions using other parameters and calling
C functions, random variables from different distributions, and
values input interactively by the user.
<P>
Numeric-valued parameters can be used to construct topologies
in a flexible way. Within a compound module, parameters can define
the number of submodules, number of gates, and the way the internal
connections are made.
<P>
Compound modules can pass parameters or expressions of parameters
to their submodules. Parameter passing can be done by value or
by reference. 
<P>
During simulation execution, if a module changes the value of
a parameter taken by reference, the changed value propagates to
other modules. This effect can be used to tune the model or as
a second means of module communication. Pointer-valued parameters
can be used to implement shared memory.
<H3><A NAME="_Toc473901686">Topology description method</A></H3>
<P>
The user defines the structure of the model in NED language descriptions
(NEtwork Description).The NED language will be discussed in detail
in Chapter 4.
<H2><A NAME="_Toc473901687">Programming the algorithms</A></H2>
<P>
The simple modules of a model contain the algorithms as C++ functions.
The full flexibility and power of the programming language can
be used, supported by the OMNeT++ simulation class library.
<P>
OMNeT++ supports a process-style description method for describing
activites. During simulation execution, simple module functions
appear to run in parallel, because they are implemented as coroutines
(also termed lightweight processes). Coroutines were chosen because
they allow an intuitive description of the algorithm and they
can also serve as a good basis for implementing other description
methods like state-transition diagrams or Petri nets.
<P>
OMNeT++ has a consistent object-oriented design. One can freely
use OOP concepts (inheritance, polimorphism etc) to extend the
functionality of the simulator.
<P>
Elements of the simulation (messages, modules, queues etc.) are
represented as objects. These classes are part of the simulation
class library:
<UL>
<LI>modules, gates, connections etc. 
<LI>parameters 
<LI>messages 
<LI>container classes (e.g. queue, array) 
<LI>data collection classes 
<LI>statistic and distribution estimation classes (histograms,
P<SUP>2</SUP> algorithm for calculating quantiles etc.) 
<LI>transient detection and result accuracy detection classes
</UL>
<P>
The objects are designed so that they can efficiently work together,
creating a powerful framework for simulation programming.
<H3><A NAME="_Toc473901688">Creating simple modules</A></H3>
<P>
Each simple module type is implemented with a C++ class. Simple
module classes are derived from a simple module base class, by
redefining the virtual function that contains the algorithm. The
user can add other member functions to the class to split up a
complex algorithm; he can also add data members to the class.
<P>
It is also possible to derive new simple module classes from exisiting
ones. For example, if one wants to experiment with retransmission
timeout schemes in a transport protocol, he can implemement the
protocol in one class, create a virtual function for the retransmission
algorithm and then derive a family of classes that implement concrete
schemes. This concept is further supported by the fact that in
the network description, actual module types can be parameters.
<H3><A NAME="_Toc473901689">Object mechanisms</A></H3>
<P>
The use of smart container classes allows the user to build <I>aggregate
data structures</I>. For example, one can add any number of objects
to a message object as parameters. Since the added objects can
contain further objects, complex data structures can be built.
<P>
There is an efficient <I>ownership</I> mechanism built in. The
user can specify an owner for each object; then, the owner object
will have the responsibility of destroying that object. Most of
the time, the ownership mechanism works transparently; ownership
only needs to be explicitly managed when the user wants to do
something non-typical.
<P>
The <I>forEach</I> mechanism allows one to enumerate the objects
inside a container object in a uniform way and do some operation
on them. This feature which makes it possible to handle many objects
together. (The forEach feature is extensively used by the user
interfaces with debugging capability and the snapshot mechanism;
see later.)
<H3><A NAME="_Toc473901690">Derive new classes</A></H3>
<P>
It most cases, the functionality offered by the OMNeT++ classes
is enough for the user. But if it is needed, one can derive new
classes from the exisiting ones or create entirely new classes.
For flexibility, several member functions are declared virtual.
When the user creates new classes, certain rules need to be kept
so that the object can fully work together with other objects.
<H3><A NAME="_Toc473901691">Self-describing objects to ease debugging</A>
</H3>
<P>
The class library is designed so that objects can give textual
information about themselves. This makes it possible to peek into
a running simulation program: through an appropriate user interface,
one can examine (and modify) the internal data structures of a
running simulation. This feature helps the user to get some insight
what is happening inside the model and get hands-on experience.
<P>
A unique feature called <I>snapshot</I> allows the user to dump
the contents of the simulation model or a part of it into a text
file. The file will contain textual reports about every object;
this can be of invaluable help at times of debugging. Ordinary
variables can also be made to appear in the snapshot file. Snapshot
creations can scheduled from within the simulation program or
done from the user interface.
<H2><A NAME="_Toc473901692">Using OMNeT++</A></H2>
<H3><A NAME="_Toc473901693">Building and running simulations</A>
</H3>
<P>
This section gives some idea how to work with OMNeT++ in practice:
issues like model files, compiling and running simulations are
discussed.
<P>
An OMNeT++ model consists of the following parts:
<UL>
<LI>NED language topology description(s) which describe the module
structure with parameters, gates etc. They are files with <TT>.ned</TT>
suffix. NED files can be written with any text editor or using
the GNED graphical editor.
<LI>Simple modules sources. They are C++ files, with <TT>.h/.cc</TT>
suffix.
</UL>
<P>
The simulation system provides the following components:
<UL>
<LI>Simulation kernel. This contains the code that manages the
simulation and the simulation class library. It is written in
C++, compiled and put together to form a library (a file with
<TT>.a</TT> or <TT>.lib</TT> extension)
<LI>User interfaces. OMNeT++ user interfaces are used with simulation
execution, to facilitate debugging, demonstration, or batch execution
of simulations. There are several user interfaces, written in
C++, compiled and put together into libraries (<TT>.a</TT> or
<TT>.lib</TT> files).
</UL>
<P>
Simulation programs are built from the above components. First,
the NED files are compiled into C++ source code, using the NEDC
compiler which is part of OMNeT++. Then all C++ sources are compiled
and linked with the simulation kernel and a user interface to
form a simulation executable.
<P>
<B>Running the simulation and analyzing the results</B>
<P>
The simulation executable is a standalone program; thus, it can
be run on other machines without OMNeT++ or the model files being
present. When the program is started, it reads in a configuration
file (usually called <TT>omnetpp.ini</TT>); it contains settings
that control how the simulation is run, values for model parameters,
etc. The configuration file can also prescribe several simulation
runs; in the simplest case, they will be executed by the simulation
program one after another.
<P>
The output of the simulation is written into data files: output
vector files, output scalar files, and possibly the user's own
output files. OMNeT++ provides a GUI tool named Plove to view
and plot the contents of output vector files. But it is not expected
that someone will process the result files using OMNeT++ alone:
output files are text files in a format which (maybe after some
preprocessing using sed, awk or perl) can be read into math packages
like Matlab or its free equivalent Octave, or imported into spreadsheets
like Excel. All these external programs have rich functionality
for statistical analysis and visualization, and OMNeT++ does not
try to duplicate their efforts. This manual briefly describes
some data plotting programs and how to use them with OMNeT++.
<P>
<B>User interfaces</B>
<P>
The primary purpose of user interfaces is to make the inside of
the model visible to the user, to start/stop simulation execution,
and possibly allow the user intervene by changing variables/objects
inside the model. This is very important in the development/debugging
setPhase of the simulation project. Just as important, a hands-on
experience allows the user to get a 'feel' about the model's behaviour.
A nice graphical user interface can also be used to demonstrate
how the model works internally.
<P>
The same simulation model can be executed with different user
interfaces, without any change in the model files themselves.
The user would test and debug the simulation with a powerful graphical
user interface, and finally run it with a simple and fast user
interface that supports batch execution.
<P>
<B>Component libraries</B>
<P>
Module types can be stored in files separately from the place
of their actual usage. This means that the user can group existing
module types and create component libraries.
<P>
<B>Universal standalone simulation programs</B>
<P>
A simulation executable can store several independent models that
use the same set of simple modules. The user can specify in the
configuration file which model he/she wants to run. This allows
one to build one large executable that contains several simulation
models, and distribute it as a standalone simulation tool. The
flexibility of the topology description language also supports
this approach.
<H3><A NAME="_Toc473901694">What is what in the directories</A>
</H3>
<P>
To help you navigate among files in the OMNeT++ distribution,
here's a list what you can find in the different directories.
<P>
The <TT>omnetpp</TT> directory contains the following subdirectories.
<P>
The simulation system itself:
<PRE>
<B><FONT>omnetpp/              </FONT></B><FONT>OMNeT++ root directory
</FONT><B>   bin/               </B>soft links to executables in src/
<B>   lib/               </B>soft links to sim. library files in src/
<B>   doc/               </B>manuals (Word6, HTML), readmes, license etc.
<B>   src/
       nedc/          </B>system description compiler
<B>       sim/           </B>simulation kernel
<B>            std/      </B>files for non-distributed execution
<B>            pvm/      </B>files for distributed execution over PVM
<B>       envir/         </B>common code for user interfaces
<B>       cmdenv/        </B>command-line user interface
<B>       tkenv/         </B>Tcl/Tk-based user interface
<B>       gned/          </B>graphical NED editor
<B>       plove/         </B>output vector analyzer and plotting tool
<B>       utils/         </B>makefile-autocreator etc
</PRE>
<P>
Sample simulations are within the <TT>samples</TT> directory.
Each of the sample directories contain a network description (.<TT>ned</TT>
file) and corresponding simple module code (<TT>.h</TT>, <TT>.cc</TT>
files). Makefiles are included. The <TT>contrib</TT> directory
contains material from the OMNeT++ community.
<PRE>
<B><FONT>omnetpp/
</FONT>   samples/           </B>directories for sample simulations
<B>       nim/           </B>a simple two-player game
<B>       hcube/         </B>hypercube network with deflection routing
<B>       token/         </B>Token-Ring network
<B>       fddi/          </B>an accurate FDDI MAC simulation
<B>       hist/          </B>demo of the histogram classes
<B>       dyna/          </B>dynamic module creation (client-server network)
<B>       pvmex/         </B>demonstrates distributed execution
<B>       fifo1/         </B>single-server queue
<B>       fifo2/         </B>another implementation of a single-server queue
       <B>demo/          </B>several sim. models in a single executable <SUP>(NEW)
</SUP><B>   contrib/           </B>directory for contributed material
<B>       octave/        </B>Octave scripts for result processing
<B>       emacs/         </B>NED syntax highlight for Emacs
</PRE>
<HR><H1><A NAME="_Toc473901695">An example: the NIM game</A></H1>
<P>
This chapter contains a full example program that can give you
some basic idea of using the simulator. An enhanced version of
the NIM example can be found among the sample programs and is
documented in the Examples Manual.
<P>
Nim is an ancient game with two players and a bunch of sticks.
The players take turns, removing 1, 2, 3 or 4 sticks from the
heap of sticks at each turn. The one who takes the last stick
is the loser. 
<P>
Of course, building a model of the Nim game is not much of a simulation
project, but it nicely demonstrates the modelling approach used
by OMNeT++.
<P>
Describing the model consists of two phases: 
<UL>
<LI>topology description 
<LI>defining the operation of components 
</UL>
<H2><A NAME="_Toc473901696">Topology</A></H2>
<P>
The game can be modelled in OMNeT++ as a network with three modules:
the &quot;game&quot; (a manager module) and two players. The modules
will communicate by exchanging messages. The &quot;game&quot;
module keeps the current number of tokens and organizes the game;
in each turn, the player modules receives the number of tokens
from the Game module and sends back its move.
<P>
<CENTER><IMG SRC="img00006.gif"><BR>
Fig. 3.1. Module structure for the Nim game</CENTER>
<P>
<TT>Player1</TT>, <TT>Player2</TT> and <TT>Game</TT> are simple
modules (e.g. they have no submodules.) Each module is an instance
of a module type. We'll need a module type to represent the <TT>Game</TT>
module; let's call it <TT>Game</TT> too. 
<P>
We can implement two kinds of players: <TT>SmartPlayer</TT>, which
knows the winning algorithm, and  <TT>SimplePlayer</TT>, which
simply takes a random number of sticks. In our example, <TT>Player1</TT>
will be a <TT>SmartPlayer</TT> and  <TT>Player2</TT> will be a
<TT>SimplePlayer</TT> .
<P>
The enclosing module, <TT>Nim</TT> is a compound module (it has
submodules). It is also defined as a module type of which one
instance is created, the system module.
<P>
Modules have input and output gates (the tiny boxes labelled <TT>in</TT>,
<TT>out</TT>, <TT>from_player1</TT>, etc. in the figure). An input
and an output gate can be connected: connections (or links) are
shown as in the figure as arrows. During the simulation, modules
communicate by sending messages through the connections.
<P>
The user defines the topology of the network in NED files.
<P>
We placed the model description in two files; the first file defines
the simple module types and the second one the system module.
<P>
The first file (NED keywords are typed in boldface):
<PRE>
<FONT>//---------------------------------------------------------
</FONT>// file: nim_mod.ned
//       Simple modules in nim.ned
//---------------------------------------------------------

// Declaration of simple module type Game.
<B>simple</B> Game
    <B>parameters</B>:
        num_sticks,         // initial number of sticks 
        first_move;         // 1=Player1, 2=Player2
    <B>gates</B>:
        <B>in</B>:  from_player1,  // input and output gates
             from_player2;  // for connecting to Player1/Player2
        <B>out</B>: to_player1,   
             to_player2;
<B>endsimple


</B>// Now the declarations of the two simple module types.
// Any one of the two types can be Player1 or Player2.

// A player that makes random moves
<B>simple</B> SimplePlayer
    <B>gates</B>:
        <B>in</B>: in;         // gates for connecting to Game
        <B>out</B>: out;
<B>endsimple

</B>// A player who knows the winning algorithm
<B>simple</B> SmartPlayer
    <B>gates</B>:
        <B>in</B>: in;         // gates for connecting to Game
        <B>out</B>: out;
<B>endsimple
</B>
</PRE>
<P>
The second file:
<PRE>
<FONT>//-------------------------------------------------------------
</FONT>// file: nim.ned
//       Nim compound module + system module
//-------------------------------------------------------------

<B>import</B> &quot;nim_mod&quot;;

<B>module</B> Nim
    <B>submodules</B>:
        game: Game
            <B>parameters</B>:
                num_sticks = intuniform(21, 31),
                first_move = intuniform(1, 2);
        player1: SmartPlayer;
        player2: SimplePlayer;
    <B>connections</B>:
        player1.out --&gt; game.from_player1,
        player1.in  &lt;-- game.to_player1,

        player2.out --&gt; game.from_player2,
        player2.in  &lt;-- game.to_player2;
<B>endmodule

</B>// system module creation
<B>network</B> 
    nim: Nim
<B>endnetwork
</B>
</PRE>
<H2><A NAME="_Toc473901697">Simple modules</A></H2>
<P>
The module types <TT>SmartPlayer</TT>, <TT>SimplePlayer</TT> and
<TT>Game</TT> are implemented in C++, using the OMNeT++ library
classes and functions. 
<P>
Each simple module type is derived from the C++ class <TT>cSimpleModule</TT>,
with its <TT>activity()</TT> member function redefined. The <TT>activity()</TT>
functions of all simple modules in the network are executed as
coroutines, so they appear as if they were running in parallel.
Messages are instances of the class <TT>cMessage</TT>.
<P>
We present here the C++ sources of the <TT>SmartPlayer</TT> and
<TT>Game</TT> module types.
<P>
The <TT>SmartPlayer</TT> first introduces himself by sendings
its name to the <TT>Game</TT> module. Then it enters an infinite
loop; with each iteration, it receives a message from <TT>Game</TT>
with the number of sticks left, it calculates its move and sends
back a message containing the move. 
<P>
Here's the source:
<PRE>
<FONT>#include &lt;stdio.h&gt;
</FONT>#include &lt;string.h&gt;
#include &lt;time.h&gt;

#include &quot;omnetpp.h&quot;

// derive SmartPlayer from cSimpleModule
class SmartPlayer : public cSimpleModule
{
    Module_Class_Members( SmartPlayer, cSimpleModule, 8192)
       // this is a macro; it expands to constructor definition etc.
       // 8192 is the size for the coroutine stack (in bytes)
                        
    virtual void activity(); 
       // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( SmartPlayer );


// define operations of SmartPlayer
void SmartPlayer::activity()
{
    int move;

    // initialization phase: send module type to Game module
    // create a message with the name &quot;SmartPlayer&quot; and send it to Game

    cMessage *msg = new cMessage(&quot;SmartPlayer&quot;);
    send(msg, &quot;out&quot;);

    // infinite loop to process moves; 
    //     simulation will be terminated by Game
    for (;;)
    {
        // messages have several fields; here, we'll use the message
        // kind member to store the number of sticks
        cMessage *msgin = receive();   // receive message from Game
        int num_sticks = msgin-&gt;kind();// extract message kind (an int)
                                       // this hold the number of sticks
                                       //  still on the stack  
        delete msgin;                  // dispose of the message

        move = (num_sticks + 4) % 5;   // calculate move
        if (move == 0)                 // we cannot take zero
             move = 1;                 // seems like we going to lose

        ev &lt;&lt; &quot;Taking &quot; &lt;&lt; move        // some debug output. The ev
           &lt;&lt; &quot; out of &quot; &lt;&lt; num_sticks // object represents the user
           &lt;&lt; &quot; sticks.\n&quot;;            // interface of the simulator

        cMessage *msgout = new cMessage; // create empty message
        msgout-&gt;setKind( move );         // use message kind as storage
                                         // for move
        send( msgout, &quot;out&quot;);            // send the message to Game
    }
}
</PRE>
<P>
The <TT>Game</TT> module first waits for a message from both players
and extracts the message names that are also the players' names.
Then it enters a loop, with the <TT>player_to_move</TT> variable
alternating between 1 and 2. With each iteration, it sends out
a message with the current number of sticks to the corresponding
player and gets back the number of sticks taken by that player.
When the sticks are out, the module announces the winner and ends
the simulation.
<P>
The source:
<PRE>
<FONT>//-------------------------------------------------------------
</FONT>// file: game.cc
//        (part of NIM - an OMNeT++ demo simulation)
//-------------------------------------------------------------

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;omnetpp.h&quot;

// derive Game from cSimpleModule
class Game : public cSimpleModule
{
     Module_Class_Members(Game,cSimpleModule,8192)
       // this is a macro; it expands to constructor definition etc.
       // 8192 is the size for the coroutine stack (in bytes)

     virtual void activity();
       // this redefined virtual function holds the algorithm
};

// register the simple module class to OMNeT++
Define_Module( Game );

// operation of Game:
void Game::activity()
{
	// strings to store player names; player[0] is unused
	char player[3][32];

	// read parameter values
	int num_sticks = par(&quot;num_sticks&quot;);
	int player_to_move = par(&quot;first_move&quot;);

	// waiting for players to tell their names
	for (int i=0; i&lt;2; i++)
	{
		cMessage *msg = receive();
		if (msg-&gt;arrivedOn(&quot;from_player1&quot;))
			strcpy( player[1], msg-&gt;name());
		else
			strcpy( player[2], msg-&gt;name());
		delete msg;
	}

	// ev represents the user interface of the simulator
	ev &lt;&lt; &quot;Let the game begin!\n&quot;;
	ev &lt;&lt; &quot;Player 1: &quot; &lt;&lt; player[1] &lt;&lt; &quot;   Player 2: &quot; &lt;&lt; player[2]
	   &lt;&lt; &quot;\n\n&quot;;

	do
	{
		ev &lt;&lt; &quot;Sticks left: &quot; &lt;&lt; num_sticks &lt;&lt; &quot;\n&quot;;
		ev &lt;&lt; &quot;Player &quot; &lt;&lt; player_to_move &lt;&lt; &quot; (&quot;
		   &lt;&lt; player[player_to_move] &lt;&lt; &quot;) to move.\n&quot;;

		cMessage *msg = new cMessage(&quot;&quot;, num_sticks);
				    // num_sticks will be the msg kind
		if (player_to_move == 1)
			send(msg, &quot;to_player1&quot;);
		else
			send(msg, &quot;to_player2&quot;);

		msg = receive();
		int sticks_taken = msg-&gt;kind();
		delete msg;

		num_sticks -= sticks_taken;

		ev &lt;&lt; &quot;Player &quot; &lt;&lt; player_to_move &lt;&lt; &quot; (&quot;
		   &lt;&lt; player[player_to_move] &lt;&lt; &quot;) took &quot;
		   &lt;&lt; sticks_taken &lt;&lt; &quot; stick(s).\n&quot;;

		player_to_move = 3 - player_to_move;
	}
	while (num_sticks&gt;0);

	ev &lt;&lt; &quot;\nPlayer &quot; &lt;&lt; player_to_move &lt;&lt; &quot; (&quot;
	   &lt;&lt; player[player_to_move] &lt;&lt; &quot;) won!\n&quot;;

	endSimulation();
}
</PRE>
<H2><A NAME="_Toc473901698">Running the simulation</A></H2>
<P>
Once the source files are ready, one needs to compile and link
them into a simulation executable. One can specify the user interface
to be linked.
<P>
Before running the simulation, one can put parameter values and
all sorts of other settings into an initialization file that will
be read when the simulation program starts:
<PRE>
<FONT>;---------------------
</FONT>; file: omnetpp.ini
;---------------------
[General]
network = nim
random-seed = 3
ini-warnings = false

[Cmdenv]
module-messages = yes
verbose-simulation = no<BR>
</PRE>
<P>
Suppose we link the NIM simulation with the command line user
interface. We get the executable  <TT>nim</TT> (<TT>nim.exe</TT>
under Windows). When we run it, we'll get the following screen
output:
<PRE>
<FONT>% <I>./nim</I></FONT>
</PRE>
<P>
Or:
<PRE>
<FONT>C:\OMNETPP\SAMPLES\NIM&gt; <I>nim.exe

</I></FONT>OMNeT++ Discrete Simulation, TUB Dept. of Telecommunications, 1990-97

Preparing for Run #1...
Setting up network `nim'...
Running simulation...
Let the game begin!
Player 1: SmartPlayer   Player 2: SimplePlayer

Sticks left: 29
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 2 out of 29 sticks.
Player 2 (SimplePlayer) took 2 stick(s).
Sticks left: 27
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 1 out of 27 sticks.
Player 1 (SmartPlayer) took 1 stick(s).
Sticks left: 26
[...]
Sticks left: 5
Player 1 (SmartPlayer) to move.
SmartPlayer is taking 4 out of 5 sticks.
Player 1 (SmartPlayer) took 4 stick(s).
Sticks left: 1
Player 2 (SimplePlayer) to move.
SimplePlayer is taking 1 out of 1 sticks.
Player 2 (SimplePlayer) took 1 stick(s).

Player 1 (SmartPlayer) won!
&lt;!&gt; Module nim.game: Simulation stopped with endSimulation().

End run of OMNeT++
</PRE>
<H2><A NAME="_Toc473901699">Other examples</A></H2>
<P>
An enhanced version of the NIM example can be found among the
sample programs and is documented in the Examples Manual. It adds
a third, interactive player and derives specific player types
from a <TT>Player</TT> abstract class. It also adds the possibity
that actual types for <TT>player1</TT> and <TT>player2</TT> can
be specified in the ini file or interactively entered by the user
at the beginning of the simulation.
<P>
Nim does not show very much of how complex algorithms like communication
protocols can be implemented in OMNeT++. To have an idea about
that, look at the Token Ring example. It is also extensively commented,
though you may need to peep into the user manual to fully understand
it.
<P>
Other programs in the example manual are Dyna and FDDI. Dyna models
a simple client-server network and demonstrates dynamic module
creation. The FDDI example is an accurate FDDI MAC simulation
which was written on the basis of the ANSI standard.
<P>
The following table summarizes the sample simulations:<TABLE BORDER=1>
<TR><TD WIDTH=91><B>NAME</B></TD><TD WIDTH=210><B>TOPIC</B></TD>
<TD WIDTH=354><B>DEMONSTRATES</B></TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>nim</FONT></B>
</PRE>

</TD><TD WIDTH=210>a simple two-player game</TD><TD WIDTH=354>module inheritance<P>
module type as parameter
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>hcube</FONT></B>
</PRE>

</TD><TD WIDTH=210>hypercube network with deflection routing</TD>
<TD WIDTH=354>hypercube topology with dimension as parameter<P>
topology templates<P>
output vectors
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>token</FONT></B>
</PRE>

</TD><TD WIDTH=210>Token Ring network</TD><TD WIDTH=354>ring topology with the number of nodes as parameter<P>
using <TT>cQueue</TT>
<P>
<TT>wait()</TT> and the putaside-queue
<P>
output vectors
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>fifo1</FONT></B>
</PRE>

</TD><TD WIDTH=210>single-server queue</TD><TD WIDTH=354>simple module inheritance<P>
decomposing <TT>activity()</TT> into several functions
<P>
using simple statistics and output vectors<P>
printing stack usage info to help optimize memory consumption<P>
using <TT>finish()</TT>
</TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>fifo2</FONT></B>
</PRE>

</TD><TD WIDTH=210>another fifo implementation</TD><TD WIDTH=354>using <TT>handleMessage()</TT>
<P>
decomposing <TT>handleMessage()</TT> into several functions
<P>
the FSM macros<P>
simple module inheritance<P>
using simple statistics and output vectors<P>
using <TT>finish()</TT>
</TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>fddi</FONT></B>
</PRE>

</TD><TD WIDTH=210>FDDI MAC simulation</TD><TD WIDTH=354>using statistics classes<P>
and many other features
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>hist</FONT></B>
</PRE>

</TD><TD WIDTH=210>demo of the histogram classes</TD><TD WIDTH=354>collecting observations into statistics objects<P>
saving statistics objects to file and restoring them<P>
using the <TT>inspect.lst</TT> file in Tkenv
</TD></TR>
<TR><TD WIDTH=91>
<PRE>
<B><FONT>dyna</FONT></B>
</PRE>

</TD><TD WIDTH=210>a client-server network</TD><TD WIDTH=354>dynamic module creation<P>
using <TT>WATCH()</TT>
<P>
star topology with the number of modules as parameters
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>pvmex</FONT></B>
</PRE>

</TD><TD WIDTH=210>distributed execution</TD><TD WIDTH=354>distributed execution
</TD></TR>
<TR><TD WIDTH=91><PRE>
<B><FONT>demo<B><SUP>(NEW)</SUP></B></FONT></B>
</PRE>

</TD><TD WIDTH=210>tour of OMNeT++ samples</TD><TD WIDTH=354>shows how to link several sim. models into one executable
</TD></TR>
</TABLE>
<P>
<HR><H1><A NAME="_Toc473901700">The NED language</A></H1>
<H2><A NAME="_Toc473901701">NED overview</A></H2>
<P>
The description of model topology is given in the NED language.
The NED language supports modular description of a network. This
means that a network description consists of a number of component
descriptions (channels, simple/compound module types). The channels,
simple modules and compound modules of one network description
can be used in another network description. As a consequence,
the NED language makes it possible for the user to build his own
libraries of network descriptions.
<P>
Files containing network descriptions generally have a <TT>.ned</TT>
suffix. Network descriptions are not used directly: they are translated
into C++ code by the NEDC compiler, then compiled by the C++ compiler
and linked into the simulation executable.
<P>
The EBNF description of the language can be found in the appendix.
<H3><A NAME="_Toc473901702">Components of a NED description</A>
</H3>
<P>
A NED description can contain the following components, in arbitrary
number or order:
<UL>
<LI>import statements
<LI>channel definitions
<LI>simple and compound module declarations
<LI>system module declarations
</UL>
<P>
The rest of this chapter discusses each of these types in detail.
<H3><A NAME="_Toc473901703">Reserved words</A></H3>
<P>
The writer of the network description has to take care that no
reserved words are used for names. The reserved words of the NED
language are:
<PRE>
<FONT>import include channel endchannel simple endsimple module endmodule error delay datarate const parameters gates submodules connections gatesizes on if machines for do endfor network endnetwork nocheck ref ancestor true false like not and or input numeric string bool char </FONT>
</PRE>
<H3><A NAME="_Toc473901704">Case sensitivity</A></H3>
<P>
The network description and all identifiers in it are case sensitive.
<H2><A NAME="_Toc473901705">The import statement</A></H2>
<P>
Example:
<PRE>
<B><FONT>import</FONT></B><FONT> &quot;tkn_mod&quot;, &quot;tkn2_mod&quot;;
<BR>
</FONT>
</PRE>
<P>
The <TT>import</TT> statement (the word <TT>include</TT> can also
be used with identical meaning) is used to import declarations
from other network description files. After importing a network
description, one can use the components (channels, simple/compound
module types) defined in it.
<P>
From the imported files, only the declaration information is used,
but <I>no C++ code is generated</I>. The consequence is that one
has to compile and link each network description, not only the
top-level ones.
<P>
The user can specify the name of the files with or without the<TT>
.ned</TT> extension. One can also include a path in the filenames,
or better, use the NEDC compiler's <TT>-I &lt;path&gt;</TT> command-line
option to name the directories where the imported files reside.
<H2><A NAME="_Toc473901706">Channel definitions</A></H2>
<P>
A channel definition specifies a connection type of given characteristics.
The channel name can be used later in the NED description to create
connections with these parameters.
<P>
Example:
<PRE>
<B><FONT>channel</FONT></B><FONT> DialUpConnection
</FONT>	<B>delay</B><FONT> normal (0.004, 0.0018)
	<B>error</B> 0.00001
	<B>datarate</B> 14400
<B>endchannel
</B></FONT>
</PRE>
<P>
Any of the <TT>delay</TT>, <TT>error</TT> and <TT>datarate</TT>
parameters are optional and they can appear in any order. The
values are NED expressions. This means that they can be constants
(integer or real), random values from various distributions, etc.
<H2><A NAME="_Toc473901707">Simple module definitions</A></H2>
<P>
Simple modules are the basic building blocks for other (compound)
modules. A simple module is defined by declaring its parameters
and gates.
<P>
Example:
<PRE>
<B><FONT>simple</FONT></B><FONT> SomeNameForModule
</FONT>	<B>parameters</B><FONT>:
</FONT>		//...
	<B>gates</B>:
		//...
<B>endsimple
</B>
</PRE>
<H3><A NAME="_Toc473901708">Simple module parameters</A></H3>
<P>
Parameters are variables that belong to a module. Simple module
parameters can be queried and used by simple module algorithms.
For example, a parameter called <TT>num_of_messages</TT> can be
used by a module called <TT>MsgSource</TT> to determine how many
messages it has to generate.
<P>
Parameters are declared by listing their names in the <TT>parameters:</TT>
section of a module description. The parameter type can optionally
be specified as <TT>numeric</TT>, <TT>numeric</TT> <TT>const</TT>
(or simply <TT>const</TT>), <TT>bool</TT>, <TT>string</TT>, or
<TT>anytype</TT>:
<P>
Example:
<PRE>
<B><FONT>simple</FONT></B><FONT> MsgSource
</FONT>	<B>parameters</B><FONT>:
</FONT>		interarrival_time, 
           num_of_messages : <B>const,
</B>           address : <B>string</B>;
	<B>gates</B>: //...
<B>endsimple
</B>
</PRE>
<P>
If the parameter type is omitted, <TT>numeric</TT> is assumed.
Practically, this means that you only need to explicitly specify
the type for string, bool or char-valued parameters.
<P>
Note that the actual parameter values are given later, when the
module is used as a building block of a compound module type or
as a system module.
<P>
When the user writes the word <TT>const</TT> before the parameter,
it is converted to constant; that is, the parameter's value is
replaced by its evaluation. This can be important when the original
value was a random number or an expression. One is advised to
write out the <TT>const</TT> keyword for each parameter that should
be constant.
<P>
Beware when using <TT>const</TT> and by-reference parameter passing
(<TT>ref</TT> modifier, see later) at the same time. Converting
the parameter to constant can affect other modules and cause errors
that are difficult to discover.
<H3><A NAME="_Toc473901709">Simple module gates</A></H3>
<P>
Gates are the connection points of modules. The starting and ending
points of the connections between modules are gates. OMNeT++ supports
simplex (one-directional) connections, so there are two kinds
of gates: input and output. Messages are sent through output gates
and received through input gates. 
<P>
Gates are identified with their names. Gate vectors are supported:
a gate vector contains a number of single gates.
<P>
Gates are declared by listing their names in the <TT>gates:</TT>
section of a module description. An empty bracket pair <TT>[]</TT>
denotes a gate vector. Elements of the vector are numbered from
zero.
<P>
Examples:
<PRE>
<B><FONT>simple</FONT></B><FONT> DataLink
</FONT>	<B>parameters</B><FONT>: //..
	<B>gates</B>:
		<B>in</B>:	from_port, from_higher_layer;
		<B>out</B>:	to_port, to_higher_layer;
<B>endsimple

</B></FONT><B>simple</B> RoutingModule
	<B>parameters</B>: //...
	<B>gates</B>:
		<B>in</B>:	output[];
		<B>out</B>:	input[];
<B>endsimple
</B>
</PRE>
<P>
The sizes of gate vectors are given later, when the module is
used as a building block of a compound module type. Thus, every
instance of the module can have gate vectors of different sizes.
<H2><A NAME="_Toc473901710">Compound module definitions</A></H2>
<P>
Compound modules are modules that are composed of one or more
submodules. Compound modules, like a simple modules, can have
parameters and gates, so a compound module definition looks similar
to a simple module definition, except that it also has sections
to specify the submodules and connections within the module.
<P>
Submodules can either be simple or compound modules, they are
equivalent.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> SomeNameForCompoundModule
</FONT>	<B>parameters</B><FONT>:
</FONT>		//...
	<B>gates</B>:
		//...
	<B>submodules</B>:
		//...
	<B>connections</B>:
		//...
<B>endmodule
</B>
</PRE>
<P>
Any of the above sections (parameters, gates, submodules, connections)
is optional.
<H3><A NAME="_Toc473901711">Compound module parameters</A></H3>
<P>
Parameters are declared in the same way as with simple modules.
Please refer to the &quot;Simple module parameters&quot; section.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> Router
</FONT>	<B>parameters</B><FONT>:
</FONT>		rte_processing_delay, rte_buffersize,
		num_of_ports : <B>const</B>;
	<B>gates</B>: //...
	<B>submodules</B>: //...
	<B>connections</B>://...
<B>endmodule<BR>
</B>
</PRE>
<P>
Compound module parameters can be used in two ways:
<UL>
<LI>used in expressions for submodule parameter values
<LI>used in defining the internal topology of the network
</UL>
<P>
For example, a parameter called <TT>num_of_ports</TT> can be used
to construct a router module with the number of ports as a parameter.
<H3><A NAME="_Toc473901712">Compound module gates</A></H3>
<P>
Gates have the same role and are declared in the same way as with
simple modules. Please refer to the &quot;Simple module gates&quot;
section.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> Router
</FONT>	<B>parameters</B><FONT>: //...
	<B>gates</B>:
		<B>in</B>: input_port[];
		<B>out</B>: output_port[];
	<B>submodules</B>: //...
	<B>connections</B>: //...
<B>endmodule
</B></FONT>
</PRE>
<H3><A NAME="_Toc473901713">Submodules</A></H3>
<P>
Submodules are defined in the <TT>submodules:</TT> section of
a module description. For each submodule, there are sections to
define the actual values to be passed to its parameters and the
sizes of its gate vectors.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> NameForCompoundModule
</FONT>	<B>parameters</B><FONT>: //...
	<B>gates</B>: //...
	<B>submodules</B>:
</FONT>		SubModuleName: TypeOfSubModule
			<B>parameters</B>: 
				//...
			<B>gatesizes</B>:	
				//...
		SecondSubModuleName: TypeOfSecondSubModule
			//...
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
In a submodule definition, one has to supply the name of a previously
defined module as the type and a module name. The description
of the module type can occur in the same network description or
in an imported network description.
<P>
<B>Module vector as submodule</B>
<P>
It is possible to create an array of submodules (a module vector).
This is done with an expression between brackets right behind
the module type name. The expression can refer to module parameters.
A zero value as module count is also allowed.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> BigCompound
</FONT>	<B>parameters</B><FONT>:
		num_of_submods: <B>const</B>;
	<B>submodules</B>:
</FONT>		Submod1: Node[3]
			//...
		Submod2: Node[num_of_submods]
			//...
		Submod3: Node[(num_of_submods+1)/2]
			//...
<B>endmodule
</B>
</PRE>
<P>
<B>Module type as parameter</B>
<P>
Instead of supplying a concrete module type, one can leave it
as a parameter. At the same time, to let the NED compiler know
what parameters and gates that module has, the user has to supply
the name of an existing module type. This is done with the <TT>like</TT>
phrase. 
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> CompoundModule
</FONT>	<B>parameters</B><FONT>:
           node_type : <B>string</B>;
	<B>gates</B>: //...
	<B>submodules</B>:
		theNode: node_type <B>like</B> GeneralNode
			<B>parameters</B>: 
</FONT>				buffer = 10;
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
The above example means that the type of the submodule <TT>theNode</TT>
is not known in advance; it will be taken from the <TT>node_type</TT>
parameter of <TT>CompoundModule</TT> which must be a string (for
example, &quot;<TT>SwitchingNode</TT>&quot;). The module type
called <TT>GeneralNode</TT> must have appeared earlier in the
NED files; its declaration will be used to check whether <TT>theNode</TT>'s
parameters and gates exist and are used correctly. The <TT>node_type</TT>
parameter will probably be given an <TT>input</TT> value somewhere
higher in the module hierarchy so that the actual module type
can be specified in the ini file or entered interactively.
<P>
The <TT>GeneralNode</TT> module type does not need to be implemented
in C++, because no instance of it is created; it is merely used
to check the correctness of the NED file. 
<P>
On the other hand, the actual module type that will be substituted
(i.e. <TT>SwitchingNode</TT> in our case) does not need to be
declared in the NED files.
<P>
The <TT>like</TT> phrase enables the user to create <I>families</I>
of modules that serve similar purposes and implement the same
interface (they have the same gates and parameters) and to use
them interchangably in NED files. This scheme directly parallels
with the concept of <I>polimorphism</I> used in object-oriented
programming.
<P>
<B>Submodule parameters</B>
<P>
Right after the declaration, the values for the parameters of
the declared submodules can be specified. 
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> ManyParameters
</FONT>	<B>parameters</B><FONT>:
</FONT>		par1, par2, switch;
	<B>submodules</B>:
		Submod1: Node
			<B>parameters</B>:
				p1 = 10,
				p2 = par1+par2,
				p3 = switch==0 ? par1 : par2;
		//...
<B>endmodule
</B>
</PRE>
<P>
Expressions are mostly C-style, and they can contain parameters
of the compound module being defined. A separate section is dedicated
to expressions. Here, only the modes of parameter passing are
discussed.
<P>
The default parameter passing method is by value. However, the
user can write <TT>ref</TT> or <TT>ancestor</TT> before the parameter
name. Writing <TT>ref</TT> means that the parameter is not passed
by value, but by reference. This means that instead of the value
of the parameter the address of the parameter is passed.
<P>
Writing <TT>ancestor</TT> before the parameter name means that
the parameter will be searched upwards, among the parameters of
all future enclosing modules of the current module. This reference
cannot be resolved or checked by the NEDC compiler; it can only
be done at runtime, when the whole network has been built up.
The parameter which is found first is used; if no such parameter
can be found in any of the enclosing modules, the system will
give an error during runtime. 
<P>
The <TT>ancestor</TT> and <TT>ref</TT> modifiers are independent,
they can be used together.
<P>
For example:
<PRE>
<B><FONT>simple</FONT></B><FONT> sub_sub
</FONT>	<B>parameters</B><FONT>:
</FONT>		s_s_par1, s_s_par2;
<B>endmodule</B> sub_sub<BR>

<B><FONT>module</FONT></B><FONT> sub
</FONT>	<B>parameters</B><FONT>:
</FONT>		s_par;
	<B>submodules</B>:
		child: sub_sub
			<B>parameters</B>:
				s_s_par1 = <B>ref</B> s_par,
				s_s_par2 = <B>ref</B> <B>ancestor</B> m_par2;
<B>endmodule</B> sub

<B>module</B> mod
	<B>parameters</B>:
		m_par1, m_par2;
	<B>submodules</B>:
		child: sub
			<B>parameters</B>:
				s_par = m_par1;
<B>endmodule</B> mod
</PRE>
<P>
Again, note that the network description compiler can check for
the existence of ordinary parameters but not for ancestor parameters
(it cannot predict in what modules the current module will be
embedded in an actual network description).
<P>
Parameters taken by reference can be used as a second means of
module communication, because during simulation execution, if
a module changes the value of a parameter taken be reference,
the changed value propagates to other modules. <TT>ref</TT> parameters
can also be used to implement shared memory (see in Chapter 5).
<P>
<B>Submodule gate sizes</B>
<P>
The sizes of gate vectors are defined with the <TT>gatesizes:</TT>
keyword. Gate vector sizes can be given as constants, parameters
or expressions.
<P>
An example:
<PRE>
<B><FONT>simple</FONT></B><FONT> SimpleType
</FONT>	<B>gates</B><FONT>:
		<B>in</B>: inputs[]; <B>out</B>: outputs[];
<B>endsimple

module</B> SomeCompound
	<B>parameters</B>:
		num: <B>const</B>;
	<B>submodules</B>:
</FONT>		Submod1: SimpleType
			<B>gatesizes</B>:
				inputs[10], outputs[num];
		//...
<B>endmodule
</B>
</PRE>
<P>
<B>Conditional parameter and gatesize sections</B>
<P>
Multiple <TT>parameters:</TT> and <TT>gatesizes:</TT> sections
can exist in a submodule definition and each of them can be tagged
with conditions.
<P>
For example:
<PRE>
<B><FONT>module</FONT></B><FONT> Serial:
</FONT>        <B>parameters</B><FONT>: count: <B>const</B>;
        <B>submodules</B>:
</FONT>                node : Node [count]
                        <B>parameters</B>:
                                position = &quot;middle&quot;;
                        <B>parameters</B> <B>if</B> index==0:
                                position = &quot;beginning&quot;;
                        <B>parameters</B> <B>if</B> index==count-1:
                                position = &quot;end&quot;;
                        <B>gatesizes</B>:
                                in[2], out[2];
                        <B>gatesizes</B> <B>if</B> index==0 or index==count-1:
                                in[1], in[1];
        <B>connections</B>:
                //...
<B>endmodule
</B>
</PRE>
<P>
If the conditions are not disjunct and a parameter value or a
gate size is defined twice, the last definition will take effect,
overwriting the former ones. Thus, values intended as defaults
should appear in the first sections.
<H3><A NAME="_Toc473901714">Connections</A></H3>
<P>
In a compound module definition, the gates of the compound module
and its immediate submodules are connected. In other words, the
NED language does not support connections that would cross &quot;the
walls&quot; of a compound module without using gates of that module.
Only point-to-point connections are supported.
<P>
In summary:
<OL>
<LI>The gate of a submodule or enclosing module gate can be connected
another submodule or enclosing module gate
<LI>Gate direction must be observed (e.g. you cannot connect two
submodule output gates)
</OL>
<P>
Connections are specified in the <TT>Connections:</TT> section
of a compound module definition. It lists the connections, separated
with semicolons.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> SomeCompound:
</FONT>	<B>parameters</B><FONT>: //...
	<B>gates</B>: //...
	<B>submodules</B>: //...
	<B>connections</B>:
</FONT>		node1.output --&gt; node2.input;
		node1.input &lt;-- node2.output;
		//...
<B>endmodule
</B>
</PRE>
<P>
Each connection can be:
<UL>
<LI>direct (that is, no delay, bit error rate or data rate), can
use a named channel, or a channel given with delay, error and
data rate values;
<LI>single or multiple (loop) connection;
<LI>conditional or non-conditional.
</UL>
<P>
These connection types are described in the following sections.
<P>
<B>Single connections and channels</B>
<P>
The source gate can be an output gate of a submodule or an input
gate of the compound module, and the destination gate can be an
input gate of a submodule or an output gate of the compound module.
<P>
If the user does not specify a channel, the connection will have
no propagation delay, no transmission delay and no bit errors:
<PRE>
<FONT>	Sender.outgate --&gt; Receiver.ingate;
</FONT>
</PRE>
<P>
The arrow can point either left-to-right or right-to-left.
<P>
The user can also specify a channel by its name:
<PRE>
<FONT>	Sender.outgate --&gt; Dialup14400 --&gt; Receiver.ingate;
</FONT>
</PRE>
<P>
In this case, the NED sources moust contain the definition of
the channel.
<P>
One can also specify the channel parameters directly:
<PRE>
<FONT>	Sender.outgate --&gt; error 1e-5 delay 0.001 --&gt; Receiver.ingate;
</FONT>
</PRE>
<P>
Either of the parameters can be omitted and they can be in any
order.
<P>
<B>Loop connections</B>
<P>
If submodule or gate vectors are used, it is possible to create
more than one connection with one statement. This is termed a
<I>multiple</I> or <I>loop connection</I>.
<P>
A multiple connection is created with the <TT>for</TT> statement:
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..4 <B>do
</B></FONT>	Sender.outgate[i] --&gt; Receiver[i].ingate
<B>endfor
</B>
</PRE>
<P>
The result of the above loop connection can be illustrated as
follows:
<P>
<CENTER><IMG SRC="img00007.gif"><BR>
Fig.4.1 Loop connection</CENTER>
<P>
One can place several connections in the body of the <TT>for</TT>
statement, separated with semicolons.
<P>
More than one indices can be specified in a <TT>for</TT> statement,
with their own lower and upper bounds. This will be interpreted
as nested <TT>for</TT> statements, the leftmost index being the
outermost and the rightmost index being the innermost loop.
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..4, j=0..4 <B>do
</B></FONT>	//...
<B>endfor
</B>
</PRE>
<P>
One can also use an index in the lower and upper bound expressions
of the subsequent indices:
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..3, j=i+1..4 <B>do
</B></FONT>	//...
<B>endfor
</B>
</PRE>
<P>
In the above example, the following <I>(i,j)</I> pairs will be
used for the connections inside the <TT>for</TT> statement:
<P>
<I> (0,1) (0,2) (0,3) (0,4) (1,2) (1,3) (1,4) (2,3) (2,4) (3,4)</I>
<P>
A gate cannot be used in more than one connection and one connection
cannot be made more than once. Consider the following bogus statement:
<PRE>
<B><FONT>for</FONT></B><FONT> i = 0..2, j = 0..2 <B>do
</B></FONT>	module1.out [i] --&gt; module2.in [<I><B>i</B></I><FONT>];
</FONT><B>endfor</B>
</PRE>
<P>
It will cause a runtime error: each connection is made twice,
as the index variable <I>j</I> is not used in the connection.
In general, every connection inside a loop should use all the
index variables at both sides of the connection.
<P>
<B>Conditional connections</B>
<P>
Connections can be conditional. This is a conditional connection:
<PRE>
<B><FONT>for</FONT></B><FONT> i=0..n <B>do
</B></FONT>	Sender.outgate[i] --&gt; Receiver[i].ingate <B>if</B><FONT> i%2==0;
<B>endfor
</B></FONT>
</PRE>
<P>
This way we connected every second gate.
<P>
<B>The nocheck modifier</B>
<P>
Conditional connections are especially useful with random numbers
when they can create random connections. Here, a problem can be
that by default, the simulation program checks if all gates are
connected. You can turn off this check by using the <TT>nocheck</TT>
modifier.
<P>
This example generates a random subgraph of a full graph:
<PRE>
<B><FONT>module</FONT></B><FONT> Stochastic:
</FONT><B>	parameters</B>: //..
<B>	gates</B>: //..
<B>	submodules</B>: //..

<B>	connections</B> <B>nocheck</B>:
	<B>	for</B> i=0..9 <B>do
</B>			Sender.outgate[i] --&gt; Receiver[i].ingate
								<B>if</B> uniform(0,1)&lt;0.3;
	<B>	endfor
endmodule
</B>
</PRE>
<P>
When using <TT>nocheck</TT>, it is the simple modules' responsibility
not to send messages on gates that are not connected.
<H2><A NAME="_Toc473901715">Parameterized compound modules</A>
</H2>
<P>
With the help of conditional parameter and gatesize blocks and
conditional connections, one can create complex topologies.
<H3><A NAME="_Toc473901716">Examples</A></H3>
<P>
<B>Example 1: Router</B>
<P>
The following example contains a router module with the number
of ports taken as parameter. The compound module is built using
three module types: <TT>Application</TT>, <TT>RoutingModule</TT>,
<TT>DataLink</TT>. We assume that their definition is in a separate
NED file which we will import.
<PRE>
<B><FONT>import</FONT></B><FONT> &quot;modules&quot;;

</FONT><B>module</B> Router:
	<B>parameters</B>:
		rte_processing_delay, rte_buffersize,
		num_of_ports:<B> const</B>;
	<B>gates</B>:
		<B>in</B>: input_ports[];
		<B>out</B>: output_ports[];
	<B>submodules</B>:
		local_user: Application;
		routing: RoutingModule
			<B>parameters</B>:
				processing_delay = rte_processing_delay,
				buffersize = rte_buffersize;
			<B>gatesizes</B>:
				input[num_of_ports+1],
				output[num_of_ports+1];
		port_if: DataLink[num_of_ports]
			<B>parameters</B>:
				retry_count = 5,
				window_size = 2;
	<B>connections</B>:
		<B>for</B> i=0..num_of_ports-1 <B>do
			</B>routing.output[i] --&gt; port_if[i].from_higher_layer;
<B>			</B>routing.input[i] &lt;-- port_if[i].to_higher_layer;
<B>			</B>port_if[i].to_port --&gt; output_ports[i];
<B>			</B>port_if[i].from_port &lt;-- input_ports[i];
		<B>endfor;
		</B>routing.output[num_of_ports] --&gt; local_user.input;
<B>		</B>routing.input[num_of_ports] &lt;-- local_user.output;
<B>endmodule
</B>
</PRE>
<P>
<B>Example 2: Chain</B>
<P>
For example, one can create a chain of modules like this:
<PRE>
<B><FONT>module</FONT></B><FONT> Serial:
</FONT><B>	parameters</B>: count: <B>const</B>;
	<B>submodules</B>:
		node : Node [count]
<B>			gatesizes</B>:
				in[2], out[2];
			<B>gatesizes</B> <B>if</B> index==0 or index==count-1:
				in[1], out[1];
	<B>connections</B>:
		<B>for</B> i = 0..count-2 <B>do
</B>			node[i].out[i!=0 ? 1 : 0] --&gt; node[i+1].in[0];
			node[i].in[i!=0 ? 1 : 0] &lt;-- node[i+1].out[0];
		<B>endfor
endmodule
</B>
</PRE>
<P>
<B>Example 3: Binary Tree</B>
<P>
Building a binary tree is a good example of using conditional
connections:
<PRE>
<B><FONT>simple</FONT></B><FONT> BinaryTreeNode:
</FONT>    <B>gates</B><FONT>:
        <B>in</B>:  from_up, from_downleft, from_downright;
        <B>out</B>: upward,  downleft,      downright;
<B>endsimple

</B></FONT><B>module</B> BinaryTree:
    <B>parameters</B>: height:<B> const</B>;
    <B>submodules</B>: node: BinaryTreeNode [ 2^height-1 ];
                //....
    <B>connections</B>:
        <B>for</B> i = 0..2^height-2, j = 0..2^height-2 <B>do
</B>            node[i].upward --&gt; node[j].from_downleft  <B>if</B> leftchild(i,j);
            node[i].from_up &lt;-- node[j].downleft      <B>if</B> leftchild(i,j);
            node[i].upward --&gt; node[j].from_downright <B>if</B> rightchild(i,j);
            node[i].from_up &lt;-- node[j].downright     <B>if</B> rightchild(i,j);
        <B>endfor
</B>        //....
<B>endmodule
</B>
</PRE>
<P>
The dotted lines should be replaced by modules that close the
tree at its root and the lower edge. The leftchild(i,j) and rightchild(i,j)
functions are:
<P>
leftchild(i,j) = 
<P>
rightchild(i,j) = 
<P>
These formulas can be directly substituted in the NED description,
or alternatively, written in C and linked into the simulation
executable.
<P>
<B>Example 4: Random graph</B>
<P>
Conditional connections can also be used to generate random topologies.
The following code generates a random subgraph of a full graph:
<PRE>
<B><FONT>module</FONT></B><FONT> RandomGraph:
</FONT>	<B>parameters</B><FONT>:
		count: <B>const</B>,
</FONT>		connectedness; // 0.0&lt;x&lt;1.0
	<B>submodules</B>:
		node: Node [count]
			<B>gatesizes</B>: <B>in</B>[count], <B>out</B>[count];
	<B>connections</B> <B>nocheck</B>:
		<B>for</B> i=0..count-1, j=0..count-1 <B>do
</B>			node[i].out[j] --&gt; node[j].in[i]
				<B>if</B> i!=j and uniform(0,1)&lt;connectedness;
		<B>endfor
endmodule
</B>
</PRE>
<P>
Note that not each gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here
with the <TT>nocheck</TT> modifier. Consequently, it is the simple
modules' responsibility not to send on a gate which is not leading
anywhere.
<H3><A NAME="_Toc473901717">Using const with parametrized topologies</A>
</H3>
<P>
Since parameter values can be used in defining the internal topology
of the module, the <TT>const </TT>modifier has a significant role.
Consider the following example:
<PRE>
<B><FONT>simple</FONT></B><FONT> Sender
</FONT>	<B>parameters</B><FONT>:
</FONT>		num_of_outgates;
	<B>gates</B>:
		<B>out</B>: outgate[num_of_outgates];
<B>endsimple</B> Sender

<B>simple</B> Receiver
	<B>gates</B>:
		<B>in</B>: ingate;
<B>endsimple</B> Receiver

<B>module</B> Network;
	<B>parameters</B>:
		num_of_mods:<B> const</B>;
	<B>submodules</B>:
		sender: Sender
			<B>parameters</B>:
				num_of_outgates = <I>num_of_mods</I>;
		receiver: Receiver [<I>num_of_mods</I>]
	<B>connections</B>:
		<B>for</B> i=1..<I>num_of_mods</I> <B>do
</B>			sender.outgate[i] --&gt; receiver[i].ingate
		<B>endfor</B>;
<B>endmodule

network</B> net: Network
	<B>parameters</B>:
		num_of_mods = normal (5,2);
<B>endnetwork<BR>
</B>
</PRE>
<P>
If parameter <TT>num_of_mods</TT> wasn't <TT>const</TT>, the following
would happen:
<P>
<TT>normal(5,2</TT>) would be substituted for the <TT>num_of_mods</TT>.
There are three places where an evaluation of <TT>num_of_mods</TT>
(that is, <TT>normal (5,2)</TT>) is done (they are typed in italics
in the example). It is likely that these evaluations would not
result in the same value, and consequently, the gate vector sizes
would not match each other and the end value of the <TT>for</TT>
statement. Thus, the loop connection would not be created properly.
<P>
Using <TT>const</TT> for the parameter <TT>num_of_mods</TT> prevents
this from happening: an evaluation of <TT>normal(5,2)</TT> is
substituted for <TT>num_of_mods</TT> and an equal number of gates
are created.
<H3><A NAME="_Toc473901718">Design patterns for compound modules</A>
</H3>
<P>
Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are described
below. 
<P>
<B>'Subgraph of a Full Graph' </B>
<P>
This pattern takes a subset of the connections of a full graph.
A condition is used to &quot;carve out&quot; the necessary interconnection
from the full graph:
<PRE>
<FONT>for i=0..N-1, j=0..N-1 do
</FONT>  node[i].out[...] --&gt; node[j].in[...] if condition(i,j);
endfor
</PRE>
<P>
The <TT>RandomGraph</TT> compound module (presented earlier) is
an example of this pattern, but the pattern can generate any graph
where an appropriate <I>condition(i,j)</I> can be formulated.
For example, when generating a tree structure, the condition would
return whether node <I>j</I> is a child of node <I>i</I> or vica
versa. 
<P>
Though this pattern is very general, its usage can be prohibitive
if the <I>N</I> number of nodes is high and the graph is sparse
(it has much fewer connections that <I>N<SUP>2</SUP></I>). The
following two patterns do not suffer from this drawback. 
<P>
<B>'Connections of Each Node' </B>
<P>
The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this: 
<PRE>
<FONT>for i=0..Nnodes, j=0..Nconns(i)-1 do
</FONT>  node[i].out[j] --&gt; node[rightNodeIndex(i,j)].in[j];
endfor
</PRE>
<P>
The <TT>Hypercube</TT> compound module (to be presented later)
is a clear example of this approach. <TT>BinaryTree</TT> can also
be regarded as an example of this pattern where the inner j loop
is unrolled. 
<P>
The applicability of this pattern depends on how easily the <I>rightNodeIndex(i,j)</I>
function can be formulated. 
<P>
<B>'Enumerate All Connections' </B>
<P>
A third pattern is to list all connections within a loop: 
<PRE>
<FONT>for i=0..Nconnections-1 do
</FONT>  node[leftNodeIndex(i)].out[...] --&gt; node[rightNodeIndex(i)].in[...];
endfor
</PRE>
<P>
The pattern can be used if <I>leftNodeIndex(i)</I> and <I>rightNodeIndex(i)</I>
mapping functions can be sufficiently formulated. 
<P>
The <TT>Serial</TT> module is an example of this approach where
the mapping functions are extremely simple: <I>leftNodeIndex(i)=i</I>
and <I>rightNodeIndex(i)=i+1</I>. The pattern can also be used
to create a random subset of a full graph with a fixed number
of connections. 
<P>
In the case of irregular structures where none of the above patterns
can be employed, the user can resort to specifying constant submodule/gate
vector sizes and explicitly listing all connections, like he/she
would do it in most existing simulators.
<H3><A NAME="_Toc473901719">Topology templates</A></H3>
<P>
<B>Overview</B>
<P>
Topology templates are nothing more than compound modules where
one or more submodule types are left as parameters (using the
<TT><B><FONT>like</FONT></B></TT> phrase of
the NED language). You can write such modules which implement
mesh, hypercube, butterfly, perfect shuffle or other topologies,
and you can use them wherever needed in you simulations. With
topology templates, you can reuse <I>interconnection structure</I>.
<P>
<B>An example: hypercube</B>
<P>
The concept is demonstrated on a network with hypercube interconnection.
When building an N-dimension hypercube, we can exploit the fact
that each node is connected to N others which differ from it only
in one bit of the binary representations of the node indices (see
figure). 
<P>
<CENTER><IMG SRC="img00008.gif"><BR>
Fig.4.1 Hypercube topology</CENTER>
<P>
The hypercube topology template is the following (it can be placed
into a separate file, e.g hypercube.ned): 
<PRE>
<FONT>simple Node
</FONT>  gates: out: out[]; in: in[];
endsimple

module Hypercube
  parameters:
    dim, nodetype;
  submodules:
    node: nodetype[2^dim] like Node
      gatesizes:
	out[dim], in[dim];
  connections:
    for i=0..2^dim-1, j=0..dim-1 do
	  node[i].out[j] --&gt; node[i # 2^j].in[j]; // # is bitwise XOR
    endfor
endmodule
</PRE>
<P>
When you create an actual hypercube, you substitute the name of
an existing module type (e.g. <TT>Hypercube_PE</TT>) for the <TT>nodetype</TT>
parameter. The module type implements the algorithm the user wants
to simulate and it must have the same gates that the <TT>Node</TT>
type has. The topology template code can be used through file
inclusion: 
<PRE>
<FONT>include &quot;hypercube.ned&quot;

</FONT>simple Hypercube_PE
  gates: out: out[]; in: in[];
endsimple

network hypercube: Hypercube
  parameters:
    dim = 4,
    nodetype = &quot;Hypercube_PE&quot;;
endnetwork
</PRE>
<P>
If you put the <TT>nodetype</TT> parameter to the ini file, you
can use the same simulation model to test e.g. several routing
algorithms in a hypercube, each algorithm implemented with a different
simple module type - you just have to supply different values
to <TT>nodetype</TT>, such as <TT>&quot;WormholeRoutingNode&quot;</TT>,
<TT>&quot;DeflectionRoutingNode&quot;</TT>, etc.
<H2><A NAME="_Toc473901720">Network definition</A></H2>
<P>
A <I>network</I> <I>definition</I> (or <I>system module definition</I>)
specifies the system module. In its syntax, it is very similar
to a submodule declaration. The system definition starts with
keyword <TT>network</TT> and ends with <TT>endnetwork.</TT>
<P>
An example:
<PRE>
<B><FONT>network</FONT></B><FONT> modelledNetwork: SomeModule
</FONT>	<B>parameters</B><FONT>:
</FONT>		par1=10,
		par2=normal(100,20);
<B>endnetwork
</B>
</PRE>
<P>
Here, <TT>SomeModule</TT> is the name of a compound or a simple
module type.
<P>
There can be several system definitions in a network description,
each one defines a different network. The simulation program built
with such a network description is able to run any of them; the
desired one can be specified in the config file (see later).
<H2><A NAME="_Toc473901721">Support for parallel execution</A>
</H2>
<P>
OMNeT++ simulations can be executed in parallel. This means that
different parts of the model execute on different hosts or processors.
(We'll use the term &quot;host&quot; or &quot;machine&quot; in
this sense.) The unit of granularity is the simple module: one
simple module always executes on a single processor.
<P>
Parallel execution is also supported by NED: the language provides
an elegant way of specifying execution hosts for different modules.
We'll discuss this feature in the following sections.
<H3><A NAME="_Toc473901722">Extensions to the compound module
and system definitions</A></H3>
<P>
To support the segmentation of the model for execution of different
modules, the compound module definition was extended with the
<TT>machines:</TT> and the <TT>on:</TT> keywords.
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> SomeNameForCompoundModule
</FONT>	<B>machines</B><FONT>: host1, host2, host3, host4;
	<B>parameters</B>: //...
	<B>gates</B>: //...
	<B>submodules</B>: 
</FONT>		submodule1 : submodtype1
			<B>on:</B> host1;
		submodule2 : submodtype2
			<B>on:</B> host2, host3;
		submodule3 : submodtype1
			<B>on:</B> host4;
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
The <TT>machines:</TT> section lists formal host names which are
used in the <TT>on:</TT> lists of the submodules.
<P>
In the example, the second submodule is itself a compound module
that can be further subdivided to run on two separate hosts, so
its definition must have a <TT>machines:</TT> section with two
parameters. You do not have to propagate host names down to simple
module level: you can stop at a compound module which executes
on a single host. In other words, a compound module with no <TT>machines:</TT>
section is equivalent to one with one machine parameter.
<P>
Of course, you can give the same value to several machine parameters,
as to <TT>submodule1</TT>'s in the following example. In this
case, the whole compound module will be placed on a single host,
as if it never had machine parameters at all.
<PRE>
<B><FONT>module</FONT></B><FONT> AnotherCompoundModule
</FONT>	<B>machines</B><FONT>: host1, host2;
	<B>parameters</B>: //...
	<B>gates</B>: //...
	<B>submodules</B>: 
</FONT>		submodule1 : submodtype1
			<B>on:</B> host1, host1, host1;
		//...
	<B>connections</B>: //...
<B>endmodule
</B>
</PRE>
<P>
Host names propagate up to network definition level. Extension
to the network definition:
<PRE>
<B><FONT>network</FONT></B><FONT> distVector: DistVector
</FONT>	on: machine1, machine2, machine3;
<B>endnetwork
</B>
</PRE>
<P>
The <TT>on:</TT> parameters of the network definition can be actual
host names, or alternatively, they can be symbolic names that
are mapped to actual host names in the config file.
<H3><A NAME="_Toc473901723">Conditional 'on' sections</A></H3>
<P>
Similarly to the <TT>parameters:</TT> and <TT>gatesizes:</TT>
section, multiple <TT>on:</TT> sections can exist for the submodules
if they are tagged with <TT>if</TT> phrases.
<P>
This makes it possible to control the module distribution with
parameters. You can even put different parts of a module vector
on different machines using the <TT>index</TT> operator (see later
in the section describing expressions).
<P>
Example:
<PRE>
<B><FONT>module</FONT></B><FONT> DistVector:
</FONT><B>	machines</B>: host1, host2, host3;
	<B>submodules</B>:
		node : Node [count]
			<B>on</B> <B>if</B> index&lt;count*.33: host1;
			<B>on</B> <B>if</B> index&gt;=count*.33 and index&lt;count*.66: host2;
			<B>on</B> <B>if</B> index&gt;=count*.66: host3;
<B>endmodule

network</B> distvector: DistVector
	on machine1, machine2, machine3;
<B>endnetwork
</B>
</PRE>
<H2><A NAME="_Toc473901724">Expressions</A></H2>
<P>
In the NED language there are a number of places where expressions
are expected.
<P>
When such an expression is encountered by the NEDC compiler, it
is compiled and it will be evaluated run-time.
<P>
Expressions have a C-style syntax. They are built with the usual
math operators; they can use parameters taken by value or by reference;
call C functions; contain random and input values etc.
<H3><A NAME="_Toc473901725">Using parameters in expressions (ref
and ancestor)</A></H3>
<P>
Expressions can use the parameters of the compound module being
built. A parameter can be taken by value or by reference. The
default is by value; to select by-reference passing for a parameter,
you have to use the <TT>ref</TT> modifier. Parameters passed by
reference can be used by a module to propagate values (status
info etc.) to other modules.
<P>
The <TT>ancestor</TT> modifier allows one to access parameters
from higher in the module hierarchy.
<PRE>
<B><FONT>module</FONT></B><FONT> Compound
</FONT>	<B>parameter</B><FONT>: nnn;
	<B>submodules</B>:
</FONT>		proc: Processor
			<B>parameters</B>: par1 = <B>ref</B> nnn / 2,
			            par2 = 10 * <B>ancestor</B> par_somewhere_up;
<B>endmodule</B>
</PRE>
<H3><A NAME="_Toc473901726">Operators</A></H3>
<P>
The following operators can be used in expressions, in order of
precedence:<TABLE BORDER=1>
<TR><TD WIDTH=89>
<PRE>
<B><FONT>operator</FONT></B>
</PRE>

</TD><TD WIDTH=277><PRE>
<B>meaning</B>
</PRE>
</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>-, !, ~</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
unary minus, negation, bitwise complement</PRE>

</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>^</FONT>
</PRE>
</TD><TD WIDTH=277><PRE>
power of</PRE>

</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>*, /, %</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
multiply, divide, modulus</PRE>
</TD>
</TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>+, -</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
add, substract</PRE>
</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&lt;&lt;, &gt;&gt;</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
bitwise shifting</PRE>
</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&amp;, |, #</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
bitwise and, or, xor 
  <I>(^ is reserved for power)</I>
</PRE>

</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>==</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
equal</PRE>
</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>!=</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
not equal</PRE>
</TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&gt;, &gt;=</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
greater, greater or equal</PRE>
</TD>
</TR>
<TR><TD WIDTH=89><PRE>
<FONT>&lt;, &lt;=</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
less, less or equal</PRE>
</TD></TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>?:</FONT>
</PRE>
</TD>
<TD WIDTH=277><PRE>
the C/C++ &quot;inline if&quot;</PRE>
</TD>
</TR>
<TR><TD WIDTH=89></TD><TD WIDTH=277></TD></TR>
<TR><TD WIDTH=89><PRE>
<FONT>&amp;&amp;, ||, ##</FONT>
</PRE>

</TD><TD WIDTH=277><PRE>
logical operators and, or, xor</PRE>

</TD></TR>
</TABLE>
<H3><A NAME="_Toc473901727">The sizeof() and index operators</A>
</H3>
<P>
A useful operator is <TT>sizeof()</TT>, which gives the size of
a vector gate. The <TT>index</TT> operator gives the index of
the current submodule in its module vector.
<P>
An example for both:
<PRE>
<B><FONT>module</FONT></B><FONT> Compound
</FONT>	<B>gates</B><FONT>: <B>in</B>: fromgens[];
	<B>submodules</B>:
		proc: Processor[ <B>sizeof</B>(fromgens) ];
			<B>parameters</B>: address = 10*(1+<B>index</B>);
	<B>connections</B>:
		<B>for</B> i = 0 .. <B>sizeof</B>(fromgens)-1 <B>do
</B></FONT>			in[i] --&gt; proc[i].input;
		<B>endfor
endmodule
</B>
</PRE>
<P>
Here, we create as many processors as there are input gates for
this compound module in the network. The <TT>address</TT> parameters
of the processors are 10, 20, 30 etc.
<H3><A NAME="_Toc473901728">Time constants</A></H3>
<P>
Anywhere you would put numeric constants (integer or real) to
mean time in seconds, you can also specify the time in units like
milliseconds, minutes or hours:
<PRE>
<FONT>   ...
</FONT>   <B>parameters</B><FONT>: propagation_delay = 560ms,          // 0.560s
</FONT>               connection_timeout = 6m 30s 500ms,  // 390.5s
               lunchtime = 0.5h;                   // 30 min
</PRE>
<P>
The following units can be used:
<TABLE BORDER=1>
<TR><TD WIDTH=75><CENTER><TT>ns</TT></CENTER></TD><TD WIDTH=150>nanoseconds
</TD><TD WIDTH=93>*10<SUP>-9</SUP></TD></TR>
<TR><TD WIDTH=75><CENTER><TT>us</TT></CENTER></TD><TD WIDTH=150>microseconds
</TD><TD WIDTH=93>*10<SUP>-6</SUP></TD></TR>
<TR><TD WIDTH=75><CENTER><TT>ms</TT></CENTER></TD><TD WIDTH=150>milliseconds
</TD><TD WIDTH=93>*10<SUP>-3</SUP></TD></TR>
<TR><TD WIDTH=75><CENTER><TT>s</TT></CENTER></TD><TD WIDTH=150>seconds
</TD><TD WIDTH=93>*1</TD></TR>
<TR><TD WIDTH=75><CENTER><TT>m</TT></CENTER></TD><TD WIDTH=150>minutes
</TD><TD WIDTH=93>*60</TD></TR>
<TR><TD WIDTH=75><CENTER><TT>h</TT></CENTER></TD><TD WIDTH=150>hours
</TD><TD WIDTH=93>*3600</TD></TR>
<TR><TD WIDTH=75><CENTER><TT>d</TT></CENTER></TD><TD WIDTH=150>days
</TD><TD WIDTH=93>*60*3600</TD></TR>
</TABLE>
<P>
<H3><A NAME="_Toc473901729">Random values</A></H3>
<P>
OMNeT++ has the following predefined distributions:
<UL>
<LI>uniform, uniform integer
<LI>exponential
<LI>normal, truncated normal
</UL>
<P>
Each distribution has one or more parameters. 
<P>
Examples:
<PRE>
<FONT>uniform(0,1)       // uniform in [0,1)
</FONT>intuniform(-2,2)   // uniform int, limits included: -2,-1,0,1,or 2
exponential(5)     // exponential with mean=5 (thus parameter=0.2)
normal(100,5)      // mean 100, variance 5
truncnormal(5,3)   // normal distr, truncated to nonnegative values
</PRE>
<P>
The functions all use the random number generator 0. By using
the <TT>genk_</TT>-prefixed versions of the above functions, you
can specify which generator should be used. The index of the generator
comes as the first argument.
<P>
Example:
<PRE>
<FONT>genk_normal(2,100,5)      // as normal(100,5), using generator 2
</FONT>
</PRE>
<P>
The above distributions are implemented with C functions (see
later in the Functions section). This also means that you can
easily add further ones by writing their code in C++ and using
the <TT>Register_Function</TT> macro. Your distributions will
be treated in the same way as the built-in ones.
<H3><A NAME="_Toc473901730">Input value</A></H3>
<P>
The syntax is:
<PRE>
<B><FONT>input</FONT></B><FONT>( 10, &quot;Number of processors:&quot; )
</FONT>
</PRE>
<P>
Or you can omit the prompt text:
<PRE>
<B><FONT>input</FONT></B><FONT>( 10ms )
</FONT>
</PRE>
<P>
Value for input parameters can be given in the config file. If
they are not there, the user will be offered a prompt to enter
the value.
<H3><A NAME="_Toc473901731">Functions</A></H3>
<P>
In NED expressions, you can use mathematical functions:
<UL>
<LI>many of the C language's <TT>&lt;math.h&gt;</TT> library functions:
<TT>exp()</TT>, <TT>log()</TT>, <TT>sin()</TT>, <TT>cos()</TT>,
<TT>floor()</TT>, <TT>ceil()</TT>, etc. 
<LI>functions that generate random variables: <TT>uniform</TT>,
<TT>exponential</TT>, <TT>normal</TT> and others were already
discussed.
<LI>user defined functions that can implement new functions or
yield random variables of distributions that are originally not
built in.
</UL>
<P>
To use user-defined functions, one has to code the function in
C++.  The C++ function must take 0, 1, 2, or 3 arguments of type
<TT>double</TT> and return a <TT>double</TT>. The function must
be registered in one of the C++ files with the <TT>Define_Function()</TT>
macro. 
<P>
An example function (the following code must appear in one of
the C++ sources):
<PRE>
<FONT>double average(double a, double b)
</FONT>{
  return (a+b)/2;
}

Define_Function(average, 2)<BR>
</PRE>
<P>
The number 2 means that the <TT>average()</TT> function has 2
arguments. After this, the <TT>average()</TT> function can be
used in NED files:
<PRE>
<B><FONT>module</FONT></B><FONT> Compound
</FONT>	<B>parameter</B><FONT>: a,b;
	<B>submodules</B>:
</FONT>		proc: Processor
			<B>parameters</B>: av = average(a,b);
<B>endmodule
</B>
</PRE>
<P>
An important application of this concept is to extend OMNeT++
with new distributions. 
<H3><A NAME="_Toc473901732">Display strings</A></H3>
<P>
Display strings specify the arrangement and appearance of modules
in graphical user interfaces (currently only Tkenv): they control
how the objects (compound modules, their submodules and connections)
are displayed. Display strings occur in NED descriptions's <TT>display:</TT>
phrases.
<P>
The display string format is a semicolon-separated list of tags.
Each tag consists of a key (usually one letter), an equal sign
and a comma-separated list of parameters, like:
<PRE>
<FONT>  &quot;p=100,100;b=60,10,rect;o=blue,black,2&quot;
</FONT>
</PRE>
<P>
Parameters may be omitted also at the end and also inside the
parameter list, like:
<PRE>
<FONT>  &quot;p=100,100;b=rect;o=,,2&quot;
</FONT>
</PRE>
<P>
Module/submodule parameters can be included with the <TT>$name</TT>
notation:
<PRE>
<FONT>  &quot;p=$xpos,$ypos;b=rect,60,10;o=$fillcolor,black,2&quot;
</FONT>
</PRE>
<P>
Objects that may have display strings are:
<UL>
<LI>compound modules (as the enclosing module in the drawing),
<LI>submodules
<LI>connections
</UL>
<P>
<B>Tags used in submodule display strings:</B>
<TABLE BORDER=1>
<TR><TD WIDTH=277><B>Tag</B></TD><TD WIDTH=387><B>Meaning</B>
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>p=</FONT></B><I><FONT>xpos</FONT></I><FONT>,<I>ypos</I></FONT>
</PRE>

</TD><TD WIDTH=387>Place submodule at (<I>xpos</I>,<I>ypos</I>) pixel position, with the origin being the top-left corner of the enclosing module.
<P>
Defaults: an appropriate automatic layout is where submodules do not overlap.<P>
If applied to a submodule vector, <I>ring</I> or <I>row</I> layout is selected automatically.
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>p=</FONT></B><I><FONT>xpos</FONT></I><B><FONT>,</FONT></B><I><FONT>ypos</FONT></I><B><FONT>,row,</FONT></B><I><FONT>deltax</FONT></I>
</PRE>

</TD><TD WIDTH=387>Used for module vectors. Arranges submodules in a row starting at (<I>xpos</I>,<I>ypos</I>), keeping <I>deltax</I> distances.
<P>
Defaults: <I>deltax</I> is chosen so that submodules do not overlap.
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>p=</FONT></B><I><FONT>xpos</FONT></I><B><FONT>,</FONT></B><I><FONT>ypos</FONT></I><B><FONT>,col,</FONT></B><I><FONT>deltay</FONT></I>
</PRE>

</TD><TD WIDTH=387>Used for module vectors. Arranges submodules in a column starting at (<I>xpos</I>,<I>ypos</I>), keeping <I>deltay</I> distances.
<P>
Defaults: <I>deltay</I> is chosen so that submodules do not overlap.
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>p=</FONT></B><I><FONT>xpos</FONT></I><B><FONT>,</FONT></B><I><FONT>ypos</FONT></I><B><FONT>,matrix,
</FONT></B><I>itemsperrow</I><B>,</B><I>deltax,deltay</I>
</PRE>

</TD><TD WIDTH=387>Used for module vectors. Arranges submodules in a matrix starting at (<I>xpos</I>,<I>ypos</I>), at most <I>itemsperrow</I> submodules in a row, keeping <I>deltax</I> and <I>deltay</I> distances.
<P>
Defaults: <I>itemsperrow</I>=5, <I>deltax,deltay</I> are chosen so that submodules do not overlap.
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>p=</FONT></B><I><FONT>xpos</FONT></I><B><FONT>,</FONT></B><I><FONT>ypos</FONT></I><B><FONT>,ring,
</FONT></B><I>width,height</I>
</PRE>

</TD><TD WIDTH=387>Used for module vectors. Arranges submodules in an ellipse, with the top-left corner of its bounding boxes at (<I>xpos</I>,<I>ypos</I>), with the <I>width</I> and <I>height</I>.
<P>
Defaults: <I>widths</I>=40, <I>height</I>=24
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>b=</FONT></B><I><FONT>width</FONT></I><B><FONT>,</FONT></B><I><FONT>height</FONT></I><B><FONT>,rect</FONT></B>
</PRE>

</TD><TD WIDTH=387>Rectangle with the given <I>height</I> and <I>width</I>.
<P>
Defaults: <I>widths</I>=40, <I>height</I>=24
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>b=</FONT></B><I><FONT>width</FONT></I><B><FONT>,</FONT></B><I><FONT>height</FONT></I><B><FONT>,oval</FONT></B>
</PRE>

</TD><TD WIDTH=387>Ellipse with the given <I>height</I> and <I>width</I>.
<P>
Defaults: <I>widths</I>=40, <I>height</I>=24
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>o=</FONT></B><I><FONT>fillcolor</FONT></I><B><FONT>,</FONT></B><I><FONT>outlinecolor</FONT></I><B><FONT>,
</FONT></B><I>borderwidth</I>
</PRE>

</TD><TD WIDTH=387>Specifies options for the rectangle or oval. Any valid Tk color specification is accepted: English color names or <I>#rgb</I>, <I>#rrggbb</I> format (where <I>r</I>,<I>g</I>,<I>b</I> are hex digits).
<P>
Defaults: <I>fillcolor</I>=#8080ff (a lightblue), <I>outlinecolor</I>=black, <I>borderwidth</I>=2
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>i=</FONT></B><I><FONT>iconname</FONT></I>
</PRE>

</TD><TD WIDTH=387>Use the named icon.<P>
No default. If no icon name is present, <I>box</I> is used.
</TD></TR>
</TABLE>
<P>
<P>
Examples:
<PRE>
<FONT>&quot;p=100,60;i=workstation&quot;
</FONT>&quot;p=100,60;b=30,30,rect;o=,,4&quot;<BR>
</PRE>
<P>
<B>Tags used in enclosing module display strings:</B>
<TABLE BORDER=1>
<TR><TD WIDTH=277><B>Tag</B></TD><TD WIDTH=387><B>Meaning</B>
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>p=</FONT></B><I><FONT>xpos</FONT></I><FONT>,<I>ypos</I></FONT>
</PRE>

</TD><TD WIDTH=387>Place enclosing module at (<I>xpos</I>,<I>ypos</I>) pixel position, with (0,0) being the top-left corner of the window.
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>b=</FONT></B><I><FONT>width</FONT></I><B><FONT>,</FONT></B><I><FONT>height</FONT></I><B><FONT>,rect</FONT></B>
</PRE>

</TD><TD WIDTH=387>Display enclosing module as a rectangle with the given <I>height</I> and <I>width</I>.
<P>
Defaults: <I>width,</I> <I>height</I> are chosen automatically
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>b=</FONT></B><I><FONT>width</FONT></I><B><FONT>,</FONT></B><I><FONT>height</FONT></I><B><FONT>,oval</FONT></B>
</PRE>

</TD><TD WIDTH=387>Display enclosing module as an ellipse with the given <I>height</I> and <I>width</I>.
<P>
Defaults: <I>width,</I> <I>height</I> are chosen automatically
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>o=</FONT></B><I><FONT>fillcolor</FONT></I><B><FONT>,</FONT></B><I><FONT>outlinecolor</FONT></I><B><FONT>,
</FONT></B><I>borderwidth</I>
</PRE>

</TD><TD WIDTH=387>Specifies options for the rectangle or oval. Any valid Tk color specification is accepted: English color names or <I>#rgb</I>, <I>#rrggbb</I> format (where <I>r</I>,<I>g</I>,<I>b</I> are hex digits).
<P>
Defaults: <I>fillcolor</I>=#8080ff (a lightblue), <I>outlinecolor</I>=black, <I>borderwidth</I>=2
</TD></TR>
</TABLE>
<P>
<B>Tags used in connection display strings:</B>
<TABLE BORDER=1>
<TR><TD WIDTH=277><B>Tag</B></TD><TD WIDTH=387><B>Meaning</B>
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>m=auto
</FONT>m=north
m=west
m=east
m=south</B>
</PRE>

</TD><TD WIDTH=387>Drawing mode. Specifies the exact placement of the connection arrow. The arguments can be abbreviated as <TT>a,e,w,n,s</TT>.
</TD></TR>
<TR><TD WIDTH=277>
<PRE>
<B><FONT>m=manual,</FONT></B><I><FONT>srcpx</FONT></I><FONT>,<I>srcpy</I>,
</FONT><I>destpx</I>,<I>destpy</I>
</PRE>

</TD><TD WIDTH=387>The manual mode takes four parameters that explicitly specify anchoring of the ends of the arrow: <I>srcpx</I>, <I>srcpy</I>, <I>destpx</I>, <I>destpy</I>. Each value is a percentage of the width/height of the source/destination module's enclosing rectangle, with the upper-left corner being the origin. Thus, 
<P>
<TT>m=m,50,50,50,50</TT>
<P>
would connect the centers of the two module rectangles.
</TD></TR>
<TR><TD WIDTH=277><PRE>
<B><FONT>o=</FONT></B><I><FONT>color</FONT></I><B><FONT>,</FONT></B><I><FONT>width</FONT></I>
</PRE>

</TD><TD WIDTH=387>Specifies the appearance of the arrow. Any valid Tk color specification is accepted: English color names or #rgb, #rrggbb speficication (where r,g,b are hex digits).<P>
Defaults: <I>color</I>=black, <I>width</I>=2
</TD></TR>
</TABLE>
<P>
<P>
Examples:
<PRE>
<FONT>&quot;m=a;o=blue,3&quot;
</FONT>
</PRE>
<H2><A NAME="_Toc473901733">GNED -- Graphical NED Editor</A></H2>
<P>
The GNED editor allows you to design compound modules graphically.
GNED works with NED files - it doesn't use any nasty internal
file format. You can load any of your existing NED files, edit
the compound modules in it graphically and then save the file
back. The rest of the stuff in the NED file (simple modules, channels,
networks etc.) will survive the operation. GNED puts all graphics-related
data into display strings.
<P>
GNED works by parsing your NED file into an internal data structure,
and regenerating the NED text when you save the file. One consequence
of this is that indentation will be &quot;canonized&quot; -- hopefully
you consider this fact as a plus and not as a minus. Comments
in the original NED are preserved -- the parser associates them
with the NED elements they belong to, so comments won't be messed
up even if you edit the graphical representation to death by removing/adding
submodules, gates, parameters, connections, etc.
<P>
GNED is now a fully two-way visual tool. While editing the graphics,
you can always swich to NED source view, edit in there and switch
back to graphics. Your changes in the NED source will be immediately
backparsed to graphics; in fact, the graphics will be totally
reconstructed from the NED source and the display strings in it.
<P>
GNED is still under development. There are some missing functions
and bugs, but overall it should be fairly reliable. See the TODO
file in the GNED source directory for problems and missing features.
<P>
<B>Comment parsing:</B>
<P>
It is useful to know how exactly GNED identifies the comments
in the NED file. The following (maybe a bit long) NED code should
explain it:
<PRE>
<FONT>// ---------------------------------------------------------------
</FONT>// File: sample.ned
//
// This is a file comment. File comments reach from the top of 
// the file till the last blank line above the first code line.
// ---------------------------------------------------------------

//
// The file comment can also contain blank lines, so this is 
// still part of the above file comment.
//

// Module1 --
//
// This is a banner comment for the Module1 declaration below.
// Banner comments can be multi-line, but they are not supposed 
// to contain blank lines. (Otherwise the lines above the blank 
// one will be taken as part of a file comment or trailing comment.)
//
module Module1
    submodules: // and this is right-comment
        // This is another banner comment, for the submodule
        submod1: Module;
            display: &quot;p=120,108;b=96,72,rect&quot;;
    connections:
        out --&gt; submod1.in; // Right-comments can also be
                            // multi-line.
endmodule

// Finally, this is a trailing comment, belonging to the above
// module. It may contain blank lines. Trailing comments are 
// mostly used to put separator lines into the file, like this:
// --------------------------------------------------------------

// Module2 --
//
// an empty module
//
module Module2
endmodule
</PRE>
<P>
<B>Key/mouse bindings:</B>
<P>
In graphics view, there are two editing modes: draw and select/mode.
The mouse bindings are the following:
<TABLE BORDER=1>
<TR><TD WIDTH=301><B>Mouse</B></TD><TD WIDTH=288><B>Effect</B>
</TD></TR>
<TR><TD WIDTH=301><B>In <I>draw</I> mode:</B></TD><TD WIDTH=288>
</TD></TR>
<TR><TD WIDTH=301>Drag out a rectangle in empty area:</TD><TD WIDTH=288>create new submodule
</TD></TR>
<TR><TD WIDTH=301>Drag from one submodule to another:</TD><TD WIDTH=288>create new connection
</TD></TR>
<TR><TD WIDTH=301>Click in empty area:</TD><TD WIDTH=288>switch to select/move mode
</TD></TR>
<TR><TD WIDTH=301><B>In <I>select/move</I> mode:</B></TD><TD WIDTH=288>
</TD></TR>
<TR><TD WIDTH=301>Click submodule/connection:</TD><TD WIDTH=288>select it
</TD></TR>
<TR><TD WIDTH=301>Ctrl-click submodule/conn.:</TD><TD WIDTH=288>add to selection
</TD></TR>
<TR><TD WIDTH=301>Click in empty area:</TD><TD WIDTH=288>clear selection
</TD></TR>
<TR><TD WIDTH=301>Drag a selected object:</TD><TD WIDTH=288>move selected objects
</TD></TR>
<TR><TD WIDTH=301>Drag submodule or connection:</TD><TD WIDTH=288>move it
</TD></TR>
<TR><TD WIDTH=301>Drag either end of connection:</TD><TD WIDTH=288>move that end
</TD></TR>
<TR><TD WIDTH=301>Drag corner of (sub)module:</TD><TD WIDTH=288>resize module
</TD></TR>
<TR><TD WIDTH=301>Drag starting in empty area:</TD><TD WIDTH=288>select enclosed submodules/connections
</TD></TR>
<TR><TD WIDTH=301><I>Del</I> key</TD><TD WIDTH=288>delete selected objects
</TD></TR>
<TR><TD WIDTH=301><B>Both editing modes:</B></TD><TD WIDTH=288>
</TD></TR>
<TR><TD WIDTH=301>Right-click on module/submodule/connection:
</TD><TD WIDTH=288>popup menu</TD></TR>
<TR><TD WIDTH=301>Double-click on submodule:</TD><TD WIDTH=288>go into submodule
</TD></TR>
<TR><TD WIDTH=301>Click name label</TD><TD WIDTH=288>edit name
</TD></TR>
<TR><TD WIDTH=301>Drag&amp;drop module type from the tree view to the canvas
</TD><TD WIDTH=288>create a submodule of that type</TD></TR>
</TABLE>
<HR><H1><A NAME="_Toc473901734">Simple Modules</A></H1>
<P>
The activities of simple modules are implemented by the user.
The algorithms are programmed in C++, using the OMNeT++ class
library. The following sections contain a short introduction to
discrete event simulation in general, how its concepts are implemented
in OMNeT++, and gives an overview and practical advice on how
to design and code simple modules.
<H2><A NAME="_Toc473901735">Simulation concepts</A></H2>
<P>
This section contains a very brief introduction into how Discrete
Event Simulation (DES) works, in order to introduce terms we'll
use when explaining OMNeT++ concepts and implementaton. If you're
familiar with DES, you can skip this section.
<H3><A NAME="_Toc473901736">Discrete Event Simulation</A></H3>
<P>
A <I>Discrete Event System</I> is a system where state changes
(events) happen at discrete points of time, and events take zero
time to happen. It is assumed that nothing (i.e. nothing interesting)
happens between two consecutive events, that is, no state change
takes place in the system between the events (in contrast to <I>continuous</I>
systems where state changes are continuous). Those systems that
can be viewed as Discrete Event Systems can be modeled using Discrete
Event Simulation. (Continuous systems are modelled using differential
equations and suchlike.)
<P>
For example, computer networks are usually viewed as discrete
event systems. Some of the events are:
<UL>
<LI>start of a packet transmission
<LI>end of a packet transmission
<LI>expiry of a retransmission timeout
</UL>
<P>
This implies that between two events such as &quot;start of a
packet transmission&quot; and &quot;end of a packet transmission&quot;,
nothing interesting happens. That is, the packet's state remains
&quot;being transmitted&quot;. Note that the definition of events
and states always depends on the intent and purposes of the person
doing the modelling. If we were interested in the transmission
of individual bits, we would have included something like &quot;start
of bit transmission&quot; and &quot;end of bit transmission&quot;
among our events.
<P>
The time when events occur is often called <I>event timestamp</I>;
with OMNeT++ we'll say <I>arrival time</I> (because in the class
library, the word &quot;timestamp&quot; is reserved for a user-settable
attribute in the event class). Time within the model is often
called <I>simulation time</I>, <I>model time</I> or <I>virtual
time</I> as opposed to real time or CPU time or which refers to
how long the simulation program has been running or how much CPU
time it has consumed.
<H3><A NAME="_Toc473901737">The event loop</A></H3>
<P>
Discrete event simulations maintain a set of future events, in
a data structure often called FES (Future Event Set). Such simulators
usually work according to the following pseudocode:
<P>
<I>initialize -- this includes building the model and inserting
initial events to FES</I>
<P>
<I>while (FES not empty and simulation not yet complete)</I>
<P>
<I>{</I>
<P>
<I> retrieve first event from FES</I>
<P>
<I> t:= timestamp of this event</I>
<P>
<I> <B>process event</B> (processing may insert new events in
FES or delete existing ones)</I>
<P>
<I>}</I>
<P>
<I>finish simulation (write statistical results, etc.)<BR>
</I>
<P>
The first, initialization step usually builds the data structures
representing the simulation model, calls any user-defined initialization
code, and inserts initial events into the FES to ensure that the
simulation can start. Initialization strategy can be quite different
from one simulator to another.
<P>
The subsequent loop consumes events from the FES and processes
them. Events are processed in strict timestamp order in order
to maintain causality, that is, to ensure that no event may have
an effect on earlier events.
<P>
Processing an event involves calls to user-supplied code. For
example, using the computer network simulation example, processing
a &quot;timeout expired&quot; event may consist of re-sending
a copy of the network packet, updating the retry count, scheduling
another &quot;timeout&quot; event, and so on. The user code may
also remove events from the FES, for example when cancelling timeouts.
<P>
Simulation stops when there are no more events left (this happens
rarely in practice), or when it isn't necessary for the simulation
to run further because the model time or the CPU time has reached
a given limit, or because the statistics have reached the desired
accuracy. At this time, before the program exits, the simulation
programmer will typically want to record statistics into output
files.
<H3><A NAME="_Toc473901738">Simple modules in OMNeT++</A></H3>
<P>
The user creates simple module types are by subclassing the <TT>cSimpleModule</TT>
class, which is part of the OMNeT++ class library. <TT>cSimpleModule</TT>,
just as <TT>cCompoundModule</TT>, is derived from a common base
class, <TT>cModule</TT>.
<P>
<TT>cSimpleModule</TT>, although stuffed with simulation-related
functionality, doesn't do anything useful by itself. The simulation
programmer has to redefine some virtual member functions to make
it do useful work.
<P>
These member functions are the following:
<UL>
<LI><TT>void initialize()</TT>
<LI><TT>void activity()</TT>
<LI><TT>void handleMessage(cMessage *msg)</TT>
<LI><TT>void finish()</TT>
</UL>
<P>
<P>
In the initialization step, OMNeT++ builds the network: it creates
the necessary simple and compound modules and connects them according
to the NED definitions. OMNeT++ also calls the <TT>initialize()</TT>
functions of all modules.
<P>
The <TT>activity()</TT> and <TT>handleMessage()</TT> functions
are called during event processing. This means that the user will
implement the model's behavior in these functions. <TT>Activity()</TT>
and <TT>handleMessage()</TT> implement different event processing
strategies: for each simple module, the user has to redefine exactly
one of these functions. <TT>activity()</TT> is a coroutine-based
solution which implements the process interaction approach (coroutines
are non-preemptive [cooperative] threads),  and <TT>handleMessage()</TT>
is a function called for each event. Modules written with these
functions can be freely mixed within a simulation model, so you
can choose per-module basis.
<P>
The <TT>finish()</TT> functions are called when the simulation
terminates successfully. It is the place of writing statistics.
<P>
All these functions will be discussed later in detail.
<H3><A NAME="_Toc473901739">Events in OMNeT++</A></H3>
<P>
OMNeT++ uses messages to represent events. Each event is represented
by an instance of the <TT>cMessage</TT> class or one its subclasses;
there is no separate event class. Messages are sent from one module
to another -- this means that the place where the &quot;event
will occur&quot; is the <I>message's destination module</I>, and
the model time when the event occurs is the <I>arrival time</I>
of the message. Events like &quot;timeout expired&quot; are implemented
with the module sending a message to itself.
<P>
Simulation time in OMNeT++ is stored in the C++ type <TT>simtime_t</TT>,
which is a typedef for <TT>double</TT>.
<P>
Events are consumed from the FES in arrival time order, to maintain
causality. More precisely, give two messages, the following rules
apply: 
<OL>
<LI>the message with <B>earlier arrival time</B> is executed first.
If arrival times are equal,
<LI>the one with <B>smaller priority value</B> is executed first.
If priorities are the same,
<LI>the one <B>scheduled or sent earlier</B> is executed first.
</OL>
<P>
<I>Priority</I> is an integer user-assigned attribute of messages.
<P>
Storing simulation time in <TT>double</TT>s may sometimes cause
inconveniences. Due to finite machine precision, two doubles calculated
in two different ways do not always compare equal even if they
theoretically should be. This means that if you want to explicitly
rely on the arrival times of two events being the same, you should
take care that simulation times which should be equal are calculated
in exactly the same way. Another possible approach is to avoid
equal arrival times, for example by adding/substracting small
values to schedule times to ensure specific execution order (<I>inorder_epsilon</I>).
<P>
We also thought about some <I>simtime_precision</I> parameter
in the simulation kernel that would force t<SUB>1</SUB> and t<SUB>2</SUB>
to be regarded equal if they are &quot;very close&quot; (if they
differ less than <I>simtime_precision</I>). However, it is not
at all clear how small <I>simtime_precision</I> should be; the
mechanism incurs some run-time overhead; and all in all I'm not
sure the whole thing would be of more benefit than trouble.
<H3><A NAME="_Toc473901740">FES implementation</A></H3>
<P>
The implementation of the FES is a crucial factor in the performance
of a discrete event simulator. In OMNeT++, the FES is implemented
with <I>binary heap</I>, the most widely used data stucture for
this purpose. Heap is also the best algorithm we know, although
exotic data structures like <I>skiplist</I> may perform better
than heap in some cases. In case you're interested, the FES implementation
is in the <TT>cMessageHeap</TT> class, but as a simulation programmer
you won't ever need to care about it.
<H2><A NAME="_Toc473901741">Defining simple module types</A></H2>
<H3><A NAME="_Toc473901742">Overview</A></H3>
<P>
The C++ implementation of a simple module consists of:
<UL>
<LI>declaration of the module class: your class subclassed from
<TT>cSimpleModule</TT> (either directly or indirectly)
<LI>a module type registration (<TT>Define_Module</TT> or <TT>Define_Module_Like</TT>
macro)
<LI>implementation of the module class
</UL>
<P>
For example, the C++ source for a Sliding Window Protocol implementation
might look like this:
<PRE>
<FONT>// file: swp.cc
</FONT>#include &lt;omnetpp.h&gt;

// module class declaration:
class SlidingWindow : public cSimpleModule
{
	Module_Class_Members( SlidingWindow,cSimpleModule,8192)
	virtual void activity();
};

// module type registration:
Define_Module( SlidingWindow );

// implementation of the module class:
void SlidingWindow::activity()
{
     int window_size = par(&quot;window_size&quot;);
     ...
}<BR>
</PRE>
<P>
In order to be able to refer to this simple module type in NED
files, we should have an associated NED declaration which might
look like this:
<PRE>
<FONT>// file: swp.ned
</FONT><B>simple</B> SlidingWindow
    <B>parameters</B>:
        window_size: <B>numeric const</B>;
    <B>gates</B>:
        <B>in:</B>  from_net, from_user;
        <B>out:</B> to_net,   to_user;
<B>endsimple
</B>
</PRE>
<H3><A NAME="_Toc473901743">The module declaration</A></H3>
<P>
The module declaration
<UL>
<LI>announces that you're going to use the class as a simple module
type
<LI>associates the module class with an interface declared in
NED
</UL>
<P>
<B>Forms of module declaration</B>
<P>
Module declarations can take two forms:
<P>
<TT>  Define_Module(<I><FONT>classname</FONT></I>);</TT>
<P>
<TT>  Define_Module_Like(<I><FONT>classname</FONT></I>,
<I><FONT>neddeclname</FONT></I>);</TT>
<P>
The first form associates the class (subclassed from <TT>cSimpleModule</TT>)
with the NED simple module declaration of the same name. For example,
the
<PRE>
<FONT>Declare_Module(SlidingWindow);
</FONT>
</PRE>
<P>
line would ensure that when you create an instance of <TT>SlidingWindow</TT>
in your NED files, the module has the parameters and gates given
in the <TT>simple</TT> <TT>SlidingWindow</TT> NED declaration,
and the implementation will be an instance of the <TT>SlidingWindow</TT>
C++ class.
<P>
The second form associates the class with a NED simple module
declaration of a different name.<TT><I><FONT>
</FONT></I></TT>You can use this form when you have several modules
which share the same interface. This feature will be discussed
in detail in the next section.
<P>
<B>Header files</B>
<P>
Module declarations should not be put into header files, because
they are macros expanding to lines for which the compiler generates
code.
<P>
<B>Compound modules</B>
<P>
All module types (including compound modules) need to have module
declarations. For all compound modules, the NEDC compiler generates
the <TT>Define_Module(..)</TT> lines automatically. However, it
is your responsibility to put <TT>Define_Module(..)</TT> lines
into one of the C++ sources for all your simple module types.
<P>
<B>Implementation</B>
<P>
Unless you are dying to learn about the dirty internals, you may
just as well skip this section. But if you're interested, here
it is: <TT>Define_Module</TT> (and also <TT>Define_Module_Like</TT>)
is a macro which expands to a function definition plus the definition
of a global object, something like this ugly code (luckily, you
won't ever need to be interested in it):
<PRE>
<FONT>static cModule *<I>MyClass</I>__create(char *name, cModule *parentmod ) {
</FONT>     return (cModule *) new <I>MyClass</I><FONT>(name, parentmod);
</FONT>}
cModuleType <I>MyClass</I>__type(&quot;<I>MyClass</I>&quot;,&quot;<I>MyClass&quot;</I>, 
                          (ModuleCreateFunc)<I>MyClass</I>__create);
</PRE>
<P>
The <TT>cModuleType</TT> object can act as a factory: it is able
to create an instance of the given module type. This, together
with the fact that all <TT>cModuleType</TT> objects are available
in a single linked list,  allows OMNeT++ to instantiate module
types given only their class names as strings, without having
to include the class declaration into any other C++ source.
<P>
The global object also stores the name of the NED interface associated
with the module class. The interface description object (another
object, generated by nedc) is looked up automatically at network
construction time. Whenever a module of the given type is created,
it will automatically have the parameters and gates specified
in the associated interface description.
<H3><A NAME="_Toc473901744">Several modules, single NED interface</A>
</H3>
<P>
Suppose you have three different C++ module classes (<TT>TokenRing_MAC</TT>,
<TT>Ethernet_MAC</TT>, <TT>FDDI_MAC</TT>) which have identical
gates and parameters. Then you can create a single NED declaration,
<TT>General_MAC</TT>  for them and write the following module
declarations in the C++ code:
<PRE>
<FONT>Define_Module_Like( TokenRing_MAC, General_MAC);
</FONT>Define_Module_Like( Ethernet_MAC, General_MAC);
Define_Module_Like( FDDI_MAC, General_MAC);
</PRE>
<P>
In this case, you won't be able to directly refer to the <TT>TokenRing_MAC</TT>,
<TT>Ethernet_MAC</TT>, <TT>FDDI_MAC</TT> module types in your
NED files. For example, you cannot write
<PRE>
<FONT>module PC
</FONT>    submodules:
        mac: Ethernet_MAC; // error: Ethernet_MAC not defined
    ...
endmodule
</PRE>
<P>
However, you can pass the module type in a string-valued parameter
to the compound module:
<PRE>
<FONT>module PC
</FONT>    parameters:
        mac_type: string;
    submodules:
        mac: mac_type like General_MAC; // OK!
    ...
endmodule
</PRE>
<P>
The <TT>mac_type</TT> parameter should take the value <TT>&quot;TokenRing_MAC&quot;</TT>,
<TT>&quot;Ethernet_MAC&quot;</TT> or<TT> &quot;FDDI_MAC&quot;</TT>,
and a submodule of the appropriate type will be created. The value
for the parameter can even be given in the ini file. This gives
you a powerful tool to customize simulation models (see also <I>Topology
templates</I> from the NED chapter).
<H3><A NAME="_Toc473901745">The class declaration</A></H3>
<P>
As mentioned before, simple module classes have to be derived
from <TT>cSimpleModule</TT> (either directly or indirectly). In
addition to overwriting some of the previously mentioned four
member functions (<TT>initialize(),activity(),handleMessage(),finish()</TT>),
you have to write a constructor and some more functions. Some
of this task can be automated, so when writing the C++ class declaration,
you have two choices:
<OL>
<LI>either use a macro which expands to the &quot;stock&quot;
version of the functions
<LI>or write them yourself.
</OL>
<P>
<B>Using macro to declare the constructor</B>
<P>
If you choose the first solution, you use the <TT>Module_Class_Members()</TT>
macro:
<PRE>
<FONT>Module_Class_Members( <I>classname</I>, <I>baseclass</I>, <I>stacksize</I>);
</FONT>
</PRE>
<P>
The first two arguments are obvious (<TT><I><FONT>baseclass</FONT></I></TT>
is usually <TT>cSimpleModule</TT>), but <TT><I><FONT>stacksize</FONT></I></TT>
needs some explanation. If you use <TT>activity()</TT>, the module
code runs as a coroutine, so it will need a separate stack. (This
will be discussed in detail later.)
<P>
As an example, the class declaration
<PRE>
<FONT>class SlidingWindow : public cSimpleModule
</FONT>{
	Module_Class_Members( SlidingWindow,cSimpleModule,8192)
	...
};
</PRE>
<P>
expands to something like this:
<PRE>
<FONT>class SlidingWindow : public cSimpleModule
</FONT>{
  public:
    SlidingWindow(char *name, cModule *parentmodule,
                                unsigned stacksize = 8192) :
          cSimpleModule(name, parentmodule, stacksize) {}
    virtual char *className() {return &quot;SlidingWindow&quot;;}
    ...
};
</PRE>
<P>
<B>Expanded form of the constructor</B>
<P>
You will implement:
<UL>
<LI>a constructor with the argument list: <TT>(char *name, cModule
*parentmodule, unsigned stacksize = <I><FONT>stacksize</FONT></I>)</TT>
<LI>a <TT>className()</TT> function which returns the name of
the class as <TT>char*</TT>
</UL>
<P>
The advantage is that you get full control over the constructor,
so you can initialize data members of the class (if you have any).
You should not change the number or types of the arguments taken
by the constructor, because it is called by OMNeT++-generated
code. Also, remember to overwrite the <TT>className()</TT> function.
<P>
An example:
<PRE>
<FONT>class TokenRing_MAC : public cSimpleModule
</FONT>{
  public:
    cQueue queue;  // a data member
    TokenRing_MAC(char *name, cModule *parentmodule,
                                unsigned stacksize = 8192);
    virtual char *className() {return &quot;TokenRing_MAC&quot;;}
    ...
};

TokenRing_MAC(char *name, cModule *parentmodule, unsigned stacksize) :
  cSimpleModule(name, parentmodule, stacksize),
  queue(&quot;queue&quot;)  // initialize data member
{
}
</PRE>
<P>
<B>Stack size decides between activity() and handleMessage()</B>
<UL>
<LI>if the specified stack size is zero, <TT>handleMessage()</TT>
will be used;
<LI>if it is greater than zero, <TT>activity()</TT> will be used.
</UL>
<P>
If you make mistake (e.g. you forget to set zero stack size for
a <TT>handleMessage()</TT> simple module): the default versions
of the functions issue error messages telling you what is the
problem.
<H3><A NAME="_Toc473901746">Decomposing activity() or handleEvent()
and inheritance</A></H3>
<P>
It is usually a good idea to decompose a <TT>activity()</TT> or
<TT>handleEvent()</TT> function when it grows too large. &quot;Too
large&quot; is a matter of taste of course, but you should definitely
consider splitting up the function if it is more that a few screens
(say 50-100 lines) long. This will have a couple of advantages:
<UL>
<LI>will help future readers of the code understand your program;
<LI>will help <I>you</I> understand what it is you're really programming
and bring some structure into it;
<LI>will enable you to customize the class by inheriting from
it and overwriting member functions
</UL>
<P>
If you have variables which you want to access from all member
functions (typically state variables are like that), you'll need
to add those variables to the class as data members.
<P>
Let's see an example:
<PRE>
<FONT>class TransportProtocol : public cSimpleModule
</FONT>{
  public:
    Module_Class_Members(TransportProtocol, cSimpleModule,8192)

    int window_size;
    int n_s;   // N(s)
    int n_r;   // N(r)
    cOutVector eedVector;
    cStdDev eedStats;
    //...

    virtual void activity();
    virtual void recalculateTimeout();
    virtual void insertPacketIntoBuffer(cMessage *packet);
    virtual void resendPacket(cMessage *packet);
    //...
};

Define_Simple_Module( TransportProtocol );

void TransportProtocol::activity()
{
    window_size = par(&quot;window_size&quot;);
    n_s = n_r = 0;
    eedVector.setName(&quot;End-to-End Delay&quot;);
    eedStats.setName(&quot;eedStats&quot;);
    //...
}

//...
</PRE>
<P>
Note that you may have to use the expanded form of the constructor
(instead of <TT>Module_Class_Members()</TT>) to pass arguments
to the constructors of member objects like <TT>eedVector</TT>
and <TT>eedStats</TT>. But most often you don't need to go as
far as that; for example, you can set parameters later from <TT>activity()</TT>,
as shown in the example above.
<P>
To implement another variant of the Transport Protocol which uses
a different timeout scheme, you could simply subclass <TT>TransportProtocol</TT>:
<PRE>
<FONT>class AdvancedTransportProtocol : public TransportProtocol
</FONT>{
  public:
    Module_Class_Members(AdvanvancedTransportProtocol,
                                              TransportProtocol, 8192)
    virtual void recalculateTimeout();
};

Define_Simple_Module( AdvancedTransportProtocol );

void AdvancedTransportProtocol::recalculateTimeout()
{
    //...
}
</PRE>
<H2><A NAME="_Toc473901747">Adding functionality to cSimpleModule</A>
</H2>
<P>
This section discusses <TT>cSimpleModule's</TT> four previously
mentioned member functions, intended to be redefined by the user:
<TT>initialize()</TT>, <TT>activity()</TT>, <TT>handleMessage()</TT>
and<TT> finish()</TT>.
<H3><A NAME="_Toc473901748">activity()</A></H3>
<P>
<B>Process-style description</B>
<P>
With <TT>activity()</TT>, you can code the simple module much
like you would code an operating system process or a thread. You
can wait for an incoming message (event) at any point of the code,
you can suspend the execution for some time (model time!), etc.
When the <TT>activity()</TT> function exits, the module is terminated.
(The simulation can continue if there are other modules which
can run.) 
<P>
The most important functions you can use in <TT>activity()</TT>
are (they will be discussed in detail later):
<UL>
<LI><TT>receive..()</TT> family of functions -- to receive messages
(events)
<LI><TT>wait()</TT> -- to suspend execution for some time (model
time)
<LI><TT>send()</TT> family of functions -- to send messages to
other modules
<LI><TT>scheduleAt()</TT> -- to schedule an event (the module
&quot;sends a message to itself&quot;)
<LI><TT>cancelEvent()</TT> -- to delete an event scheduled with
<TT>scheduleAt()</TT>
<LI><TT>end()</TT> -- to finish execution of this module (same
as exiting the <TT>activity()</TT> function)
</UL>
<P>
The <TT>activity()</TT> function normally contains an infinite
loop, with at least a <TT>wait()</TT> or <TT>receive()</TT> call
in its body.
<P>
Examples:
<P>
TBD
<P>
<B>Application area</B>
<P>
One area where the process-style description is especially convenient
is when the process has many states but transitions are very limited,
ie. from any state the process can only go to one or two other
states. For example, this is the case when programming a network
application which uses a single network connection. The pseudocode
of the application which talks to a transport layer protocol might
look like this:
<P>
<I>activity()</I>
<P>
<I>{</I>
<P>
<I> while(true)</I>
<P>
<I> {</I>
<P>
<I>  open connection by sending OPEN command to transport layer</I>
<P>
<I>  receive reply from transport layer</I>
<P>
<I>  if (open not successful)</I>
<P>
<I>  {</I>
<P>
<I>   wait(some time)</I>
<P>
<I>   continue  // loop back to while()</I>
<P>
<I>  }</I>
<P>
<I>  </I>
<P>
<I>  while(there's more to do)</I>
<P>
<I>  {</I>
<P>
<I>   send data on network connection</I>
<P>
<I>   if (connection broken)</I>
<P>
<I>   {</I>
<P>
<I>    continue outer loop  // loop back to outer while()</I>
<P>
<I>   }</I>
<P>
<I>   wait(some time)</I>
<P>
<I>   receive data on network connection</I>
<P>
<I>   if (connection broken)</I>
<P>
<I>   {</I>
<P>
<I>    continue outer loop  // loop back to outer while()</I>
<P>
<I>   }</I>
<P>
<I>   wait(some time)</I>
<P>
<I>  }</I>
<P>
<I>  close connection by sending CLOSE command to transport layer</I>
<P>
<I>  if (close not successful)</I>
<P>
<I>  {</I>
<P>
<I>   // handle error</I>
<P>
<I>  }</I>
<P>
<I>  wait(some time)</I>
<P>
<I> }</I>
<P>
<I>}<BR>
</I>
<P>
If you want to handle several connections simultaneously, you
may dynamically create as instances of the simple module above
as needed. Dynamic module creation will be discussed later.
<P>
<B>Activity() is run as a coroutine</B>
<P>
<TT>Activity()</TT> is run in a coroutine. Coroutines are a sort
of threads which are scheduled non-preemptively (this is also
called cooperative multitasking). From one coroutine you can switch
to another coroutine by a <I>transferTo(otherCoroutine)</I> call.
Then this coroutine is suspended and <I>otherCoroutine</I> will
run. Later, when <I>otherCoroutine</I> does a <I>transferTo(firstCoroutine)</I>
call, execution of the first coroutine will resume from the point
of the <I>transferTo(otherCoroutine) </I>call. The full state
of the coroutine, including local variables are preserved while
the thread of execution is in another coroutines. This implies
that each coroutine must have an own processor stack, and <I>transferTo()</I>
involves a switch from one processor stack to another.
<P>
Coroutines are at the heart of OMNeT++, and the simulation programmer
doesn't ever need to call <I>transferTo()</I> or other functions
in the coroutine library, nor does he need to care about the coroutine
library implementation. But it is important to understand how
the event loop found in discrete event simulators works with coroutines.
<P>
When using coroutines, the event loop looks like this (simplified):
<P>
<I>while (FES not empty and simulation not yet complete)</I>
<P>
<I>{</I>
<P>
<I> retrieve first event from FES</I>
<P>
<I> t:= timestamp of this event</I>
<P>
<I> <B>transferTo(module containing the event)</B></I>
<P>
<I>}<BR>
</I>
<P>
That is, when the module has an event, the simulation kernel transfers
the control to the module's coroutine. It is expected that when
the module &quot;decides it has finished the processing of the
event&quot;, it will transfer the control back to the simulation
kernel by a <I>transferTo(main)</I> call. Initially, simple modules
using <TT>activity()</TT> are &quot;booted&quot; by events (<I>&quot;starter
messages&quot;</I>) inserted into the FES by the simulation kernel
before the start of the simulation.
<P>
How does the coroutine know it has &quot;finished processing the
event&quot;? The answer: <I>when it requests another event</I>.
The functions which request events from the simulation kernel
are the <TT>receive..()</TT> family and <TT>wait()</TT>, so their
implementations contain a <I>transferTo(main)</I> call somewhere.
<P>
Their pseudocode, as implemented in OMNeT++:
<P>
<I>receiveNew()   // other receive...() variations are similar</I>
<P>
<I>{</I>
<P>
<I> transferTo(main)</I>
<P>
<I> retrieve current event</I>
<P>
<I> return the event  // remember: events = messages</I>
<P>
<I>}<BR>
</I>
<P>
<I>wait()</I>
<P>
<I>{</I>
<P>
<I> create an event e and schedule it at (current sim. time +
wait interval)</I>
<P>
<I> while(true) {</I>
<P>
<I>  transferTo(main)</I>
<P>
<I>  retrieve current event</I>
<P>
<I>  if (current event is e)</I>
<P>
<I>   break from loop</I>
<P>
<I>  else</I>
<P>
<I>   store current event for later use (in the &quot;put-aside
queue&quot;)</I>
<P>
<I> }</I>
<P>
<I> delete event e</I>
<P>
<I> return</I>
<P>
<I>}<BR>
</I>
<P>
Thus, the <TT>receive...()</TT> and <TT>wait()</TT> calls are
special points in the <TT>activity()</TT> function, because that's
where:
<UL>
<LI>simulation time elapses in the module, and
<LI>other modules get a chance to execute.
</UL>
<P>
<B>Starter messages</B>
<P>
Modules written with <TT>activity()</TT> need starter messages
to &quot;boot&quot;. These starter messages are inserted into
the FES automatically by OMNeT++ at the beginning of the simulation,
even before the <TT>initialize()</TT> functions are called.
<P>
<B>Coroutine stack size</B>
<P>
All the simulation programmer needs to care about coroutines is
to choose the processor stack size for them. This cannot be automated
(Eerrr... at least not without hardware support, some trick with
virtual memory handling).
<P>
8 or 16 kbytes is usually a good choice, but you may need more
if the module uses recursive functions or has local variables
which occupy a lot of stack space. OMNeT++ has a built-mechanism
that will usually detect if the module stack is too small and
overflows. OMNeT++ can also tell you how much stack space a module
actually uses, so you can find it out if you overestimated the
stack needs.
<P>
<B>initalize() and finish() with activity()</B>
<P>
Because local variables of <TT>activity()</TT> are preserved across
events, you can store everything (state information, packet buffers,
etc.) in them. Local variables can be initialized at the top of
the <TT>activity()</TT> function, so there isn't much need to
use <TT>initialize()</TT>.
<P>
However, you need <TT>finish()</TT> if you want to write statistics
at the end of the simulation. And because <TT>finish()</TT> cannot
access the local variables of <TT>activity()</TT>, you have to
put the variables and objects that contain the statistics into
the module class. You still don't need <TT>initialize()</TT> because
class members can also be initialized at the top of <TT>activity()</TT>.
<P>
Thus, a typical setup looks like this pseudocode:
<P>
<I>class MySimpleModule ...</I>
<P>
<I>{</I>
<P>
<I> ...</I>
<P>
<I> variables for statistics collection</I>
<P>
<I> activity();</I>
<P>
<I> finish();</I>
<P>
<I>};<BR>
</I>
<P>
<I>MySimpleModule::activity()</I>
<P>
<I>{</I>
<P>
<I> declare local vars and initialize them</I>
<P>
<I> initialize statistics collection variables</I>
<P>
<I> </I>
<P>
<I> while(true)</I>
<P>
<I> {</I>
<P>
<I>  ...</I>
<P>
<I> }</I>
<P>
<I>}<BR>
</I>
<P>
<I>MySimpleModule::finish()</I>
<P>
<I>{</I>
<P>
<I> record statistics into file</I>
<P>
<I>}<BR>
</I>
<P>
<B>Advantages and drawbacks</B>
<P>
Advantages:
<UL>
<LI><TT>initialize()</TT> not needed, state can be stored in local
variables of <TT>activity()</TT>
<LI>process-style description is a natural programming model in
many cases
</UL>
<P>
Drawbacks:
<UL>
<LI>memory overhead: stack allocation may unacceptably increase
the memory requirements of the simulation program if you have
several thousands or ten thousands of simple modules;
<LI>run-time overhead: switching between coroutines is somewhat
slower than a simple function call
</UL>
<P>
<B>Other simulators</B>
<P>
Coroutines are used by a number of other simulation packages:
<UL>
<LI>All simulation software which inherit from SIMULA (e.g. C++SIM)
are based on coroutines, although all in all the programming model
is quite different.
<LI>The simulation/parallel programming language Maisie and its
successor Parsec (from UCLA) also use coroutines (although implemented
on with &quot;normal&quot; preeemptive threads). The philosophy
is quite similar to OMNeT++. Parsec, being &quot;just&quot; a
programming language, has a more elegant syntax but much less
features than OMNeT++.
<LI>Many Java-based simulation libraries are based on Java threads.
</UL>
<H3><A NAME="_Toc473901749">handleMessage()</A></H3>
<P>
<B>Function called for each event</B>
<P>
The idea is that at each event we simply call a user-defined function
instead of switching to a coroutine that has <TT>activity()</TT>
running in it. The &quot;user-defined function&quot; is <TT>the
handleMessage(cMessage *msg)</TT> virtual member function of <TT>cSimpleModule</TT>;
the user has to redefine the function to make it do useful work.
Calls to <TT>handleMessage()</TT> occur in the main stack of the
program -- no coroutine stack is needed and no context switch
is done.
<P>
The <TT>handleMessage()</TT> function will be called for every
message that arrives at the module. The function should process
the message and return immediately after that. The simulation
time is potentially different in each call.  No simulation time
elapses within a call to <TT>handleMessage()</TT>.
<P>
The pseudocode of the event loop which is able to handle both
<TT>activity()</TT> and <TT>handleMessage()</TT> simple modules:
<P>
<I>while (FES not empty and simulation not yet complete)</I>
<P>
<I>{</I>
<P>
<I> retrieve first event from FES</I>
<P>
<I> t:= timestamp of this event</I>
<P>
<I> m:= module containing this event</I>
<P>
<I> if (m works with handleMessage())</I>
<P>
<I><B>  m-&gt;handleMessage( event )</B></I>
<P>
<I>else  // m works with activity()</I>
<P>
<I> transferTo( m )</I>
<P>
<I>}<BR>
</I>
<P>
Modules with <TT>handleMessage()</TT> are NOT started automatically:
the simulation kernel creates starter messages <I>only for modules
with </I><TT><I><FONT>activity()</FONT></I></TT>.
This means that you have to schedule self-messages from the <TT>initialize()</TT>
function if you want the <TT>handleMessage()</TT> simple module
to start working &quot;by itself&quot;, without first receiving
a message from other modules.
<P>
<B>Programming with handleMessage()</B>
<P>
To use the <TT>handleMessage()</TT> mechanism in a simple module,
you must specify<B> </B><I>zero stack size</I> for the module.
This is important, because this tells OMNeT++ that you want to
use <TT>handleMessage()</TT> and not <TT>activity()</TT>.
<P>
Message/event related functions you can use in <TT>handleMessage()</TT>:
<UL>
<LI><TT>send()</TT> family of functions -- to send messages to
other modules
<LI><TT>scheduleAt()</TT> -- to schedule an event (the module
&quot;sends a message to itself&quot;)
<LI><TT>cancelEvent()</TT> -- to delete an event scheduled with
<TT>scheduleAt()</TT>
</UL>
<P>
You cannot use the <TT>receive...()</TT> family and <TT>wait()</TT>
functions in<TT> handleMessage()</TT>, because they are coroutine-based
by nature, as explained in the section about <TT>activity()</TT>.
You also cannot use <TT>end()</TT> because its job is to terminate
the coroutine.
<P>
You have to add data members to the module class for every piece
of information you want to preserve. This information cannot be
stored in local variables of <TT>handleMessage()</TT> because
they are destroyed when the function returns. Also, they cannot
be stored in static variables in the function (or the class),
because they would be shared between all instances of the class.
<P>
Data members to be added to the module class will typically include
things like:
<UL>
<LI>state (e.g. <TT>IDLE/BUSY</TT>, <TT>CONN_DOWN</TT>/<TT>CONN_ALIVE</TT>/...)
<LI>other variables which belong to the state of the module: retry
counts, packet queues, etc.
<LI>values retrieved/computed once and then stored: values of
module parameters, gate indices, routing information, etc.
<LI>pointers of message objects created once and then reused for
timers, timeouts, etc.
<LI>variables/objects for statistics collection
</UL>
<P>
You can initialize these variables from the <TT>initialize()</TT>
function. The constructor is not a very good place for this purpose
because it is called in the network setup phase when the model
is still under construction, so a lot of information you may want
to use is not yet available then.
<P>
Another task you have to do in <TT>initialize()</TT> is to schedule
initial event(s) which trigger the first call(s) to <TT>handleMessage()</TT>.
After the first call, <TT>handleMessage()</TT> must take care
to schedule further events for itself so that the &quot;chain&quot;
is not broken. Scheduling events is not necessary if your module
only has to react to messages coming from other modules.
<P>
<TT>finish()</TT> is used in the normal way: to record statistics
information accumulated in data members of the class at the end
of the simulation.
<P>
<B>Application area</B>
<P>
There are two areas where handleMessage() is definitely a better
choice than activity():
<OL>
<LI>For modules which have to maintain little or no state information,
such as packet sinks.
<LI>Other good candidates are modules with a large state space
and many arbitrary state transition possibilities (i.e. where
there are many possible subsequent states for any state). Such
algorithms are difficult to program with <TT>activity()</TT>,
or the result is code which is better suited for <TT>handleMessage()</TT>
(see rule of thumb below). Most communication protocols are like
this.
</OL>
<P>
There's also a good rule of thumb. If your module, programmed
with <TT>activity()</TT>, looks like this:
<P>
<I>activity()</I>
<P>
<I>{</I>
<P>
<I>initialization code</I>
<P>
<I>while(true)</I>
<P>
<I>{</I>
<P>
<I> msg = receive();</I>
<P>
<I> arbitrary code which doesn't contain any receive() or wait()
calls</I>
<P>
<I>}</I>
<P>
<I>}<BR>
</I>
<P>
Then it can be trivially converted to <TT>handleMessage()</TT>:
<P>
<I>initialize()</I>
<P>
<I>{</I>
<P>
<I>initialization code</I>
<P>
<I>}<BR>
</I>
<P>
<I>handleMessage( msg )</I>
<P>
<I>{</I>
<P>
<I>arbitrary code which doesn't contain any receive() or wait()
calls</I>
<P>
<I>}<BR>
</I>
<P>
<B>Example 1: Simple traffic generators and sinks</B>
<P>
The code for simple packet generators and sinks programmed with
<TT>handleMessage()</TT>might be as simple as this:
<P>
<I>PacketGenerator::handleMessage(m)</I>
<P>
<I>{</I>
<P>
<I> create and send out packet</I>
<P>
<I> schedule m again to trigger next call to handleMessage  //
(self-message)</I>
<P>
<I>}<BR>
</I>
<P>
<I>PacketSink::handleMessage(m)</I>
<P>
<I>{</I>
<P>
<I> delete m</I>
<P>
<I>}<BR>
</I>
<P>
Note that <I>PacketGenerator</I> will need to redefine <TT>initialize()</TT>
to create <I>m</I> and schedule the first event.
<P>
The following simple module generates packets with exponential
inter-arrival time. (Some details in the source haven't been discussed
yet, but the code is probably understandable nevertheless.)
<PRE>
<FONT>class Generator : public cSimpleModule
</FONT>{
    Module_Class_Members(Generator,cSimpleModule,0) 
                                     // note zero stack size!
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module( Generator );

void Generator::initialize()
{
    // schedule first sending
    scheduleAt(simTime(), new cMessage);
}

void Generator::handleMessage(cMessage *msg)
{
    // generate &amp; send packet
    cMessage *pkt = new cMessage;
    send(pkt, &quot;out&quot;);

    // schedule next call
    scheduleAt(simTime()+exponential(1.0), msg);
}
</PRE>
<P>
<B>Example 2: Bursty traffic generator</B>
<P>
A bit more realistic example is to rewrite our <TT>Generator</TT>
to create packet bursts, each consisting of <TT>burst_length</TT>
packets.
<P>
We add some data members to the class: 
<UL>
<LI><TT>burst_length</TT> will store the parameter that specifies
how many packets a burst must contain,
<LI><TT>burst_ctr</TT> will count in how many packets are left
to be sent in the current burst.
</UL>
<P>
The code:
<PRE>
<FONT>class BurstyGenerator : public cSimpleModule
{
</FONT>    Module_Class_Members(Generator,cSimpleModule,0)
                                // note the zero stack size!

    int burst_length;
    int burst_ctr;

    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module( BurstyGenerator );

void BurstyGenerator::initialize()
{
    // init parameters and state variables
    burst_length = par(&quot;burst_length&quot;);
    burst_ctr = burst_length;

    // schedule first packet of first burst
    scheduleAt(simTime(), new cMessage);
}

void BurstyGenerator::handleMessage(cMessage *msg)
{
    // generate &amp; send packet
    cMessage *pkt = new cMessage;
    send(pkt, &quot;out&quot;);

    // if this was the last packet of the burst
    if (--burst_ctr == 0)
    {
       // schedule next burst
       burst_ctr = burst_length;
       scheduleAt(simTime()+exponential(5.0), msg);
    }
    else
    {
       // schedule next sending within burst
       scheduleAt(simTime()+exponential(1.0), msg);
    }
}
</PRE>
<P>
<B>Advantages and drawbacks</B>
<P>
Advantages:
<UL>
<LI>consumes less memory: no separate stack needed for simple
modules
<LI>fast: function call is faster than switching between coroutines
</UL>
<P>
Drawbacks:
<UL>
<LI>local variables cannot be used to store state information
<LI>need to redefine initialize()
<LI>programming model is inconvenient in some cases
</UL>
<P>
<B>Other simulators</B>
<P>
Many simulation packages use a similar approach, often topped
with something like a state machine (FSM) which hides the underlying
function calls. Such systems are:
<UL>
<LI>OPNET<SUP>(TM)</SUP> (MIL3, Inc.) which uses FSM's designed
using a graphical editor;
<LI>NetSim++ clones OPNET's approach;
<LI>SMURPH (University of Alberta) defines a (somewhat eclectic)
language to describe FSMs, and uses a precompiler to turn it into
C++ code;
<LI>Ptolemy (UC Berkeley) uses a similar method.
</UL>
<P>
OMNeT++'s FSM support is described in the next section.
<H3><A NAME="_Toc473901750">initialize() and finish()</A></H3>
<P>
<B>Purpose</B>
<P>
<TT>initialize()</TT> - to provide place for any user setup code
<P>
<TT>finish()</TT> - to provide place where the user can record
statistics after the simulation has completed
<P>
<B>When and how they are called</B>
<P>
The <TT>initialize()</TT> functions of the modules are invoked
<I>before</I> the first event is processed, but <I>after</I> the
initial events (starter messages) have been placed into the FES
by the simulation kernel. 
<P>
Both simple and compound modules have <TT>initialize()</TT> functions.
A compound module has its <TT>initialize()</TT> function called
<I>before</I> all its submodules have.
<P>
The <TT>finish()</TT> functions are called when the event loop
has terminated, and only if it terminated normally (i.e. not with
a runtime error). The calling order is the reverse as with <TT>initialize()</TT>:
first submodules, then the containing compound module. (The bottom
line is that in the moment there's no &quot;official&quot; possibility
to redefine <TT>initialize()</TT> and <TT>finish()</TT> for compound
modules; the unofficial way is to write into the nedc-generated
C++ code. Future versions of OMNeT++ will support adding these
functions to compound modules.)
<P>
This is summarized in the following pseudocode (although you won't
find this code &quot;as is&quot; in the simulation kernel sources):
<P>
<I>perform simulation run:</I>
<P>
<I> build network (i.e. the system module and its submodules recursively)</I>
<P>
<I> insert starter messages for all submodules using activity()</I>
<P>
<I> do callInitialize() on system module</I>
<P>
<I> </I>
<P>
<I> enter event loop  // (described earlier)<BR>
</I>
<P>
<I> if (event loop terminated normally)   // i.e. not with a runtime
error</I>
<P>
<I>  do callFinish() on system module</I>
<P>
<I> clean up<BR>
</I>
<P>
<I>callInitialize()</I>
<P>
<I>{</I>
<P>
<I> call to user-defined initialize() function</I>
<P>
<I> if (module is compound)</I>
<P>
<I>  for (each submodule)</I>
<P>
<I>   do callInitialize() on submodule</I>
<P>
<I>}<BR>
</I>
<P>
<I>callFinish()</I>
<P>
<I>{</I>
<P>
<I> if (module is compound)</I>
<P>
<I>  for (each submodule)</I>
<P>
<I>   do callFinish() on submodule</I>
<P>
<I> call to user-defined finish() function</I>
<P>
<I>}<BR>
</I>
<P>
<B>initialize() vs. constructor</B>
<P>
Usually you should not put simulation-related code into the simple
module constructor. For example, modules often need to investigate
their surroundings (maybe the whole network) at the beginning
of the simulation and save the collected info into internal tables.
Code like that cannot be placed into the constructor since the
network is still being set up when the constructor is called.
<P>
<B>finish() vs. destructor</B>
<P>
Keep in mind that <TT>finish()</TT> is not always called, so it
isn't a good place for cleanup code which should run every time
the module is deleted. <TT>finish()</TT> is only a good place
for writing statistics, result post-processing and other stuff
which are to run only on successful completion.
<P>
Cleanup code should go into the desctructor. But in fact, you
almost never need to write a destructor because OMNeT++ keeps
track of objects you create and disposes of them automatically
(sort of automatic garbage collection). However it cannot track
objects not derived from cObject (see later),  so they may need
to be deleted manually from the destructor.
<P>
<B>&quot;end-of-simulation event&quot;</B>
<P>
The task of <TT>finish()</TT> is solved in many simulators (e.g.
OPNET) by introducing a special <I>end-of-simulation</I> event.
This is not a very good practice because the simulation programmer
has to code the algorithms (often FSMs) so that they can <I>always</I>
properly respond to end-of-simulation events, in whichever state
they are. This often makes program code unnecessarily complicated.
<P>
This fact is also evidenced in the design of the Parsec simulation
language (UCLA). Its predecessor Maisie used end-of-simulation
events, but -- as documented in the Parsec manual - this is led
to awkward programming in many cases, so for Parsec, end-of-simulation
events were dropped in favour of <TT>finish()</TT> (called <I>finalize()</I>
in Parsec).
<H2><A NAME="_Toc473901751">Finite State Machines in OMNeT++</A>
</H2>
<P>
<B>Overview</B>
<P>
Finite State Machines (FSMs) can make life with <TT>handleMessage()</TT>
easier. OMNeT++ provides a class and a set of macros to build
FSMs. OMNeT++'s FSMs work very much like OPNET's or SDL's.
<P>
The key points are:
<UL>
<LI>There are two kinds of states: <I>transient</I> and <I>steady</I>.
At each event (that is, at each call to <TT>handleMessage()</TT>),
the FSM transitions out of the current (<I>steady</I>) state,
undergoes a series of state changes (runs through a number of
<I>transient</I> states), and finally arrives at another <I>steady</I>
state. Thus between two events, the system is always in one of
the steady states. Transient states are therefore not really a
must - they exist only to group actions to be taken during a transition
in a convenient way.
<LI>You can assign program code to entering and leaving a state
(known as entry/exit code). Staying in the same state is handled
as leaving and re-entering the state.
<LI>Entry code should not modify the state (this is verified by
OMNeT++). State changes (transitions) must be put into the exit
code.
</UL>
<P>
OMNeT++'s FSMs <I>can</I> be nested. This means that any state
(or rather, its entry or exit code) may contain a further full-fledged
<TT>FSM_Switch</TT> (see below). This allows you to introduce
sub-states and thereby bring some structure into the state space
if it would become too large.
<P>
<B>The FSM API</B>
<P>
FSM state is stored in an object of type <TT>cFSM</TT>. The possible
states are defined by an <TT>enum</TT>; the <TT>enum</TT> is also
a place to tell which state is transient and which is steady.
In the following example, <TT>SLEEP</TT> and <TT>ACTIVE</TT> are
steady states and <TT>SEND</TT> is transient (the numbers in parens
must be unique within the state type and they are used for constructing
the numeric IDs for the states):
<PRE>
<FONT>enum {
</FONT>    INIT = 0,
    SLEEP = FSM_Steady(1),
    ACTIVE = FSM_Steady(2),
    SEND = FSM_Transient(1),
};
</PRE>
<P>
The actual FSM is embedded in a switch-like statement, <TT>FSM_Switch()</TT>,
where you have cases for entering and leaving each state:
<PRE>
<FONT>FSM_Switch(fsm)
</FONT>{
     case FSM_Exit(<I>state1</I>): 
         //...
         break;
     case FSM_Enter(<I>state1</I>): 
         //...
         break;
     case FSM_Exit(<I>state2</I>): 
         //...
         break;
     case FSM_Enter(<I>state2</I>): 
         //...
         break;
     //...
};
</PRE>
<P>
State transitions are done via calls to <TT>FSM_Goto()</TT>, which
simply stores the new state in the <TT>cFSM </TT>object:
<PRE>
<FONT>FSM_Goto(fsm,<I>newState</I>);
</FONT>
</PRE>
<P>
The FSM starts from the state with the numeric code 0; this state
is conventionally named <TT>INIT</TT>.
<P>
<B>Debugging FSMs</B>
<P>
If you <TT>#define</TT> <TT>FSM_DEBUG</TT> before including <TT>omnetpp.h</TT>,
each state transition will be logged to <TT>ev</TT>:
<PRE>
<FONT>#define FSM_DEBUG
</FONT>#include &lt;omnetpp.h&gt;
</PRE>
<P>
The actual printing is done through the <TT>FSM_Print()</TT> macro.
You might redefine it if you don't like what it currently does:
<PRE>
<FONT>#define FSM_Print(fsm,exiting) \
</FONT>    (ev &lt;&lt; &quot;FSM &quot; &lt;&lt; (fsm).name() \
        &lt;&lt; ((exiting) ? &quot;: exiting &quot; : &quot;: entering &quot;) \
        &lt;&lt; (fsm).stateName() &lt;&lt; endl)
</PRE>
<P>
<B>Implementation</B>
<P>
The <TT>FSM_Switch()</TT> is a macro. It expands to a <TT>switch()</TT>
statement embedded in a <TT>for()</TT> loop which repeats until
the FSM reaches a steady state. (The actual code is rather ugly,
but if you're dying to see it, it's in <TT>cfsm.h</TT>.)
<P>
Infinite loops are avoided by counting state transitions: if an
FSM goes through 64 transitions without reaching a steady state,
the simulation will terminate with an error message.
<P>
<B>An example</B>
<P>
Let us write another flavour of a bursty generator. It has two
states, SLEEP and ACTIVE. In the SLEEP state, the module does
nothing. In the ACTIVE state, it sends messages with a given inter-arrival
time. The code was taken from the <TT>fifo2</TT> sample simulation.
<PRE>
<FONT>#define FSM_DEBUG
</FONT>#include &lt;omnetpp.h&gt;

class BurstyGenerator : public cSimpleModule
{
  public:
    Module_Class_Members(BurstyGenerator,cSimpleModule,0)

    // parameters
    double sleepTimeMean;
    double burstTimeMean;
    double sendIATime;
    cPar *msgLength;

    // FSM and its states
    cFSM fsm;
    enum {
       INIT = 0,
       SLEEP = FSM_Steady(1),
       ACTIVE = FSM_Steady(2),
       SEND = FSM_Transient(1),
    };

    // variables used
    int i;
    cMessage *startStopBurst;
    cMessage *sendMessage;

    // the virtual functions
    virtual void initialize();
    virtual void handleMessage(cMessage *msg);
};

Define_Module( BurstyGenerator );

void BurstyGenerator::initialize()
{
    fsm.setName(&quot;fsm&quot;);

    sleepTimeMean = par(&quot;sleep_time_mean&quot;);
    burstTimeMean = par(&quot;burst_time_mean&quot;);
    sendIATime = par(&quot;send_ia_time&quot;);
    msgLength = &amp;par(&quot;msg_length&quot;);

    i = 0; 
    WATCH(i); // always put watches in initialize()
    startStopBurst = new cMessage(&quot;startStopBurst&quot;);
    sendMessage = new cMessage(&quot;sendMessage&quot;);

    scheduleAt(0.0,startStopBurst);
}

void BurstyGenerator::handleMessage(cMessage *msg)
{
    FSM_Switch(fsm)
    {
      case FSM_Exit(INIT):
        // transition to SLEEP state
        FSM_Goto(fsm,SLEEP);
        break;

      case FSM_Enter(SLEEP):
        // schedule end of sleep period (start of next burst)
        scheduleAt(simTime()+exponential(sleepTimeMean),
                   startStopBurst);
        break;

      case FSM_Exit(SLEEP):
        // schedule end of this burst
        scheduleAt(simTime()+exponential(burstTimeMean), 
                   startStopBurst);
        // transition to ACTIVE state:
        if (msg!=startStopBurst)
            error(&quot;invalid event in state ACTIVE&quot;);
        FSM_Goto(fsm,ACTIVE);
        break;

      case FSM_Enter(ACTIVE):
        // schedule next sending
        scheduleAt(simTime()+exponential(sendIATime), sendMessage);
        break;

      case FSM_Exit(ACTIVE):
        // transition to either SEND or SLEEP
        if (msg==sendMessage) {
            FSM_Goto(fsm,SEND);
        } else if (msg==startStopBurst) {
            cancelEvent(sendMessage);
            FSM_Goto(fsm,SLEEP);
        } else
            error(&quot;invalid event in state ACTIVE&quot;);
        break;

      case FSM_Exit(SEND):
      {
        // generate and send out job
        char msgname[32];
        sprintf( msgname, &quot;job-%d&quot;, ++i);
        ev &lt;&lt; &quot;Generating &quot; &lt;&lt; msgname &lt;&lt; endl;
        cMessage *job = new cMessage(msgname);
        job-&gt;setLength( (long) *msgLength );
        job-&gt;setTimestamp();
        send( job, &quot;out&quot; );
        
        // return to ACTIVE
        FSM_Goto(fsm,ACTIVE);
        break;
      }
    }
}
</PRE>
<H2><A NAME="_Toc473901752">Message transmission modeling</A>
</H2>
<P>
<B>Data rate modeling</B>
<P>
If data rate is specified for a connection, a message will have
a certain nonzero transmission time, depending on its length.
This means that when a message is sent out through an output gate,
the message &quot;reserves&quot; the gate for a given period (&quot;it
is being transmitted&quot;).
<P>
<CENTER><IMG SRC="img00009.gif"><BR>
Fig.5.1 Connection with a data rate</CENTER>
<P>
While a message is under transmission, other messages have to
wait until the transmission finishes. You can still use <TT>send()</TT>
while the gate is busy, but the message's arrival will be delayed;
just like the gate had an internal queue for the messages waiting
to be transmitted.
<P>
The OMNeT++ class library provides you with functions to check
whether a certain output gate is transmitting or to learn when
it finishes transmission.
<P>
If the connection with a data rate is not the immediate one connected
to the simple module's output gate but the second one in the route,
you have to check the second gate's busy condition. 
<P>
<B>Implementation of message sending</B>
<P>
Message sending is implemented in the following way: the arrival
time and the bit error flag of a message are calculated at once,
when the <TT>send()</TT> (or similar) function is invoked. That
is, if the message travels through several links until it reaches
its destination, it is <I>not</I> scheduled individually for each
link, but rather, every calculation is done once, within the <TT>send()</TT>
call. This implementation was chosen because of its run-time efficiency.
<P>
In the actual implementation of queuing the messages at busy gates
and modelling the transmission delay, messages do not actually
queue up in gates; gates do not have internal queues. Instead,
as the time when each gate will finish transmission is known at
the time of sending the message, the arrival time of the message
can be calculated in advance. Then the message will be stored
in the event queue (FES) until the simulation time advances to
its arrival time and it is retrieved by its destination module.
<P>
TBD add pseudocode
<P>
<B>Conseqence</B>
<P>
The implementation has the following consequence. If you change
the delay (or the bit error rate, or the data rate) of a link
during simulation, the modelling of messages sent &quot;just before&quot;
the parameter change will not be accurate. Namely, if link parameters
change while a message is &quot;under way&quot; in the model,
that message will not be affected by the parameter change, although
it should. However, all subsequent messages will be modelled correctly.
Similar for data rate: if a data rate changes during the simulation,
the change will affect only the messages that are <I>sent</I>
after the change. 
<P>
If it is important to model gates and channels with changing properties,
you can go two ways:
<UL>
<LI>write sender module such that they schedule events for when
the gate finishes its current transmission and send then;
<LI> alternatively, you can implement channels with simple modules
(&quot;active channels&quot;).
</UL>
<P>
<B>The approach of some other simulators</B>
<P>
Note that some simulators (e.g. OPNET) assign <I>packet queues</I>
to input gates (ports), and messages send are buffered at the
destination module (or the remote end of the link) until received
by the destination module. With that approach, events and messages
are separate entities, that is, a <I>send</I> operation includes
placing the message in the packet queue <I>and</I> scheduling
an event which will signal the arrival of the packet. In some
implementations, also output gates have packet queues where packets
wait until the channel becomes free (available for transmission).
<P>
OMNeT++ gates don't have associated queues. The place where the
sent but not yet received messages are buffered is the <I>FES</I>.
OMNeT++'s approach is potentially faster than the above mentioned
solution because it doesn't have the enqueue/dequeue overhead
and also spares an event creation. The drawback is, as mentioned
above, that changes to channel parameters do not take effect immediately.
<H2><A NAME="_Toc473901753">Coding conventions</A></H2>
<P>
Here's a bunch of advice on how to write OMNeT++ models. Some
of them are &quot;rules of thumb&quot;, saying if you program
like that, you're likely to have less trouble; other conventions
are aimed at making the models produced by the OMNeT++ community
more consistent.
<P>
Conventions for writing simple modules:
<OL>
<LI>Put the NED description, the C++ class declaration and the
implementation into three separate files. Do not put two or more
modules' code into the same file unless they are build upon one
another - don't be afraid of small files! Thus, for a simple module
called <TT>Foobar</TT>, you should have <TT>Foobar.ned</TT>, <TT>Foobar.h</TT>
and <TT>Foobar.cc</TT>. This reduces coupling of module sources
and makes your code more reusable.
<LI>Adopt a good coding style. Some hints: Choose your favourite
indentation style and keep to that consistently. I recommend four-space
indents and the brace placement style in which the OMNeT++ sources
are written. Write only one statement per line. Avoid putting
comments at the end of the line - place them <I>above</I> the
code on a separate line instead! Use blank lines to break the
code into not-very-long logical blocks, and put a few-word comment
above each block what that block does. Leave at least two blank
lines between two (member) functions. The purpose of all that
is that the structure of your code be obvious at the first glance!
<LI>Identifiers: Begin module type names with a capital letter,
and capitalize the beginning of each word, like in <TT>TokenRingMAC</TT>.
Do not use underscore '_' in module names. Use the C++-style naming
on member functions: beginning of each word is capitalized (except
for the first one) and no underscores: <TT>sendUnnumberedFrame()</TT>.
On parameter names, you may use C-style (<TT>window_size</TT>)
or C++-style (<TT>windowSize</TT>) naming, whichever you prefer.
<LI>Make the functions virtual. Maybe someone who reuses your
code will need a different behavior than what you thought of.
<LI>Use inheritance if you're writing a very complex simple module:
create a basic simple module class and build upon it deriving
new module classes. This will make your code more readable and
easier to manage/reuse. Unfortunately, inheritance is not supported
in NED so you actually have to make distinct NED descriptions
for each simple module class. Even if you have an abstract classes,
prepare a NED desctiption for it: it is useful as a reference
to others who might derive a different simple module class from
your abstract class. Inheritance in NED is planned in later releases
of OMNeT++.
<LI>Avoid global variables (and what's the same, static class
members). They are not reset to their initial value (zero) when
you run the simulation, stop it and rebuild the network. This
can cause several problems when you use Cmdenv to execute several
runs one after another, or in Tkenv when you rebuild the network
from the menu.
<LI>Query the values of parameters into state variables (--&gt;class
members) of the <I>same</I> name at the top of the <TT>activity()</TT>
function. If you know the value of a parameter is a random value
(like uniform 0..10) or it can change during simulation, then
to avoid having to look it up by name each time (like <TT>d=par(&quot;delay&quot;)</TT>)
you may query its pointer into a <TT>cPar*</TT> state variable
with the same name prepended with 'p' (like <TT>pDelay=&amp;par(&quot;delay&quot;)</TT>).
<LI>Use <TT>ev.printf()</TT> and <TT>ev&lt;&lt;...</TT> (see later)
to print out information on what the module is doing. Doing so
will pay out several times when it comes to debugging. Use a parameter
and a state variable called <TT>debug</TT>. Surround your debugging
output (<TT>ev&lt;&lt;...</TT> and <TT>ev.printf()</TT> calls)
with <TT>if(debug)</TT>. You may introduce more specific debug
switches (like <TT>debug_queuing</TT> etc.)
</OL>
<H2><A NAME="_Toc473901754">Component libraries</A></H2>
<P>
Because of the structure of the simulation system, one can create
libraries of reusable elements in several ways. The three basic
types are:
<UL>
<LI>simple module libraries
<LI>NED source libraries
<LI>precompiled compound module libraries
</UL>
<P>
The elegant thing is that the user of the library does not need
to know which kind of library he/she is using; the three types
of libraries are equivalent in terms of usage.
<H3><A NAME="_Toc473901755">Simple module libraries</A></H3>
<P>
Simple modules that can be used in more than simulations can form
an object library. Good candidates for module libraries are simple
modules that implement:
<UL>
<LI>Physical/Data-link protocols: Ethernet, Token Ring, FDDI,
LAPB etc.
<LI>Higher layer protocols: IP, TCP, X.25 L2/L3, etc.
<LI>Network application types: E-mail, NFS, X, audio etc.
<LI>Basic elements: message generator, sink, concentrator/simple
hub, queue etc.
<LI>Modules that implement routing algorithms in a multiprocessor
or network
<LI>...
</UL>
<P>
To create a library, you compile the simple module C++ sources
and collect the object files in one directory. You'll also need
to the provide the NED descriptions:
<PRE>
<FONT>library/generator.ned
</FONT>        generator.o
        sink.ned
        sink.o
        ethernet.ned
        ethernet.o
</PRE>
<P>
The NED files contain the interfaces of the simple modules. For
example:
<PRE>
<FONT>// generator.ned
</FONT><B>simple</B> Generator
    <B>parameters</B>: 
       interarrival time, message_length, message_kind;
    <B>gates</B>:
       <B>out</B>: output;
<B>endsimple
</B>
</PRE>
<P>
The user of the library would include <TT>generator.ned</TT> in
his/her NED files, and link the executable with <TT>generator.o</TT>.
This is more or less the same concept as conventional C/C++ header
files and libraries. The basic advantage is the same as with C/C++:
you save compilation time and hide concrete implementation. The
latter also means that you can give the module library to others
without having to share the C++ source.
<P>
It could also be meaningful to provide the C++ header files with
the module class declarations. This would enable the user to directly
call the member functions of the module object from the simulation
program and derive new module classes by redefining the virtual
functions.
<P>
You do not need to have a separate NED file for each module: you
could merge all of them into a single <TT>library.ned</TT> that
contains the NED declarations of all modules without all side
effects. However, it is not recommended to put all object files
into one library (<TT>.a</TT> or <TT>.lib</TT>), because then
every simple module would be present in simulation programs linked
with the library, regardless whether the simulation uses them
or not.
<H3><A NAME="_Toc473901756">Compound module NED source libraries</A>
</H3>
<P>
The NED sources of reusable compound modules can also be placed
in a library. Candidates are:
<UL>
<LI>network nodes such as hubs, bridges, routers
<LI>different workstation/computer types: file server, X terminal
etc.
<LI>node of a massively parallel multiprocessor (used in testing
different topologies)
<LI>topology templates: parametrized ring, mesh, hypercube, torus
etc. topologies, with the sizes (shapes etc) and the actual node
types to be left as parameters
<LI>...
</UL>
<P>
The NED sources are used through the import mechanism; the corresponding
simple module object files still to be linked in the executable.
<P>
The user does not necessarily notice that he/she is using a compound
module library and not a simple module library. In NED files,
the user imports and uses the compound module sources in exactly
the same way as he/she used the simple module interface declarations.
Linking also goes in the same way; if the simple modules objects
necessary for a certain compound module are aggregated into a
library (<TT>.a</TT> or <TT>.lib</TT>), the user does not even
notice the difference from the number of files he/she has to link
in.
<H3><A NAME="_Toc473901757">Precompiled compound module libraries</A>
</H3>
<P>
If you share a compound module with others, you do not necessarily
have to share the NED source and reveal the internals of the compound
module. You can turn the compound module into something that very
much looks like a simple module.
<P>
Suppose you have the following compound module:
<PRE>
<FONT>// router-compound.ned
</FONT><B>module</B> Router:
	<B>parameters</B>:
		processing_delay, buffersize;
	<B>gates</B>:
		<B>in</B>: input_ports[];
		<B>out</B>: output_ports[];
	<B>submodules</B>:
		routing: RoutingModule
			<B>parameters</B>:
                      //...
			<B>gatesizes</B>:
				//...
		datalink: DataLink[num_of_ports]
			<B>parameters</B>:
				retry_count = 5,
				window_size = 2;
           //...
	<B>connections</B>:
           // ...
<B>endmodule
</B>
</PRE>
<P>
First, you would compile this NED file with the NEDC compiler
and the resulting C++ code with the C++ compiler. Then you would
aggregate this object file with the simple module object files
into a single library (<TT>.a</TT> or <TT>.lib</TT>). Also, you
would write a separate NED file that declares the interface of
the new &quot;simple&quot; module:
<PRE>
<FONT>// router-simple.ned
</FONT><B>simple</B> Router:
	<B>parameters</B>:
		processing_delay, buffersize;
	<B>gates</B>:
		<B>in</B>: input_ports[];
		<B>out</B>: output_ports[];
<B>endsimple
</B>
</PRE>
<P>
The method produced a <I>precompiled compound module</I>. The
resulting two files can be placed into a simple module library
and can be used identically to ordinary simple modules.
<P>
Using precompiled compound modules you can hide the internal complexity
of your model from direct inspection. However, nothing can prevent
a user from building a simulation executable with it and  exploring
the structure of your compound module using OMNeT++ simulation
kernel functions. Consequently, using precompiled compound modules
is more useful as a structuring tool.
<H2><A NAME="_Toc473901758">Some simulation techniques</A></H2>
<H3><A NAME="_Toc473901759">Modelling computer networks</A></H3>
<P>
The hierarchical module structure of OMNeT++ allows you to organize
the model around different levels:
<P>
Physical topology:
<OL>
<LI>Top-level network
<LI>Subnetwork (site)
<LI>LAN
<LI>node
</OL>
<P>
Within a node:
<OL>
<LI>OSI layers. The Data-Link, Network, Transport, Application
layers are of greater importance.
<LI>Applications/protocols within a layer.
</OL>
<P>
The advantage of OMNeT++ over many existing simulators is that
the depth of the module nesting is not limited, and, what is in
connection with the previous one, that a simple module can be
transformed into a compound module by splitting the code into
several simple modules <I>without affecting exisiting users</I>
of the module and vica versa. The latter means that the programmer
of the model is not under pressure from possibly incorrect early
design decisions about what to implement with a single module
and what with a compound module.
<H3><A NAME="_Toc473901760">Modelling multiprocessor systems</A>
</H3>
<P>
One can make use of flexible model topologies. It is straightforward
to create ring, mesh, butterfly, torus, hypercube, tree, fat tree
and other topologies with conditional loop connections.
<P>
Furthermore, general <I>topology templates</I> (e.g. mesh or hypercube)
can be created, where the types of the actual nodes are left as
parameters. The actual node types are substituted as parameter
values for each concrete simulation. Topology templates could
be placed in a library and imported from there if needed.
<H3><A NAME="_Toc473901761">Parameter tuning</A></H3>
<P>
Tuning means finding the parameter values which produce optimal
operation of the system. In OMNeT++, you can tune the model during
runtime. The code that monitors performance and changes parameter
values can be placed:
<UL>
<LI>inside the model. In this case, the code does not necessarily
form separate module(s); you can add the extra code to any already
exisiting module.
<LI>outside the model of the actual system. If you choose this
method, you will create new modules that monitor and control the
model.
</UL>
<P>
OMNeT++ supports the model tuning concept by providing reference
parameters. Parameters that influence the model performance and
need to be tuned will be declared at the highest layer and taken
by both the model and the monitor part.
<P>
An example of model tuning is how one can determine the critical
throughput of a communication network by changing the offered
load according to performance measures of the network (queueing
times etc.)
<H3><A NAME="_Toc473901762">Multiple experiments within one simulation
run</A></H3>
<P>
One might need to perform a large number of simulation runs where
the model parameters are not known in advance. This can be the
case when one wants to optimize a system and parameter tuning
cannot be used because 
<OL>
<LI>for each experiment, he wants to start the model from a well-defined
initial state, or
<LI>he wants to change the model topology from one simulation
run to the other
</OL>
<P>
In this case, the following solution be followed. The network
would consist of only one simple module that would organize the
simulation runs by creating, running and destroying the actual
models with each experiment. The simple module's code would look
like this:
<P>
<I>SimulationManager::activity()</I>
<P>
<I>{</I>
<P>
<I> determine parameters for the first run</I>
<P>
<I> while(true)</I>
<P>
<I> {</I>
<P>
<I>  create the model (a compound module) with the current run
parameters</I>
<P>
<I>  schedule</I>
<P>
<I>  wait( some time)  // while the model runs</I>
<P>
<I>  delete future events that belong to the model</I>
<P>
<I>  get statistics out of the model</I>
<P>
<I>  destroy the model</I>
<P>
<I>  if (simulation is done)</I>
<P>
<I>   break</I>
<P>
<I>  calculate parameters for the next run</I>
<P>
<I> }</I>
<P>
<I> write out results</I>
<P>
<I>}<BR>
</I>
<P>
The solutions built into OMNeT++ (flexible module topologies,
dynamic creation of compound modules etc.) strongly support this
concept.
<H3><A NAME="_Toc473901763">Dynamic topology optimization</A>
</H3>
<P>
Dynamic topology optimization is the generalization of the &quot;parameter
tuning&quot; and &quot;multiple experiments within one simulation
run&quot; concepts. If one wants to simulate large systems, it
is possible that one part of the model needs its topology to be
optimized (optimal number of servers, optimal interconnection
etc.) while other parts of the model have reached their steady
state and should not be bothered.
<P>
This can be achieved by modifying the previous scheme. Parts of
the model that do not need topology optimization can be created
once and left running for the whole duration of the simulation;
other parts are examined and their structure is modified from
time to time.<BR>
<HR><H1><A NAME="_Toc473901764">The Simulation Library</A></H1>
<P>
OMNeT++ has a rich C++ class library which you can use when implementing
simple modules. A quick overview of the areas supported by the
simulation library:
<UL>
<LI>sending and receiving messages, scheduling and cancelling
events, terminating the module or the simulation: member functions
of <TT>cSimpleModule</TT>
<LI>events, messages, network packets: the <TT>cMessage</TT> and
<TT>cPacket</TT> classes
<LI>random number generation: <TT>normal()</TT>, <TT>exponential()</TT>,
etc.
<LI>access to module gates and parameters: member functions of
<TT>cModule</TT> (base class for <TT>cSimpleModule</TT>); <TT>cPar</TT>
and <TT>cGate</TT> classes
<LI>accessing other modules in the network: member functions of
<TT>cModule</TT> and <TT>cGate</TT>
<LI>storing data in containers: <TT>cArray</TT>, <TT>cQueue</TT>,
<TT>cBag</TT> and <TT>cLinkedList</TT> classes
<LI>discovering network topology and support routing: <TT>cTopology</TT>
class
<LI>recording statistics into file: <TT>cOutVector</TT> class
<LI>collecting simple statistics: <TT>cStddev</TT> and <TT>cWeightedStddev</TT>
classes
<LI>distribution estimation: <TT>cLongHistogram</TT>, <TT>cDoubleDistogram</TT>,
<TT>cVarHistogram</TT>, <TT>cPSquare</TT>, <TT>cKSplit</TT> classes
<LI>making variables inspectable in the graphical user interface
(Tkenv): the <TT>WATCH</TT> macro (<TT>cWatch</TT> class)
<LI>sending debug output to and prompting for user input in the
graphical user interface (Tkenv): the <TT>ev</TT> object (<TT>cEnvir</TT>
class)
</UL>
<H2><A NAME="_Toc473901765">Class library conventions</A></H2>
<P>
<B>Base class</B>
<P>
Classes in the OMNeT++ simulation library are derived from <TT>cObject</TT>.
Functionality and conventions that come from <TT>cObject</TT>:
<UL>
<LI>name attribute
<LI><TT>className()</TT> member and other member functions giving
textual information about the object
<LI>conventions for assignment, copying, duplicating the object
<LI>ownership control for containers derived from <TT>cObject</TT>
<LI>support for traversing the object tree
<LI>support for inspecting the object in graphical user interfaces
(Tkenv)
<LI>support for automatic cleanup (garbage collection) at the
end of the simulation
</UL>
<P>
Classes inherit and redefine several <TT>cObject</TT> member functions;
in the following we'll discuss some of the practically important
ones.
<P>
<B>Setting and getting attributes</B>
<P>
Member functions that set and query object attributes follow consistent
naming. The setter member function has the form <TT>setSomething(...)</TT>
and its getter counterpart is named <TT>something()</TT>, i.e.
the &quot;get&quot; verb found in Java and some other libraries
is omitted for brevity. For example, the <I>length</I> attribute
of the <TT>cMessage</TT> class can be set and read like this:
<PRE>
<FONT>msg-&gt;setLength( 1024 );
</FONT>length = msg-&gt;length();
</PRE>
<P>
<B>className()</B>
<P>
For each class, the <TT>className()</TT> member function returns
the class name as a string:
<PRE>
<FONT>char *classname = msg-&gt;className();  // returns &quot;cMessage&quot;
</FONT>
</PRE>
<P>
<B>Name attribute</B>
<P>
An object can be assigned a name (a character string). The name
string is the first argument to the constructor of every class,
and it defaults to <TT>NULL</TT> (no name string). If you supply
a name string, the object will make its own copy (<TT>strdup</TT>).
As an example, you can create a message object like this:
<PRE>
<FONT>cMessage *mymsg = new cMessage(&quot;mymsg&quot;);
</FONT>
</PRE>
<P>
You can also set the name after the object has been created:
<PRE>
<FONT>mymsg-&gt;setName(&quot;mymsg&quot;);
</FONT>
</PRE>
<P>
You can get a pointer to the internally stored copy of the name
string like this:
<PRE>
<FONT>char *name = mymsg-&gt;name(); // --&gt; returns ptr to internal copy 
</FONT>                            //     of &quot;mymsg&quot;
</PRE>
<P>
For convenience and efficiency reasons, the empty string <TT>&quot;&quot;</TT>
and <TT>NULL</TT> are treated as equivalent by library objects:
 <TT>&quot;&quot;</TT> is stored as <TT>NULL</TT> (so that it
does not consume heap), but it is returned as <TT>&quot;&quot;</TT>
(so that it is easier to print out etc). Thus, if you create a
message object with either <TT>NULL</TT> or <TT>&quot;&quot;</TT>
as name, it will be stored as <TT>NULL</TT> and <TT>name()</TT>
will return a pointer to <TT>&quot;&quot;</TT>, a static string:
<PRE>
<FONT>cMessage *msg = new cMessage(NULL, &lt;additional args&gt;);
</FONT>char *str = msg-&gt;name();  // --&gt; returns ptr to &quot;&quot;
</PRE>
<P>
<B>fullName() and fullPath()</B>
<P>
Objects have two more member functions which return other sort
of names based on the name attribute: <TT>fullName()</TT> and
<TT>fullPath()</TT>.
<P>
Suppose we have a module in the network <TT>university_lan</TT>,
compound module <TT>fddi_ring</TT>, simple module <TT>station[10]</TT>.
If you call the functions on the simple module object (<TT>cSimpleModule</TT>
inherits from <TT>cObject</TT>, too), the functions will return
these values:
<PRE>
<FONT>ev &lt;&lt; module-&gt;name();       // --&gt; &quot;station&quot;
</FONT>ev &lt;&lt; module-&gt;fullName();   // --&gt; &quot;station[10]&quot;
ev &lt;&lt; module-&gt;fullPath();   // --&gt; &quot;university_lan.fddi_ring.station[10]&quot;
</PRE>
<P>
These functions work for any object. For example, a local object
inside the module would produce results like this:
<PRE>
<FONT>void FDDIStation::activity()
</FONT>{
    cQueue buffer(&quot;buffer&quot;);
    ev &lt;&lt; buffer-&gt;fullPath();   // --&gt; &quot;university_lan.fddi_ring.
                                //        station[10].buffer&quot;
}
</PRE>
<P>
<TT>fullName()</TT> and <TT>fullPath()</TT>, together with <TT>className()</TT>
can be used for example to generate informative error messages.
<P>
Be aware that <TT>fullName()</TT> and <TT>fullPath()</TT> return
pointers to static buffers. Each call will overwrite the previous
content of the buffer, so for example you shouldn't put two calls
in a single <TT>printf()</TT> statement:
<PRE>
<FONT>ev.printf(&quot;object1 is '%s', object2 is '%s'\n&quot;,
</FONT>           object1-&gt;fullPath(), 
           object2-&gt;fullPath()
          );   // WRONG! Same string is printed twice.
</PRE>
<P>
<B>Copying and duplicating objects</B>
<P>
The <TT>dup()</TT> member function creates an exact copy of the
object, duplicating contained objects also if necessary. This
is especially useful in the case of message objects. <TT>dup()</TT>
returns a pointer of type <TT>cObject *</TT>, so it needs to be
cast to the proper type:
<PRE>
<FONT>cMessage *copyMsg = (cMessage *) msg-&gt;dup();
</FONT>
</PRE>
<P>
<TT>dup()</TT> works through calling the copy constructor, which
in turn relies on the assignment operator between objects. <TT>operator=()
</TT>can be used to copy contents of an object into another object
of the same type. The copying is done properly; object contained
in the object will also be duplicated if necessary. For various
reasons, <TT>operator=()</TT> does not copy the name string; the
copy constructor does it.
<P>
<B>Iterators</B>
<P>
There are several container classes in the library (<TT>cQueue</TT>,
<TT>cArray</TT> etc.) For many of them, there is a corresponding
iterator class that you can use to loop through the objects stored
in the container. For example:
<PRE>
<FONT>cQueue queue;
</FONT>//..
for (cQueueIterator queueIter(queue); !queueIter.end(); queueIter++)
{
    cObject *containedObject = queueIter();
}
</PRE>
<P>
<B>Ownership control</B>
<P>
By default, if a container object is destroyed, it destroys the
contained objects too. If you call <TT>dup()</TT>, the contained
objects are duplicated too for the new container. This is done
so because contained objects are owned by the container; ownership
is defined as the right/duty of deallocation. However, there is
a fine-grain ownership control mechanism built in which allows
you to specify on per-object basis whether you want objects to
be owned by the container or not; by calling the <TT>takeOwnership()</TT>
member function with <TT>false</TT>, you tell the container that
you don't want it to become the owner of objects that will be
inserted in the future. You can explicitly select an owner for
any object by calling its <TT>setOwner()</TT> member function.
<H2><A NAME="_Toc473901766">Utilities</A></H2>
<P>
<B>Tracing</B>
<P>
The tracing feature will be used extensively in the code examples,
so it is shortly introduced here. It will be covered in detail
in a later section. 
<P>
The <TT>ev</TT> object represents the user interface of the simulation.
You can send debugging output to <TT>ev</TT> with the C++-style
output operators:
<PRE>
<FONT>ev &lt;&lt; &quot;packet received, sequence number is &quot; &lt;&lt; seq_num &lt;&lt; endl;
</FONT>
</PRE>
<P>
An alternative solution is <TT>ev.printf()</TT>:
<PRE>
<FONT>ev.printf(&quot;packet received, sequence number is %d\n&quot;,seq_num);
</FONT>
</PRE>
<P>
<B>Simulation time conversion</B>
<P>
There are utility functions which convert simulation time (<TT>simtime_t</TT>)
to a printable string (like <TT>&quot;3s 130ms 230us&quot;</TT>)
and vica versa. 
<P>
The <TT>simtimeToStr()</TT> function converts a <TT>simtime_t</TT>
(passed in the first arg) to textual form. The result is placed
into the buffer pointed to by the second arg. If the second arg
is omitted or it is <TT>NULL</TT>, <TT>simtimeToStr()</TT> will
place the result into a static buffer which is overwritten with
each call:
<PRE>
<FONT>char buf[32];
</FONT>ev.printf(&quot;t1=%s, t2=%s\n&quot;, simtimeToStr(t1), simTimeToStr(t2,buf));
</PRE>
<P>
The <TT>strToSimtime()</TT> function parses a time specification
passed in a string, and returns a <TT>simtime_t</TT>. If the string
cannot be entirely interpreted, <TT>-1</TT> is returned:
<PRE>
<FONT>simtime_t t = strToSimtime(&quot;30s 152ms&quot;);
</FONT>
</PRE>
<P>
Another variant, <TT>strToSimtime0()</TT>can be used if the time
string is a substring in a larger string. Instead of taking a
<TT>char*</TT>, it takes a reference to <TT>char*</TT> (<TT>char*&amp;</TT>)
as the first argument. The function sets the pointer to the first
character that could not be interpreted as part of the time string,
and returns the value. It never returns -1; if nothing at the
beginning of the string looked like simulation time, it returns
0.
<PRE>
<FONT>char *s = &quot;30s 152ms and some rubbish&quot;;
</FONT>simtime_t t = strToSimtime0(s);  // now s points to &quot;and some rubbish&quot;
</PRE>
<P>
<B>Utility &lt;string.h&gt; functions</B>
<P>
The <TT>opp_strdup()</TT>, <TT>opp_strcpy()</TT>, <TT>opp_strcmp()</TT>
functions are the same as their <TT>&lt;string.h&gt;</TT> equivalents,
except that they treat <TT>NULL</TT> and the empty string (&quot;&quot;)
as identical, and <TT>opp_strdup()</TT> uses <TT>operator</TT>
<TT>new</TT> instead of <TT>malloc()</TT>.
<P>
The <TT>opp_concat()</TT> function might also be useful, for example
in constructing object names. It takes up to four <TT>char*</TT>
pointers, concatenates them in a static buffer and returns pointer
to the result. The result's length shouldn't exceed 255 characters.
<H2><A NAME="_Toc473901767">Messages and packets</A></H2>
<H3><A NAME="_Toc473901768">The cMessage class</A></H3>
<P>
In OMNeT++, <TT>cMessage</TT> is a central class. Objects of <TT>cMessage</TT>
and subclasses may model a number of things: events; messages;
packets, frames, cells, bits or signals travelling in a network;
entities travelling in a system and so on.
<P>
<B>Attributes</B>
<P>
A <TT>cMessage</TT> object has number of attributes. Some are
used by the simulation kernel, others are provided just for the
convenience of the simulation programmer. A more-or-less complete
list:
<UL>
<LI>The <I>name</I> attribute is inherited from <TT>cObject</TT>.
<LI>The <I>message kind</I> attribute is supposed to carry some
message type information. Zero and positive values can be freely
used for any purpose. Negative values are reserved for use by
the OMNeT++ simulation library; especially, <TT>MK_PACKET</TT>
(-1) and <TT>MK_INFO</TT> (-2) are used to denote that the message
is a network packet (see the <TT>cPacket</TT> class later).
<LI>The <I>length</I> attribute (understood in bits) is used to
compute transmission delay when the message travels through a
connection that has an assigned data rate. 
<LI>The <I>bit error flag</I> attribute is set to <TT>true</TT>
by the simulation kernel with a probability of 1-(1-<I>ber</I>)<I><SUP>length</SUP></I>
when the message is sent through a connection that has an assigned
bit error rate (<I>ber</I>).
<LI>The <I>priority</I> attribute is used by the simulation kernel
to order messages in the message queue (FES) that have the same
arrival time values.
<LI>The <I>time stamp</I> attribute is not used by the simulation
kernel; you can use it for purposes like remembering the time
when the message was enqueued or re-sent. 
<LI>Other attributes and data members make simulation programming
easier, they will be discussed later: <I>parameter list</I>, <I>encapsulated
message</I>, <I>context pointer</I>.
<LI>A number of read-only attributes store information about the
message's (last) sending/scheduling: <I>source/destination module
and gate</I>, <I>sending (scheduling) and arrival time</I>. They
are mostly used by the simulation kernel while the message is
in the FES, but the information is still in the message object
when a module receives the message.
</UL>
<P>
<B>Basic usage</B>
<P>
A <TT>cMessage</TT> object can be created in the following way:
<PRE>
<FONT>cMessage *msg = new cMessage( &quot;msg-name&quot;, kind, length, priority, errorflag);
</FONT>
</PRE>
<P>
The <TT>kind</TT>, <TT>length</TT>, and <TT>priority</TT> are
integers, and <TT>errorflag</TT> is boolean. All arguments have
default values, so the following initializations are also valid:
<PRE>
<FONT>cMessage *msg1 = new cMessage;
</FONT>cMessage *msg2 = new cMessage(&quot;data-packet&quot;, DATAPACKET_KIND, 8*1500 );
</PRE>
<P>
Once a message has been created, its data members can be changed
by the following functions:
<PRE>
<FONT>msg-&gt;setKind( kind );
</FONT>msg-&gt;setLength( length );
msg-&gt;setPriority( priority );
msg-&gt;setBitError( err );
msg-&gt;setTimestamp();
msg-&gt;setTimestamp( simtime );
</PRE>
<P>
With these functions the user can set the message kind, the message
length, the priority, the error flag and the time stamp. The <TT>setTimeStamp()</TT>
function without any argument sets the time stamp to the current
simulation time. 
<P>
The values can be obtained by the following functions:
<PRE>
<FONT>int k = msg-&gt;kind();
</FONT>int p = msg-&gt;priority();
int l = msg-&gt;length();
bool b = msg-&gt;hasBitError();
simtime_t t = msg-&gt;timestamp();
</PRE>
<P>
<B>Duplicating messages</B>
<P>
It is often needed to duplicate a message (for example, send one
and keep a copy). This can be done in the standard ways as for
any other OMNeT++ object:
<PRE>
<FONT>cMessage *copy1 = (cMessage *) msg-&gt;dup();
</FONT>cMessage *copy2 = new cMessage( *msg );
</PRE>
<P>
The two are equivalent. The resulting message is an exact copy
of of the original, including message parameters (<TT>cPar</TT>
or other object types) and encapsulated messages.
<H3><A NAME="_Toc473901769">Attaching parameters and objects to
a message</A></H3>
<P>
<B>Adding, setting and reading parameters</B>
<P>
You can add any number of parameters to a <TT>cMessage</TT> object.
Parameters are objects of <TT>cPar</TT> type. You add a new parameter
to the message with the <TT>addPar()</TT> member function: 
<PRE>
<FONT>msg-&gt;addPar(&quot;dest_addr&quot;);
</FONT>
</PRE>
<P>
You can get back the reference to the parameter object with the
<TT>par()</TT> member function, and because <TT>cPar</TT> supports
typecasting and assignment, it is easy to read and set the value
of a parameter:
<PRE>
<FONT>long dest_addr = msg.par(&quot;dest_addr&quot;);
</FONT>msg.par(&quot;dest_addr&quot;) = 168;
</PRE>
<P>
The <TT>addPar()</TT> function also returns a reference to the
added <TT>cPar</TT> object, so you can set the value of the new
parameter at the same place:
<PRE>
<FONT>msg-&gt;addPar(&quot;dest_addr&quot;) = 168;
</FONT>
</PRE>
<P>
You can use the <TT>hasPar()</TT> function to see if the message
has a given parameter or not:
<PRE>
<FONT>if (!msg-&gt;hasPar(&quot;dest_addr&quot;)) 
</FONT>    msg-&gt;addPar(&quot;dest_addr&quot;);
</PRE>
<P>
<B>Numeric indices</B>
<P>
Message parameters can be accessed also by index in the parameter
array. The <TT>findPar()</TT> function returns the index of a
parameter or -1 if the parameter cannot be found. The parameter
can then be accessed using an overloaded <TT>par()</TT> function.
Access by index is more efficient than access by name (although
access by name might become faster in the future by using hashtables):
<PRE>
<FONT>long dest_addr = 0;
</FONT>int index = msg-&gt;findPar(&quot;dest_addr&quot;);
if (index&gt;=0)
    dest_addr = msg-&gt;par(index);
</PRE>
<P>
<B>Adding arbitrary data by accessing the internal array</B>
<P>
Message parameters are stored in an object of type <TT>cArray</TT>
which can store any object type not only <TT>cPar</TT>s. The <TT>parList()</TT>
member function lets you directly access the internal <TT>cArray</TT>,
so by calling <TT>cArray's</TT> member functions you can attach
any object to the message. An example:
<PRE>
<FONT>cLongHistogram *pklen_distr = new cLongHistogram(&quot;pklen_distr&quot;);
</FONT>msg-&gt;parList().add( pklen_distr );
...
cLongHistogram *pklen_distr = 
           (cLongHistogram *) msg-&gt;parList().get(&quot;pklen_distr&quot;);
</PRE>
<P>
You should take care that names of the attached objects do not
clash with parameter names.
<P>
If you do not add parameters to the message and do not call the
<TT>parList()</TT> function, the internal <TT>cArray</TT> object
will not be created. This saves you both storage and execution
time.
<P>
You can attach non-object types (or non-<TT>cObject</TT> objects)
to the message by using <TT>cPar</TT>'s <TT>void*</TT> pointer
<TT>'P'</TT>) type (see later in the description of <TT>cPar</TT>).
An example:
<PRE>
<FONT>struct conn_t *conn = new conn_t; // a C struct
</FONT>msg-&gt;addPar(&quot;conn&quot;) = (void *) conn;
msg-&gt;par(&quot;conn&quot;).configPointer(NULL,NULL,sizeof(struct conn_t));
</PRE>
<P>
<B>Runtime overhead</B>
<P>
It has been reported that using <TT>cPar</TT> message parameters
might account for quite a large part of execution time (sometimes
as much as 80%! ). If your simulation is going to be very CPU-intensive,
you're probably better off subclassing either <TT>cMessage</TT>
or rather <TT>cPacket</TT>, and adding the required parameters
as <TT>int</TT>s, <TT>long</TT>s, <TT>bool</TT>s, etc. to the
new message class.
<P>
Some time in the future OMNeT++ will directly support message
subclassing, and it will make the new parameters inspectable in
the graphical user interface (Tkenv). This is a feature much demanded
by users.
<P>
However, if you don't expect your simulations execute for hours,
then <TT>cPar</TT> parameters are the most convenient way to go.
<H3><A NAME="_Toc473901770">Message encapsulation</A></H3>
<P>
It is often necessary to encapsulate a message into another when
you're modelling layered protocols of computer networks. Although
you can encapsulate messages by adding them to the parameter list,
there's a better way.  
<P>
The <TT>encapsulate()</TT> function encapsulates a message into
another one. The length of the message will grow by the length
of the encapsulated message. An exception: when the encapsulating
(outer) message has zero length, OMNeT++ assumes it is not a real
packet but some out-of-band signal, so its length is left at zero.
<PRE>
<FONT>cMessage *userdata = new cMessage(&quot;userdata&quot;);
</FONT>userdata-&gt;setLength(8*2000);
cMessage *tcpseg = new cMessage(&quot;tcp&quot;);
tcpseg-&gt;setLength(8*24);
tcpseg-&gt;encapsulate(userdata);
ev &lt;&lt; tcpseg-&gt;length() &lt;&lt; endl;   // --&gt; 8*2024 = 16192
</PRE>
<P>
A message can only hold one encapsulated message at a time. The
second <TT>encapsulate()</TT> call will result in an error. It
is also an error if the message to be encapsulated isn't owned
by the module..
<P>
You can get back the encapsulated message by <TT>decapsulate()</TT>:
<PRE>
<FONT>cMessage *userdata = tcpseg-&gt;decapsulate();
</FONT>
</PRE>
<P>
<TT>decapsulate()</TT> will decrease the length of the message
accordingly, except if it was zero. If the length would become
negative, an error occurs.
<P>
The <TT>encapsulatedMsg()</TT> function returns a pointer to the
encapsulated message, or <TT>NULL</TT> if no message was encapsulated.
<H3><A NAME="_Toc473901771">Information about the last sending</A>
</H3>
<P>
<B>Readonly attributes</B>
<P>
The following functions exist in <TT>cMessage</TT>:
<PRE>
<FONT>bool isSelfMessage()
</FONT>cGate *senderGate();                      // return NULL if scheduled
cGate *arrivalGate();                     //    or unsent message

int senderModuleId();
int senderGateId();
int arrivalModuleId();
int arrivalGateId();

simtime_t creationTime();
simtime_t sendingTime();
simtime_t arrivalTime();
bool arrivedOn(int g);
bool arrivedOn(char *s, int g=0);
</PRE>
<P>
TBD comments
<P>
<B>Context pointer</B>
<P>
<TT>cMessage</TT> contains a <TT>void*</TT> pointer which is set/returned
by the <TT>setContextPointer()</TT> and <TT>contextPointer()</TT>
functions:
<PRE>
<FONT>void *context = ...;
</FONT>msg-&gt;setContextPointer( context );
void *context2 = msg-&gt;contextPointer();
</PRE>
<P>
It can be used for any purpose by the simulation programmer. It
is not used by the simulation kernel, and it is treated as a mere
pointer (no memory management is done on it). 
<P>
Intended purpose: a module which schedules several self-messages
(timers) will need to identify a self-message when it arrives
back to the module, ie. the module will have to determine which
timer went off and what to do then. The context pointer can be
made to point at a data structure kept by the module which can
carry enough &quot;context&quot; information about the event.
<H3><A NAME="_Toc473901772">The cPacket class</A></H3>
<P>
The <TT>cPacket</TT> class is derived from <TT>cMessage</TT>.
It is indended as a base for all messages that model packets or
frames in a telecommunications network.
<P>
<TT>cPacket</TT> adds two new data members to <TT>cMessage</TT>:
<I>protocol</I> and <I>PDU</I> type (packet/frame/event type).
Both are short integers, and are handled by the following member
functions:
<PRE>
<FONT>short protocol();
</FONT>short pdu();
setProtocol(short p);
setPdu(short p);
</PRE>
<P>
Acceptable message kind values are:
<UL>
<LI><TT>MK_PACKET </TT>
<LI><TT>MK_INFO</TT>
</UL>
<P>
The <TT>cPacket</TT> constructor sets the message kind to <TT>MK_PACKET</TT>.
Both <TT>MK_PACKET</TT> and <TT>MK_INFO</TT> are defined as negative
integers. (Remember, negative message kind values are reserved
for the simulation library.)
<P>
The protocol and PDU fields would ideally take a value from the
<TT>protocol.h</TT> header in the simulation library. The contents
of <TT>protocol.h</TT> is currently experimental; comments and
contributions are welcome.
<P>
TDB examples for protocol and pdu values.
<H3><A NAME="_Toc473901773">Subclassing cMessage and cPacket</A>
</H3>
<P>
TBD include an example
<H2><A NAME="_Toc473901774">Sending and receiving messages</A>
</H2>
<H3><A NAME="_Toc473901775">Sending messages</A></H3>
<P>
Once the message has been created, it can be sent through an output
gate using one of these functions:
<PRE>
<FONT>send(cMessage *msg, char *gate_name, int index);
</FONT>send(cMessage *msg, int gate);
</PRE>
<P>
For the first function, the argument <TT>gate_name</TT> is the
name of the gate the message has to be sent through. If this gate
is a vector gate, <TT>index</TT> determines though which particular
output gate this has to be done; otherwise, the <TT>index</TT>
argument is not needed.
<P>
The second function uses the gate number and because it does not
have to search through the gate array, it is faster than the first
one.
<P>
Examples:
<PRE>
<FONT>send( new cMessage(&quot;token&quot;), &quot;out-gate&quot;);
</FONT>send( new cMessage(&quot;token&quot;), &quot;vectorgate&quot;, i);

int out_gate_id = findGate(&quot;out-gate&quot;);
for (i=0; i&lt;n; i++)
{
   send( new cMessage(&quot;packet&quot;), out_gate_id);
   wait(in_time);
}
</PRE>
<P>
All message sending functions check that you actually own the
message you are about to send. If the message is with another
module, currently scheduled or in a queue etc., you'll get a runtime
error. (The feature does not increase runtime overhead significantly,
because it uses the object ownership management; it merely checks
that the owner of the message is the module which wants to send
it.)
<H3><A NAME="_Toc473901776">Delayed sending</A></H3>
<P>
It is often needed to model a delay (processing time etc) immediately
followed by message sending. In OMNeT++, it is possible to implement
it like this:
<PRE>
<FONT>wait( some_delay );
</FONT>send( msg, &quot;outgate&quot; );
</PRE>
<P>
If the module needs to react to messages that arrive during the
delay, <TT>wait()</TT> cannot be used and the timer mechanism
described under <I>Implementing timers</I> would need to be employed.
<P>
However, there is a more straightforward method than the above
two, and this is delayed sending. Delayed sending can be done
with one of these functions:
<PRE>
<FONT>sendDelayed(cMessage *msg, double delay, char *gate_name, int index);
</FONT>sendDelayed(cMessage *msg, double delay, int gate);
</PRE>
<P>
The arguments are the same as for <TT>send()</TT>, except for
the extra <TT><I><FONT>delay</FONT></I></TT>
parameter. The effect of the function is the same as if the module
had kept the message for the delay interval and sent it afterwards.
That is, the sending time of the message will be the current simulation
time (time at the <TT>sendDelayed()</TT> call) plus the delay.
The delay value must be nonnegative.
<P>
Example:
<PRE>
<FONT>sendDelayed( new cMessage(&quot;token&quot;), 0.005, &quot;out-gate&quot;);
</FONT>
</PRE>
<H3><A NAME="_Toc473901777">Direct message sending</A></H3>
<P>
Sometimes it is necessary or convenient to ignore gates/connections
and send a message directly to a remote destination module. The
<TT>sendDirect()</TT> function does that, and it takes the pointer
of the remote module (<TT>cModule *</TT>). You can also specify
a delay and an input gate of the destination module.
<PRE>
<FONT>cModule *destinationmodule = ...;
</FONT>double delay = truncnormal(0.005, 0.0001);
sendDirect( new cMessage, delay, destinationmodule, &quot;in&quot; );
</PRE>
<P>
The destination module receives the message as if it was sent
&quot;normally&quot;.
<H3><A NAME="_Toc473901778">Receiving messages</A></H3>
<P>
<B>With </B><TT><B><FONT>activity()</FONT></B></TT><B>
only!</B> The message receiving functions can only be used in
the <TT>activity()</TT> function, <TT>handleMessage()</TT> gets
the messages in its argument list.
<P>
A message can be received by a number of  functions, the most
general one is the <TT>receive()</TT> function:
<PRE>
<FONT>cMessage *msg = receive();
</FONT>
</PRE>
<P>
Simple module objects contain a built-in queue object called <TT>putAsideQueue</TT>.
The put-aside queue is used by some of the message-receiving functions.
<P>
There are two groups of functions that receive messages:
<UL>
<LI><TT>receive(), receiveOn()</TT>
<LI><TT>receiveNew(), receiveNewOn()</TT>
</UL>
<P>
The functions <TT>receive()/receiveOn()</TT>check the put-aside
queue first and try to return a message from it. Only if they
do not find an appropriate message in the put-aside queue, will
wait for new messages.
<P>
The functions <TT>receiveNew()/receiveNewOn()</TT> wait for new
messages, ignoring the put-aside queue.
<P>
Furthermore, the <TT>...On()</TT> functions expect messages to
arrive on a specific gate. Messages that arrive on another gate
are inserted the put-aside queue. The <TT>On</TT>-less versions
accept any message.
<P>
Since the <TT>receive()</TT> and <TT>receiveOn()</TT> return messages
also from the put-aside queue, the arrival times of messages they
return can be less than the current simulation time. A na&iuml;ve
(and also incorrect) approach to check whether a message is a
new one or it has been retrived from the putaside-queue could
be the following:
<PRE>
<FONT>cMessage *msg = receive();
</FONT>if (msg-&gt;arrivalTime()&lt;simTime()) // not correct! several events may
                                  // occur at the same simulation time
{
   // handle msg as an old message
}
</PRE>
<P>
The correct way to do this is to check the putaside-queue:
<PRE>
<FONT>bool queue_was_empty = putAsideQueue.empty();
</FONT>cMessage *msg = receive();
if (!queue_was_empty) 
{
   // handle msg as an old message
}
</PRE>
<P>
To discard the contents of the put-aside queue, one could use
the following code:
<PRE>
<FONT>while (!putAsideQueue.empty())
</FONT>   delete receive();
</PRE>
<P>
To demonstrate <TT>receiveOn()</TT>, the following code fragment
waits for a message on one specific input gate and discards all
messages that arrived on other gates in the meanwhile:
<PRE>
<FONT>cMessage *msg = receiveNewOn(&quot;important_input_gate&quot;);
</FONT>while (!putAsideQueue.empty())
   delete receive();
</PRE>
<P>
The above code is almost equivalent to the following, except that
it preserves the previous contents of the put-aside queue:
<PRE>
<FONT>cMessage *msg;
</FONT>for(;;) 
{
     msg = receiveNew();
     if (msg-&gt;arrivedOn(&quot;important_input_gate&quot;)) 
         break;
     delete msg;
}
</PRE>
<P>
All message receiving functions can be given a timeout value.
(This is a <I>delta</I>, not an absolute simulation time.) If
an appropriate message doesn't arrive within the timeout period,
the function returns a <TT>NULL</TT> pointer. An example:
<PRE>
<FONT>simtime_t timeout = 3.0; 
</FONT>cMessage *msg = receive( timeout );
if (msg=NULL)
    // timeout expired without any messages
else
    // process message
</PRE>
<H3><A NAME="_Toc473901779">The wait() function</A></H3>
<P>
<B>With </B><TT><B><FONT>activity()</FONT></B></TT><B>
only!</B> The <TT>wait()</TT> function's implementation contains
a <TT>receive()</TT> call which cannot be used in <TT>handleMessage()</TT>.
<P>
The <TT>wait()</TT> function suspends the execution of the module
for a given amount of simulation time (a <I>delta</I>), regardless
whether messages arrive at the module in the meanwhile or not:
<PRE>
<FONT>wait( delay_interval );
</FONT>
</PRE>
<P>
In other simulation software, <TT>wait()</TT> is often called
<TT>hold</TT>. Internally, the <TT>wait()</TT> function is implemented
by a <TT>scheduleAt()</TT> followed by a <TT>receive()</TT>. The
<TT>wait()</TT> function is very convenient in modules that do
not need to be prepared for arriving messages, for example message
generators. An example:
<PRE>
<FONT>for(;;)
</FONT>{
    wait( par(&quot;interarrival-time&quot;) );
    // generate and send message
}
</PRE>
<P>
The messages that arrived during the <TT>wait()</TT> call will
accumulate in the putaside-queue. The putaside-queue can be examined
directly (an example was shown in the previous section), and its
contents is also retrieved by the <TT>receive()</TT> or <TT>receiveOn()</TT>
functions.
<H3><A NAME="_Toc473901780">Implementing timers</A></H3>
<P>
The module can send a message to itself using the <TT>scheduleAt()</TT>
function:
<PRE>
<FONT>scheduleAt( time, message );
</FONT>
</PRE>
<P>
<TT>scheduleAt() </TT>accepts an <I>absolute</I> simulation time
(usually <TT>simTime()+</TT><I>something</I>). This function,
along with the <TT>cancelEvent()</TT> function which removes the
given message from the future event set can be used to implement
timers:
<PRE>
<FONT>cMessage *timeout_msg = new cMessage;
</FONT>scheduleAt( simTime()+10.0, timeout_msg );
//...
cMessage *msg = receive();
if (msg == timeout_msg)  
{
   // timeout expired
}
else
{
   // other message has arrived: timer can be cancelled now:
   delete cancelEvent( timeout_msg );
}
</PRE>
<P>
<TT>cancelEvent()</TT>causes an error if the message is not in
the FES. This means that if you're unsure where the message to
be cancelled actually is, you can write code like this:
<PRE>
<FONT>if (msg-&gt;isScheduled())
</FONT>    delete cancelEvent(msg);
else
    ...
</PRE>
<P>
Or maybe like this:
<PRE>
<FONT>if (msg-&gt;isScheduled())
</FONT>    delete cancelEvent(msg);
else if (putAsideQueue.contains(msg))
    delete putAsideQueue.remove(msg);
else
    ...
</PRE>
<H3><A NAME="_Toc473901781">Querying the state of an output gate</A>
</H3>
<P>
You may have reasons to check whether a certain output gate is
transmitting or to learn when it will finish transmission. This
is done with gate object's <TT>isBusy()</TT> and <TT>transmissionFinishes()</TT>
member functions. The latter function, <TT>transmissionFinishes()</TT>
returns the time when the gate will finish its current transmission
or (if it is currently free) when it finished its last transmission.
<P>
An example:
<PRE>
<FONT>cMessage *packet = new cMessage(&quot;DATA&quot;);
</FONT>packet-&gt;setLength( 1000 );

if (gate(&quot;TxGate&quot;).isBusy())   // if gate is busy, wait until it
{                              //       becomes free
   wait( gate(&quot;TxGate&quot;).transmissionFinishes() - simTime());
}
send( packet, &quot;TxGate&quot;);
</PRE>
<P>
If the connection with a data rate is not immediately the one
connected to the simple module's output gate but the second one
in the route, you have to check the second gate's busy condition.
You would use the following code:
<PRE>
<FONT>if (gate(&quot;mygate&quot;)-&gt;toGate()-&gt;isBusy())
</FONT>   //...
</PRE>
<P>
Note that if data rates change during the simulation, the changes
will affect only the messages that are <I>sent</I> after the change.
<H3><A NAME="_Toc473901782">Stopping the simulation</A></H3>
<P>
<B>Normal termination</B>
<P>
You can finish the simulation with the <TT>endSimulation()</TT>
function:
<PRE>
<FONT>endSimulation();
</FONT>
</PRE>
<P>
However, typically you don't need <TT>endSimulation()</TT> because
you can specify simulation time and CPU time limits in the ini
file (see later).
<P>
<B>Stopping on errors</B>
<P>
If your simulation detects an error condition and wants to stop
the simulation, you can do it with the <TT>error()</TT> member
function of <TT>cModule</TT>. It is used like <TT>printf()</TT>:
<PRE>
<FONT>if (windowSize&lt;1)
</FONT>    error(&quot;Invalid window size %d; must be &gt;=1&quot;, windowSize);
</PRE>
<P>
Do not include a newline (<TT>&quot;\n&quot;</TT>) or punctuation
(period or exclamation mark) in the printed-out text, it will
be added by OMNeT++.
<H2><A NAME="_Toc473901783">Accessing module parameters and gates</A>
</H2>
<H3><A NAME="_Toc473901784">Module parameters</A></H3>
<P>
Module parameters can be accessed with the <TT>par()</TT> member
function of <TT>cModule</TT>:
<PRE>
<FONT>cPar&amp; delay_par = par(&quot;delay&quot;);
</FONT>
</PRE>
<P>
The <TT>cPar</TT> class is a general value-storing object. It
supports type casts to numeric types, so parameter values can
be read like this:
<PRE>
<FONT>int num_tasks = par(&quot;num_tasks&quot;);
</FONT>double proc_delay = par(&quot;proc_delay&quot;);
</PRE>
<P>
If the parameter is a random variable or its value can change
during execution, it is best to store a reference to it and re-read
the value each time it is needed:
<PRE>
<FONT>cPar&amp; wait_time = par(&quot;wait_time&quot;);
</FONT>for(;;)
{
    //...
    wait( (simtime_t)wait_time );
}
</PRE>
<P>
If the <TT>wait_time</TT> parameter was given a random value (e.g.
<TT>exponential(1.0)</TT>) in the NED source or the ini file,
the above code results in a different delay each time.
<P>
Parameter values can also be changed from the program, during
execution. If the parameter was taken by reference (with a <TT>ref</TT>
modifier in the NED file), other modules will also see the change.
Thus, parameters taken by reference can be used as a means of
module communication.
<P>
An example:
<PRE>
<FONT>par(&quot;wait_time&quot;) = 0.12;
</FONT>
</PRE>
<P>
Or:
<PRE>
<FONT>cPar&amp; wait_time = par(&quot;wait_time&quot;);
</FONT>wait_time = 0.12;
</PRE>
<P>
See <TT>cPar</TT> explanation later in this manual for further
information on how to change a <TT>cPar</TT>'s value.
<H3><A NAME="_Toc473901785">Gates and links</A></H3>
<P>
<B>Gate objects</B>
<P>
Module gates are <TT>cGate</TT> objects. Gate objects know whether
and to which gate they are connected, and they can be asked about
the parameters of the link (delay, data rate, etc.)
<P>
The <TT>gate()</TT>member function of <TT>cModule</TT> returns
a pointer to a <TT>cGate</TT> object, and an overloaded form of
the function lets you to access elements of a vector gate:
<PRE>
<FONT>cGate *outgate = gate(&quot;out&quot;);
</FONT>cGate *outvec5gate = gate(&quot;outvec&quot;,5);
</PRE>
<P>
For gate vectors, the first form returns the first gate in the
vector (at index 0). 
<P>
The <TT>isVector()</TT> member function can be used to determine
if a gate belongs to a gate vector or not. But this is almost
insignificant, because non-vector gates are treated as vectors
with size 1.
<P>
Given a gate pointer, you can use the <TT>size()</TT> and <TT>index()</TT>
member functions of <TT>cGate</TT> to determine the size of the
gate vector and the index of the gate within the vector:
<PRE>
<FONT>int size2 = outvec5gate-&gt;size();  // --&gt; size of outvec[] 
</FONT>int index = outvec5gate-&gt;index();  // --&gt; 5 (it is gate 5 in the vector) 
</PRE>
<P>
For non-vector gates, <TT>size()</TT> returns 1 and <TT>index()</TT>
returns 0.
<P>
The <TT>type()</TT> member function returns a character, <TT>'I'</TT>
for input gates and <TT>'O'</TT> for output gates:
<PRE>
<FONT>char type = outgate-&gt;type()  // --&gt; 'O'
</FONT>
</PRE>
<P>
<B>Gate IDs</B>
<P>
Module gates (input and output, single and vector) are stored
in an array within their modules. The gate's position in the array
is called the <I>gate ID</I>. The gate ID is returned by the <TT>id()</TT>
member function:
<PRE>
<FONT>int id = outgate-&gt;id();
</FONT>
</PRE>
<P>
For a module with input gates <TT>from_app</TT> and <TT>in[3]</TT>
and output gates of <TT>to_app</TT> and<TT> status</TT>, the array
may look like this:
<TABLE BORDER=1>
<TR><TD WIDTH=54><CENTER><B>ID</B></CENTER></TD><TD WIDTH=84><CENTER><B>dir</B></CENTER>
</TD><TD WIDTH=162><CENTER><B>name[index]</B></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>0</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>from_app</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>1</CENTER></TD><TD WIDTH=84><CENTER><I>output</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>to_app</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>3</CENTER></TD><TD COLSPAN=2 WIDTH=246><CENTER><I>empty</I></CENTER>
</TD></TR>
<TR><TD WIDTH=54><CENTER>2</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>in[0]</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>3</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>in[1]</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>4</CENTER></TD><TD WIDTH=84><CENTER><I>input</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>in[2]</TT></CENTER></TD></TR>
<TR><TD WIDTH=54><CENTER>5</CENTER></TD><TD WIDTH=84><CENTER><I>output</I></CENTER>
</TD><TD WIDTH=162><CENTER><TT>status</TT></CENTER></TD></TR>
</TABLE>
<P>
<P>
The array may have empty slots. Gate vectors are guaranteed to
occupy contiguous IDs, that is, it is legal to calculate the ID
of <I>gate[k]</I> as <TT>gate(&quot;gate&quot;,0).id()+k</TT>.
<P>
Message sending and receiving functions accept both gate names
and gate IDs; the functions using gates IDs are a bit faster.
Gate IDs do not change during execution, so it is often worth
retrieving them in advance and using them instead of gate names.
<P>
Gate IDs can also be determined with the <TT>findGate()</TT> member
of <TT>cModule</TT>:
<PRE>
<FONT>int id1 = findGate(&quot;out&quot;);
</FONT>int id2 = findGate(&quot;outvect&quot;,5);
</PRE>
<P>
<B>Link parameters</B>
<P>
The following member functions return the link attributes:
<PRE>
<FONT>cLinkType *link = outgate-&gt;link();
</FONT>cPar *d = outgate-&gt;delay();
cPar *e = outgate-&gt;error();
cPar *r = outgate-&gt;datarate();
</PRE>
<P>
<B>Transmission state</B>
<P>
The <TT>isBusy()</TT> member function returns whether the gate
is currently transmitting, and if so, the <TT>transmissionFinishes()</TT>
member function returns when it will finish transmitting. 
<P>
<B>Connectivity</B>
<P>
TBD figure
<P>
The <TT>isConnected()</TT> member function returns whether the
gate is connected. If the gate is an output gate, the gate to
which it is connected is obtained by the <TT>toGate()</TT> member
function. For input gates, the function is <TT>fromGate()</TT>.
<PRE>
<FONT>cGate *gate = gate(&quot;somegate&quot;);
</FONT>if (gate-&gt;isConnected())
{
    cGate *othergate = (gate-&gt;type()=='O') ? 
                              gate-&gt;toGate() : gate-&gt;fromGate();
    ev &lt;&lt; &quot;gate is connected to: &quot; &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
} 
else
{
    ev &lt;&lt; &quot;gate not connected&quot; &lt;&lt; endl;
}
</PRE>
<P>
An alternative to <TT>isConnected()</TT> is to check the return
value of <TT>toGate()</TT> or <TT>fromGate()</TT>. The following
code is fully equivalent to the one above:
<PRE>
<FONT>cGate *gate = gate(&quot;somegate&quot;);
</FONT>cGate *othergate = (gate-&gt;type()=='O') ? 
                             gate-&gt;toGate() : gate-&gt;fromGate();
if (othergate)
    ev &lt;&lt; &quot;gate is connected to: &quot; &lt;&lt; othergate-&gt;fullPath() &lt;&lt; endl;
else
    ev &lt;&lt; &quot;gate not connected&quot; &lt;&lt; endl;
</PRE>
<P>
To find out to which simple module a given output gate leads finally,
you would have to walk along the path like this (the <TT>ownerModule()</TT>
member function returns the module to which the gate belongs):
<PRE>
<FONT>cGate *gate = gate(&quot;out&quot;);
</FONT>while (gate-&gt;toGate()!=NULL) 
{
    gate = gate-&gt;toGate();
}
cModule *destmod = gate-&gt;ownerModule();
</PRE>
<P>
but luckily, there are two convenience functions which do that:
<TT>sourceGate()</TT> and <TT>destinationGate()</TT>.
<H2><A NAME="_Toc473901786">Walking the module hierarchy</A></H2>
<P>
<B>Module vectors</B>
<P>
If a module is part of a module vector, the <TT>index()</TT> and
<TT>size()</TT> member functions can be used to query its index
and the vector size:
<PRE>
<FONT>ev &lt;&lt; &quot;This is module [&quot; &lt;&lt; module-&gt;index() &lt;&lt; 
</FONT>      &quot;] in a vector of size [&quot; &lt;&lt; module-&gt;size() &lt;&lt; &quot;].\n&quot;;
</PRE>
<P>
<B>Module IDs</B>
<P>
Each module in the network has a unique ID that is returned by
the <TT>id()</TT> member function. The module ID is used internally
by the simulation kernel to identify modules.
<PRE>
<FONT>int myModuleId = id();
</FONT>
</PRE>
<P>
If you know the module ID, you can ask the <TT>simulation</TT>
object (a global variable) to get back the module pointer:
<PRE>
<FONT>int id = 100;
</FONT>cModule *mod = simulation.module( id );
</PRE>
<P>
Module IDs are guaranteed to be unique, even when modules are
created and destroyed dynamically. That is, an ID which once belonged
to a module which was deleted is never issued to another module
later.
<P>
<B>Walking up and down the module hierarchy</B>
<P>
The surrounding compound module can be accessed by the <TT>parentModule()</TT>
member function:
<PRE>
<FONT>cModule *parent = parentModule();
</FONT>
</PRE>
<P>
For example, the parameters of the parent module are accessed
like this:
<PRE>
<FONT>double timeout = parentModule()-&gt;par( &quot;timeout&quot; );
</FONT>
</PRE>
<P>
To access all modules within a compound module, use <TT>cSubModIterator</TT>.
For example:
<PRE>
<FONT>for (cSubModIterator submod(*parentModule()); !submod.end(); submod++)
</FONT>{
    ev &lt;&lt; submod()-&gt;fullName();
}
</PRE>
<P>
(<TT>submod()</TT> is pointer to the current module the iterator
is at.)
<P>
The above method can also be used to iterate along a module vector,
since the <TT>name()</TT> function returns the same for all modules:
<PRE>
<FONT>for (cSubModIterator submod(*parentModule()); !submod.end(); submod++)
</FONT>{
    if (submod()-&gt;isName( name() ))   // if submod() is in the same
                                      //   vector as this module
    {
        int its_index = submod()-&gt;index();
        // do something to it
    }
}
</PRE>
<P>
<B>Walking along links</B>
<P>
To determine the module at the other end of a connection, use
<TT>cGate</TT>'s <TT>fromGate()</TT>, <TT>toGate()</TT> and <TT>ownerModule()</TT>
functions. For example:
<PRE>
<FONT>cModule *neighbour = gate( &quot;outputgate&quot; )-&gt;toGate()-&gt;ownerModule();
</FONT>
</PRE>
<P>
For input gates, you would use <TT>fromGate()</TT> instead of
<TT>toGate()</TT>.
<H2><A NAME="_Toc473901787">Dynamic module creation</A></H2>
<P>
<B>Why</B>
<P>
If you do not know how many modules you'll need, you can create
modules dynamically and dispose of them when they are no longer
needed. Both simple and compound modules can be created this way.
If you create a compound module dynamically, all its submodules
will be recursively built.
<P>
Let's suppose you are implementing a transport protocol for a
computer network model. It is convenient to have a separate module
to handle each connection. However, there's no way to know how
many connections there'll be simultaneously. The solution is to
create a manager module which receives connection requests and
creates a module for each connection. The Dyna example simulation
does something like this.
<P>
It is often convenient to use direct message sending with dynamically
created modules.
<P>
<B>Module factories</B>
<P>
TBD
<PRE>
<FONT>cModuleType *moduleType = findModuleType(&quot;TCPConnectionHandler&quot;);
</FONT>
</PRE>
<P>
<B>Simple form</B>
<P>
Mainly for creating simple modules.
<P>
TBD
<P>
<TT>cModuleType</TT> has <TT>createScheduleInit(char *name, cModule
*parentmod)</TT> convenience function to get a module up and running
in one step.
<PRE>
<FONT>mod = modtype-&gt;createScheduleInit(&quot;name&quot;,this);
</FONT>
</PRE>
<P>
Does create()+buildInside()+callInitialize()+scheduleStart(now).
<P>
Should work for both simple and compound modules.
<P>
Not applicable if the module:
<UL>
<LI>has parameters to be set
<LI>has gate vector sizes to be set
<LI>has gates to be connected before initialize()
</UL>
<P>
Example:
<P>
TBD
<P>
<B>Expanded form</B>
<P>
If the previous simple form cannot be used. There are 5 steps:
<P>
<B> Step 1.  </B>find descriptor object
<P>
<B> Step 2.  </B>create module
<P>
<B> Step 3.  </B>set up parameters and gate sizes (if needed)
<P>
<B> Step 4.  </B>call function that builds out submodules and
finalizes the module
<P>
<B> Step 5.  </B>call function that creates activation message(s)
for the new simple module(s)
<P>
Each step (except for Step 3.) can be done with one line of code.
<P>
See the following example where Step 3. is omitted:
<PRE>
<FONT>// find descriptor object
</FONT>cModuleType *moduleType = findModuleType(&quot;TCPConnectionHandler&quot;);

// create (possibly compound) module and build its submodules (if any)
cModule *module = moduleType-&gt;create( &quot;TCPconn&quot;, this );
moduleType-&gt;buildInside( module );

// create activation message
module-&gt;scheduleStart( simTime() );
</PRE>
<P>
If you want to set up parameter values or  gate vector sizes (Step
3.), the code goes between the <TT>create()</TT> and <TT>buildInside()</TT>
calls:
<PRE>
<FONT>cModuleType *moduleType = findModuleType(&quot;TCP-conn-handler&quot;);

</FONT>cModule *module = moduleType-&gt;create( &quot;TCPconn&quot;, this );

// set up parameters and gate sizes before we set up its submodules
module-&gt;par(&quot;window-size&quot;) = 4096;
module-&gt;setGateSize(&quot;to-apps&quot;, 3);

moduleType-&gt;buildInside( module );

module-&gt;scheduleStart( simTime() );
</PRE>
<P>
To delete a module dynamically:
<PRE>
<FONT>module-&gt;deleteModule();
</FONT>
</PRE>
<P>
If the module was a compound module, this involves recursively
destroying all its submodules. A simple module can also delete
itself; in this case, if the module was implemented using <TT>activity()</TT>,
the <TT>deleteModule()</TT> call does not return to the caller
(the reason is that deleting the module also deletes the CPU stack
of the coroutine). 
<P>
Currently, you cannot safely delete a compound module from a simple
module in it; you must delegate the job to a module outside the
compound module. 
<P>
<B>Creating connections</B>
<P>
There are two functions that you can use to connect gates. For
a normal user, they are useful for creating connections to dynamically
created modules.
<PRE>
<FONT>connect( cModule *src_module, int src_gatenumber,
</FONT>         cLinkType *channeltype,
         cModule *dest_module, int dest_gatenumber );

connect( cModule *src_module, int src_gatenumber,
         cPar *delay, cPar *error, cPar *datarate,
         cModule *dest_module, int dest_gatenumber );
</PRE>
<P>
Any of the <TT>channeltype</TT>, <TT>delay</TT>, <TT>error</TT>
and <TT>datarate</TT> pointers can be <TT>NULL</TT>.
<P>
An example:
<PRE>
<FONT>connect( this, findGate(&quot;out&quot;),
</FONT>         (cLinkType *)NULL,
         module, module-&gt;findGate(&quot;in&quot;,0) 
       );
</PRE>
<H2><A NAME="_Toc473901788">Routing support: cTopology</A></H2>
<H3><A NAME="_Toc473901789">Overview</A></H3>
<P>
The <TT>cTopology</TT> class  was designed primarily to support
routing in telecommunication or multiprocessor networks.
<P>
A <TT>cTopology</TT> object stores an abstract representation
of the network in graph form:
<UL>
<LI>each <TT>cTopology</TT> node corresponds to a <I>module </I>(simple
or compound), and
<LI>each <TT>cTopology</TT> edge corresponds to a <I>link</I>
or <I>series of connecting links</I>.
</UL>
<P>
You can specify which modules (either simple or compound) you
want to include in the graph. The graph will include all connections
among the selected modules. In the graph, all nodes are at the
same level, there's no submodule nesting. Connections which span
across compound module boundaries are also represented as one
graph edge. Graph edges are directed, just as module gates are.
<P>
If you're writing a router or switch model, the <TT>cTopology</TT>
graph can help you determine what nodes are available through
which gate and also to find optimal routes. The <TT>cTopology</TT>
object can calculate shortest paths between nodes for you.
<P>
The mapping between the graph (nodes, edges) and network model
(modules, gates, connections) is preserved: you can easily find
the corresponding module for a <TT>cTopology</TT> node and vica
versa.
<H3><A NAME="_Toc473901790">Basic usage</A></H3>
<P>
You can extract the network topology into a <TT>cTopology</TT>
object by a single function call. You have several ways to select
which modules you want to include in the topology:
<UL>
<LI>by module type
<LI>by a parameter's presence and its value
<LI>with a user-supplied boolean function
</UL>
<P>
First, you can specify which node types you want to include. The
following code extracts all modules of type <TT>Router</TT> or
<TT>User</TT>. (<TT>Router</TT> and <TT>User</TT> can be both
simple and compound module types.)
<PRE>
<FONT>cTopology topo;
</FONT>topo.extractByModuleType( &quot;Router&quot;, &quot;User&quot;, NULL );
</PRE>
<P>
Any number of module types (up to 32) can be supplied; the list
must be terminated by <TT>NULL</TT>.
<P>
Second, you can extract all modules which have a certain parameter:
<PRE>
<FONT>topo.extractByParameter( &quot;ip_address&quot; );
</FONT>
</PRE>
<P>
You can also specify that the parameter must have a certain value
for the module to be included in the graph:
<PRE>
<FONT>cPar yes = &quot;yes&quot;;
</FONT>topo.extractByParameter( &quot;include_in_topo&quot;, &amp;yes );
</PRE>
<P>
The third form allows you to pass a function which can determine
for each module whether it should or should not be included. You
can have <TT>cTopology</TT> pass supplemental data to the function
through a <TT>void*</TT> pointer. An example which selects all
top-level modules (and does not use the <TT>void*</TT> pointer):
<PRE>
<FONT>int select_function(cModule *mod, void *)
</FONT>{
    return mod-&gt;parentModule() == simulation.systemModule();
}

topo.extractFromNetwork( select_function, NULL );
</PRE>
<P>
TBD one more example which <I>does</I> <I>use</I> the void* ptr.
<P>
A <TT>cTopology</TT> object uses two types: <TT>sTopoNode</TT>
for nodes and <TT>sTopoLink</TT> for edges. (<TT>sTopoLinkIn</TT>
and <TT>sTopoLinkOut</TT> are 'aliases' for <TT>sTopoLink</TT>;
we'll speak about them later.)
<P>
Once you have the topology extracted, you can start exploring
it. Consider the following code (we'll explain it shortly):
<PRE>
<FONT>for (int i=0; i&lt;topo.nodes(); i++)
</FONT>{
   sTopoNode *node = topo.node(i);
   ev &lt;&lt; &quot;Node i=&quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; node-&gt;module()-&gt;fullPath() &lt;&lt; endl;

   ev &lt;&lt; &quot;  It has &quot; &lt;&lt; node-&gt;outLinks() &lt;&lt; &quot; conns to other nodes\n&quot;;
   ev &lt;&lt; &quot;  and &quot; &lt;&lt; node-&gt;inLinks() &lt;&lt; &quot; conns from other nodes\n&quot;;

   ev &lt;&lt; &quot;  Connections to other modules are:\n&quot;;
   for (int j=0; j&lt;node-&gt;outLinks(); j++)
   {
      sTopoNode *neighbour = node-&gt;out(i)-&gt;remoteNode();
      cGate *gate = node-&gt;out(i)-&gt;localGate();
      ev &lt;&lt; &quot;     &quot; &lt;&lt; neighbour-&gt;module()-&gt;fullPath() &lt;&lt;
            &quot; through gate &quot; &lt;&lt; gate-&gt;fullName() &lt;&lt; endl;
   }
}
</PRE>
<P>
The <TT>nodes()</TT> member function (1st line) returns the number
of nodes in the graph, and <TT>node(i)</TT> returns a pointer
to the <I>i</I>th node, an <TT>sTopoNode</TT> structure.
<P>
The correspondence between a graph node and a module can be obtained
by:
<PRE>
<FONT>sTopoNode *node = topo.nodeFor( module );
</FONT>cModule *module = node-&gt;module();
</PRE>
<P>
The <TT>nodeFor()</TT> member function returns a pointer to the
graph node for a given module. (If the module is not in the graph,
it returns <TT>NULL</TT>). <TT>nodeFor()</TT> uses binary search
within the <TT>cTopology</TT> object so it is fast enough.
<P>
<TT>sTopoNode's</TT> other member functions let you determine
the connections of this node: <TT>inLinks()</TT>, <TT>outLinks()</TT>
return the number of connections, <TT>in(i)</TT> and <TT>out(i)</TT>
return pointers to graph edge objects.
<P>
By calling member functions of the graph edge object, you can
determine the modules and gates involved. The <TT>remoteNode()</TT>
function returns the other end of the connection, and <TT>localGate()</TT>,
<TT>remoteGate()</TT>, <TT>localGateId()</TT> and <TT>remoteGateId()</TT>
return the gate pointers and ids of the gates involved. (Actually,
the implementation is a bit tricky here: the same graph edge object
<TT>sTopoLink</TT> is returned either as <TT>sTopoLinkIn</TT>
or as <TT>sTopoLinkOut</TT> so that &quot;remote&quot; and &quot;local&quot;
can be correctly interpreted for edges of both directions.)
<H3><A NAME="_Toc473901791">Shortest paths</A></H3>
<P>
The real power of <TT>cTopology</TT> is in finding shortest paths
in the network to support optimal routing. <TT>cTopology</TT>
finds shortest paths from <I>all</I> nodes <I>to</I> a target
node. The algorithm is computationally inexpensive. In the simplest
case, all edges are assumed to have the same weight.
<P>
A real-life example when we have the target module pointer, finding
the shortest path looks like this:
<PRE>
<FONT>sTopoNode *targetnode = topo.nodeFor( targetmodule );
</FONT>topo.unweightedSingleShortestPathsTo( targetnode );
</PRE>
<P>
This performs the Dijkstra algorithm and stores the result in
the <TT>cTopology</TT> object. The result can then be extracted
using <TT>cTopology</TT> and <TT>sTopoNode</TT> methods. Naturally,
each call to <TT>unweightedSingleShortestPathsTo()</TT> overwrites
the results of the previous call. 
<P>
Walking along the path from our module to the target node:
<PRE>
<FONT>sTopoNode *node = topo.nodeFor( this );

</FONT>if (node == NULL)
{
   ev &lt;&lt; &quot;We (&quot; &lt;&lt; fullPath() &lt;&lt; &quot;) are not included in the topology.\n&quot;;
}
else if (node-&gt;paths()==0)
{
   ev &lt;&lt; &quot;No path to destination.\n&quot;;
}
else
{
   while (node != topo.targetNode())
   {
      ev &lt;&lt; &quot;We are in &quot; &lt;&lt; node-&gt;module-&gt;fullPath() &lt;&lt; endl;
      ev &lt;&lt; node-&gt;distanceToTarget() &lt;&lt; &quot; hops to go\n&quot;;
      ev &lt;&lt; &quot;There are &quot;&lt;&lt; node-&gt;paths() &lt;&lt; 
            &quot; equally good directions, taking the first one\n&quot;;
      sTopoLinkOut *path = node-&gt;path(0);
      ev &lt;&lt; &quot;Taking gate &quot; &lt;&lt; path-&gt;localGate()-&gt;fullName() &lt;&lt;
            &quot; we arrive in &quot; &lt;&lt; path-&gt;remoteNode-&gt;module()-&gt;fullPath()&lt;&lt;
            &quot; on its gate &quot; &lt;&lt; path-&gt;remoteGate()-&gt;fullName() &lt;&lt; endl;
      node = node-&gt;remoteNode();
   }
}
</PRE>
<P>
The purpose of the <TT>distanceToTarget()</TT> member function
of a node is self-explanatory. In the unweighted case, it returns
the number of hops. The <TT>paths()</TT> member function returns
the number of edges which are part of a shortest path, and <TT>path(i)</TT>
returns the <I>i</I>th edge of them as <TT>sTopoLinkOut</TT>.
If the shortest paths were created by the <TT>...SingleShortestPaths()</TT>
function, <TT>paths()</TT> will always return 1 (or 0 if the taget
is not reachable), that is, only one of the several possible shortest
paths are found.  The <TT>...MultiShortestPathsTo()</TT> functions
find all paths, at increased run-time cost. The <TT>cTopology</TT>'s
<TT>targetNode()</TT> function returns the target node of the
last shortest path search.
<P>
You can enable/disable nodes or edges in the graph. This is done
by calling their <TT>enable()</TT> or <TT>disable()</TT> member
functions. Disabled nodes or edges are ignored by the shortest
paths calculation algorithm. The <TT>enabled()</TT> member function
returns the state of a node or edge in the topology graph.
<P>
One usage of <TT>disable()</TT> is when you want to determine
in how many hops the target node can be reached from our node
<I>through a particular output gate</I>. To calculate this, you
calculate the shortest paths to the target <I>from the neighbor
node</I>, but you must disable the current node to prevent the
shortest paths from going through it:
<PRE>
<FONT>sTopoNode *thisnode = topo.nodeFor( this );
</FONT>thisnode-&gt;disable();
topo.unweightedSingleShortestPathsTo( targetnode );
thisnode-&gt;enable();

for (int j=0; j&lt;thisnode-&gt;outLinks(); j++)
{
   sTopoLinkOut *link = thisnode-&gt;out(i);
   ev &lt;&lt; &quot;Through gate &quot; &lt;&lt; link-&gt;localGate()-&gt;fullName() &lt;&lt; &quot; : &quot; &lt;&lt;
         1 + link-&gt;remoteNode()-&gt;distanceToTarget() &lt;&lt; &quot; hops&quot; &lt;&lt; endl;
}
</PRE>
<P>
In the future, other shortest path algorithms will also be implemented:
<PRE>
<FONT>unweightedMultiShortestPathsTo(sTopoNode *target);
</FONT>weightedSingleShortestPathsTo(sTopoNode *target);
weightedMultiShortestPathsTo(sTopoNode *target);
</PRE>
<H2><A NAME="_Toc473901792">Generating random numbers</A></H2>
<P>
Random number generation is considered to be an important issue.
The random number generator used in OMNeT++ is a linear congruential
generator (LCG) with a cycle length of 2<SUP>31</SUP>-2. The startup
code of OMNeT++ contains code that checks if the random number
generator works OK, so you do not have to worry about this if
you port the simulator to a new architecture or use a different
compiler.
<P>
If a simulation program uses random numbers for more than one
purpose, the numbers should come from different random number
generators. OMNeT++ provides several independent random number
generators (by default 32; this number can be changed in <TT>defs.h</TT>).
<P>
To avoid unwanted correlation, it is also important that different
simulation runs and different random number sources within one
simulation run use non-overlapping series of random numbers, so
the generators should be started with seeds well apart. For selecting
good seeds, the <TT>seedtool</TT> program can be used (it is documented
later).
<P>
The random number generator was taken from [JAIN91, pp. 441-444,455].
It has the following properties:
<UL>
<LI>Range:  1 ... 2<SUP>31</SUP>-2
<LI>Period length:  2<SUP>31</SUP>-2
<LI>Method:  x := (x * 7<SUP>5</SUP>) mod (2<SUP>31</SUP>-1)
<LI>To check:  if  x[0]=1  then  x[10000]=1,043,618,065
<LI>Required hardware:  exactly 32-bit integer aritmetics
</UL>
<P>
The concrete implementation:
<PRE>
<FONT>long intrand()
</FONT>{
     const long int a=16807, q=127773, r=2836;
     seed=a*(seed%q) - r*(seed/q);
     if (seed&lt;=0) seed+=INTRAND_MAX;
     return seed;
}
</PRE>
<H3><A NAME="_Toc473901793">Using random number generators directly</A>
</H3>
<P>
The generator is directly accessible through the <TT>intrand()</TT>
 function:
<PRE>
<FONT>long rnd = intrand();    // in the range 1..INTRAND_MAX-1
</FONT>
</PRE>
<P>
The random number seed can be specified in the ini file (<TT>random-seed=</TT>)
or set directly from within simple modules with the <TT>randseed()</TT>
function:
<PRE>
<FONT>randseed( 10 );          // set seed to 10
</FONT>long seed = randseed();  // current seed value
</PRE>
<P>
Zero is not allowed as a seed.
<P>
The <TT>intrand()</TT> and <TT>randseed()</TT> functions use generator
0. They have another variant which uses a specified generator:
<PRE>
<FONT>long rnd = genk_intrand(6);   // like intrand(), using generator 6
</FONT>genk_randseed( k, 167 );      // set seed of generator k to 167
<BR>
</PRE>
<P>
The <TT>intrand(n)</TT> and <TT>dblrand()</TT> functions are based
on <TT>intrand()</TT>:
<PRE>
<FONT>int dice = 1 + intrand(6); // result of intrand(6) is in the range 0..5  
</FONT>                           // (it is calculated as intrand()%6)
double prob = dblrand();   // in the range 0.0..1.0
                           // calculated as intrand()/(double)INTRAND_MAX
</PRE>
<P>
They also have their counterparts that use generator <I>k</I>:
<PRE>
<FONT>int dice = 1 + genk_intrand(k,6);   // uses generator k
</FONT>double prob = genk_dblrand(k);      //       &quot;&quot;
</PRE>
<H3><A NAME="_Toc473901794">Random numbers from distributions</A>
</H3>
<P>
The following functions are based on <TT>dblrand()</TT> and return
random variables of different distributions:
<PRE>
<FONT>double uniform(double lower_limit, double upper_limit);
</FONT>double intuniform(double lower_limit, double upper_limit);
double exponential(double mean);
double normal(double mean, double deviation);
double truncnormal(double mean, double deviation);
</PRE>
<P>
They are the same functions that can be used in NED files. <TT>intuniform()</TT>
generates integers including both the lower and upper limit, so
for example the outcome of tossing a coin could be written as
<TT>intuniform(1,2)</TT>. <TT>truncnormal()</TT> is the normal
distribution truncated to nonnegative values; its implementation
generates a number with normal distribution and if the result
is negative, it keeps generating other numbers until the outcome
is nonnegative.
<P>
The counterparts of the above functions using generator <I>k</I>:
<PRE>
<FONT>double genk_uniform(double k, double lower_limit, double upper_limit);
</FONT>double genk_intuniform(double k, double lower_limit, double upper_limit);
double genk_exponential(double k, double mean);
double genk_normal(double k, double mean, double deviation);
double genk_truncnormal(double k, double mean, double deviation);
</PRE>
<P>
Note that they take the number of the generator as a <TT>double</TT>;
it is so because these functions are designed so that they can
be used with the <TT>cPar</TT> class and in NED files. You will
find more information about this in the section describing <TT>cPar</TT>.
<P>
If the above distributions do not suffice, you can write your
own functions. If you register your functions with the <TT>Register_Function()</TT>
macro, you can use them in NED files and ini files too. You can
find the implementation of many distributions in the class library
of GNU C++.
<H3><A NAME="_Toc473901795">Random numbers from histograms</A>
</H3>
<P>
You can also specify your distribution as a histogram. The <TT>cLongHistogram</TT>,
<TT>cDoubleHistogram</TT>, <TT>cVarHistogram</TT>,<TT> cKSplit</TT>
or <TT>cPSquare</TT> classes are there to generate random numbers
from equidistant-cell or equiprobable-cell histograms. This feature
is documented later, with the statistical classes.
<H2><A NAME="_Toc473901796">Container classes</A></H2>
<H3><A NAME="_Toc473901797">Queue class: cQueue</A></H3>
<P>
<B>Basic usage</B>
<P>
<TT>cQueue</TT> is a container class that acts as a queue. <TT>cQueue</TT>
can hold objects of type derived from <TT>cObject</TT> (almost
all classes from the OMNeT++ library), such as <TT>cMessage</TT>,
<TT>cPar</TT>, etc. Internally, <TT>cQueue</TT> uses a double-linked
list to store the elements.
<P>
As an example of use, the simple modules' put-aside queues (<TT>putAsideQueue</TT>
member) are <TT>cQueue</TT>s which store <TT>cMessage</TT> objects.
(However, the Future Event Set [FES] is not a <TT>cQueue</TT>;
it is implemented with heap [class <TT>cMessageHeap</TT>] because
it is a lot more efficient.)
<P>
A queue object has a head and a tail. Normally, new elements are
inserted at its head and elements are removed at its tail. 
<P>
<CENTER><IMG SRC="img00010.gif"><BR>
Fig.5.2. What is what with <TT>cQueue</TT></CENTER>
<P>
The basic <TT>cQueue</TT> member functions dealing with insertion
and removal are <TT>insert()</TT> and <TT>pop()</TT>. They are
used like this:
<PRE>
<FONT>cQueue queue(&quot;my-queue&quot;);
</FONT>cMessage *msg;

// insert messages
for (int i=0; i&lt;10; i++) 
{ 
    msg = new cMessage;
    queue.insert( msg );
}<BR>

<FONT>// remove messages
</FONT>while( ! queue.empty() )
{ 
    msg = (cMessage *)queue.pop();
    delete msg;
}
</PRE>
<P>
The<TT> length()</TT> member function returns the number of items
in the queue, and <TT>empty()</TT> tells whether there's anything
in the queue.
<P>
There are other functions dealing with insertion and removal.
The <TT>insertBefore()</TT> and <TT>insertAfter()</TT> functions
insert a new item exactly before and after a specified one, regardless
of the ordering function. 
<P>
The <TT>tail()</TT> and <TT>head()</TT> functions return pointers
to the objects at the tail and head of the queue, without affecting
queue contents. 
<P>
The <TT>pop()</TT>function can be used to remove items from the
tail of the queue, and the <TT>remove()</TT> function can be used
to remove any item known by its pointer from the queue:
<PRE>
<FONT>queue.remove( msg );
</FONT>
</PRE>
<P>
<B>Priority queue</B>
<P>
By default, <TT>cQueue</TT> implements a FIFO, but it can also
act as a priority queue, that is, it can keep the inserted objects
ordered. If you want to use this feature, you have to provide
a function that takes two <TT>cObject</TT> pointers, compares
the two objects and returns -1, 0 or 1 as the result (see the
reference for details). An example of setting up an ordered <TT>cQueue</TT>:
<PRE>
<FONT>cQueue sortedqueue(&quot;sortedqueue&quot;, cObject::cmpbyname, true ); 
</FONT>                                    // sorted by object name, ascending
</PRE>
<P>
If the queue object is set up as an ordered queue, the <TT>insert()</TT>
function uses the ordering function: it searches the queue contents
from the head until it reaches the position where the new item
needs to be inserted, and inserts it there. 
<P>
<B>Iterators</B>
<P>
Normally, you can only access the objects at the head or tail
of the queue. However, if you use an iterator class, <TT>cQueueIterator</TT>,
you can examine each object in the queue.
<P>
The <TT>cQueueIterator</TT> constructor takes two arguments, the
first is the queue object and the second one specifies the initial
position of the iterator: 0=tail, 1=head. Otherwise it acts as
any other OMNeT++ iterator class: you can use the <TT>++</TT>
and <TT>--</TT> operators to advance it, the <TT>()</TT> operator
to get a pointer to the current item, and the <TT>end()</TT> member
function to examine if you're at the end (or the beginning) of
the queue.
<P>
An example:
<PRE>
<FONT>for( cQueueIterator iter(queue,1); !iter.end(), iter++) 
</FONT>{
    cMessage *msg = (cMessage *) iter();
    //...
}<BR>
</PRE>
<H3><A NAME="_Toc473901798">Expandable array: cArray</A></H3>
<P>
<B>Basic usage</B>
<P>
<TT>cArray</TT> is a container class that holds objects derived
from <TT>cObject</TT>. <TT>cArray</TT> stores the pointers of
the objects inserted instead of making copies. <TT>cArray</TT>
works as an array, but if it gets full, it grows automatically.
Internally, <TT>cArray</TT> is implemented with an array of pointers;
if the array gets full, it is reallocated.
<P>
<TT>cArray</TT> objects are used in OMNeT++  to store parameters
attached to messages, and internally, for storing module parameters
and gates.
<P>
Creating an array:
<PRE>
<FONT>cArray array(&quot;array&quot;);
</FONT>
</PRE>
<P>
Adding an object at the first free index:
<PRE>
<FONT>cPar *pp = new cPar(&quot;pp&quot;);
</FONT>int index = array.add( pp );
</PRE>
<P>
Adding an object at a given index (if the index is occupied, you'll
get an error message):
<PRE>
<FONT>cPar *pp = new cPar(&quot;pp&quot;);
</FONT>int index = array.addAt(5, pp);
</PRE>
<P>
Finding an object in the array:
<PRE>
<FONT>int index = array.find(pp);
</FONT>
</PRE>
<P>
Getting a pointer to an object at a given index:
<PRE>
<FONT>cPar *rr = (cPar *) array[index]; 
</FONT>
</PRE>
<P>
You can also search the array or get a pointer to an object by
the object's name:
<PRE>
<FONT>int index = array.find(&quot;pp&quot;);
</FONT>Par *rr = (cPar *) array[&quot;pp&quot;];
</PRE>
<P>
You can remove an object from the array by saying:
<PRE>
<FONT>array.remove(index); 
</FONT>
</PRE>
<P>
The removal doesn't deallocate the object. If you also want to
deallocate it, say this:
<PRE>
<FONT>delete array.remove( index );
</FONT> 
</PRE>
<P>
<B>Iteration</B>
<P>
<TT>cArray</TT> has no iterator, but it's easy to loop through
all the indices with an integer variable. The items() member function
returns the largest index plus one.
<PRE>
<FONT>for (int i=0; i&lt;array.items(); i++)
</FONT>{
    if (array[i])  // is this position used?
    {
        cObject *obj = array[i];
        ev &lt;&lt; obj-&gt;name() &lt;&lt; endl;
    }
}
</PRE>
<H2><A NAME="_Toc473901799">Non-object container classes</A></H2>
<P>
There are two container classes to store non-object items:<TT>
cLinkedList</TT> and <TT>cBag</TT>. The first one parallels with
<TT>cQueue</TT>, the second one with <TT>cArray</TT>. They can
be useful if you have to deal with C structs or objects that are
not derived from <TT>cObject</TT>.
<P>
See the class library reference for more info about them.
<H2><A NAME="_Toc473901800">The parameter class: cPar</A></H2>
<H3><A NAME="_Toc473901801">Basic usage</A></H3>
<P>
<TT>cPar</TT> is a class that was designed to hold a value. The
value is numeric in the first place, but string, pointer and other
types are also supported.
<P>
<TT>cPar</TT> is used in OMNeT++ in the following places:
<UL>
<LI>as module parameters
<LI>as message parameters
</UL>
<P>
There are many ways to set a <TT>cPar</TT>'s value. One is the
 <TT>set...Value()</TT> member functions:
<PRE>
<FONT>cPar pp(&quot;pp&quot;);
</FONT>pp.setDoubleValue(1.0);
</PRE>
<P>
or by using overloaded operators:
<PRE>
<FONT>cPar pp(&quot;pp&quot;);
</FONT>pp = 1.0;
</PRE>
<P>
For reading its value, it is best to use overloaded type cast
operators:
<PRE>
<FONT>double d1 = (double)pp;
</FONT>// or simply:
double d2 = pp;
</PRE>
<P>
Long integers:
<PRE>
<FONT>pp = 89363L;  // or:
</FONT>pp.setLongValue( 89363L );
</PRE>
<P>
Character string:
<PRE>
<FONT>pp = &quot;hi there&quot;;  // or:
</FONT>pp.setStringValue( &quot;hi there&quot; );
</PRE>
<P>
The <TT>cPar</TT> object makes its own copy of the string, so
the original one does not need to be preserved. Short strings
(less than ~20 chars) are handled more efficiently because they
are stored in the object's memory space (and are not dynamically
allocated).
<P>
There are several other types <TT>cPar</TT> can store: such as
boolean, void* pointer; cObject* pointer, <TT> </TT>function with
constant args; they will be mentioned in the next section.
<P>
For numeric and string types, an input flag can be set. In this
case, when the object's value is first used, the parameter value
will be searched for in the configuration (ini) file; if it is
not found there, the user will be given a chance to enter the
value interactively.
<P>
Examples:
<PRE>
<FONT>cPar inp(&quot;inp&quot;);
</FONT>inp.setPrompt(&quot;Enter my value:&quot;);
inp.setInput( true );      // make it an input parameter
double a = (double)inp;    // the user will be prompted HERE
</PRE>
<H3><A NAME="_Toc473901802">Random number generation through cPar</A>
</H3>
<P>
Setting <TT>cPar</TT> to call a function with constant arguments
can be used to make <TT>cPar</TT> return random variables of different
distributions:
<PRE>
<FONT>cPar rnd(&quot;rnd&quot;);
</FONT>rnd.setDoubleValue(intuniform, -10.0, 10.0);// uniform distr.
rnd.setDoubleValue(normal, 100.0, 5.0);     // normal distr. (mean,dev)
rnd.setDoubleValue(exponential, 10.0);      // exponential distr. (mean)
</PRE>
<P>
<TT>intuniform</TT>, <TT>normal</TT> etc. are ordinary C functions
taking <TT>double</TT> arguments and returning <TT>double</TT>.
Each time you read the value of a <TT>cPar</TT> containing a function
like above, the function will be called with the given constant
arguments (e.g. <TT>normal(100.0,5.0)</TT>) and its return value
used.
<P>
The above functions use number 0 from the several random number
generators. To use another generator, use the <TT>genk_xxx</TT>
versions of the random functions:  
<PRE>
<FONT>rnd.setDoubleValue(genk_normal, 3, 100.0, 5.0);  // uses generator 3
</FONT>
</PRE>
<P>
A <TT>cPar</TT> object can also be set to return a random variable
from a distribution collected by a statistical data collection
object:
<PRE>
<FONT>cDoubleHistogram hist = ....;   // the distribution
</FONT>cPar rnd2(&quot;rnd2&quot;);
rnd2.setDoubleValue(hist);
</PRE>
<H3><A NAME="_Toc473901803">Storing object and non-object pointers
in cPar</A></H3>
<P>
<TT>cPar</TT> can store pointers to OMNeT++ objects. You can use
both assignment and the <TT>setObjectValue()</TT> member function:
<PRE>
<FONT>cQueue *queue = new cQueue(&quot;queue&quot;);  // just an example
</FONT>cPar par1, par2;
par1 = (cObject *) queue;
par2.setObjectValue( queue );
</PRE>
<P>
To get the store pointer back, you can use typecast or the <TT>objectValue()</TT>
member function:
<PRE>
<FONT>cQueue *q1 = (cQueue *)(cObject *)par1;
</FONT>cQueue *q2 = (cQueue *)par2.objectValue();
</PRE>
<P>
Whether the <TT>cPar</TT> object will own the other object or
not is controlled by the <TT>takeOwnership()</TT> member function,
just as with container classes. This is documented in detail in
the class library reference. By default, <TT>cPar</TT> will own
the object.
<P>
<TT>cPar</TT> can be used to store non-object pointers (for example
C structs) or non-OMNeT++ object types in the parameter object.
It works very similarly to the above mechanism. An example:
<PRE>
<FONT>double *mem = new double[15];
</FONT>cPar par1, par2;
par1 = (void *) mem;
par2.setPointerValue( (void *)mem );
...
double *m1 = (double *)(void *)par1;
double *m2 = (double *)par2.pointerValue();
</PRE>
<P>
Memory management can be specified by <TT>cPar's</TT> <TT>configPointer()</TT>
member function. It takes three arguments: a pointer to a user-supplied
deallocation function, a pointer to a user-supplied duplication
function and an item size. If all three are 0 (<TT>NULL</TT>),
no memory management is done, that is, the pointer is treated
as a mere pointer. This is the default behaviour. If you supply
only the item size (and both function pointers are <TT>NULL</TT>),
<TT>cPar</TT> will use the <TT>delete</TT> operator to deallocate
the memory area when the <TT>cPar</TT> object is destructed, and
it will use <TT>new char[size]</TT> followed by a <TT>memcpy()</TT>
to duplicate the memory area whenever the <TT>cPar</TT> object
is duplicated. If you need more sophisticated memory management,
you can supply your own deallocation and duplication functions.
All this is documented in detail in the class library reference.
An example for simple memory management:
<PRE>
<FONT>double *mem = new double[15];
</FONT>cPar par;
par.setPointerValue((void *) mem);
par.configPointer(NULL, NULL, 15*sizeof(double));
// -&gt; now if par goes out of scope, it will delete the 15-double array.
</PRE>
<P>
The <TT>configPointer()</TT> setting only affects what happens
when the <TT>cPar</TT> is deleted, duplicated or copied, but does
<I>not</I> apply to assigning new pointers. That is, if <I>you</I>
assign a new <TT>void*</TT> to the <TT>cPar</TT>, you simply overwrite
the pointer - the block denoted by the old pointer is <I>not</I>
deleted. This fact can be used to extract some dynamically allocated
block out of the <TT>cPar</TT>: carring on the previous example,
you would extract the array of 15 <TT>double</TT>s from the <TT>cPar</TT>
like this:
<PRE>
<FONT>double *mem2 = (double *)par.pointerValue();
</FONT>par.setValue( (void *)0 );
// -&gt; now par has nothing to do with the double[15] array 
</PRE>
<P>
However, if you assign some non-pointer value to the <TT>cPar</TT>,
beware: this <I>will</I> activate the memory management for the
block. If you temporarily use the same <TT>cPar</TT> object to
store other than <TT>void*</TT> ('P') values, <TT>the configPointer()</TT>
setting is lost.
<H3><A NAME="_Toc473901804">Reverse Polish expressions</A></H3>
<P>
This feature is rarely needed by the user, it is more used internally.
A <TT>cPar</TT> object can also store expressions. In this case,
the expression must be given in reversed Polish form. An example:
<PRE>
<FONT>sXElem *expression = new sXElem[5];
</FONT>expression[0] = &amp;par( &quot;count&quot; );  // pointer to module parameter
expression[1] = 1;
expression[2] = '+';
expression[3] = 2;
expression[4] = '/';

cPar expr(&quot;expr&quot;);
expr.setDoubleValue(expression,5);
</PRE>
<P>
The <TT>cPar</TT> object created above contains the <I>(count+1)/2</I>
expression where <I>count</I> is a module parameter. Each time
the <TT>cPar</TT> is evaluated, it recalculates the expression,
using the current value of <TT>count</TT>. Note the <TT>&amp;</TT>
sign in front of <TT>par(&quot;count&quot;)</TT> expression: if
it was not there, the parameter would be taken by value, evaluated
once and then the resulting constant would be used.
<P>
Another example is a distribution with mean and standard deviation
given by module parameters: 
<PRE>
<FONT>sXElem *expression = new sXElem[3];
</FONT>expression[0] = &amp;par(&quot;mean&quot; );
expression[1] = &amp;par(&quot;stddev&quot;);
expression[2] = normal;    // pointer to the normal(double,double) func.

cPar expr(&quot;expr&quot;);
expr.setDoubleValue(expression,3);
</PRE>
<P>
For more information, see the reference and the code NEDC generates
for parameter expressions.
<H3><A NAME="_Toc473901805">Using indirection</A></H3>
<P>
A <TT>cPar</TT> object can be set to stand for a value actually
stored in another <TT>cPar</TT> object. This is called <I>indirect</I>
or <I>redirected</I> value. When using indirection, every operation
on the value (i.e. reading or changing it) will be actually done
to the other <TT>cPar</TT> object:
<P>
<CENTER><IMG SRC="img00011.gif"><BR>
Fig.5.3 <TT>cPar</TT> indirection</CENTER>
<P>
Indirection is how module parameters taken by reference are implemented.
The indirection does not include name strings. That is, if you
say <TT>A-&gt;setName(&quot;newname&quot;)</TT> in the above example,
<TT>A</TT>'s name will be changed as the name member is not redirected.
(This is natural if you consider parameters taken by reference:
a parameter should/can have different name than the value it refers
to.)
<P>
You create an indirection with the <TT>'I'</TT> type character:
<PRE>
<FONT>cPar *bb = new cPar(&quot;bb&quot;);   // background value
</FONT>bb = 10L;
cPar a(&quot;a&quot;);  // redirected object

a.setRedirection(bb);  // create indirection
</PRE>
<P>
Now every operation you do on <TT>a</TT>'s value will be done
to <TT>bb</TT>:
<PRE>
<FONT>long x = a;    // returns bb's value, 10L
</FONT>a = 5;         // bb's value changes to 5
</PRE>
<P>
The only way to determine whether <TT>a</TT> is really holding
the value or it is redirected to another <TT>cPar</TT> is to use
the <TT>isRedirected()</TT> member function which returns a <TT>bool</TT>,
or <TT>redirection()</TT> which returns the pointer to the background
object, or NULL if there's no redirection:
<PRE>
<FONT>cPar *redir = a.redirection();  // returns bb's pointer
</FONT>if (redir != NULL)
     ev &lt;&lt; &quot;a is redirected to &quot; &lt;&lt; redir-&gt;name() &lt;&lt; endl;
</PRE>
<P>
To break the link between the two objects, use the <TT>cancelRedirection()</TT>
member function. (No other method will work, including assigning
<TT>a</TT> the value of another <TT>cPar</TT> object.) The <TT>cancelRedirection()</TT>
function gives the <TT>(long)0</TT> value to the redirected object
(the other will be unaffected). If you want to cancel the indirection
but keep the old value, you can do something like this:
<PRE>
<FONT>cPar *value = a.redirection();  // bb's pointer
</FONT>a.cancelRedirection();          // break the link; value of a is now 0
a = *value;                     // copy the contents of bb into a
</PRE>
<H3><A NAME="_Toc473901806">Summary</A></H3>
<P>
The various <TT>cPar</TT> types and the member functions used
to manipulate them are summarized in the following table:<TABLE BORDER=1>
<TR><TD WIDTH=60><B>Type<BR>
<B>char</B></B></TD><TD WIDTH=78><B>Type<BR>
name</B>
</TD><TD WIDTH=234><B>Member functions</B></TD><TD WIDTH=258><B>Description</B>
</TD></TR>
<TR><TD WIDTH=60>S</TD><TD WIDTH=78>string</TD><TD WIDTH=234>
<PRE>
<FONT>setStringValue(char*)
</FONT>char *stringValue()
op char*()
op=(char *)</PRE>

</TD><TD WIDTH=258>string value. Short strings (len&lt;=27) are stored inside cPar object, without using heap allocation.
</TD></TR>
<TR><TD WIDTH=60>B</TD><TD WIDTH=78>boolean</TD><TD WIDTH=234><PRE>
<FONT>setBoolValue(bool)
</FONT>bool boolValue()
op bool()
op=(bool)</PRE>

</TD><TD WIDTH=258>boolean value. Can also be retrieved from the object as long (0 or 1).
</TD></TR>
<TR><TD WIDTH=60>L</TD><TD WIDTH=78>long int</TD><TD WIDTH=234><PRE>
<FONT>setLongValue(long)
</FONT>long longValue()
op long()
op=(long)</PRE>

</TD><TD WIDTH=258>signed long integer value. Can also be retrieved from the object as double.
</TD></TR>
<TR><TD WIDTH=60>D</TD><TD WIDTH=78>double</TD><TD WIDTH=234><PRE>
<FONT>setDoubleValue(double)
</FONT>double doubleValue()
op double()
op=(double)</PRE>

</TD><TD WIDTH=258>double-precision floating point value.</TD>
</TR>
<TR><TD WIDTH=60>F</TD><TD WIDTH=78>function</TD><TD WIDTH=234><PRE>
<FONT>setDoubleValue(
   MathFunc,
   [double],
   [double],
   [double])
</FONT>double doubleValue()
op double()</PRE>

</TD><TD WIDTH=258>Mathematical function with constant arguments. The function is given by its pointer; it must take 0,1,2 or 3 doubles and return a double. This type is mainly used to generate random numbers: e.g. the function takes mean and standard deviation and returns random variable of a certain distribution.
</TD></TR>
<TR><TD WIDTH=60>X</TD><TD WIDTH=78>expr.</TD><TD WIDTH=234><PRE>
<FONT>setDoubleValue(
   sXElem*,int)
</FONT>double doubleValue()
op double()</PRE>

</TD><TD WIDTH=258>Reverse Polish expression. Expression can contain constants, cPar objects, refer to other cPars (e.g. module parameters), can use many math operators (+-*/^% etc), function calls (function must take 0,1,2 or 3 doubles and return a double). The expression must be given is in an sXElem array (see later).
</TD></TR>
<TR><TD WIDTH=60>T</TD><TD WIDTH=78>distrib.</TD><TD WIDTH=234><PRE>
<FONT>setDoubleValue(
   cStatistic*)
</FONT>double doubleValue()
op double()</PRE>

</TD><TD WIDTH=258>random variable generated from a distribution collected by a statistical data collection object (derived from cStatistic).
</TD></TR>
<TR><TD WIDTH=60>P</TD><TD WIDTH=78>void* pointer</TD><TD WIDTH=234><PRE>
<FONT>setPointerValue(void*)
</FONT>void *pointerValue()
op void *()
op=(void *)</PRE>

</TD><TD WIDTH=258>pointer to a non-cObject item (C struct, non-cObject object etc.) Memory management can be controlled through the configPointer() member function.
</TD></TR>
<TR><TD WIDTH=60>O</TD><TD WIDTH=78>object pointer</TD><TD WIDTH=234><PRE>
<FONT>setObjectValue(cObject*)
</FONT>cObject *objectValue()
op cObject *()
op=(cObject *)</PRE>

</TD><TD WIDTH=258>pointer to an object derived from cObject.<P>
Ownership management is done through takeOwnership().
</TD></TR>
<TR><TD WIDTH=60>I</TD><TD WIDTH=78>indirect value</TD><TD WIDTH=234><PRE>
<FONT>setRedirection(cPar*)
</FONT>bool isRedirected()
cPar *redirection()
cancelRedirection()</PRE>

</TD><TD WIDTH=258>value is redirected to another cPar object. All value setting and reading operates on the other cPar; even the type() function will return the type in the other cPar (so you'll never get 'I' as the type). This indirection can only be broken with the cancelIndirection() member function.<P>
Module parameters taken by REF use this mechanism.
</TD></TR>
</TABLE>
<PRE>
<FONT></FONT>
</PRE>
<H2><A NAME="_Toc473901807">Statistics and distribution estimation</A>
</H2>
<H3><A NAME="_Toc473901808">cStatistic and descendants</A></H3>
<P>
There are several statistic and result collection classes: <TT>cStdDev</TT>,
<TT>cWeightedStdDev</TT>, <TT>LongHistogram</TT>, <TT>cDoubleHistogram</TT>,
<TT>cVarHistogram</TT>, <TT>cPSquare</TT> and <TT>cKSplit</TT>.
They are all derived from the abstract base class <TT>cStatistic.</TT>
<UL>
<LI><TT>cStdDev</TT> keeps number of samples, mean, standard deviation,
minimum and maximum value etc. 
<LI><TT>cWeightedStdDev</TT> is similar to <TT>cStdDev</TT>, but
accepts weighted observations. <TT>cWeightedStdDev</TT>  can be
used for example to calculate time average. It is the only weighted
statistics class.
<LI><TT>cLongHistogram</TT> and <TT>cDoubleHistogram</TT> are
descendants of <TT>cStdDev</TT> and also keep an approximation
of the distribution of the observations using equidistant (equal-sized)
cell histograms.
<LI><TT>cVarHistogram</TT> implements a histogram where cells
do not need to be the same size. You can manually add the cell
(bin) boundaries, or alternatively, automatically have a partitioning
created where each bin has the same number of observations (or
as close to that as possible). 
<LI><TT>cPSquare</TT> is a class that uses the P<SUP>2</SUP> algorithm
described in [JCH85]. The algorithm calculates quantiles without
storing the observations; one can also think of it as a histogram
with equiprobable cells. 
<LI><TT>cKSplit</TT> uses a novel, experimental method, based
on an adaptive histogram-like algorithm. (Published papers about
<I>k-split</I> can be downloaded from the OMNeT++ Web site; just
go one level up in the directories: http://www.hit.bme.hu/phd/vargaa).
Because k-split is not very well known, we'll devote a section
to it.
</UL>
<P>
<B>Basic usage</B>
<P>
One can insert an observation into a statistic object with the
<TT>collect()</TT> function or the <TT>+=</TT> operator (they
are equivalent). <TT>cStdDev</TT> has the following methods for
getting statistics out of the object: <TT>samples()</TT>, <TT>min()</TT>,
<TT>max()</TT>, <TT>mean()</TT> , <TT>stddev()</TT>, <TT>variance()</TT>
with the obvious meanings. An example usage for <TT>cStdDev</TT>:
<PRE>
<FONT>cStdDev stat(&quot;stat&quot;);
</FONT>for (int i=0; i&lt;10; i++)  
    stat.collect( normal(0,1) );
long num_samples = stat.samples();
double smallest = stat.min(),
       largest  = stat.max();
double mean = stat.mean(),
       standard_deviation = stat.stddev(),
       variance = stat.variance();
</PRE>
<H3><A NAME="_Toc473901809">Distribution estimation</A></H3>
<P>
<B>Initialization and usage</B>
<P>
The distribution estimation classes (the histogram classes, <TT>cPSquare</TT>
and <TT>cKSplit</TT>)  are derived from <TT>cDensityEstBase</TT>.
Distribution estimation classes (except for <TT>cPSquare</TT>)
 assume that the observations are within a range. You may specify
the range explicitly (based on some a-priori info about the distribution)
or you may let the object collect the first few observations and
determine the range from them. Methods which let you specify range
settings are part of <TT>cDensityEstBase</TT>. The following member
functions exist:
<PRE>
<FONT>setRange(lower,upper);
</FONT>setRangeAuto(num_firstvals, range_ext_factor);
setRangeAutoLower(upper, num_firstvals, range_ext_factor);
setRangeAutoUpper(lower, num_firstvals, range_ext_factor);

setNumFirstVals(num_firstvals);
</PRE>
<P>
The following example creates a histogram with 20 cells and automatic
range estimation:
<PRE>
<FONT>cDoubleHistogram histogram(&quot;histogram&quot;, 20);
</FONT>histogram.setRangeAuto(100,1.5);
</PRE>
<P>
Here, 20 is the number of cells (not including the underflow/overflow
cells, see later), and 100 is the number of observations to be
collected before setting up the cells. 1.5 is the range extension
factor. It means that the actual range of the initial observations
will be expanded 1.5 times and this expanded range will be used
to lay out the cells. This method increases the chance that further
observations fall in one of the cells and not outside the histogram
range.
<P>
<CENTER><IMG SRC="img00012.gif"><BR>
Fig.5.4. Setting up a histogram's range</CENTER>
<P>
After the cells have been set up, collecting can go on. 
<P>
The <TT>transformed()</TT> function returns true when the cells
have already been set up. You can force range estimation and setting
up the cells by calling the <TT>transform()</TT> function.
<P>
The observations that fall outside the histogram range will be
counted as underflows and overflows. The number of underflows
and overflows are returned by the <TT>underflowCell()</TT> and
<TT>overflowCell()</TT> member functions.
<P>
<CENTER><IMG SRC="img00013.gif"><BR>
Fig.5.5. Histogram structure after setting up the cells</CENTER>
<P>
You create a P<SUP>2</SUP> object by specifying the number of
cells:
<PRE>
<FONT>cPSquare psquare(&quot;interarrival-times&quot;, 20);
</FONT>
</PRE>
<P>
Afterwards, a <TT>cPSquare</TT> can be used with the same member
functions as a histogram.
<P>
There are three member functions to explicitly return cell boundaries
and the number of observations is each cell. <TT>cells()</TT>
returns the number of cells, <TT>basepoint(int k)</TT> returns
the <I>k</I>th base point, <TT>cell(int k)</TT> returns the number
of observations in cell <I>k</I>, and <TT>cellPDF(int k)</TT>
returns the PDF value in the cell. These functions work for all
histogram types, <TT>cPSquare</TT> and <TT>cKSplit</TT>.
<P>
<CENTER><IMG SRC="img00014.gif"><BR>
Fig.5.6. base points and cells</CENTER>
<P>
An example:
<PRE>
<FONT>long n = histogram.samples();
</FONT>for (int i=0; i&lt;histogram.cells(); i++)
{
    double cellWidth = histogram.basepoint(i+1)-histogram.basepoint(i);
    int count = histogram.cell(i);
    double pdf = histogram.cellPDF(i);
    //...
}
</PRE>
<P>
The <TT>pdf(x)</TT> and <TT>cdf(x)</TT> member functions return
the value of the probability density function and the cumulated
density function at a given <I>x</I>, respectively.
<P>
The <TT>random()</TT> member function generates random numbers
from the distribution stored by the object:
<PRE>
<FONT>double rnd = histogram.random();
</FONT>
</PRE>
<P>
<TT>cStdDev</TT> assumes normal distribution.
<P>
You can also wrap the distribution object in a <TT>cPar</TT>:
<PRE>
<FONT>cPar rnd_par(&quot;rnd_par&quot;);
</FONT>rnd_par.setDoubleValue(&amp;histogram);
</PRE>
<P>
The <TT>cPar</TT> object stores the pointer to the histogram (or
P<SUP>2</SUP> object), and whenever it is asked for the value,
calls the histogram object's <TT>random()</TT> function:
<PRE>
<FONT>double rnd = (double)rnd_par;  // random number from the cPSquare
</FONT>
</PRE>
<P>
<B>Storing/loading distributions</B>
<P>
The statistic classes have <TT>loadFromFile()</TT> member functions
that read the histogram data from a text file. If you need a custom
distribution that cannot be written (or it is inefficient) as
a C function, you can describe it in histogram form stored in
a text file, and use a histogram object with <TT>loadFromFile()</TT>.
<P>
You can also use <TT>saveToFile()</TT>that writes out the distribution
collected by the histogram object:
<PRE>
<FONT>FILE *f = fopen(&quot;histogram.dat&quot;,&quot;w&quot;);
</FONT>histogram.saveToFile( f );      // save the distribution
fclose( f );

FILE *f2 = fopen(&quot;histogram.dat&quot;,&quot;r&quot;);
cDoubleHistogram hist2(&quot;Hist-from-file&quot;);
hist2.loadFromFile( f2 );          // load stored distibution
fclose( f2 );
</PRE>
<P>
<B>Histogram with custom cells</B>
<P>
<TT>cVarHistogram</TT> class. TBD comments.
<P>
Now we do support the following 2 uses of <TT>cVarHistogram</TT>:
<UL>
<LI>add all the boundaries (manually) before collecting samples
<LI>collect samples and transform() makes the boundaries
</UL>
<P>
Transform types for <TT>cVarHistogram</TT>:
<UL>
<LI><TT>HIST_TR_NO_TRANSFORM</TT>: no transformation; uses bin
boundaries previously defined by addBinBound()
<LI><TT>HIST_TR_AUTO_EPC_DBL</TT>: automatically creates equiprobable
cells
<LI><TT>HIST_TR_AUTO_EPC_INT</TT>: like the above, but uses a
different hack :-)
</UL>
<P>
Creating an object:
<PRE>
<FONT>cVarHistogram(char *s=NULL,
</FONT>                 int numcells=11,
                 int transformtype=HIST_TR_AUTO_EPC_DBL);
</PRE>
<P>
Manually adding a cell boundary:
<PRE>
<FONT>void addBinBound(double x);
</FONT>
</PRE>
<P>
Rangemin and rangemax is chosen after collecting the num_firstvals
initial observations. One cannot add cell boundaries when histogram
is already transformed.
<H3><A NAME="_Toc473901810">The k-split algorithm</A></H3>
<P>
<B>Purpose</B>
<P>
The k-split algorithm is an on-line distribution estimation method.
It was designed for on-line result collection in simulation programs.
The method was proposed by Varga and Fakhamzadeh in 1997. The
primary advantage of k-split is that without having to store the
observations, it gives a good estimate without requiring a-priori
information about the distribution, including the sample size.
The k-split algorithm can be extended to multi-dimensional distributions,
but here we deal with the one-dimensional version only.
<P>
<B>The algorithm</B>
<P>
The k-split algorithm is an adaptive histogram-type estimate which
maintains a good partitioning by doing cell splits. We start out
with a histogram range <I>[x<SUB>lo</SUB>, x<SUB>hi</SUB>)</I>
with <I>k</I> equal-sized histogram cells with observation counts
<I>n<SUB>1</SUB></I>, <I>n<SUB>2</SUB></I>, ... <I>n<SUB>k</SUB></I>.
Each collected observation increments the corresponding observation
count. When an observation count <I>n<SUB>i</SUB></I> reaches
a <I>split threshold</I>, the cell is split into <I>k</I> smaller,
equal-sized cells with observation counts <I>n<SUB>i,1</SUB></I>,
<I>n<SUB>i,2</SUB></I>, ... <I>n<SUB>i,k</SUB></I> initialized
to zero. The <I>n<SUB>i</SUB></I> observation count is remembered
and is called the <I>mother observation count</I> to the newly
created cells. Further observations may cause cells to be split
further (e.g. <I>n<SUB>i,1,1</SUB>,...n<SUB>i,1,k</SUB></I> etc.),
thus creating a <I>k</I>-order tree of observation counts where
leaves contain live counters that are actually incremented by
new observations, and intermediate nodes contain mother observation
counts for their children. If an observation falls outside the
histogram range, the range is extended in a natural manner by
inserting new level(s) at the top of the tree. The fundamental
parameter to the algorithm is the split factor <I>k</I>. Low values
of k, <I>k</I>=2 and <I>k</I>=3 are to be considered. In this
paper we examine only the <I>k</I>=2 case.
<P>
<CENTER><A NAME="_Ref420721862"><IMG SRC="img00015.gif"><BR>
</A>Figure 5.7. Illustration of the k-split algorithm, <I>k</I>=2.
The numbers in boxes represent the observation count values. </CENTER>
<P>
For density estimation, the total number of observations that
fell into each cell of the partition has to be determined. For
this purpose, mother observations in each internal node of the
tree must be distributed among its child cells and propagated
up to the leaves.
<P>
Let <I>n<SUB>...,i</SUB></I> be the (mother) observation count
for a cell, <I>s<SUB>...,i</SUB></I> be the total observation
count in a cell (<I>n<SUB>...,i</SUB></I> plus the observation
counts in all its sub-, sub-sub-, etc. cells), and <I>m<SUB>...,i</SUB></I>
the mother observations propagated to the cell. We are interested
in the <I>&ntilde;<SUB>...,i</SUB></I> = <I>n<SUB>...,i</SUB></I>
+ <I>m<SUB>...,i</SUB></I> estimated amount of observations in
the tree nodes, especially in the leaves. In other words, if we
have <I>&ntilde;<SUB>...,i</SUB></I> estimated observation amount
in a cell, how to divide it to obtain <I>m<SUB>...,i,1</SUB></I>,
<I>m<SUB>...,i,2 </SUB></I>... <I>m<SUB>...,i,k</SUB></I> that
can be propagated to child cells. Naturally, <I>m<SUB>...,i,1
</SUB></I>+ <I>m<SUB>...,i,2 </SUB></I>+...+ <I>m<SUB>...,i,k
</SUB></I>=<I> &ntilde;<SUB>...,i</SUB></I>. 
<P>
Two natural distribution methods are even distribution (when<I>
m<SUB>...,i,1</SUB></I> = <I>m<SUB>...,i,2</SUB></I> =...= <I>m<SUB>...,i,k</SUB></I>)
and proportional distribution (when <I>m<SUB>...,i,1</SUB></I>
: <I>m<SUB>...,i,2</SUB></I> : ... : <I>m<SUB>...,i,k</SUB></I>
= <I>s<SUB>...,i,1</SUB></I> : <I>s<SUB>...,i,2</SUB></I> : ...
: <I>s<SUB>...,i,k</SUB></I>). Even distribution is optimal when
the <I>s<SUB>...,i,j</SUB></I> values are very small, and proportional
distribution is good when the <I>s<SUB>...,i,j</SUB></I> values
are large compared to <I>m<SUB>...,i,j</SUB></I>. In practice,
a linear combination of them seems appropriate, where =0 means
even and =1 means proportional distribution:
<P>
<IMG SRC="img00016.gif">, [0,1]
<P>
<CENTER><IMG SRC="img00017.gif"></CENTER>
<P>
<CENTER>Figure 5.8. Density estimation from the k-split cell tree.
We assume =0, i.e. we distribute mother observations evenly</CENTER>
<P>
Note that while <I>n<SUB>...,i</SUB></I> are integers, <I>m<SUB>...,i</SUB></I>
and thus <I>&ntilde;<SUB>...,i</SUB></I> are typically real numbers.
The histogram estimate calculated from k-split is not exact, because
the frequency counts calculated in the above manner contain a
degree of estimation themselves. This introduces a certain<I>
cell division error</I>; the <I> </I>parameter should be selected
so that it minimizes that error. It has been shown that the cell
division error can be reduced to a more-than-acceptable small
value.
<P>
Strictly speaking, the k-split algorithm is semi-online, because
its needs some observations to set up the initial histogram range.
However, because of the range extension and cell split capabilities,
the algorithm is not very sensitive to the choice of the initial
range, so very few observations are enough for range estimation
(say <I>N<SUB>pre</SUB></I>=10). Thus we can regard k-split as
an on-line method. 
<P>
K-split can also be used in semi-online mode, when the algorithm
is only used to create an optimal partition from a larger number
of <I>N<SUB>pre</SUB></I> observations. When the partition has
been created, the observation counts are cleared and the <I>N<SUB>pre</SUB></I>
observations are fed into k-split once again. This way all mother
(non-leaf) observation counts will be zero and the cell division
error is eliminated. It has been shown that the partition created
by k-split can be better than both the equi-distant and the equal-frequency
partition.
<P>
OMNeT++ contains an experimental implementation of the k-split
algorithm, the <TT>cKSplit</TT> class. Research on k-split is
still under way.
<P>
<B>The cKSplit class</B>
<P>
TBD comments
<P>
Member functions:
<PRE>
<FONT>void setCritFunc(KSplitCritFunc _critfunc, double *_critdata);
</FONT>void setDivFunc(KSplitDivFunc _divfunc, double *_divdata);
void rangeExtension( bool enabled );

struct sGrid
{
  int parent;      // index of parent grid
  int reldepth;    // depth = (reldepth - rootgrid's reldepth)
  long total;      // sum of cells &amp; all subgrids (includes 'mother')
  int mother;      // observations 'inherited' from mother cell
  int cells[K];    // cell values
};

int treeDepth();
int treeDepth(sGrid&amp; grid);

double realCellValue(sGrid&amp; grid, int cell);
void printGrids();

sGrid&amp; grid(int k);
sGrid&amp; rootGrid();
</PRE>
<H3><A NAME="_Toc473901811">Transient detection and result accuracy</A>
</H3>
<P>
In many simulations, only the steady state performance (i.e. the
performance after the system has reached a stable state) is of
interest. The initial part of the simulation is called the transient
period. After the model has entered steady state, simulation must
proceed until enough statistical data have been collected to compute
result with the required accuracy.
<P>
Detection of the end of the transient period and a certain result
accuracy is supported by OMNeT++. The user can attach transient
detection and result accuracy objects to a result object (<TT>cStatistic</TT>'s
descendants). The transient detection and result accuracy objects
will do the specific algorithms on the data fed into the result
object and tell if the transient period is over or the result
accuracy has been reached.
<P>
The base classes for classes implementing specific transient detection
and result accuracy detection algorithms are:
<UL>
<LI><TT>cTransientDetection</TT>: base class for transient detection
<LI><TT>cAccuracyDetection</TT>: base class for result accuracy
detection
</UL>
<P>
<B>Basic usage</B>
<P>
TBD comments
<P>
Attaching detection objects to a cStatistic and getting pointers
to the attached objects:
<PRE>
<FONT>addTransientDetection(cTransientDetection *object);
</FONT>addAccuracyDetection(cAccuracyDetection *object);
cTransientDetection *transientDetectionObject();
cAccuracyDetection  *accuracyDetectionObject(); 
</PRE>
<P>
Detecting the end of the period:
<UL>
<LI>polling the detect() function of the object
<LI>installing a post-detect function
</UL>
<P>
<B>Transient detection</B>
<P>
Currently one transient detection algorithm is implemented, i.e.
there's one class derived from <TT>cTransientDetection</TT>. The
 <TT>cTDExpandingWindows</TT> class uses the sliding window approach
with two windows, and checks the difference of the two averages
to see if the transient period is over.
<PRE>
<FONT>void setParameters(int reps=3, 
</FONT>                   int minw=4,
                   double wind=1.3, 
                   double acc=0.3);
</PRE>
<P>
<B>Accuracy detection</B>
<P>
Currently one transient detection algorithm is implemented, i.e.
there's one class derived from <TT>cAccuracyDetection</TT>. The
algorithm implemented in the <TT>cADByStddev</TT> class is: divide
the standard deviation by the square of the number of values and
check if this is small enough.
<PRE>
<FONT>void setParameters(double acc=0.1, 
</FONT>                   int reps=3);
</PRE>
<H2><A NAME="_Toc473901812">Recording simulation results</A></H2>
<H3><A NAME="_Toc473901813">Output vectors: cOutVector</A></H3>
<P>
Objects of type <TT>cOutVector</TT> are responsible for writing
time series data (referred to as <I>output vectors</I>) to a file.
The <TT>record()</TT> member is used to output a value (or a value
pair) with a timestamp. 
<P>
It can be used like this:
<PRE>
<FONT>cOutVector resp_v( &quot;response time&quot;, 2 );

</FONT>while (...)
{
	double response_time;
	//...
	resp_v.record( response_time );
	//...
}
</PRE>
<P>
All <TT>cOutVector</TT> objects write to the same, common file.
The file is textual; each <TT>record()</TT> call generates a line
in the file. The output file can be processed using Plove, but
otherwise its simple format allows it to be easily processed with
<TT>sed</TT>, <TT>awk</TT>, <TT>grep</TT> and the like, and it
can be imported by spreadsheet programs. The file format is described
later in this manual (in the section about simulation execution).
<P>
You can disable the output vector or specify a simulation time
interval for recording. If the output vector object is disabled
or the simulation time is outside the specified interval, <TT>record()</TT>
does nothing.
<H3><A NAME="_Toc473901814">Output scalars</A></H3>
<P>
While output vectors are to record time series data and thus they
typically record a large volume of data during a simulation run,
output scalars are supposed to record a single value per simulation
run. You can use outputs scalars
<UL>
<LI>to record summary data at the end of the simulation run
<LI>to do several runs with different parameter settings/random
seed and determine the dependence of some measures on the parameter
settings. For example, multiple runs and output scalars are the
way to produce <I>Throughput vs. Offered Load</I> plots.
</UL>
<P>
Output scalars are recorded with the <TT>recordScalar()</TT> member
function. It is overloaded, you can use it to write <TT>double</TT>s
and strings (<TT>char *</TT>):
<PRE>
<FONT>double avg_throughput = total_bits / simTime();
</FONT>recordScalar(&quot;Average throughput&quot;, avg_throughput);
</PRE>
<P>
You can record whole statistics objects by calling <TT>recordStats()</TT>:
<PRE>
<FONT>cStdDev *eedstats = new cStdDev;
</FONT>....
recordStats(&quot;End-to-end Statistics&quot;, eedstats);
</PRE>
<P>
Calls to <TT>recordScalar()</TT> and <TT>recordStats()</TT> are
usually placed in the redefined <TT>finish()</TT> member function
of a simple module.
<P>
The above calls write into the (textual) output scalar file. The
output scalar file is preserved across simulation runs (unlike
the output vector file is, scalar files are not deleted at the
beginning of each run). Data are always appended at the end of
the file, and output from different simulation runs are separated
by special lines.
<H2><A NAME="_Toc473901815">Deriving new classes</A></H2>
<P>
Nearly all classes in the simulation class library are descendants
of <TT>cObject</TT>. If you want to derive a new class from <TT>cObject</TT>
or a <TT>cObject</TT> descendant, you must redefine some member
functions so that objects of the new type can fully co-operate
with other parts of the simulation system. A more-or-less complete
list of these functions are presented here. Do not be embarrassed
at the length of the list: most functions are not absolutely necessary
to implement. For example, you do not need to redefine <TT>forEach()</TT>
unless your class is a container class.
<UL>
<LI>default constructor, copy constructor. The copy constructor
can simply call the assignment operator.
<LI><TT>operator=():</TT> the assignment operator (copies object
contents from another object)
<LI><TT>dup()</TT>: duplicates the object by creating an exact
copy (uses copy constructor)
<LI><TT>className()</TT>: returns class name string
<LI><TT>info()</TT>: returns a one-line info about object contents
<LI><TT>writeContents()</TT>: write a more detailed report about
the object into a file
<LI><TT>forEach()</TT>: iterates through all contained objects
if any
<LI><TT>netPack(),netUnpack():</TT> they are needed only if objects
of this type will be sent over PVM from one segment to another.
The <TT>netPack(),netUnpack()</TT>functions of the library classes
are in the <TT>sim/pvm/pvmpack.cc</TT> file.
<LI><TT>inspectorFactoryName():</TT> used by Tkenv to create inspector
windows for objects of this type.
</UL>
<P>
One should also use the <TT>Register_Class()</TT> macro to register
the new class. It is used by the <TT>createOne()</TT> function
and the PVM extension of OMNeT++.
<P>
Let us see a simple example. The header file:
<PRE>
<FONT>// File: cmyclass.h
</FONT>#include &quot;cobject.h&quot;

class cMyClass : public cObject
{
   public:
        int samples;

        cMyClass(cMyClass&amp; myclass);
        cMyClass(char *name=NULL, int k=0);
        virtual ~cMyClass()  {}
        virtual char *className()  {return &quot;cMyClass&quot;;}
        virtual cObject *dup()  {return new cMyClass(*this);}
        virtual void info(char *buf);
        virtual void writeContents(ostream&amp; os);
        cMyClass&amp; operator=(cMyClass&amp; myclass);
};
</PRE>
<P>
The corresponding <TT>.cc</TT> file:
<PRE>
<FONT>// File: cmyclass.cc
</FONT>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;iostream.h&gt;
#include &quot;cmyclass.h&quot;

Register_Class( cMyClass );

cMyClass::cMyClass(cMyClass&amp; myclass) : cObject()
{
        setName( myclass.name() );
        operator=( myclass );
}

cMyClass::cMyClass(char *name, int k) : cObject( name )
{
        samples = k;
}

void cMyClass::info(char *buf)
{
        cObject::info( buf );
        sprintf( buf+strlen(buf), &quot; samples=%d&quot;, samples);
}

void cMyClass::writeContents(ostream&amp; os)
{
        os &lt;&lt; &quot;  samples:  &quot; &lt;&lt; samples &lt;&lt; '\n';
}

cMyClass&amp; cMyClass::operator=(cMyClass&amp; myclass)
{
        cObject::operator=(myclass);
        samples = myclass.samples;
}
</PRE>
<P>
See the virtual functions of <TT>cObject</TT> in the class library
reference for more information.
<H2><A NAME="_Toc473901816">Tracing and debugging aids</A></H2>
<H3><A NAME="_Toc473901817">Displaying information about module
activity</A></H3>
<P>
The global object called <TT>ev</TT> represents the user interface
of the simulation program. You can send data to <TT>ev</TT> using
the C++-style I/O operator (<TT>&lt;&lt;</TT>). 
<PRE>
<FONT>ev &lt;&lt; &quot;started\n&quot;;
</FONT>ev &lt;&lt; &quot;about to send message #&quot; &lt;&lt; i &lt;&lt; endl;
ev &lt;&lt; &quot;queue full, discarding packet\n&quot;;
</PRE>
<P>
The exact way messages are displayed to the user depends on the
user interface. In the command-line user interface (Cmdenv), it
is simply dumped to the standard output. (This output can also
be disabled from the ini file so that it doesn't slow down simulation
when it is not needed.) In windowing user interfaces (Tkenv),
each simple module can have a separate text output window. 
<P>
The above means that you should <I>not</I> use <TT>printf</TT>,
<TT>cout &lt;&lt;</TT> and the like because with Tkenv, their
output would appear in the <TT>xterm</TT> window behind the graphical
window of the simulation application.
<P>
The user can also specify a phase string that is displayed at
the top of the text output windows. The phase string can indicate
what the module is currently doing.
<PRE>
<FONT>setPhase(&quot;starting up&quot;);
</FONT>for(;;)
{
   setPhase(&quot;idle&quot;);
   //...
   setPhase(&quot;opening connection&quot;);
   ev &lt;&lt; &quot;connection request from &quot; &lt;&lt; src &lt;&lt; &quot;\n&quot;;
   //..
   setPhase(&quot;connection alive&quot;);
   //..
   setPhase(&quot;closing connection&quot;);
   //...
}
</PRE>
<P>
Writing out informative messages at strategic points of the code
is an effective way debugging.
<H3><A NAME="_Toc473901818">Watches</A></H3>
<P>
You may want some of your <TT>int</TT>, <TT>long</TT>, <TT>double</TT>,
<TT>char</TT>, etc. variables to be inspectable in Tkenv and to
be output into the snapshot file. In this case, you can create
<TT>cWatch</TT> objects for them with the <TT>WATCH</TT> macro:
<PRE>
<FONT>int i; WATCH(i);
</FONT>char c; WATCH(c);
</PRE>
<P>
Tkenv also lets you change the value of the <TT>WATCH</TT>ed variables.
<P>
The <TT>WATCH()</TT> macro expands to a dynamically  created <TT>cWatch</TT>
object. The object remembers the address and type of your variable.
The macro expands to something like:
<PRE>
<FONT>new cWatch(&quot;i&quot;,i);
</FONT>
</PRE>
<P>
You can also make a <TT>WATCH</TT> for pointers of type <TT>char*</TT>
or <TT>cObject*</TT>, but this may cause a segmentation fault
if the pointer does not point to a valid location when Tkenv or
<TT>snapshot()</TT> wants to use it.
<P>
You can also set watches for variables that are members of the
module class or for structure fields:
<PRE>
<FONT>WATCH( lapbconfig.timeout );
</FONT>
</PRE>
<P>
<B>Placement of WATCHes</B>
<P>
Be careful not to execute a <TT>WATCH</TT> statement more than
once, as each call would create a new <TT>cWatch</TT> object!
If you use <TT>activity()</TT>, the best place for <TT>WATCH</TT>es
is the top of the <TT>activity()</TT> function. If you use <TT>handleMessage()</TT>,
place the <TT>WATCH()</TT> statement into <TT>initialize()</TT>.
<TT>WATCH()</TT> creates a dynamic <TT>cWatch</TT> object, and
we do not want to create a new object each time <TT>handleMessage()</TT>
is called.
<H3><A NAME="_Toc473901819">Snapshots</A></H3>
<P>
The <TT>snapshot()</TT> function outputs textual information about
all or selected objects of the simulation (including the objects
created in module functions by the user) into the snapshot file.
<PRE>
<FONT>bool snapshot(cObject *obj = &amp;simulation, char *label = NULL);
</FONT>
</PRE>
<P>
The function can be called from module functions, like this:
<PRE>
<FONT>snapshot();           // dump the whole network
</FONT>snapshot(this);       // dump this simple module and all its objects
snapshot(&amp;putAsideQueue);        // dump queue contents
snapshot(&amp;simulation.msgQueue);  // dump future events
</PRE>
<P>
This will append snapshot information to the end of the snapshot
file. (The snapshot file name has an extension of <TT>.sna</TT>,
default is <TT>omnetpp.sna</TT>. Actual file name can be set in
the config file.)
<P>
The snapshot file output is detailed enough to be used for debugging
the simulation: by regularly calling <TT>snapshot()</TT>, one
can trace how the values of variables, objects changed over the
simulation. The arguments: <TT>label</TT> is a string that will
appear in the output file; <TT>obj</TT> is the object whose inside
is of interest. By default, the whole simulation (all modules
etc) will be written out.
<P>
If you run the simulation with Tkenv, you can also create a snapshot
from the menu.
<P>
An example of a snapshot file:
<PRE>
<FONT>================================================
</FONT>||               SNAPSHOT                     ||
================================================
| Of object:    `simulation'
| Label:        `three-station token ring'
| Sim. time:     0.0576872457 ( 57ms)
| Network:      `token'
| Run no.        1
| Started at:    Mar 13, 1997, 14:23:38
| Time:          Mar 13, 1997, 14:27:10
| Elapsed:       5 sec
| Initiated by:  operator
================================================

(cSimulation) `simulation' begin
  Modules in the network:
    `token' #1 (TokenRing)
        `comp[0]' #2 (Computer)
            `mac' #3 (TokenRingMAC)
            `gen' #4 (Generator)
            `sink' #5 (Sink)
        `comp[1]' #6 (Computer)
            `mac' #7 (TokenRingMAC)
            `gen' #8 (Generator)
            `sink' #9 (Sink)
        `comp[2]' #10 (Computer)
            `mac' #11 (TokenRingMAC)
            `gen' #12 (Generator)
            `sink' #13 (Sink)
end

(cCompoundModule) `token' begin
   #1 params    (cArray) (n=6)
   #1 gates     (cArray) (empty)
   comp[0]         (cCompoundModule,#2)
   comp[1]         (cCompoundModule,#6)
   comp[2]         (cCompoundModule,#10)
end

(cArray) `token.parameters' begin
   num_stations (cModulePar) 3 (L)
   num_messages (cModulePar) 10000 (L)
   ia_time      (cModulePar) truncnormal(0.005,0.003) (F)
   THT          (cModulePar) 0.01 (D)
   data_rate    (cModulePar) 4000000 (L)
   cable_delay  (cModulePar) 1e-06 (D)
end

(cModulePar) `token.num_stations' begin
  Type: L
  Value: 3
end

<I>[...token.num_messages omitted...]

</I>(cModulePar) `token.ia_time' begin
  Type:  F
  Value: truncnormal(0.005,0.003)
end

<I>[...rest of parameters &amp; gates stuff deleted from here...]

</I>(cCompoundModule) `token.comp[0]' begin
   parameters   (cArray) (empty)
   gates        (cArray) (n=2)
   mac             (TokenRingMAC,#3)
   gen             (Generator,#4)
   sink            (Sink,#5)
end

(cArray) `token.comp[0].parameters' begin
end

(cArray) `token.comp[0].gates' begin
   in           (cGate)  &lt;-- comp[2].out
   out          (cGate)  --&gt; D --&gt; comp[1].in
end

(cGate) `token.comp[0].in' begin
  type:  input
  inside connection:  token.comp[0].mac.phy_in
  outside connection: token.comp[2].out
  delay: -
  error: -
  data rate: -
end

(cGate) `token.comp[0].out' begin
  type:  output
  inside connection:  token.comp[0].mac.phy_out
  outside connection: token.comp[1].in
  delay:              (cPar) 1e-06 (D)
  error: -
  data rate: -
end

(TokenRingMAC) `token.comp[0].mac' begin
   parameters   (cArray) (n=2)
   gates        (cArray) (n=4)
   local-objects (cHead)
   class-data-members (cHead)
   putaside-queue (cQueue) (empty)
end

<I>[...comp[0].mac parameters stuff deleted from here...]

</I>(cArray) `token.comp[0].mac.gates' begin
   phy_in       (cGate)  &lt;-- &lt;parent&gt;.in
   from_gen     (cGate)  &lt;-- gen.out
   phy_out      (cGate)  --&gt; &lt;parent&gt;.out
   to_sink      (cGate)  --&gt; sink.in
end

<I>[...detailed gate list deleted from here...]

</I>(cHead) `token.comp[0].mac.local-objects' begin
   sendqueue-length (cOutVector) (single)
   send-queue   (cQueue) (n=11)
end

(cOutVector) `token.comp[0].mac.local-objects.sendqueue-length' begin
end

(cQueue) `token.comp[0].mac.local-objects.send-queue' begin
   0--&gt;1        (cMessage) Tarr=0.0158105774 ( 15ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0163553310 ( 16ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0205628236 ( 20ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0242203591 ( 24ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0300994268 ( 30ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0364005251 ( 36ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0370745702 ( 37ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0387984129 ( 38ms)  Src=#4 Dest=#3
   0--&gt;1        (cMessage) Tarr=0.0457462493 ( 45ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0487308918 ( 48ms)  Src=#4 Dest=#3
   0--&gt;2        (cMessage) Tarr=0.0514466766 ( 51ms)  Src=#4 Dest=#3
end

(cMessage) `token.comp[0].mac.local-objects.send-queue.0--&gt;1' begin
  #4 --&gt; #3
  sent:      0.0158105774 ( 15ms)
  arrived:   0.0158105774 ( 15ms)
  length:    33536
  kind:      0
  priority:  0
  error:     FALSE
  time stamp:0.0000000  ( 0.00s)
  parameter list:
   dest         (cPar) 1 (L)
   source       (cPar) 0 (L)
   gentime      (cPar) 0.0158106 (D)
end

(cArray) `token.comp[0].mac.local-objects.send-queue.0--&gt;1.par-vector' begin
   dest         (cPar) 1 (L)
   source       (cPar) 0 (L)
   gentime      (cPar) 0.0158106 (D)
end

<I>[...message parameters and the other messages' stuff deleted...]

</I>(cHead) `token.comp[0].mac.class-data-members' begin
end

(cQueue) `token.comp[0].mac.putaside-queue' begin
end

<I>[...comp[0].gen and comp[0].sink stuff deleted from here...]
[...whole comp[1] and comp[2] stuff deleted from here...]

</I>(cMessageHeap) `simulation.message-queue' begin
   1--&gt;0        (cMessage) Tarr=0.0576872457 ( 57ms)  Src=#8 Dest=#7
                (cMessage) Tarr=0.0577201630 ( 57ms)  Mod=#8 (selfmsg)
                (cMessage) Tarr=0.0585677054 ( 58ms)  Mod=#4 (selfmsg)
                (cMessage) Tarr=0.0594939072 ( 59ms)  Mod=#12 (selfmsg)
                (cMessage) Tarr=0.0601010000 ( 60ms)  Mod=#7 (selfmsg)
   1--&gt;2        (cMessage) Tarr=0.0601020000 ( 60ms)  Src=#11 Dest=#13
end

<I>[...detailed list of message queue contents deleted from here...]
</I>
</PRE>
<P>
To reduce the size of the file, you may well decide to make a
snapshot only of a part of the model. This example reports only
about the current simple module's put-aside queue:
<PRE>
<FONT>snapshot(&amp;putAsideQueue);
</FONT>
</PRE>
<H3><A NAME="_Toc473901820">Breakpoints</A></H3>
<P>
<B>With activity() only!</B> In those user interfaces which support
debugging, breakpoints stop execution and the state of the simulation
can be examined.
<P>
You can set a breakpoint inserting a <TT>breakpoint()</TT> call
into the source:
<PRE>
<FONT>for(;;)
</FONT>{
   cMessage *msg = receive();
   breakpoint(&quot;before-processing&quot;);
   //..
   breakpoint(&quot;before-send&quot;);
   send( reply_msg, &quot;out&quot; );
   //..
}
</PRE>
<P>
In user interfaces that do not support debugging, <TT>breakpoint()</TT>
calls are simply ignored.
<H3><A NAME="_Toc473901821">Disabling warnings</A></H3>
<P>
Some container classes and functions suspend the simulation and
issue warning messages in potentially bogus/dangerous situations,
for example when an object is not found and NULL pointer/reference
is about to be returned. Very often this is useful, but sometimes
it is more trouble. You can turn warnings on/off from the ini
file (warnings=yes/no).
<P>
It is a good practice to leave warnings enabled, and temporarily
disable warnings in places where OMNeT++ would normally issue
warnings but you know the code is correct. This is done in the
following way:
<PRE>
<FONT>bool w = simulation.warnings();
</FONT>simulation.setWarnings( false );
...
... // critical code
...
simulation.setWarnings( w );
</PRE>
<H3><A NAME="_Toc473901822">Getting coroutine stack usage</A>
</H3>
<P>
If is important to choose the correct stack size for modules.
If the stack is too large, it unnecessarily consumes memory; if
it is too small, stack violation occurs.
<P>
From the Feb99 release, OMNeT++ contains a mechanism that detects
stack overflows. It checks the intactness of a predefined byte
pattern (<TT>0xdeadbeef</TT>) at the stack boundary, and reports
&quot;stack violation&quot; if it was overwritten. The mechanism
usually works fine, but occasionally it can be fooled by large
-- and not fully used -- local variables (e.g. <TT>char buffer[256]</TT>):
if the byte pattern happens to fall in the middle of such a local
variable, it may be preserved intact and OMNeT++ does not detect
the stack violation.
<P>
To be able to make a good guess about stack size, you can use
the <TT>stackUsage()</TT> call which tells you how much stack
the module actually uses. It is most conveniently called from
<TT>finish()</TT>:
<PRE>
<FONT>void FooModule::finish()
</FONT>{
   ev &lt;&lt; stackUsage() &lt;&lt; &quot;bytes of stack used\n&quot;;
}
</PRE>
<P>
The value includes the extra stack added by the user interface
library (see <I>extraStackforEnvir</I> in <TT>envir/omnetapp.h</TT>),
which is currently 8K for Cmdenv and 16K for Tkenv.
<P>
<TT>stackUsage()</TT>also works by checking the existence of predefined
byte patterns in the stack area, so it is also subject to the
above effect with local variables.<BR>
<H2><A NAME="_Toc473901823">Changing the network graphics at run-time</A>
</H2>
<P>
Sometimes it is useful to change the appearance of some components
in the network graphics, such as the color of the modules, color/width
of connection arrows etc. 
<P>
The appearance of nodes and connections is determined by the display
strings. Display strings are initially taken from the NED description
(stuff like: <TT>display: &quot;p=100,10;i=pc&quot;</TT> ). You
can change the display string of a module or connection arrow
at run-time by calling <TT>setDisplayString()</TT>. The display
string of a connection arrow is stored in its source gate. Display
string changes will immediately take effect. 
<P>
Examples:
<PRE>
<FONT>  setDisplayString(dispSUBMOD,&quot;p=100,100;b=60,30,rect;o=red,black,3&quot;);
</FONT>  parentModule()-&gt;setDisplayString(dispSUBMOD,&quot;p=100.....&quot;);
  gate(&quot;out&quot;)-&gt;setDisplayString(&quot;o=yellow,3&quot;);
</PRE>
<H2><A NAME="_Toc473901824">Tips for speeding up the simulation</A>
</H2>
<P>
Here are a few tips that can help you make the simulation faster:
<UL>
<LI>Turn off the display of screen messages when you run the simulation.
You can do this in the ini file. Alternatively, you can place
<TT>#ifdef</TT>s around your <TT>ev&lt;&lt;</TT> and <TT>ev.printf()</TT>
calls and turn off the define when compiling the simulation for
speed.
<LI>Store the module parameters in local variables to avoid calling
<TT>cPar</TT> member functions every time.
<LI>Use gate numbers instead of gate names.
<LI>Try to minimize message creations and deletions. Reuse messages
if possible.
<LI>Do not give name strings to objects that are created and deleted
many times (pass <TT>NULL</TT> pointer as name).
<LI>Use numeric index to get an object from a <TT>cArray</TT>,
not the object name. You can do this also with message parameters.
</UL>
<P>
Two techniques are discussed here in detail:
<UL>
<LI>message subclassing, and
<LI>using shared objects
</UL>
<H3><A NAME="_Toc473901825">Using shared objects</A></H3>
<P>
In a complex simulation, a lot of messages are created, sent and
destroyed. Messages typically have more or less parameters attached
to them as <TT>cPar</TT> objects and it frequently happens that
a certain parameter has identical values in all messages (for
example, source address in a frame is the same in all messages
sent by one module). Still, separate parameter objects are created
and destroyed with each message, which is very costly. One could
save significant amount of CPU time and memory if a single object
could serve as a parameter to all existing messages.
<P>
This can be achieved with proper ownership control. See the following
example:
<PRE>
<FONT>void MyComputer::activity()
</FONT>{
   cPar source_addr;    // address of this node
   cPar dest_addrs[3];  // possible destinations

   source_addr.setStringValue( &quot;DECnet000728&quot; );
   dest_addrs[0].setStringValue( &quot;cisco_F99030&quot; );
   dest_addrs[1].setStringValue( &quot;DEC___28E6AD&quot; );
   dest_addrs[2].setStringValue( &quot;DECnet000B04&quot; );

   long k=0;
   for(;;)
   {
      cMessage *packet = new cMessage(&quot;DATA&quot;);

      packet-&gt;addPar( *new cPar(&quot;sequence&quot;, 'L', k++) );

      packet-&gt;parList().takeOwnership( false );  // NOTE THIS LINE!!!

      packet-&gt;addPar( source_addr );
      packet-&gt;addPar( dest_addrs[ k%3 ] );

      send(packet, &quot;output-gate&quot;);

      wait( truncnormal(1.5, 0.5) );
   }
}
</PRE>
<P>
The above simple module code models the message generation part
of a computer on a LAN. The module sends out messages (packets)
to different stations in every 1.5 seconds or so. The messages
have three parameters: the source address, the destination address
and a sequence number. The source address is the same in each
packet, and there are only three possible destination stations.
The sequence number is different in each packet.
<P>
To avoid the overhead caused by having to create source and destination
address objects for each message, the module creates these objects
only once; they will be shared among all messages. Separate sequence
number objects are created for each message.
<P>
Let us see what happens to the sequence number object when it
is inserted into the message. The message object, by default,
takes the ownership of the object. Ownership means the <I>responsibility</I>
<I>of</I> <I>destruction</I>; that is, when the message is destroyed,
the parameter object will be destroyed as well.
<P>
This is exactly what we need most of the time. But if we just
added the <I>shared</I> source and destination address objects
to a message, then we would have problems when the message is
destroyed. Somehow it must be told to the message object to leave
our shared parameters alone and not to become their owner. This
is exactly what the 
<PRE>
<FONT>packet-&gt;parList().takeOwnership(false);
</FONT>
</PRE>
<P>
line does: it sets a flag that tells the message (to be more precise,
to its internal parameter list object) not to take the ownership
of objects that will be inserted from then on. It does not affect
objects already inserted. As a result, all messages will just
hold pointers to the shared <TT>cPar</TT> objects and never do
any harm to them.
<P>
The above example shows that with CPU-intensive simulations, you
can save a lot of computation time and memory just by using the
ownership mechanism already present in OMNeT++.
<HR><H1><A NAME="_Toc473901826">Building Simulation Programs</A></H1>
<H2><A NAME="_Toc473901827">Overview</A></H2>
<P>
As it was already mentioned, an OMNeT++ model physically consists
of the following parts:
<UL>
<LI>NED language topology description(s). These are files with
the <TT>.ned</TT> suffix.
<LI>Simple modules. These are C++ files, with <TT>.cc</TT> suffix.
</UL>
<P>
Model files are usually placed in the <TT>projects/modelname</TT>
subdirectory of the main OMNeT++ directory.
<P>
The NED files are compiled into C++ using the NEDC compiler which
is part of OMNeT++. The NEDC compiler (source and executable)
is normally located in the <TT>nedc</TT> subdirectory of the main
OMNeT++ directory.
<P>
The simulation system provides the following components that will
be part of the simulation executable:
<UL>
<LI>Simulation kernel with the simulation class library. This
is a library file with <TT>.a</TT> or <TT>.lib</TT> extension,
normally in the <TT>sim</TT> subdirectory of the main OMNeT++
directory. It comes in two versions: <TT>libsim_std.a</TT> (<TT>sim_std.lib</TT>)
is the standard version and <TT>libsim_pvm.a</TT> (<TT>sim_pvm.lib</TT>)
is the one to be used with parallel execution.
<LI>User interfaces. These are also library files (<TT>.a</TT>
or <TT>.lib</TT> file), normally in the <TT>envir</TT> directory
and other directories. The common part of all user interfaces
is <TT>libenvir.a</TT> (<TT>envir.lib</TT>), and the specific
user interfaces are <TT>libcmdenv.a</TT> (<TT>cmdenv.lib</TT>),
<TT>libtkenv.a</TT> (<TT>tkenv.lib</TT>). 
</UL>
<P>
Simulation programs are built from the above components. First,
the NED files are compiled into C++ source code using the NEDC
compiler. Then all C++ sources are compiled and linked with the
simulation kernel and a user interface to form a simulation executable.
<P>
The following figure gives an overview of the process of building
and running simulation programs.<BR>
<P>
<CENTER><IMG SRC="img00018.gif"><BR>
</CENTER>
<P>
This section discusses how to use the simulation system on the
following platforms:
<UL>
<LI>Unix with gcc installed (and which is similar, Cygwin on Windows
NT)
<LI>Borland C++ 5.0 on Windows NT
<LI>MSVC 6.0 on Windows NT
</UL>
<H2><A NAME="_Toc473901828">Using Unix and gcc</A></H2>
<H3><A NAME="_Toc473901829">Installation</A></H3>
<P>
Installation essentially consists of building NEDC and the necessary
libraries. 
<P>
After you've unpacked the distribution in your home directory,
just type the following commands:
<PRE>
<FONT>cd ~/omnetpp
</FONT>./configure
./makeall
</PRE>
<P>
It will build all the libraries and the example programs for you.
If you have a C++ compiler other then gcc, you'll have to edit
the <TT>configur</TT> script.
<H3><A NAME="_Toc473901830">Producing a makefile with the makemake
script</A></H3>
<P>
The <TT>makemake</TT> script can automatically generate the <TT>makefile</TT>
for your simulation program, based on the source files it finds
in your directory. <TT>makemake</TT> has several options; type
<PRE>
<FONT>makemake -h
</FONT>
</PRE>
<P>
to see them.
<P>
To be able to use <TT>makemake</TT>, you have to collect all your
sources (<TT>.ned</TT>, <TT>.cc</TT>, <TT>.h</TT> files) in one
directory. (Large models which spread across several directories
are covered later in this section.)
<P>
Then type 
<PRE>
<FONT>makemake
</FONT>
</PRE>
<P>
If you already had a makefile in that directory, you'll have to
force makemake to overwrite it:
<PRE>
<FONT>makemake -f
</FONT>
</PRE>
<P>
If you have problems, check the path definitions (locations of
include files and libraries etc.) in the <TT>configure</TT> script
and correct them if necessary. Then re-run <TT>configure</TT>
to commit the changes to all <TT>makefile</TT>s, the <TT>makemake</TT>
script etc.
<P>
You can specify the user interface (Cmdenv/Tkenv) with the <TT>-u</TT>
option (with no <TT>-u</TT>, Tkenv is the default):
<PRE>
<FONT>makemake -u Tkenv<BR>
</FONT>
</PRE>
<P>
The name of the output file is set with the -o option (the default
is the name of the directory):
<PRE>
<FONT>makemake -o fddi-net
</FONT>
</PRE>
<P>
If some of your source files are generated from ther files (for
example, you use machine-generated NED files), write make rule
into a file called <TT>makefrag</TT>. When you run <TT>makemake</TT>,
it will automatically insert <TT>makefrag</TT> into the resulting
<TT>makefile</TT>. (With the <TT>-i</TT> option, you can also
name other files to include into <TT>makefile</TT>).
<H3><A NAME="_Toc473901831">Multi-directory models</A></H3>
<P>
In the case of a large project, your source files may be spread
across several directories. You have to decide whether you want
to use static linking, shared or run-time loaded libraries. Here
we discuss static linking.
<P>
In each subdirectory (say <TT>trafgen/</TT> and <TT>router/</TT>),
run
<PRE>
<FONT>makemake -n
</FONT>
</PRE>
<P>
The <TT>-n</TT> option means no linking is necessary, only compiling
has to be done.
<P>
In your toplevel source directory, run
<PRE>
<FONT>makemake trafgen/ router/
</FONT>
</PRE>
<P>
This results in recursive <TT>makefiles</TT>: when you build the
simulation, <TT>make</TT> will descend into <TT>trafgen/</TT>
and <TT>router/</TT>, run <TT>make</TT> in both, then it will
link an executable with the object files in the two directories.
<P>
You may need to use the <TT>-I</TT> option if you include files
from other directories. The <TT>-I</TT> option is for both C++
and NED files. In our example, you could run
<PRE>
<FONT>makemake -n -I../router
</FONT>
</PRE>
<P>
in the <TT>trafgen/</TT> directory and vica versa.
<P>
If you're willing to play with shared and run-time loaded libraries,
several <TT>makemake</TT> options and the <TT>[General]/load-libs=</TT>
ini file option leave you enough room to do so.
<H3><A NAME="_Toc473901832">Static vs shared OMNeT++ system libraries</A>
</H3>
<P>
Default linking uses the shared libraries. One reason you would
want static linking is that debugging the OMNeT++ class library
is more trouble with shared libraries. Another reason might be
that you want to run the executable on another machine without
having to worry about setting <TT>LD_LIBRARY_PATH</TT>. 
<P>
If you want static linking, find the
<PRE>
<FONT>LIB_SUFFIX='so'
</FONT>
</PRE>
<P>
line in the <TT>configure</TT> script and change it to
<PRE>
<FONT>LIB_SUFFIX='a'
</FONT>
</PRE>
<P>
Then re-run the <TT>configure</TT> script and <TT>makeall</TT>.
This will create the static libraries. To ensure the linker will
actually use them (and not the shared ones), delete the <TT>*.so</TT>
files in the <TT>omnetpp/lib</TT> directory.
<H2><A NAME="_Toc473901833">Using Win32 with Borland C++ 5.0</A>
</H2>
<H3><A NAME="_Toc473901834">Compiling the libraries and nedc</A>
</H3>
<P>
IDE files are provided for all OMNeT++ libraries (Sim, Envir,
Cmdenv, Tkenv). You should be able to build the .lib files from
the Borland C++ IDE without problem. You may need to adjust the
include and lib paths in Options|Project --&gt; Directories.
<P>
Tkenv needs special treatment. You need to get the Tcl and Tk
sources (I tried with 8.0 patchlevel 2: <TT>tcl80p2.zip</TT> and
<TT>tk80p2.zip</TT>), build the libraries and install them properly.
Tkenv includes the Tk header files so before compiling Tkenv,
you may need to adjust the paths in Options|Project --&gt; Directories.
<P>
The default location of Tkenv's TCL script parts and the bitmaps
directory is passed to the Tkenv as a compile-time external define.
(At run-time, they can be overridden be the OMNETPP_TKENV_DIR
and OMNETPP_BITMAP_PATH environment variables.) You'll probably
need to adjust those paths too: they are in Options|Project --&gt;
Compiler --&gt; Defines.
<P>
To compile nedc, you'll need to get a bison/flex pair that works
in the Win95/NT command box. Alternatively, you can compile it
in DOS with Borland C++ 3.1 and with bison/flex from the DJGPP
package.
<H3><A NAME="_Toc473901835">Setting up a project file</A></H3>
<P>
It is best starting by copying an example simulation's project
file to a different name and modify that. What you will need to
have in your project file:
<UL>
<LI>your simple module C++ sources;
<LI>your NED files;
<LI>for each NED file, the C++ file it will compile into (the
<TT>_n.cc</TT> file). Place the <TT>.ned</TT> file under the <TT>_n.cc</TT>
file in the project tree hieararchy.
<LI>the OMNeT++ libraries: <TT>sim_std.lib</TT>, <TT>envir.lib</TT>,
plus <TT>cmdenv.lib</TT> or <TT>tkenv.lib</TT>, depending on which
user interface you want to link in. You also need the Tcl and
Tk libraries if you're using Tkenv. 
</UL>
<P>
If you started out from a project file in the distribution, you
can easily switch from one user interface to another by selecting
the Exclude From Parent option for exactly of the <TT>omnetpp-cmdenv</TT>
and <TT>omnetpp-tkenv</TT> source pools (right click --&gt; Edit
Local Options --&gt; Topics/Build Attributes --&gt; Exclude from
parent).
<P>
If you're going to build a LARGE model, be sure to increase the
stack size in Options|Project options|Linker|32-bit Linker|Reserved
stack size. The default is 0x1000000 (1MB), which is hardly enough
for OMNeT++ simulations. Increase it to 64MB for example: 0x40000000.
If the simulation exceeds the stack size configured here, you'll
get nice exceptions, General Protection Faults and the like.
<H3><A NAME="_Toc473901836">Starting from scratch</A></H3>
<P>
If you want to make your own project files (maybe for porting
to another compiler?), here are some hints:
<UL>
<LI>Compile as a 32-bit flat console application. None of the
special libraries (OWL, MFC, Class Library,  OCF etc) are needed.
<LI>You have to turn off exception handling, it conflicts with
the coroutine library somehow. In the IDE: Options|Project --&gt;
C++ Options --&gt; Exception Handling/RTTI --&gt; clear [ ] Enable
exceptions. It must be done both when compiling the libraries
and when compiling simulation applications.
<LI>Borland C++ does not recognize the .cc extension as C++. You
have to teach it: Options|Tools --&gt; select CppCompile --&gt;
Edit --&gt; Advanced --&gt; add the .cc extension to the Translate
From and Default For entries. Do the same with the EditText tool.
<LI>You also have to teach Borland C++ how to handle .ned files.
Select Options|Tools --&gt; New. Fill in the dialog as follows:
</UL>
<P>
Name: NEDCompile
<P>
Path: ..\..\src\nedc\nedc.exe
<P>
Command Line: $NOSWAP $CAP MSG(BORL2MSG) $EDNAME
<P>
Menu Text: NED Compile
<P>
Help Hint: OMNeT++ NED compiler
<P>
Select Advanced, and fill in the dialog:
<P>
Type: Translator
<P>
Translate From: .ned
<P>
Translate To: .cc
<P>
Default For: .ned
<H2><A NAME="_Toc473901837">Using Win32 with MSVC</A></H2>
<P>
TBD
<HR><H1><A NAME="_Toc473901838">Running The Simulation</A></H1>
<H2><A NAME="_Toc473901839">Command line switches</A></H2>
<P>
An OMNeT++ executable accepts the following command line switches:
<P>
<TT>-h</TT> The program prints a short help message and the networks
contained in the executable and exits.
<P>
<TT>-f&lt;</TT><I>fileName&gt;</I> Specify the name of the configuration
file. The default is <TT>omnetpp.ini</TT>. Multiple <TT>-f</TT>
switches can be given; this allows you to partition your configuration
file. For example, one file can contain your general settings,
another one most of the module parameters, another one the module
parameters you change often.
<P>
<TT>-l&lt;</TT><I>fileName&gt;</I> Load a shared object (<TT>.so</TT>
file on Unix). Multiple <TT>-l</TT> switches are accepted. Your
<TT>.so</TT> files may contain module code etc. By dynamically
loading all simple module code and compiled network description
(<TT>_n.o</TT> files on Unix) you can even eliminate the need
to re-link the simulation program after each change in a source
file. (Shared objects can be created with <TT>gcc -shared ...</TT>)
<P>
<TT>-r&lt;</TT><I>runs&gt;</I> Only recognized by simulations
linked with Cmdenv. It specifies which runs should be executed
(e.g. <TT>-r2,4,6-8</TT>). This option overrides the<TT> runs-to-execute=</TT>
option in the <TT>[Cmdenv]</TT> section of the ini file (see later).
<P>
All other options are read from the configuration file.
<P>
An example of running an OMNeT++ executable with the <TT>-h</TT>
flag:
<PRE>
<FONT>C:\OMNETPP\PROJECTS\FDDI&gt;fddi.exe -h

</FONT>OMNeT++ Discrete Simulation, TUB Dept. of Telecommunications, 1990-97

Networks in this program:
  1. NRing
  2. FDDI1

End run of OMNeT++
</PRE>
<H2><A NAME="_Toc473901840">The configuration file</A>: omnetpp.ini
</H2>
<H3><A NAME="_Toc473901841">Sections and entries</A></H3>
<P>
The configuration file (also called ini file, because it has an
<TT>.ini</TT> extension) contains options that control how the
simulation is executed and can also contain settings of model
parameters. The ini file is a text file consisting of entries
grouped into different sections. The following sections can exist:
<PRE>
<B><FONT>[General]
</FONT>[Cmdenv], [Tkenv],...
[Parameters]
[OutVectors]
[DisplayStrings]
[Machines]
[Slaves]
[Run 1], [Run 2], [Run 3],...
</B>
</PRE>
<P>
'<TT>#</TT>' and  '<TT>;</TT>' denote comments. A sample ini file:
<PRE>
<FONT># omnetpp.ini

</FONT><B>[General]
</B>ini-warnings = false
network = token
distributed = no
snapshot-file = token.sna
output-vector-file = token.vec
log-parchanges = no
parchange-file = token.pch
random-seed = 1
sim-time-limit = 1000ms
cpu-time-limit = 180s
total-stack-kb = 2048

<B>[Cmdenv]
</B>runs-to-execute = 1-3,5
module-messages = yes
verbose-simulation = no
display-update = 100ms

<B>[Parameters]
</B>token.num_stations = 3
token.num_messages = 10000

<B>[Run 1]
</B>token.wait_time = 10ms

<B>[Run 2]
</B>token.wait_time = 30ms
</PRE>
<P>
Parameters that were set to <TT>input</TT> value in the NED file
are searched for in the ini file.
<P>
OMNeT++ can execute several simulation runs automatically one
after another. If multiple runs are selected, option settings
and parameter values can be given either individually for each
run, or together for all runs, depending in which section the
option or parameter appears.
<P>
This is summarized in the following table:
<TABLE BORDER=1>
<TR><TD WIDTH=221><B>What</B></TD><TD WIDTH=221><B>If set for all runs together</B>
</TD><TD WIDTH=221><B>If set for individual runs</B></TD></TR>
<TR><TD WIDTH=221>general settings</TD><TD WIDTH=221><TT>[General]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>user interface-specific settings</TD><TD WIDTH=221><TT>[Cmdenv]</TT>, <TT>[Tkenv]</TT> etc.
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>module parameter values</TD><TD WIDTH=221><TT>[Parameters]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>output vector configuration</TD><TD WIDTH=221><TT>[OutVectors]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>graphical appearance</TD><TD WIDTH=221><TT>[DisplayStrings]</TT>
</TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.</TD>
</TR>
<TR><TD WIDTH=221>logical - physical machine mappings</TD><TD WIDTH=221><TT>[Machines]</TT>
</TD><TD WIDTH=221>not possible</TD></TR>
<TR><TD WIDTH=221>with distributed execution: settings for slave processes
</TD><TD WIDTH=221><TT>[Slaves]</TT></TD><TD WIDTH=221><TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc.
</TD></TR>
</TABLE>
<P>
<P>
The most important options of the <TT>[General]</TT> section are
the following.
<UL>
<LI>The <TT>ini-warnings </TT>option can be used for &quot;debugging&quot;
ini files: if enabled, it lists which options were searched for
but not found. 
<LI>The <TT>network</TT> option selects the model to be set up
and run. 
<LI>The length of the simulation can be set with the <TT>sim-time-limit</TT>
and the <TT>cpu-time-limit</TT> options (the usual time units
such as <TT>ms</TT>, <TT>s</TT>, <TT>m</TT>, <TT>h</TT>, etc.
can be used). 
<LI>The <TT>warnings</TT> option enables/disables run-time warnings;
it is recommended to be turned on while debugging. 
<LI>The <TT>distributed</TT> flag selects between normal and parallel
execution. 
<LI>The output file names can be set with the following options:
<TT>snapshot-file</TT>, <TT>output-vector-file</TT>, <TT>output-scalar-file</TT>,
<TT>parchange-file.</TT> (For the last file to be written, one
must explicitly enable parameter change logging with the <TT>log-parchanges</TT>
option). 
<LI>The <TT>load-libs</TT> entry can be used to load shared objects
(containing simple modules, compiled NED code etc) at run-time.
Each setting has a meaningful default value.
</UL>
<P>
Almost any of the above options can also be specified individually
for each run. Per-run settings (if they exist) have priority over
globally set one.
<H3><A NAME="_Toc473901842">Splitting up the configuration file</A>
</H3>
<P>
OMNeT++ supports file inclusion in ini files. This feature allows
you to partition large ini files to logical units, fixed and varying
part etc.
<P>
An example:
<PRE>
<FONT># omnetpp.ini
</FONT>...
include parameters.ini
include per-run-pars.ini
...
</PRE>
<H3><A NAME="_Toc473901843">Module parameters in the configuration
file</A></H3>
<P>
Values for module parameters go into the <TT>[Parameters]</TT>
or the <TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc. sections of the
ini file. The run-specific settings take precedence over the overall
settings. Parameters that were assigned a (non-<TT>input</TT>)
value in the NED file are not influenced by ini file settings.
<P>
Wildcards (*,?) can be used to supply values to several model
parameters at a time. Filename-style (glob) and not regex-style
pattern matching is used. Character ranges use curly braces instead
of square brackets to avoid interference with the notation of
module vectors: <TT>{a-zA-Z}</TT>. If a parameter name matches
several wildcards-patterns, the first matching occurrence is used.
<P>
An example ini file:
<PRE>
<FONT># omnetpp.ini

</FONT><B>[Parameters]
</B>token.num_stations = 3
token.num_messages = 10000

<B>[Run 1]
</B>token.stations[*].wait_time = 10ms

<B>[Run 2]
</B>token.stations[0].wait_time = 5ms
token.stations[*].wait_time = 1000ms
</PRE>
<H3><A NAME="_Toc473901844">Configuring output vectors</A></H3>
<P>
As a simulation program is evolving, it is becoming capable of
collecting more and more statistics. The size of output vector
files can easily reach a magnitude of several ten or hundred megabytes,
but very often, only some of the recorded statistics are interesting
to the analyst. 
<P>
In OMNeT++, you can control how <TT>cOutVector</TT> objects record
data to disk. You can turn output vectors on/off or you can assign
a result collection interval. Output vector configuration is given
in the <TT>[OutVectors]</TT> section of the ini file, or in the
<TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc sections individually for
each run. By default, all output vectors are turned on.
<P>
Entries configuring output vectors can be like that:
<PRE>
<I><FONT>module-pathname</FONT></I><FONT>.<I>objectname</I>.enabled = yes/no
</FONT><I>module-p</I>athname.<I>objectname</I>.interval = <I>start</I>..<I>stop
module-pathname</I>.<I>objectname</I>.interval = ..<I>stop
module-pathname</I>.<I>objectname</I>.interval = <I>start</I>..
</PRE>
<P>
The object name is the string passed to <TT>cOutVector</TT> in
its constructor or with the <TT>setName()</TT> member function.
<PRE>
<FONT>cOutVector eed(&quot;End-to-End Delay&quot;,1);
</FONT>
</PRE>
<P>
Start and stop values can be any time specification accepted in
NED and config files (e.g. <I>10h 30m 45.2s</I>). 
<P>
As with parameter names, wildcards are allowed in the object names
and module path names.
<P>
An example:
<PRE>
<FONT>#
</FONT># omnetpp.ini
#

[OutVectors]
*.interval = 1s..60s
*.End-to-End Delay.enabled = yes
*.Router2.*.enabled = yes
*.enabled = no
</PRE>
<P>
The above configuration limits collection of all output vectors
to the 1s..60s interval, and disables collection of output vectors
except all end-to-end delays and the ones in any module called
<TT>Router2</TT>.
<H3><A NAME="_Toc473901845">Module parameter logging</A></H3>
<P>
It is possible to log all the changes to module parameters into
a text file. This can be useful when the simulation contains run-time
tuning of one or more module parameters and one wants to have
the trajectory documented.
<P>
Module parameter logging must be explicitly enabled from the header
file if one wants to use it:
<PRE>
<FONT>[General]
</FONT>log-parchanges = yes
parchange-file = token.pch
</PRE>
<P>
The format of the parameter change file is similar to the that
of the output vector file. 
<P>
If a parameter is taken by reference by several modules, any change
to the parameter will appear in the file under the name of the
top-level parameter, no matter which module actually changed it
and under what name.
<H3><A NAME="_Toc473901846">Display strings</A></H3>
<P>
Display strings control the modules' graphical appearance in the
Tkenv user interface. Display strings can be assigned to modules,
submodules and gates (a connection's display string is stored
in its &quot;from&quot; gate). Display strings can be hardcoded
into the NED file or specified in the configuration file. (Hardcoded
display strings take precedence over the ones given in ini files.)
Format of display string are documented in the User Interfaces
chapter.
<P>
Display strings can appear in the <TT>[DisplayStrings]</TT> section
of the ini file. They are expected as entries in one of the following
forms:
<PRE>
<I><FONT>moduletype</FONT></I><FONT> = &quot;...&quot;
</FONT><I>moduletype.submodulename</I> = &quot;...&quot;

<I>moduletype.inputgatename</I> = &quot;...&quot;
<I>moduletype.submodulename.outputgatename</I> = &quot;...&quot;
</PRE>
<P>
As with parameter names, wildcards are allowed in module types,
submodule and gate names.
<H3><A NAME="_Toc473901847">Specifying seed values</A></H3>
<P>
As is was pointed out earlier, it is of great importance that
different simulation runs and different random number sources
within one simulation run use non-overlapping sequences of random
numbers.
<P>
In OMNeT++, you have three choices:
<OL>
<LI>Automatic seed selection. 
<LI>Specify seeds in the ini file (with the help of the <TT>seedtool</TT>
program, see later)
<LI>Manually set the seed from within the program.
</OL>
<P>
If you decide for automatic seed selection, do not specify any
seed value in the ini file. For the random number generators,
OMNeT++ will automatically select seeds that are 1,000,000 values
apart in the sequence. If you have several runs, each run is started
with a fresh set of seeds that are 1,000,000 values apart from
the seeds used for previous runs. Since the generation of new
seed values is costly, OMNeT++ has a table of precalculated seeds
(256 values); if they are all used up, OMNeT++ starts from the
beginning of the table again.
<P>
Automatic seed selection may not be appropriate for you for several
reasons. First, you may need more than 256 seeds values; or, if
you use variance reduction techniques, you may want to use the
same seeds for several simulation runs. In this case, there is
a standalone program to generate appropriate seed values (<TT>seedtool</TT>
will be discussed in the next section), and you can specify the
seeds explicitly in the ini file.
<P>
The following ini file explicitly initializes two of the random
number generators, and uses different seed values for each run:
<PRE>
<FONT>[Run 1]
</FONT>gen0-seed = 1768507984
gen1-seed = 33648008

[Run 2]
gen0-seed = 1082809519
gen1-seed = 703931312
...
</PRE>
<P>
If you want the same seed values for all runs, you will write
something like this:
<PRE>
<FONT>[General]
</FONT>gen0-seed = 1768507984
gen1-seed = 33648008
</PRE>
<P>
All other random number generators (2,3,...) will have their seeds
automatically assigned.
<P>
As a third way, you can also set the seed values from the code
of a simple module using <TT>genk_randseed()</TT>, but I see no
reason why you would want to do so.
<H3><A NAME="_Toc473901848">List of all ini file options</A></H3>
<P>
The exact meaning of the different entries are:<TABLE BORDER=1>
<TR><TD COLSPAN=2 WIDTH=655>[General]</TD></TR>
<TR><TD WIDTH=289>ini-warnings = yes</TD><TD WIDTH=366>Helps debugging of the ini file. If turned on, OMNeT++ prints out the name of the entries it that it wanted to read but they were not in the ini file.
</TD></TR>
<TR><TD WIDTH=289>network = </TD><TD WIDTH=366>The name of the network to be simulated.
</TD></TR>
<TR><TD WIDTH=289>distributed = no</TD><TD WIDTH=366>Parallel execution or not.
</TD></TR>
<TR><TD WIDTH=289>number-of-runs = 1</TD><TD WIDTH=366>OMNeT++ will run multiple runs only of you set this value greater then 1; the existence of sections<TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc. alone is not enough.
</TD></TR>
<TR><TD WIDTH=289>snapshot-file = omnetpp.sna</TD><TD WIDTH=366>Name of the snapshot file. The result of each <TT>snapshot()</TT> call will be appended to this file.
</TD></TR>
<TR><TD WIDTH=289>output-vector-file = omnetpp.vec</TD><TD WIDTH=366>Name of output vector file.
</TD></TR>
<TR><TD WIDTH=289>output-scalar-file = omnetpp.sca</TD><TD WIDTH=366>Name of output scalar file.
</TD></TR>
<TR><TD WIDTH=289>pause-in-sendmsg = no</TD><TD WIDTH=366>Only makes sense with step-by-step execution. If enabled, OMNeT++ will split <TT>send()</TT> calls to two steps.
</TD></TR>
<TR><TD WIDTH=289>warnings = yes</TD><TD WIDTH=366>Globally turns on/off simulation runtime warnings. It is advisable to leave this turned on.
</TD></TR>
<TR><TD WIDTH=289>log-parchanges = no</TD><TD WIDTH=366>Specifies whether changes of module parameters should be logged to file.
</TD></TR>
<TR><TD WIDTH=289>parchange-file = omnetpp.pch</TD><TD WIDTH=366>File to save parameter changes to.
</TD></TR>
<TR><TD WIDTH=289>sim-time-limit = 1000ms</TD><TD WIDTH=366>Duration of the simulation in simulation time.
</TD></TR>
<TR><TD WIDTH=289>cpu-time-limit= 180s</TD><TD WIDTH=366>Duration of the simulation in real time.
</TD></TR>
<TR><TD WIDTH=289>random-seed = 542</TD><TD WIDTH=366>Random number seed for generator 0. Should not be zero.
</TD></TR>
<TR><TD WIDTH=289>total-stack-kb = 8192</TD><TD WIDTH=366>Specifies the total stack size (sum of all coroutine stacks) in kilobytes. You need to increase this value if you get the &quot;Cannot allocate coroutine stack ...&quot; error.
</TD></TR>
<TR><TD WIDTH=289>load-libs = </TD><TD WIDTH=366>Name of shared libraries (<TT>.so</TT> files) to load after startup. You can use it to load simple module code etc.
<P>
Example:<P>
<TT><FONT>load-libs=../x25/x25.so ../lapb/lapb.so</FONT></TT>
</TD></TR>
<TR><TD WIDTH=289>netif-check-freq=</TD><TD WIDTH=366>used with parallel execution
</TD></TR>
<TR><TD WIDTH=289>gen0-seed = 3567<BR>
gen1-seed = 4535<P>
...
</TD><TD WIDTH=366>Seeds for the given random number generator. They should not be zero.
</TD></TR>
</TABLE>
<P>

<TABLE BORDER=1>
<TR><TD COLSPAN=2 WIDTH=655>[Cmdenv]</TD></TR>
<TR><TD WIDTH=289>runs-to-execute=1,3-4,6</TD><TD WIDTH=366>Specifies which simulation runs should be executed
</TD></TR>
<TR><TD WIDTH=289>module-messages = yes/no</TD><TD WIDTH=366>Globally enables/disables <TT>ev</TT>-style messages in simple modules (e.g. <TT>ev &lt;&lt; &quot;sending\n&quot;;</TT>).
</TD></TR>
<TR><TD WIDTH=289>Verbose-simulation = yes/no</TD><TD WIDTH=366>Enable/disable banners for each event <BR>
(&quot;<TT>Event #1234, T=...&quot;</TT> stuff.)
</TD></TR>
<TR><TD WIDTH=289>display-update = 100ms</TD><TD WIDTH=366>If there would be no display from the simulation execution (both the above options are disabled), OMNeT++ can print out regular messages of the progress. The interval is understood in simulation time.
</TD></TR>
</TABLE>
<P>

<TABLE BORDER=1>
<TR><TD COLSPAN=2 WIDTH=655>[Tkenv]</TD></TR>
<TR><TD WIDTH=289>default-run = 1</TD><TD WIDTH=366>Specifies which run Tkenv should set up automatically after startup. If there's no default-run= entry or the value is 0, Tkenv will ask which run to set up.
</TD></TR>
<TR><TD WIDTH=289>use-mainwindow = yes</TD><TD WIDTH=366></TD>
</TR>
<TR><TD WIDTH=289>print-banners = yes</TD><TD WIDTH=366></TD>
</TR>
<TR><TD WIDTH=289>breakpoints-enabled = yes</TD><TD WIDTH=366>Specifies whether the simulation should be stopped at each <TT>breakpoint()</TT> call in the simple modules.
</TD></TR>
<TR><TD WIDTH=289>update-freq-fast = 10</TD><TD WIDTH=366></TD>
</TR>
<TR><TD WIDTH=289>update-freq-express = 500</TD><TD WIDTH=366>
</TD></TR>
<TR><TD WIDTH=289>animation-delay = 0.3s</TD><TD WIDTH=366>Delay between steps when you slow-execute the simulation.
</TD></TR>
<TR><TD WIDTH=289>Animation-enabled = yes</TD><TD WIDTH=366></TD>
</TR>
<TR><TD WIDTH=289>animation-msgnames = yes</TD><TD WIDTH=366>
</TD></TR>
<TR><TD WIDTH=289>animation-msgcolors = yes</TD><TD WIDTH=366>
</TD></TR>
<TR><TD WIDTH=289>animation-speed = 1.0</TD><TD WIDTH=366></TD>
</TR>
</TABLE>
<P>
<TABLE BORDER=1>
<TR><TD COLSPAN=2 WIDTH=655>[Slaves]</TD></TR>
<TR><TD WIDTH=289>write-slavelog = yes</TD><TD WIDTH=366></TD>
</TR>
<TR><TD WIDTH=289>slavelog-file = slave.log</TD><TD WIDTH=366>
</TD></TR>
<TR><TD WIDTH=289>module-messages = yes</TD><TD WIDTH=366></TD>
</TR>
<TR><TD WIDTH=289>errmsgs-to-console = yes</TD><TD WIDTH=366>
</TD></TR>
<TR><TD WIDTH=289>infomsgs-to-console = no</TD><TD WIDTH=366>
</TD></TR>
<TR><TD WIDTH=289>modmsgs-to-console = no</TD><TD WIDTH=366></TD>
</TR>
</TABLE>
<H2><A NAME="_Toc473901849">Choosing good seed values: the seedtool
utility</A></H2>
<P>
For selecting good seeds, the <TT>seedtool</TT> program can be
used (it is in the <TT>utils</TT> directory). When started without
command-line arguments, the program prints out the following help:
<PRE>
<FONT>seedtool - part of the OMNeT++ Simulation System, BME-HIT 1997
</FONT>A tool to help select good random number generator seed values.
Usage:
  seedtool i seed         - index of 'seed' in cycle
  seedtool s index        - seed at index 'index' in cycle
  seedtool d seed1 seed2  - distance of 'seed1' and 'seed2' in cycle
  seedtool g seed0 dist   - generate seed 'dist' away from 'seed0'
  seedtool g seed0 dist n - generate 'n' seeds 'dist' apart, starting at
                            'seed0'
  seedtool t              - generate hashtable
  seedtool p              - print out hashtable
</PRE>
<P>
The last two options, <TT>p</TT> and <TT>t</TT> were used internally
to generate a hash table of pre-computed seeds that greatly speeds
up the tool. For practical use, the <TT>g</TT> option is the most
important. Suppose you have 4 simulation runs that need two independent
random number generators each and you want to start their seeds
at least 10,000,000 values apart. The first seed value can be
simply 1. You would type the following command:
<PRE>
<FONT>C:\OMNETPP\UTILS&gt; seedtool g 1 10000000 8
</FONT>
</PRE>
<P>
The program outputs 8 numbers that can be used as random number
seeds:
<PRE>
<FONT>1768507984
</FONT>33648008
1082809519
703931312
1856610745
784675296
426676692
1100642647
</PRE>
<P>
You would specify these seed values in the ini file.
<H2><A NAME="_Toc473901850">Repeating or iterating simulation
runs</A></H2>
<P>
TBD Intro, and multiple simulation runs in omnetpp.ini vs controlling
script.
<P>
<B>Variations over parameter values</B>
<P>
You don't need to generate the whole <TT>omnetpp.ini</TT> from
program if you use include files. You can have a fixed <TT>omnetpp.ini</TT>
which contains the line 
<PRE>
<FONT>include parameters.ini
</FONT>
</PRE>
<P>
and then generate <TT>parameters.ini</TT> by program for each
run.
<P>
Here's the &quot;runall&quot; script of Joel Sherrill's <I>File
System Simulator</I> as an example:
<PRE>
<FONT>#! /bin/bash
</FONT>#
#  This script runs multiple variations of the file system simulator.
#
all_cache_managers=&quot;NoCache FIFOCache LRUCache PriorityLRUCache ...&quot;
all_schedulers=&quot;FIFOScheduler SSTFScheduler CScanScheduler ...&quot;

for c in ${all_cache_managers}; do
  for s in ${all_schedulers}; do
    (
      echo &quot;[Parameters]&quot;
      echo &quot;filesystem.generator_type = \&quot;GenerateFromFile\&quot;&quot;
      echo &quot;filesystem.iolibrary_type = \&quot;PassThroughIOLibrary\&quot;&quot;
      echo &quot;filesystem.syscalliface_type = \&quot;PassThroughSysCallIface\&quot;&quot;
      echo &quot;filesystem.filesystem_type = \&quot;PassThroughFileSystem\&quot;&quot;
      echo &quot;filesystem.cache_type = \&quot;${c}\&quot;&quot;
      echo &quot;filesystem.blocktranslator_type = \&quot;NoTranslation\&quot;&quot;
      echo &quot;filesystem.diskscheduler_type = \&quot;${s}\&quot;&quot;
      echo &quot;filesystem.accessmanager_type = \&quot;MutexAccessManager\&quot;&quot;
      echo &quot;filesystem.physicaldisk_type = \&quot;HP97560Disk\&quot;&quot;
    ) &gt;algorithms.ini

    ./filesystem
  done
done
</PRE>
<P>
And <TT>omnetpp.ini</TT> includes <TT>algorithms.ini</TT>.
<P>
<B>Variations over seed value (multiple independent runs)</B>
<P>
The same technique can be used if you want several runs with different
random seeds. This code should do 500 runs with independent seeds
(suppose one run doesn't use more than 10 million random values):
<PRE>
<FONT>#! /bin/bash
</FONT>for seed in `seedtool g 1 10000000 500`
do
    (
      echo &quot;[General]&quot;
      echo &quot;random-seed = ${seed}&quot;
      echo &quot;output-vector-file = xcube-${seed}.vec&quot;
    ) &gt;parameters.ini
    ./xcube
done
</PRE>
<P>
<TT>omnetpp.ini</TT> should include <TT>parameters.ini</TT>.
<P>
<B>Other languages for writing the control script</B>
<P>
The above examples use the Unix shell, but you have quite a number
of options in what language to implement the controlling script.
Some ideas:
<UL>
<LI>shell (mentioned above)
<LI>Perl
<LI>Tcl
<LI>Octave (suggested by Richard Lyon, see the <TT>contrib/octave</TT>
directory for examples)
<LI>DOS/Win32 batch (maybe this is not such a good idea...)
</UL>
<P>
<H2><A NAME="_Toc473901851">User interfaces of simulation executables</A>
</H2>
<P>
The user interface is separated from the simulation kernel; the
two parts interact through a well-defined interface. This construction
makes it possible to implement several types of user interfaces,
without changing the simulation kernel. Also, the same simulation
model can be executed with different user interfaces, without
any change in the model files themselves. The user would test
and debug the simulation with a powerful graphical user interface,
and finally run it with a simple and fast user interface that
supports batch execution.
<P>
User interfaces takes the form of libraries (<TT>.a</TT> file
or <TT>.so</TT> on UNIX, <TT>.lib</TT> or <TT>.dll</TT> file on
NT). The libraries are interchangeable. When the user creates
a simulation executable, he can pick one of the user interface
libraries that he links in.
<P>
Three user interfaces have been implemented:
<UL>
<LI>Cmdenv: command-line user interface for batch execution 
<LI>Tkenv: graphical, windowing user interface (Tcl/Tk) 
</UL>
<P>
The following sections contain more detailed descriptions about
each user interface.
<H3><A NAME="_Toc473901852">Cmdenv: the command-line user interface</A>
</H3>
<P>
The command line user interface is a small, portable and fast
user interface that compiles and runs on all platforms whether
it is UNIX, DOS, or WinNT console. Cmdenv is designed primarily
for batch execution.
<P>
Cmdenv uses simply executes all simulation runs that are described
in the configuration file. If one run stops with an error message,
subsequent ones will still be executed.
<P>
Cmdenv recognizes the following ini file options:
<PRE>
<FONT>[Cmdenv]
</FONT>runs-to-execute = 1,4-6,8
module-messages = no
verbose-simulation = no
display-update = 100ms
</PRE>
<P>
The first one specifies which runs (described in the <TT>[Run
1]</TT>, <TT>[Run 2]</TT> etc. sections) should be executed. If
the value is missing, Cmdenv executes all runs that have ini file
sections; if no runs are specified in the ini file, Cmdenv does
one run. The <TT>-r</TT> command line option overrides this ini
file setting.
<P>
The second and the third are yes/no settings and control the amount
of screen output during simulation. The fourth one is in effect
when the other two are disabled (that is, there would be no display
at all from the simulation execution); it prints out progress
messages at the specified frequency.
<P>
<U>Portability:</U> all platforms.
<H3><A NAME="_Toc473901853">Tkenv: graphical user interface on
Unix/NT</A></H3>
<P>
<B>Features</B>
<P>
Tkenv is a portable graphical windowing user interface. Tkenv
supports interactive execution of the simulation, tracing and
debugging. Tkenv is recommended in the development stage of a
simulation or for presentation and educational purposes, since
it allows one to get a detailed picture of the state of simulation
at any point of execution and to follow what happens inside the
network. The most important feaures are: 
<UL>
<LI>message flow animation
<LI>graphical display of statistics (histograms etc.) and output
vectors during simulation execution
<LI>separate window for each module's text output 
<LI>scheduled messages can be watched in a window as simulation
progresses 
<LI>event-by-event, normal and fast execution 
<LI>labelled breakpoints 
<LI>inspector windows to examine and alter objects and variables
in the model 
<LI>simulation can be restarted 
<LI>snapshots (detailed report about the model: objects, variables
etc.) 
</UL>
<P>
Tkenv makes it possible to view simulation results (output vectors
etc.) during execution. Results can be displayed as histograms
and time-series diagrams. This can speed up the process of verifying
the correct operation of the simulation program and provides a
good environment for experimenting with the model during execution.
When used together with gdb or xxgdb, Tkenv can speed up debugging
a lot.
<P>
<U>Portability:</U> Tkenv is built with Tcl/Tk. Tkenv should work
on all platforms that Tcl/Tk has been ported to: Unix/X, Win32,
Macintosh.
<P>
You can get more information about Tcl/Tk in the Web pages listed
in the Reference.
<P>
<B>Simulation running modes in Tkenv</B>
<P>
Tkenv has the following modes for running the simulation :
<UL>
<LI>Step
<LI>Run
<LI>Fast run
<LI>Express run
</UL>
<P>
The running modes have their corresponding buttons on Tkenv's
toolbar.
<P>
In <B>Step</B> mode, you can execute the simulation event-by-event.
<P>
In <B>Run</B> mode, the simulation runs with all tracing aids
on. Message animation is active and inspector windows are updated
after each event. Output messages are displayed in the main window
and midule output windows. You can stop the simulation with the
Stop button on the toolbar. You can fully interact with the user
interface while the simulation is running: you can open inspectors
etc.
<P>
In <B>Fast</B> mode, animation is turned off. The inspectors and
the message output windows are updated after each 10 events (the
actual number can be set in Options|Simulation options and also
in the ini file). Fast mode is several times faster than the Run
mode; the speedup can get close to 10 (or the configured event
count).
<P>
In <B>Express</B> mode, the simulation runs at about the same
speed as with Cmdenv, all tracing disabled. Module output is not
recorded in the output windows any more. You can interact with
the simulation only once in a while (1000 events is the default
as I recall), thus the run-time overhead of the user interface
is minimal. You have to explicitly push the Update inspectors
button if you want an update.
<P>
<B>Inspectors</B>
<P>
In Tkenv, objects can be viewed through inspectors. To start,
choose Inspect|Network from the menu. Usage should be obvious;
just use double-clicks and popup menus that are brought up by
right-clicking. In Step, Run and Fast Run modes, inspectors are
updated automatically as the simulation progresses. To make ordinary
variables (<TT>int</TT>, <TT>double</TT>, <TT>char</TT> etc.)
appear in Tkenv, use the <TT>WATCH()</TT> macro in the C++ code.
<P>
In list dialogs, entries begin with text like <TT>&quot;ptr0x8000ab7e&quot;</TT>.
Yes, it is really the object pointer; knowing it is exremely useful
if you're running the simulation under a debugger such as gdb.
<P>
<B>Configuring  Tkenv</B>
<P>
In case of nonstandard installation, it may be necessary to set
the <TT>OMNETPP_TKENV_DIR</TT> environment variable so that Tkenv
can find its parts written in Tcl script.
<P>
The default path from where the icons are loaded can be changed
with the <TT>OMNETPP_BITMAP_PATH</TT> variable, which is a semicolon-separated
list of directories and defaults to <TT>&quot;<I><FONT>omnetpp-dir</FONT></I>/bitmaps;.;./bitmaps&quot;</TT>.
<P>
The ini file options accepted by Tkenv are:
<PRE>
<FONT>[Tkenv]
</FONT>use-mainwindow = yes
print-banners = yes
breakpoints-enabled = yes
update-freq-fast = 10
update-freq-express = 500
animation-delay = 0.3s
</PRE>
<P>
The above options can also be set from within Tkenv itself, from
a configuration dialog box.
<P>
<B>Embedding TCL code into the executable</B>
<P>
A significant part of Tkenv is written in TCL, in several <TT>.tcl</TT>
script files. The default location of the scripts is passed compile-time
to <TT>tkapp.cc</TT>, or it can be overridden at run-time by the
<TT>OMNETPP_TKENV_DIR</TT> environment variable. The existence
of a separate script library can be inconvenient if you want to
carry standalone simulation executables to different machines.
To solve the problem, there is a possibility to compile the script
parts into Tkenv as a large string constant. 
<P>
The details: the tcl2c program (its C source is there in the Tkenv
directory) is used to translate the <TT>.tcl</TT> files into C
code (<TT>tclcode.cc</TT>), which gets included into <TT>tkapp.cc</TT>.
On Unix, this feature is enabled in Tkenv's <TT>makefile</TT>;
it is documented there exactly how. On Win95/NT, one has to manually
compile <TT>tcl2c.c</TT> into <TT>tcl2c.exe</TT>, run it to produce
<TT>tclcode.cc</TT> and then compile <TT>tkapp.cc</TT> without
providing the <TT>OMNETPP_TKENV_DIR</TT> external define. The
latter will cause <TT>tkapp.cc</TT> to include and use <TT>tclcode.cc</TT>.
<H3><A NAME="_Toc473901854">In Memoriam&#133;</A></H3>
<P>
There used to be other user interfaces which have been removed
from the distribution.
<UL>
<LI><B>TVEnv</B>. A Turbo Vision-based user interface, the first
interactive UI for OMNeT++. (Turbo Vision was an excellent character-graphical
windowing environment, originally shipped with Borland C++ 3.1.)
<LI><B>XEnv</B>. A GUI written in pure X/Motif. It was an experiment,
written before I stumbled into Tcl/Tk and discovered its immense
productivity in GUI building. XEnv never got too far because it
was really very-very slow to program in Motif&#133;
</UL>
<H2><A NAME="_Toc473901855">Typical problems</A></H2>
<H3><A NAME="_Toc473901856">Stack problems</A></H3>
<P>
<TT><B><FONT>&quot;Stack violation (<I><B>FooModule</B></I><B>
stack too small?) in module <I>bar.foo</I>&quot;</B></FONT></B></TT>
<P>
OMNeT++ detected that the module has used more stack space than
it has allocated. You should increase the stack for <TT>FooModule</TT>.
You can call the <TT>stackUsage()</TT> from <TT>finish()</TT>
to find out actually how much stack the module used.<BR>
<P>
<TT><B><FONT>&quot;Error: Cannot allocate <I><B>nn</B></I><B>
bytes stack for module <I>foo.bar&quot;</I></B></FONT></B></TT>
<P>
If you get the above message, you have to increase the total stack
size (the sum of all coroutine stacks). You can do so in <TT>omnetpp.ini</TT>:
<PRE>
<FONT>[General]
</FONT>total-stack-kb = 2048  # 2MB
</PRE>
<P>
There is no<I> </I>penalty if you set <TT>total-stack-kb</TT>
too high. I recommend to set it to a few K less than the maximum
process stack size allowed by the operating system (<TT>ulimit
-s</TT>; see next section).<BR>
<P>
<TT><B><FONT>&quot;Segmentation fault&quot;</FONT></B></TT>
<P>
On Unix, if you set the total stack size higher, you may get a
segmentation fault during network setup (or during execution if
you use dynamically created modules) for exceeding the operating
system limit for maximum stack size. For example, in Linux 2.0.x,
the stack can be at most 8192K (that is, 8MB). The <TT>ulimit</TT>
syscall and utility program can be used to modify the resource
limits, but you can only increase if you're root. Furthermore,
resource limits are inherited by child processes. The following
statement worked out for me under Linux to get a shell with a
64M stack limit:
<PRE>
<FONT>$ su root
</FONT>Password:
% ulimit -s 65536
% su andras
$ ulimit -s
65536 
</PRE>
<P>
If you do not want to go through the above process at each login,
you can change the limit in the PAM configuration files. In Redhat
Linux (maybe other systems too), add the following line to <TT>/etc/pam.d/login</TT>:
<PRE>
<FONT>session    required     /lib/security/pam_limits.so
</FONT>
</PRE>
<P>
and the following line to <TT>/etc/security/limits.conf</TT>:
<PRE>
<FONT>*  hard  stack  65536
</FONT>
</PRE>
<P>
A more drastic solution is to recompile the kernel with a larger
stack limit. Edit <TT>/usr/src/linux/include/linux/sched.h</TT>
and increase <TT>_STK_LIM</TT> from <TT>(8*1024*1024)</TT> to
<TT>(64*1024*1024)</TT>.
<P>
Finally, it you're tight with memory, you can switch to Cmdenv.
Tkenv increases the stack size of each module by about 32K so
that user interface code that is called from a simple module's
context can be safely executed. Cmdenv does not need that much
extra stack.
<H3><A NAME="_Toc473901857">Memory allocation problems</A></H3>
<P>
For investigating memory allocation problems, try using Cmdenv,
and uncomment the <TT>#defines</TT> in <TT>src/envir/cmdenv/heap.cc</TT>:
<P>
<TT>HEAPCHECK</TT> checks heap on <TT>new</TT>/<TT>delete</TT>
<P>
<TT>COUNTBLOCKS</TT> counts blocks on heap and tells it if none
left
<P>
<TT>ALLOCTABLE</TT> remembers pointers and reports heap contents
if only <TT>LASTN</TT> blocks remained
<P>
<TT>DISPLAYALL</TT>  reports every <TT>new</TT>/<TT>delete</TT>
<P>
<TT>DISPSTRAYS</TT> reports deleting of pointers that were not
registered by <TT>operator</TT> <TT>new</TT> or that were deleted
since then
<P>
<TT>BKPT</TT> calls a function at a specified <TT>new</TT>/<TT>delete</TT>;
you can set a breakpoint to that function
<P>
If <TT>COUNTBLOCKS</TT> is turned on, you should see the <TT>[heap.cc-DEBUG:ALL
BLOCKS FREED OK]</TT> message at the end of the simulation. If
you do not see it, it means that some blocks have not been freed
up properly, that is, your simulation program is likely to have
memory leaks.
<H2><A NAME="_Toc473901858">Execution speed</A></H2>
<P>
If your simulation program is tested and runs OK, you'll probably
want to run it as fast as possible. Here's a table that could
help where to begin optimizing.
<P>
The measurements were made on one version of the FDDI model (you
can find it in the <TT>samples</TT> directory); we simulated 10
milliseconds. We used Cmdenv. The machine was a 100Mhz Intel Pentium
with 32MB RAM. The simulation program was compiled with Borland
C++ 3.1 (no particular optimization) and run on DOS 6.22. Disk
caching was installed (SmartDrive read/write caching, 8MB cache).
<BR>

<TABLE BORDER=1>
<TR><TD WIDTH=153><B>Settings</B></TD><TD WIDTH=99><B>Execution time</B>
</TD><TD WIDTH=373><B>Details</B></TD></TR>
<TR><TD WIDTH=153>all screen output on; full heapcheck</TD><TD WIDTH=99>7 min 50 sec
</TD><TD WIDTH=373>Setting in <TT>omnetpp.ini</TT>:
<P>
<TT>verbose-simulation = yes<BR>
<FONT>module-messages = yes</FONT></TT>
<P>
The <TT>#defines</TT> in <TT>envir/cmdenv/heap.cc</TT> were all enabled. This means full heapcheck with each allocation, tracking of all allocated blocks etc.
</TD></TR>
<TR><TD WIDTH=153>no screen output at all;<BR>
full heapcheck
</TD><TD WIDTH=99>5 min 50 sec</TD><TD WIDTH=373>All screen output were <TT>#ifdef</TT>'ed out from source; also, the <TT>omnetpp.ini</TT> contained the 
<P>
<TT>verbose-simulation = no</TT>
<P>
line. The heapcheck defines were turned on.
</TD></TR>
<TR><TD WIDTH=153>all screen output on;<BR>
no heapcheck</TD>
<TD WIDTH=99>2 min</TD><TD WIDTH=373>We turned off heapcheck (we commented out the defines in <TT>heap.cc</TT>) and turned back on the screen output. We used the same <TT>omnetpp.ini</TT>: setting as with first case.
</TD></TR>
<TR><TD WIDTH=153>screen output redirected to file;<BR>
no heapcheck
</TD><TD WIDTH=99>15.5 sec</TD><TD WIDTH=373>Same as previous configuration, except that we run the program with<P>
<TT>fddi &gt; output.txt</TT>
</TD></TR>
<TR><TD WIDTH=153>screen output redirected to NUL;<BR>
no heapcheck
</TD><TD WIDTH=99>13 sec</TD><TD WIDTH=373>Same as previous configuration, except that we run the program with<P>
<TT>fddi &gt; NUL</TT>
</TD></TR>
<TR><TD WIDTH=153>screen output turned off from ini file;<BR>
no heapcheck
</TD><TD WIDTH=99>7.5 sec</TD><TD WIDTH=373>We did not only redirect but also disabled screen output. Setting in <TT>omnetpp.ini</TT>:
<P>
<TT>verbose-simulation = no<BR>
<FONT>module-messages = no</FONT></TT>
</TD></TR>
<TR><TD WIDTH=153>no screen output generation;<BR>
no heapcheck
</TD><TD WIDTH=99>4.5 sec</TD><TD WIDTH=373>We <TT>#ifdef</TT>'ed out all printouts from the simple module sources and also turned off any messages from <TT>omnetpp.ini</TT>.
</TD></TR>
</TABLE>
<P>
<P>
The moral is that heap checks and screen output greatly influences
speed, so once you do not need them (debugging is over), throw
them out. You also gain a lot by putting <TT>#ifdef</TT> lines
around your debugging code. And of course, program with care.
<HR><H1><A NAME="_Toc473901859">Analyzing simulation results</A></H1>
<H2><A NAME="_Toc473901860">Plotting output vectors with Plove</A>
</H2>
<H3><A NAME="_Toc473901861">Plove features</A></H3>
<P>
Typically, you'll get output vector files as a result of a simulation.
Data written to <TT>cOutVect</TT> objects from simple modules
go to output vector files. Normally, you use Plove to look into
output vector files and plot vectors in it.
<P>
Plove is a handy tool for plotting OMNeT++ output vectors. It
uses Gnuplot to do the actual work. You can specify the drawing
style (lines, dots etc) for each vector as well as set the most
frequent drawing options like axis bounds, scaling, titles and
labels etc. You can save the gnuplot graphs to files (postscript,
latex, pbm etc) with a click. Plove can also generate standalone
shell scripts that plot output vectors in much the same way Plove
does itself. These scripts can be used for batch processing or
to debug filters (see later). Plove does not take away any of
gnuplot's flexibility -- you can embed your own gnuplot commands
to customize the output.
<P>
Filtering the results before plotting is possible. Filters can
do averaging, truncation of extreme values, smoothing, they can
do density estimation by calculating histograms etc. Some filters
are built in, and you can easily create new filters or modify
the existing ones. Filters can be incorporated in one of three
ways: as awk expressions, as awk programs and as external filter
programs. Filters can be parameterized. Multiple filters for the
same vector is not currently supported; also, you cannot currently
feed several vectors into a single filter.
<P>
Plove does not create temporary files, so you don't need to worry
about disk space: if the output vector is there, Plove can plot
it for you. Moreover, it can also work with gzipped vector files
without extracting them -- just make sure you have <TT>zcat</TT>.
<P>
Plove never modifies the output vector files themselves. 
<P>
On startup, Plove automatically reads the <TT>.ploverc</TT> file
in your home directory. The file contains general gnuplot settings,
the filter configuration etc. (that is, the stuff from the Options
menu).
<P>
<U>Portability:</U> Plove works fine on Unix and (with some limitations)
on Win95/NT.
<H3><A NAME="_Toc473901862">Usage</A></H3>
<P>
First, you load an output vector file (<TT>.vec</TT>) into the
left pane. You can also load gzipped vector files (<TT>.vec.gz</TT>)
without having to decompress them. You can copy vectors from the
left pane to the right pane by clicking the right arrow icon in
the middle. The large PLOT button will plot the <I>selected</I>
vectors in the right pane. Selection works as in Windows: dragging
and shift+left click selects a range, and ctrl+left click selects/deselects
individual items. To adjust drawing style, change vector title
or add filter, push the Options... button. This works for several
selected vectors too. Plove accepts nc/mc-like keystrokes: F3,
F4, F5, F6, F8, grey '+' and grey '*'.
<P>
The left pane works as a general storage for vectors you're working
with. You can load several vector files, delete vectors you don't
want to deal with, rename them etc. All this will not affect the
vector files on disk. In the right pane, you can duplicate vectors
if you want to filter the vector and also keep the original. If
you set the right options for a vector but temporarily do not
want it to hang around in the right pane, you can put it back
into the left pane for storage.
<H3><A NAME="_Toc473901863">Writing filters</A></H3>
<P>
Filters get an output vector on their standard input (as plain
text, with the timestamp being the second and the value being
the third field on each line), do some processing to it and write
the result to the standard output.
<P>
Filters can be incorporated in one of three ways: as <TT>awk</TT>
expressions, as <TT>awk</TT> programs or  as external programs.
An <TT>'awk</TT> expression' filter means assembling and launching
a command like this:
<PRE>
<FONT>cat foobar.vec | awk '{$3 = <I>&lt;expression&gt;</I>; print}' | ...
</FONT>
</PRE>
<P>
An <TT>awk</TT> program filter means running the following command:
<PRE>
<FONT>cat foobar.vec | awk '<I>&lt;program&gt;</I>' | ...
</FONT>
</PRE>
<P>
The third type of filters is used like this:
<PRE>
<FONT>cat foobar.vec | <I>&lt;program&gt;</I> <I>&lt;parameters&gt;</I> | ...
</FONT>
</PRE>
<P>
Before the filter pipeline is launched, the following substitutions
are performed on the <TT>awk</TT> scripts:
<PRE>
<FONT>  t --&gt; $2
</FONT>  x --&gt; $3
</PRE>
<P>
The parameters of the form <TT>$(paramname)</TT> are also replaced
with their actual value.
<P>
Thus, if you want to add 1 to all value, you can use the awk expression
filter <TT>x+1</TT>. It will turn into:
<PRE>
<FONT>  awk '{$3 = $3+1}; print'.
</FONT>
</PRE>
<P>
When you want to shift the vector by a used-defined <TT>DT</TT>
time, you can create the following <TT>awk</TT> program filter:
<PRE>
<FONT>{t += $(DT); print}
</FONT>
</PRE>
<P>
Do not forget the print statement, or your filter will not output
anything and the gnuplot graph will be empty.
<P>
Filters are automatically saved into and loaded from the <TT>~/.ploverc</TT>
file.
<H2><A NAME="_Toc473901864">Format of output vector files</A>
</H2>
<P>
An output vector file contains several series of data produced
during simulation. The file is textual, it looks like this:
<PRE>
<B><FONT>mysim.vec:
</FONT></B>vector  1  &quot;subnet[4].term[12]&quot;  &quot;response time&quot;  1
1  12.895  2355.66666666
1  14.126  4577.66664666
vector 2  &quot;subnet[4].srvr&quot;  &quot;queuelen+queuingtime&quot;  2
2  16.960  2.00000000000  .63663666
1  23.086  2355.66666666
2  24.026  8.00000000000  .44766536
</PRE>
<P>
There are label lines (beginning with <TT>vector</TT>) and data
lines.
<P>
A <TT>vector</TT> line introduces a new vector. Its columns are:
vector ID, module of creation, name of <TT>cOutVector</TT> object,
multiplicity of data (single numbers or pairs will be written).
<P>
Lines beginning with numbers are data lines. The columns: vector
ID, current simulation time, and one or two double values.
<H2><A NAME="_Toc473901865">Working without Plove</A></H2>
<H3><A NAME="_Toc473901866">Extracting vectors from the file</A>
</H3>
<P>
You can use the Unix <TT>grep</TT> tool to extract a particular
vector from the file. As the first step, you must find out the
ID of the vector. You can find the appropriate vector line with
a text editor or you can use <TT>grep</TT> for this purpose: 
<PRE>
<FONT>% grep &quot;queuelen+queuingtime&quot; vector.vec
</FONT>
</PRE>
<P>
Or, you can get the list of all vectors in the file by typing:
<PRE>
<FONT>% grep ^vector vector.vec
</FONT>
</PRE>
<P>
This will output the appropriate vector line:
<PRE>
<FONT>vector 6  &quot;subnet[4].srvr&quot;  &quot;queuelen+queuingtime&quot;  2
</FONT>
</PRE>
<P>
Pick the vector ID, which is 6 in this case, and <TT>grep</TT>
the file for the vector's data lines:
<PRE>
<FONT>grep ^6 vector.vec &gt; vector6.vec
</FONT>
</PRE>
<P>
Now, <TT>vector6.vec</TT> contains the appropriate vector. The
only potential problem is that the vector ID is there at the beginning
of each line and this may be hard to explain to some programs
that you use for post-processing and/or visualization. This problem
is eliminated by the OMNeT++ <TT>splitvec</TT> utility (written
in awk), to be discussed in the next section.
<H3><A NAME="_Toc473901867">Using splitvec</A></H3>
<P>
The <TT>splitvec</TT> script (part of OMNeT++) breaks the vector
file into several files which contain one vector each:
<PRE>
<B><FONT>% </FONT></B><FONT>splitvec mysim.vec
</FONT>
</PRE>
<P>
creates several files: <TT>mysim1.vec</TT>,<TT> mysim2.vec</TT>
etc.
<PRE>
<B><FONT>mysim1.vec:
</FONT></B># vector  1  &quot;subnet[4].term[12]&quot;  &quot;response time&quot;  1
12.895  2355.66666666
14.126  4577.66664666
23.086  2355.66666666

<B>mysim2.vec:
</B># vector 2  &quot;subnet[4].srvr&quot;  &quot;queuelen+queuingtime&quot;  2
16.960  2.00000000000  .63663666
24.026  8.00000000000  .44766536
</PRE>
<P>
As you can see, the vector ID is gone.
<P>
The files can be further processed with math packages, or read
by analysis or spreadsheet programs which provide numerous ways
to display data as diagrams, do calculations on them etc. One
could use for example Gnuplot, Matlab, Excel, etc.
<H3><A NAME="_Toc473901868">Visualization under Unix</A></H3>
<P>
Two programs are in common use: Gnuplot and Xmgr. Both are free
and both have their good and bad sides; will briefly discuss them.
There are innumerable tutorials and documentation about them on
the Web; some of them you will find among the References.
<P>
Both programs can eat files produced by <TT>splitvec</TT>. Both
programs can produce output in various forms: on screen, in Postscript
format, printer files, Latex output etc. For DTP purposes, Postscript
seems to be the most appropriate. On Windows, the easiest way
is to copy the picture to the clipboard from the Gnuplot window's
system menu.
<P>
Gnuplot has an interactive command interface. To get the vectors
in <TT>mysim1.vec</TT> and <TT>mysim4.vec</TT> plotted in the
same graph, you can type:
<PRE>
<FONT>plot &quot;mysim1.vec&quot; with lines, &quot;mysim4.vec&quot; with lines
</FONT>
</PRE>
<P>
To adjust the <I>y</I> range, you would type:
<PRE>
<FONT>set yrange [0:1.2]
</FONT>replot
</PRE>
<P>
There are several commands to adjust ranges, plotting style, labels,
scaling etc. Gnuplot can also plot 3D graphs. Gnuplot is also
available for DOS, Windows and other platforms. Gnuplot also has
a simple graphical interactive user interface called PlotMTV.
However, we recommend that you use OMNeT++'s Plove tool, described
in an earlier section.
<P>
Xmgr is an X/Motif based program, with a menu-driven graphical
interface. You load the appropriate file by selecting in a dialog
box. The icon bar and menu commands can be used to customise the
graph. Some say that Xmgr can produce nicer output that Gnuplot
and it is easier to use. Xmgr cannot do 3D and only runs on Unixes
with X and Motif installed. Xmgr also has a batch interface so
you can use it from scripts too.
<HR><H1><A NAME="_Toc473901869">Parallel execution</A></H1>
<H2><A NAME="_Toc473901870">Support for parallel execution</A>
</H2>
<H3><A NAME="_Toc473901871">Overview</A></H3>
<P>
OMNeT++ supports parallel execution of large simulations. To make
use of parallel execution, the model is to be partitioned to several
segments that will be simulated independently on different hosts
or processors.
<P>
The simulation kernel makes it possible to send messages from
one segment to another. A message can contain arbitrarily complex
data structures; these are transferred transparently, even between
hosts of different architectures. The simulation kernel provides
a simple synchronisation mechanism (<I>syncpoints</I>, available
through the <TT>syncpoint()</TT> call) that can ensure that causality
is kept when sending messages between segments. Syncpoints correspond
to <I>null messages</I> found in the literature.
<P>
Message sending and syncpoints enable one to implement conservative
PDES and also a novel and less-known paradigm, Statistical Synchronisation.
The simulation class library contains objects that explicity support
the implementation of models using Statistical Synchronisation.
<P>
High level debugging is supported by saving the textual output
from remote segments to a log file and/or relaying them to a single
console.
<P>
OMNeT++ supports flexible partitioning of the model. In the NED
language, by using <I>machine parameters</I> you can specify <I>logical
hosts</I> for different modules at any level of the module hierarchy
of the network. You map logical hosts to physical ones in the
ini file; if you map several logical hosts into the same physical
machine, they will be merged into a single OMNeT++ process.
<P>
The PVM3 (Parallel Virtual Machine Version 3) library is used
for communication between hosts. PVM is portable and it is widely
used in university and research environment. You can find PVM
readings in the Reference.
<H3><A NAME="_Toc473901872">Syncpoints</A></H3>
<P>
<B>Overview</B>
<P>
When running a simulation in parallel, different segments of the
model execute as independent UNIX processes, typically on separate
hosts. Since the hosts can be of different speed and the simulated
model segments can be of different complexity, at a given moment
the model times of different segments will differ: some segments
are ahead of the others and some lag behind. Suppose that a message
is sent from segment A to segment B which is ahead of A in model
time. If B processed the message, causality would break. This
should never happen.
<P>
The solution built in OMNeT++ is the following. Segment A must
know in advance when it will send the next message to segment
B and announce it with the <TT>syncpoint()</TT> call. The simulation
kernel sends the syncpoint to segment B. When segment B's model
time reaches the specified time, segment B's simulation kernel
blocks execution until the promised message arrives from A. Then
the simulation continues, typically but not necessarily with the
message that has just been received from A.
<P>
In the reverse case when A is ahead of B, A's message arrived
at B before it has reached the syncpoint. In this case, there
is no problem and the syncpoint is just an unnecessary precaution.
B just inserts the message in its future event set, clears the
syncpoint and continues execution.
<P>
<B>The syncpoint API</B>
<P>
The <TT>syncpoint()</TT> call takes two arguments. The first is
the model time when (or more precisely: when of after when) the
simple module will send a message to another simple module in
a different segment. The second argument is a gate given with
its number or its name. The gate implicitly specifies the destination
segment to synchronize with.
<PRE>
<FONT>syncpoint(t, &quot;outgate&quot;);
</FONT>
</PRE>
<P>
<B>Details of the syncpoint implementation</B>
<P>
If the destination module is in the same segment, the call is
ignored. (This makes it possible to run models designed to execute
in parallel as a single process, without any modification.) Each
segment keeps a list of syncpoints sent to it (time + gate), ordered
by time. Simulation executes normally until it comes to an event
that has a time <I>definitely</I> <I>past</I> the first syncpoint
in the list. That event is not processed, but the segment goes
into a blocked state. While the segment is blocked, it listens
for messages arriving from other segments. (In the actual implementation,
passive wait is used so a blocked segment doesn't use much CPU
time.) Each message that arrives deletes the first syncpoint in
the list that matches its gate. The segment goes out of the blocked
state when -- because of deletions -- the first syncpoint in the
list is no longer past the event in question. Then the simulation
goes on normally, either with the newly arrived message (or the
earliest of them) or the original event. A message that arrives
outside of the blocked state also causes deletion of the first
matching syncpoint in the list; this case corresponds to the reverse
case when the sender segment is ahead of the reveiving segment
in model time.
<P>
<B>Deadlock</B>
<P>
It is possible to cause deadlock with carelessly placed syncpoints.
Suppose that segment A declares a syncpoint at 10s with segment
B, but it will actually send a message only at 10.5s. If segment
B does the same to segment A, a nice deadlock is created. OMNeT++
makes no effort to detect or prevent such deadlocks; it is entirely
the simulation programmer's task to take care that deadlocks do
not occur.
<H3><A NAME="_Toc473901873">The PVM virtual machine</A></H3>
<P>
The <TT>pvmhosts</TT> file is used by PVM to describe what computers
will participate in the virtual machine, where the executables
(in our case, the OMNeT++ programs) are located on each computer,
what working directories should be set etc.
<P>
It is advisable to have a common, shared directory mounted on
all participating hosts; this eliminates the tedious work of having
to copy files to all hosts again and again.
<P>
If using OMNeT++, it is a good idea to write separate <TT>pvmhosts</TT>
files for each simulation program. Since simulation programs are
typically in separate directories, the <TT>pvmhosts</TT> file
in each directory can name that directory as executables directory
and working directory for each host. This way, there is no need
to create soft links or explicitly name directories in the OMNeT++
ini files.
<P>
Each line in the <TT>pvmhosts</TT> file describes one host. An
example line (this all should be a <I>single line</I>!):
<PRE>
<FONT>whale  ip=whale.hit.bme.hu  lo=andras
</FONT>   ??=/home/andras/pvm/pvm
   ep=/home/andras/omnetpp/projects/fddi
   wd=/home/andras/omnetpp/projects/fddi
</PRE>
<P>
To start PVM with this configuration:
<PRE>
<FONT>cd ~/omnetpp/projects/fddi
</FONT>pvm pvmhosts
</PRE>
<H3><A NAME="_Toc473901874">Mapping logical machines to physical
ones</A></H3>
<P>
The <TT>on:</TT> phrases in the NED descriptions specify the logical
machine(s) on which the module is run. The machine parameters
are mapped to physical machines in the <TT>[Machines]</TT> section
of the configuration file:
<PRE>
<FONT>; file: omnetpp.ini
</FONT><B>;...
[Machines]
</B>node1 = whale.hit.bme.hu
node4 = whale.hit.bme.hu
node2 = puppis.hit.bme.hu
node3 = dolphin.hit.bme.hu
;...
</PRE>
<H3><A NAME="_Toc473901875">Configuration of the slaves</A></H3>
<P>
Slave processes can be configured in the <TT>[Slaves]</TT> section
of the configuration file:
<PRE>
<FONT>; file: omnetpp.ini
</FONT><B>[Slaves]
</B>write-slavelog=
slavelog-file=
module-messages=
errmsgs-to-console=
infomsgs-to-console=
modmsgs-to-console=
</PRE>
<P>
Screen input/output of the slaves is re-routed to the console.
However, any file I/O is done in the local file system of each
host.
<H3><A NAME="_Toc473901876">Configuration and running</A></H3>
<P>
The user must have PVM installed on the hosts he is going to run
segments on.
<P>
To set up a simulation for distributed execution, the user must:
<OL>
<LI>set the <TT>PVM_ROOT</TT> environment variable
<LI>link the simulation executable with <TT>sim_pvm</TT> instead
of <TT>sim_std </TT>(You can do it by setting <TT>PVM_SUPPORT</TT>
to <TT>yes</TT> in a <TT>makemake</TT>-generated <TT>makefile</TT>.)
<LI>set <TT>distributed=true </TT>in the <TT>[General]</TT> section
of the configuration file.
<LI>specify the logical-hosts-to-physical-machines mapping in
the <TT>[Machines]</TT> section
<LI>copy the simulation executable and the configuration file
to each host if they have physically different disks
<LI>start <TT>pvm</TT> with an appropriate <TT>pvmhosts</TT> file
<LI>start the simulation executable on the host which is supposed
to be the console. That process will start up the program on the
other hosts too and do the simulation.
</OL>
<P>
The first machine is called &quot;console&quot; or &quot;master&quot;,
the others are called &quot;slaves&quot;.
<H3><A NAME="_Toc473901877">If there are problems...</A></H3>
<P>
PVM programs in general are more difficult to get running than
ordinary programs. Wrong settings in the PVM configuration files
can cause various problems, for example. Also, parallel programs
are a lot harder to test and debug.
<P>
What can you do if your distributed OMNeT++ simulation won't work?
<UL>
<LI>First of all, check the <TT>pvmhosts</TT> file to see if PVM
looks for the executables in the right directories on all hosts
and the working directories are right (typically, the same directory
as the executable's). 
<LI>In the ini file, enable writing the <TT>slave.log</TT> files
for the slave processes and check what is written into them.
<LI>You can try enabling the <TT>SINGLE_HOST </TT>define in the
<TT>sim/pvm/pvmmod.cc</TT> source file. This will make OMNeT++
run all segments of the distributed simulation on the local host,
making things a lot easier to manage. 
<LI>Also, try the defining <TT>PVM_DEBUG</TT> at the same place:
it enables a lot of <TT>ev.printf()</TT>s in the code interfacing
with PVM, so it is easier to spot where the problems are.
<LI>PVM itself also has an environment variable which, if set,
causes the PVM library to print out debugging information. However,
this is very low-level information, it will rarely be useful.
</UL>
<H2><A NAME="_Toc473901878">Statistical synchronisation</A></H2>
<H3><A NAME="_Toc473901879">The description of the Statistical
Synchronisation Method (SSM)</A></H3>
<P>
Similarly to other parallel discrete event simulation methods,
the model to be simulated - which is more or less a precise representation
of a real system - is divided into segments, where the segments
usually describe the behaviour of functional units of  the real
system. The communication of the segments can be represented by
sending and receiving various messages. The simulators of  the
segments are executed by separate processors.
<P>
The communication of  these segments is simulated with appropriate
interfaces. The messages generated in a given segment and to be
processed in a different segment are not  transmitted there, but
the output interfaces collect the statistical data of them.  If
the input interfaces generate messages for the segments according
to the statistical characteristics of the messages collected by
the proper output interfaces, the segments with their input- and
output  interfaces can be simulated separately, giving statistically
correct results. The events in one segment have not the same effect
 in other segments as in the original model,  so the results collected
during the SSM are not exact. The precision depends on the segmentation,
on the accuracy of statistics collection and regeneration, and
on the frequency of the statistics exchange among the processors.
<P>
<B>Segmentation</B>
<P>
The segments of the simulator are executed by separate processors,
they have their own, independent virtual times. Because the interactions
among segments are performed by the statistical parameters of
 these interactions, the segmentation should be done so, that
the overwhelming majority of the interactions should happen within
the segments and not among them. This speeds up the so-called
inter-segment transients and improves the accuracy as well.
<P>
<B>Timing of statistics exchange</B>
<P>
Asynchronous statistics exchange means, that whenever a statistical
result collection in an output interface is ready, it is applied
- after mapping and correction - in the proper input interface.
This is clearly more efficient, than the so-called synchronous
statistics exchange, which means, that we delay the application
of collected values until all the output interfaces get ready
with the result collection. Frequent statistics exchange makes
the inter-segment transient faster, but the lower sample numbers
makes the estimation - and the whole simulation - less precise.
<BR>
<P>
To learn more about SSM, see [PON92] and [PON93].
<H3><A NAME="_Toc473901880">Using SSM in OMNeT++</A></H3>
<P>
OMNeT++ directly supports the implementation of statistical interface
with the following classes:
<P>
<TT>cLongHistogram</TT>, <TT>cDoubleHistogram</TT>, <TT>cPSquare</TT>,
<TT>cPar</TT>.
<HR><H1><A NAME="_Toc473901881">The Design of OMNeT++</A></H1>
<H2><A NAME="_Toc473901882">Structure of an OMNeT++ executable</A>
</H2>
<P>
Consider the following diagram: 
<P>
<CENTER><IMG SRC="img00019.gif"></CENTER>
<P>
A simulation program contains the simulated network (with its
simple and compound modules etc.), SIM, ENVIR and exactly one
of CMDENV and TKENV. SIM contains the simulation class library
and the simulation kernel. The model only interacts with SIM.
ENVIR contains code that's common for all user interfaces, and
provides infrastructure like ini file handling for them. <TT>main()</TT>
is also in ENVIR. Specific user interface code is contained in
CMDENV and TKENV. The above components are also physically separated:
they are in separate source directories and form separate library
files (<TT>libsim_std.a</TT>, <TT>libenvir.a</TT> etc.) 
<P>
The simulation program may contain several linked-in model components:
networks, simple module types, compound module types, channel
types etc. Any network (but only one at a time) can be set up
for simulation which has all necessary components linked in.
<H2><A NAME="_Toc473901883">Embedding OMNeT++</A></H2>
<P>
Embedding is a special issue. You probably do not want to keep
the appearance of the simulation program, so you do not want Cmdenv
and Tkenv. You may or may not want to keep ENVIR.
<P>
What you'll absolutely need for a simulation to run is the SIM
package. You can keep ENVIR if its philosophy and the infrastructure
it provides (<TT>omnetpp.ini</TT>, certain command-line options
etc.) fit into your design. Then the embedding program will take
the place of Cmdenvn and Tkenv.
<P>
If  ENVIR does not fit your needs (for example, you want the model
parameters to come from a database not from <TT>omnetpp.ini</TT>),
then you have replace it. Your ENVIR replacement (the embedding
program, practically) must implement the <TT>cEnvir</TT> member
functions from <TT>envir/cenvir.h</TT>, but you have full control
over the simulation.
<P>
Normally, code that sets up a network or builds the internals
of a compound module comes from compiled NED source. You may not
like the restriction that your simulation program can only simulate
networks whose setup code is linked in. No problem; your program
can contain pieces of code like what is generated by nedc and
then it can build any network whose components (primarily the
simple modules) are linked in. It is even possible to write an
integrated environment where you can put together a network using
a graphical editor and right after that you can run it, without
intervening NED compilation and linkage.
<H2><A NAME="_Toc473901884">The simulation kernel</A></H2>
<P>
The source code for the simulation kernel of OMNeT++ and the library
classes reside in the <TT>sim</TT> directory.
<P>
Almost all objects are derived from <TT>cObject</TT> which provides
a common interface for them.
<H3><A NAME="_Toc473901885">The central object: cSimulation simulation</A>
</H3>
<P>
The <TT>cSimulation</TT> class stores a network and manages simulation.
There is only one instance, a global object called <TT>simulation</TT>.
The object has two basic roles:
<UL>
<LI>as a vector of modules
<LI>holds global variables (for example, the message queue).
</UL>
<H3><A NAME="_Toc473901886">Module classes</A></H3>
<P>
Base class for module classes: <TT>cModule</TT>. Two derived classes:
<TT>cCompoundModule</TT>, <TT>cSimpleModule</TT>. User simple
modules are derived from <TT>cSimpleModule</TT>.
<P>
A <TT>cModule</TT> has: array of parameters, array of gates +
member functions to set up and query parameters and gates.
<P>
<TT>cSimpleModule</TT> adds: put-aside queue, list of local objects
+ the virtual function <TT>activity()</TT> + member functions
like <TT>send()</TT>, <TT>receive()</TT> etc.
<P>
Gates are represented by the <TT>cGate</TT> objects. Connections
are not real objects: their attributes (delay, error, datarate)
are managed by the connection's source gate.
<H3><A NAME="_Toc473901887">Global registration lists</A></H3>
<P>
There are global objects holding lists of components available
in an OMNeT++ executable. These lists are:<TABLE BORDER=1>
<TR><TD WIDTH=115><B>List object</B></TD><TD WIDTH=174><B>Macro that creates a member.</B>
<P>
<B>Class of members</B>
</TD><TD WIDTH=372><B>Function</B></TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead 
 networks;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
<FONT>Define_Network()

cNetworkType</FONT>
</PRE>

</TD><TD WIDTH=372>List of avaliable networks. <P>
A <TT>cNetworkType</TT> object holds a pointer to a function that can build up the network. 
<P>
<TT>Define_Network()</TT> macros occur in the code generated by the NEDC compiler.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 modtypes;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
<FONT>Define_Simple_Module(),
Define_Simple_Module_Like(), Define_Compound_Module()

cModuleType</FONT>
</PRE>

</TD><TD WIDTH=372>List of available module types.<P>
A <TT>cModuleType</TT> object knows how to create a module of a specific type. If is compound, it holds a pointer to a function that can build up the inside. 
<P>
<TT>Define_Compound_Module()</TT> macros occur in the code generated by the NEDC compiler. <TT>Define_Simple_Module()</TT> macros are written by the user.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 classes;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
<FONT>Register_Class()

ClassRegister</FONT>
</PRE>

</TD><TD WIDTH=372>List of avaliable classes of which the user can create an instance.<P>
A <TT>cClassRegister</TT> object knows how to create an (empty) object of a specific class.
<P>
The list is used by the <TT>createOne()</TT> function that can create an object of any (registered) type from a string containing the class name. (E.g. <TT>ptr = createOne( &quot;cArray&quot;)</TT> creates an empty array.) <TT>createOne()</TT> is used by the PVM extension.
<P>
<TT>Register_Class()</TT> macros are present in the simulation source files for existing classes; has to be written by the user for new classes.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 functions;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
<FONT>Define_Function()

cFunctionType</FONT>
</PRE>

</TD><TD WIDTH=372>List of mathematical functions.<P>
A <TT>cFunctionType</TT> object holds a pointer to the function and knows how many arguments it takes.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 linktypes;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
<FONT>Define_Link()

cLinkType</FONT>
</PRE>

</TD><TD WIDTH=372>List of link types.<P>
A <TT>cLinkType</TT> object knows how to create <TT>cPar</TT> objects representing the delay, error and datarate attributes for a channel.
<P>
<TT>Define_Link()</TT> macros occur in the code generated by the NEDC compiler, one for each channel definition.
</TD></TR>
<TR><TD WIDTH=115>
<PRE>
<FONT>cHead
 locals;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
<FONT>-

any object</FONT>
</PRE>

</TD><TD WIDTH=372>This is only  'dummy' object, it stands for the current module's local object list
</TD></TR>
<TR><TD WIDTH=115><PRE>
<FONT>cHead
 superhead;</FONT>
</PRE>

</TD><TD WIDTH=174><PRE>
<FONT>-

cHead</FONT>
</PRE>

</TD><TD WIDTH=372>List of all other lists.</TD></TR>
</TABLE>
<H3><A NAME="_Toc473901888">The coroutine package</A></H3>
<P>
The coroutine package is in fact two coroutine packages.
<P>
There is a platform-independent coroutine package that creates
all coroutine stacks inside the main stack. It was taken from
[KOF85].  It allocates stack by deep-deep recursions and then
plays with <TT>setjmp()</TT> and <TT>longjmp()</TT> to switch
from one another. Its drawback is that under 16-bit Intel platforms
(DOS real mode and Win16), stack is limited to 64K which is not
very much.
<P>
The other package allocates stack by<TT> malloc()</TT> and uses
a short assembly code to initialize it for the first use. Then
it also uses <TT>setjmp()</TT> and <TT>longjmp()</TT>. This is
implemented under DOS + BC3.1, and also RISC6000 where the original
<TT>setjmp()</TT> /<TT> longjmp()</TT> behaved in an unfriendly
way and the portable coroutine package could not be used.
<P>
The coroutines are represented by the <TT>cCoroutine</TT> class.
<TT>cSimpleModule</TT> has <TT>cCoroutine</TT> as one a base class.
<H3><A NAME="_Toc473901889">Object ownership/contains relationships</A>
</H3>
<P>
<B>Ownership:</B> Exclusive right and duty to delete the child
objects. Ownership works through cObj's ownerp/prevp/nextp and
firstchildp/lastchildp pointers.
<P>
<B>'Contains' relationship: </B>Only for container classes, e.
g. <TT>cArray</TT> or <TT>cQueue</TT>. Keeping track of contained
objects works with another mechanism, <I>not</I> the previously
mentioned ptrs. (E.g., <TT>cArray</TT> uses a vector, <TT>cQueue</TT>
uses a separate list).
<P>
The two mechanisms are <I>independent</I>.
<P>
<B>What </B><TT><B><FONT>cObject</FONT></B></TT><B>
does:</B>
<UL>
<LI>Owner of a new object can be explicitly given; if omitted,
<TT>defaultOwner()</TT> will will be used.
<LI>An object created through the copy constructor will have the
same owner as original and does not <TT>dup()</TT> or take objects
owned by the original.
<LI>Destructor calls <TT>free()</TT> for owned objects (see later)
</UL>
<P>
<B>Rules for derived classes:</B>
<UL>
<LI>Objects contained as data members: the enclosing object should
own them.
</UL>
<P>
<B>Rules for container objects derived from </B><TT><B><FONT>cObject</FONT></B></TT><B>:</B>
<UL>
<LI>they use the functions: <TT>take(obj)</TT>, <TT>drop(obj)</TT>,
<TT>free(obj)</TT>
<LI>when an object is inserted, if <TT>takeOwnership()</TT> is
<TT>true</TT>, should take ownership of object by calling <TT>take(obj)</TT>.
<TT>takeOwnership()</TT> defaults to <TT>true</TT>!
<LI>when an object is removed, they should call <TT>drop(obj)</TT>
for it if they were the owner.
<LI>copy constructor copies should <TT>dup()</TT> and take ownership
of objects that were owned by the original.
<LI>destructor doesn't need not call <TT>free()</TT> for objects:
this will be done in <TT>cObject</TT>'s destructor.
</UL>
<P>
The class <TT>cHead</TT> is special case: it behaves as a container,
displaying objects it owns as contents.
<H2><A NAME="_Toc473901890">The user interface</A></H2>
<P>
The source code for the user interface of OMNeT++ resides in the
<TT>envir</TT> directory (common part) and in the <TT>cmdenv</TT>,
<TT>tkenv </TT>directories.
<P>
The classes in the user interface are <I>not</I> derived from
<TT>cObject</TT>, they are completely separated form the simulation
kernel.
<H3><A NAME="_Toc473901891">The main() function</A></H3>
<P>
The <TT>main()</TT> function of OMNeT++ simply sets up the user
interface and runs it. Actual simulation is done in <TT>cEnvir::run()
</TT>(see later).
<H3><A NAME="_Toc473901892">The cEnvir interface</A></H3>
<P>
The <TT>cEnvir</TT> class has only one instance, a global object
called <TT>ev</TT>:
<PRE>
<FONT>cEnvir ev;
</FONT>
</PRE>
<P>
<TT>cEnvir</TT> basically is only an interface, its member functions
hardly contain any code. <TT>cEnvir</TT> maintains a pointer to
a dynamically allocated simulation application object (derived
from <TT>TOmnetApp</TT>, see later) which does all actual work.
<P>
<TT>cEnvir</TT> member functions deal with four basic tasks:
<UL>
<LI>I/O for module activities; actual implementation is different
for each user interface (e.g. stdin/stdout for Cmdenv, windowing
in Tkenv)
<LI>setting up and running the simulation application
<LI>provides functions called by simulation kernel objects to
get information (for example, get module parameter settings from
the configuration file)
<LI>provides functions called by simulation kernel objects to
notify the user interface of some events. This is especially important
for windowing user interfaces (Tkenv), because the events are
like this: an object was deleted so its inspector window should
be closed; a message was sent so it can be displayed; a breakpoint
was hit.
</UL>
<H3><A NAME="_Toc473901893">Implementation of the user interface:
simulation applications</A></H3>
<P>
The base class for simulation application is <TT>TOmnetApp</TT>.
Specific user interfaces such as <TT>TCmdenv</TT>, <TT>TOmnetTVApp</TT>,
<TT>TOmnetXApp</TT> are derived from <TT>TOmnetApp</TT>.
<P>
<TT>TOmnetApp's</TT> member functions are almost all virtual.
<UL>
<LI>Some of them implement the <TT>cEnvir</TT> functions (described
in the previous section)
<LI>Others implement the common part of all user interfaces (for
example: reading options from the configuration files; making
the options effective within the simulation kernel)
<LI>The <TT>run()</TT> function is pure virtual (it is different
for each user interface).
</UL>
<P>
<TT>TOmnetApp</TT>'s data members:
<UL>
<LI>a pointer to the object holding configuration file contents
(type <TT>cInifile</TT>);
<LI>the options and switches that can be set from the configuration
file (these members begin with <TT>opt_</TT>)
</UL>
<P>
Concrete simulation applications:
<UL>
<LI>add new configuration options
<LI>provide a <TT>run()</TT> function
<LI>implement functions left empty in <TT>TOmnetApp</TT> (like
<TT>breakpointHit()</TT>, <TT>objectDeleted()</TT>).
</UL>
<H2><A NAME="_Toc473901894">Writing inspectors for TkEnv</A></H2>
<P>
TBD
<HR><H1><A NAME="_Toc473901895">Appendix A: OPNET and OMNeT++</A>
</H1>
<H2><A NAME="_Toc473901896">Comparison of OPNET and OMNeT++</A>
</H2>
<P>
OPNET (from MIL3 Inc.) is a state-of-the art commercial simulation
program for the modelling of communication systems. OPNET is designed
to enable full-detail modelling: every tool is given to implement
nonstandard protocols or behaviour.
<P>
A quote from the OPNET brochure:<BR>
<P>
<I>&quot; OPNET presents an advanced graphical user interface
that supports multi-windowing, makes use of menus and icons, and
runs under X Windows. Supported platforms include popular engineering
workstations from SUN, DEC, HP and Silicon Graphics. (Windows
NT version also exists.)</I>
<P>
<I> Graphical object-oriented editors for defining topologies
and architectures directly parallel actual systems, allowing an
intuitive mapping between a system and its model. OPNET's hierarchical
approach simplifies the specification and representation of large
and complex systems. </I>
<P>
<I> The process editor provides a powerful and flexible language
to design models of protocols, resources, applications, algorithms,
queuing policies, and other processes. Specification is performed
in the Proto-C language, which combines a graphical state-transition
diagram approach with a library of more than 300 communication-
and simulation-specific functions. The full generality and power
of the C language is also available.</I>
<P>
<I> OPNET simulations generate user-selected performance and behavioral
data. Simulation results can be plotted as time series graphs,
scatter plots, histograms, and probability functions. Standard
statistics and confidence intervals are easily generated and additional
insight can be obtained by applying mathematical operators to
the collected data. </I>
<P>
<I> OPNET provides an advanced animation capability for visualising
simulation events. Both automatic and user-customised animations
can be displayed interactively during or after a simulation. Animations
can depict messages flowing between objects, control flow in a
process, paths of mobile nodes, and dynamic values such as queue
size or resource status. </I>
<P>
<I> OPNET provides open system features including: interfaces
to standard languages; the ability to take advantage of third-party
libraries; an application program interface; access to databases
and data files such as those generated by network analysers; and
PostScript and TIFF export for desktop publishing. OPNET users
are guided by a comprehensive documentation set and are backed
by outstanding technical support.&quot;</I>
<P>
OPNET is very well designed and built commercial simulation software.
The author of OMNeT++ has worked for the Hungarian distributor
of OPNET for over three years and he has gained significant experience
with the software. He has taken part in several computer network
simulation projects for major Hungarian companies and also delivered
OPNET training. He has also written simulation models for a VSAT
system in OPNET. 
<P>
Following is a comparison of the features that concern general-purpose
computer systems simulation (and are not specific to computer
network simulation) and that are present both in OMNeT++ and OPNET.
<P>
<B>Model hierarchy levels</B><TABLE BORDER=1>
<TR><TD WIDTH=296><B>OPNET</B></TD><TD WIDTH=280><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=296>network level (subnetwork nesting possible)
<P>
node level (no nesting)<P>
process level (no nesting)
</TD><TD WIDTH=280>arbitrary levels of submodule nesting</TD>
</TR>
</TABLE>
<P>
<P>
<B>Topology description method</B>
<P>
OPNET provides two tools for defining module topology: graphical
editors to design network and node level models, and EMA (External
Model Access), an API for building model files from C programs.
These tools correspond to OMNeT++'s tools in the following way:
<BR>

<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Graphical</B></TD><TD WIDTH=192>graphical editor within the IDE
</TD><TD WIDTH=192>graphical editor: GNED</TD></TR>
<TR><TD WIDTH=192><B>High-level</B></TD><TD WIDTH=192>-</TD><TD WIDTH=192>NED language
</TD></TR>
<TR><TD WIDTH=192><B>Low-level</B></TD><TD WIDTH=192>EMA</TD>
<TD WIDTH=192>C++ output of NED compilation</TD></TR>
</TABLE>
<P>
<P>
There is no high-level textual model description in OPNET (like
NED is in OMNeT++). This means that one has either to use the
graphical editor or write lengthy C code using the EMA API.
<P>
The OPNET graphical model editor can only create fixed (unparametrized)
topologies.
<P>
There's a significant difference between how EMA and OMNeT++'s
NED are used. OPNET's EMA generates model files. EMA applications
are standalone programs: one writes the EMA C code, compiles and
runs it, and the EMA executable will generate a model file that
can be read into the graphical editor or loaded by simulation
programs. EMA cannot be used from within a simulation program.
In contrast, the compiled NED code of OMNeT++ becomes part of
the simulation program and it builds the model without having
to run external programs; this means that you can have a single
simulation executable that can be used to perform simulation studies
on networks with different topologies.
<P>
<B>Module parameters</B>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Expressions</B></TD><TD WIDTH=192>no expressions are allowed: only literals or exact copy of another parameter
</TD><TD WIDTH=192>arbitrary expressions using other parameters
</TD></TR>
<TR><TD WIDTH=192><B>Parameter passing</B></TD><TD WIDTH=192>by value
</TD><TD WIDTH=192>parameters can be passed by value or by reference, and be changed during simulation
</TD></TR>
<TR><TD WIDTH=192><B>Usage</B></TD><TD WIDTH=192>by process models only
</TD><TD WIDTH=192>by process models; also to define flexible topologies 
</TD></TR>
</TABLE>
<P>
<P>
In OPNET, module parameter values can be passed only &quot;as
is&quot;.
<P>
<B>Packet streams or gates</B>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Identification</B></TD><TD WIDTH=192>Packet streams are numbered from 0; no names can be assigned.
</TD><TD WIDTH=192>Gates are identified by names. Gate vectors are supported.
<P>
In the code, gates can be referenced by ID for greater speed.
</TD></TR>
<TR><TD WIDTH=192><B>Directionality</B></TD><TD WIDTH=192>Packet streams are uni-directional.
</TD><TD WIDTH=192>Gates are uni-directional.</TD></TR>
</TABLE>
<P>
<B>Flexible topologies</B>
<TABLE BORDER=1>
<TR><TD WIDTH=296><B>OPNET</B></TD><TD WIDTH=279><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=296>not really supported*</TD><TD WIDTH=279>in the NED file, parameters can define submodule types, count of submodules, gates and describe connections
</TD></TR>
</TABLE>
<P>
<P>
* If really necessary, it can be done through C programming (writing
EMA code) and running external program to create a separate model
file for each case.
<P>
<B>Tracing, animation and interactive simulation</B>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Tracing and debugging</B></TD><TD WIDTH=192>powerful command line debugger (ODB)
</TD><TD WIDTH=192>separate window for each module's output, single-steps, run until, inspectors, snapshot, etc. (Tkenv)
</TD></TR>
<TR><TD WIDTH=192><B>Animation</B></TD><TD WIDTH=192>mostly used in record/ playback mode;
<P>
animation spec. must be given in advance (via anim. probes)
</TD><TD WIDTH=192>interactive execution with message-flow animation, statistics animation etc. (Tkenv)
</TD></TR>
<TR><TD WIDTH=192><B>Interactive simulation</B></TD><TD WIDTH=192>not supported
</TD><TD WIDTH=192>strongly supported via object inspectors and watches. (Tkenv)
</TD></TR>
</TABLE>
<P>
<B>Random numbers</B><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Distributions provided</B></TD><TD WIDTH=192>many built-in distributions (through algorithms)
</TD><TD WIDTH=192>four built-in distributions, as C functions
</TD></TR>
<TR><TD WIDTH=192><B>Additional distributions</B></TD><TD WIDTH=192>through histograms
</TD><TD WIDTH=192>as C functions (algorithms); or through histograms
</TD></TR>
<TR><TD WIDTH=192><B>Random number generation</B></TD><TD WIDTH=192>one random number generator, no support for seed selection
</TD><TD WIDTH=192>several independent random number generators;
<P>
tool to support selecting good seed values
</TD></TR>
</TABLE>
<P>
<P>
OPNET has many built-in distributions implemented with algorithms
(C functions). Additional distributions are supported as histograms.
There is only one common source of random numbers. OPNET has no
aid for selecting seed values that produce long non-overlapping
random number sequences.
<P>
OMNeT++, only four basic distributions are provided. They are
implemented as C functions. Additional distributions can be added
by the user, and they are treated exactly in the same way as built-in
ones. Defining and using distributions in histogram form is also
supported. OMNeT++ provides several random number generators,
and also a tool for selecting good seed values.
<P>
<B>Process description method</B>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Method</B></TD><TD WIDTH=192>finite state machine (graphical spec. only)
</TD><TD WIDTH=192>both process-style (coroutine-based) and finite state machine (textual spec. only)
</TD></TR>
</TABLE>
<P>
<P>
<B>Direct (non-scheduled) process interaction</B>
<TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Method</B></TD><TD WIDTH=192>&quot;forced interrupt&quot;
</TD><TD WIDTH=192>member function call of other module</TD></TR>
</TABLE>
<P>
<P>
<B>Dynamic module creation</B><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>What can be created</B></TD><TD WIDTH=192>only processes within an exisiting module
</TD><TD WIDTH=192>simple modules;
<P>
connections;<P>
compound modules with arbitrarily complex, parametrized topologies
</TD></TR>
</TABLE>
<P>
<P>
<B>Object-oriented concepts</B><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Language</B></TD><TD WIDTH=192>C</TD><TD WIDTH=192>C++
</TD></TR>
<TR><TD WIDTH=192><B>Objects</B></TD><TD WIDTH=192>C API functions operating on object-like data structures; 
<P>
no support for inheritance*, polimorphism or the like 
</TD><TD WIDTH=192>full flexibility of C++: inheritance, polimorphism etc; <P>
built-in object-oriented mechanisms
</TD></TR>
</TABLE>
<P>
<P>
* The graphical user interface of OPNET (from version 3.0) contains
an &quot;inheritance mechanism&quot; for models. This is no real
inheritance in the object-oriented sense because it just means
that parameter values can be changed or fixed down, parameters
renamed, merged etc. There is no mention about changing the behaviour
of a module (that is, anything like C++'s virtual functions).
<P>
<B>Statistics collection and run-time analysis</B><TABLE BORDER=1>
<TR><TD WIDTH=295><B>OPNET</B></TD><TD WIDTH=281><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=295>writing observations to output file; &quot;probes&quot; to select statistics to be collected;
<P>
only off-line analysis (analysis of output files) is supported
</TD><TD WIDTH=281>writing observations to output files (roughly equivalent to OPNET's solution);<P>
run-time processing: basic measures (mean etc); distribution estimation with histograms; quantiles (P<SUP>2</SUP> algorithm);
<P>
support for detecting the end of the transient period and sufficient result accuracy
</TD></TR>
</TABLE>
<P>
<P>
<B>Parallel execution</B>
<TABLE BORDER=1>
<TR><TD WIDTH=295><B>OPNET</B></TD><TD WIDTH=281><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=295>not supported</TD><TD WIDTH=281>supported over PVM; arbitrary synchronisation can be used
</TD></TR>
</TABLE>
<P>
<P>
<B>Openness</B><TABLE BORDER=1>
<TR><TD WIDTH=192></TD><TD WIDTH=192><B>OPNET</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=192><B>Input file formats</B></TD><TD WIDTH=192>binary model files*;<BR>
textual parameter files
</TD><TD WIDTH=192>text files</TD></TR>
<TR><TD WIDTH=192><B>Output file formats</B></TD><TD WIDTH=192>binary files**
</TD><TD WIDTH=192>text files</TD></TR>
<TR><TD WIDTH=192><B>Availability of source</B></TD><TD WIDTH=192>not available (only the source of the shipped models is available)
</TD><TD WIDTH=192>avaliable</TD></TR>
<TR><TD WIDTH=192><B>Embedding simulations into other software product</B>
</TD><TD WIDTH=192>not supported and also not possible (the main() function cannot be supplied by the user etc.)
</TD><TD WIDTH=192>supported.
<P>
Embedding application becomes a new &quot;user interface&quot; based on Envir (1); or embedding application replaces Envir (2).
</TD></TR>
</TABLE>
<P>
<P>
* Can be read and analyzed by EMA programs.
<P>
** Can be exported to text files from the main OPNET program.
<H2><A NAME="_Toc473901897">Quick reference for OPNET users</A>
</H2>
<P>
This section is intended to help OPNET users learn OMNeT++ faster.
<BR>
<TABLE BORDER=1>
<TR><TD WIDTH=253><B>OPNET</B></TD><TD WIDTH=411><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=253>network, subnetwork, node</TD><TD WIDTH=411>Compound modules
</TD></TR>
<TR><TD WIDTH=253>module, process</TD><TD WIDTH=411>An OMNeT++ simple module corresponds to an OPNET module with its process.
</TD></TR>
<TR><TD WIDTH=253>interrupts, invocations, states</TD><TD WIDTH=411>When using <TT>handleMessage()</TT>: interrupt = event, invocation = call to <TT>handleMessage()</TT>, state = FSM state or the value of the state vars stored in the class
<P>
When using modules with <TT>activity()</TT>, this means a little different way of thinking from OPNET's. In OMNeT++, you write a simple module as you would write an operating system process or a thread, thus there's no need to distinguish 'states' or speak about 'invocations'. Within the simulation kernel, an 'invocation' corresponds to a <TT>transferTo(<I><FONT>module</FONT></I>)</TT> call.
<P>
An OMNeT++ module accepts messages (and simulation time advances) within <TT>receive&#133;(&#133;)</TT> calls; <TT>wait()</TT> is just a <TT>scheduleAt()</TT> followed by a <TT>receive()</TT>.
<P>
An OPNET interrupt is the event being processed. In this sense, OMNeT++ messages returned by <TT>receive()</TT> correspond to OPNET interrupts.
</TD></TR>
<TR><TD WIDTH=253>endsim interrupt</TD><TD WIDTH=411>The <TT>finish()</TT> virtual member functions of the simple modules are called at the end of the simulation run. You can redefine <TT>finish()</TT> to write statistics etc.
</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>
<PRE>
<FONT>op_ima_obj_attr_get(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>foo = par(&quot;foo&quot;);
foo = module-&gt;par(&quot;foo&quot;);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_ima_sim_attr_get(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>There are no simulation attributes. You can use the parameters of the top-level module instead:<PRE>
<FONT>foo = simulation.systemModule()-&gt;par(&quot;foo&quot;);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_prg_odb_print_minor(&#133;)
op_prg_odb_print_major(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>ev &lt;&lt; &quot;hello!&quot; &lt;&lt; endl;
ev.printf(&#133;);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_sim_end(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>simulation.error(&quot;Your fault! error %d&quot;,ec);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_subq_....()</FONT>
</PRE>

</TD><TD WIDTH=411>Create a queue object and then manipulate it with its member functions.<PRE>
<FONT>cQueue queue;
queue.insert( msg );
if (!queue.empty())
   msg = queue.pop();</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>List
op_prg_list_...()</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>cLinkedList list;
list.insert( ptr );
if (!list.empty())
   ptr = list.pop();</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>Topology
op_rte_...()</FONT>
</PRE>

</TD><TD WIDTH=411>The <TT>cTopology</TT> class offers similar functionality, and you can expect greater speed than with OPNET's routing funtions.
</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>
<PRE>
<FONT>Packet
op_pk_create(&#133;)
op_pk_destroy(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>Use the <TT>cMessage</TT> class.
<PRE>
<FONT>cMessage *msg = new cMessage;
delete msg;</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
packet fields
<FONT>op_pk_nfd_set(&#133;)
op_pk_nfd_get_(&#133;)
op_pk_fd_set(&#133;)
op_pk_fd_get(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>Message parameters. A parameter has both name and index.<PRE>
<FONT>msg-&gt;par(&quot;foo&quot;) = foo;
msg-&gt;addPar(&quot;new-foo&quot;) = foo;
int foo = msg-&gt;par(&quot;foo&quot;);

int fooindex = msg-&gt;parList().find(&quot;foo&quot;);
msg-&gt;par(fooindex) = foo;</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253>packet field modelled size</TD><TD WIDTH=411>Message parameters do not have associated modelled bit sizes. Message length can be used instead.<PRE>
<FONT>msg-&gt;addPar(&quot;dest_addr&quot;) = dest_addr;
msg-&gt;addLength( 32 );</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253>packet formats</TD><TD WIDTH=411>There are no explicit packet formats in OMNeT++. However, you can write function to create messages with specific fields and length:<PRE>
<FONT>cMessage *createEthernetFrame()
{
   cMessage *msg = new cMessage;
   msg-&gt;setKind(PACKET);
   msg-&gt;addPar(&quot;source&quot;);
   msg-&gt;addPar(&quot;destination&quot;);
   msg-&gt;addPar(&quot;protocol&quot;);
   msg-&gt;setLength( 8*16 );
   return msg;
}</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253>packet encapsulation</TD><TD WIDTH=411>As in OPNET, message parameters can be assigned object pointers, thus also message pointers. <P>
However, there is also direct support encapsulation:<PRE>
<FONT>msg-&gt;encapsulate(innermsg)
innermsg = msg-&gt;encapsulatedMsg();
innermsg = msg-&gt;decapsulate();</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>ICI</FONT>
</PRE>
</TD>
<TD WIDTH=411>ICIs are also represented by <TT>cMessage</TT> objects, naturally with zero length. 
<P>
If it is important to distinguish between packets and ICIs, you can use the message kind field:<PRE>
<FONT>#define PACKET  0
#define ICI     1

cMessage *pk = new cMessage;
pk-&gt;setKind(PACKET);

cMessage *ici = new cMessage;
ici-&gt;setKind(ICI);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253>ICI formats</TD><TD WIDTH=411>See packet formats.
</TD></TR>
<TR><TD WIDTH=253>ICI attributes</TD><TD WIDTH=411>See packet fields.
</TD></TR>
<TR><TD WIDTH=253>packet and ICI in the same interrupt</TD><TD WIDTH=411>You can use encapsulation. At the sender side:<PRE>
<FONT>cMessage *ici, *pk;
ici-&gt;encapsulate(pk);
send(ici,&quot;out-gate&quot;);
</FONT>
</PRE>
<P>
The receiver side:<PRE>
<FONT>ici = receive();
pk = ici-&gt;decapsulate();</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_send(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>send( msg, &quot;out-gate&quot;);
send( msg, &quot;gate-vector&quot;, index);
send( msg, gate_id );</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_send_delayed(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>sendDelayed(&#133;)</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_deliver(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>sendDirect(&#133;)</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pk_schedule_self(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>scheduleAt( simTime()+timeout, msg );</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_ev_cancel(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>cancelEvent( msg );</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_dist_load(&#133;)
op_dist_outcome(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>To generate random numbers from analytical distributions, use:<PRE>
<FONT>uniform(&#133;)
intuniform(&#133;)
exponential(&#133;)
normal(&#133;)
truncnormal(&#133;)
</FONT>
</PRE>
<P>
For custom distributions you can use the histogram classes. Histograms can load distribution data from file.<PRE>
<FONT>cDoubleHistogram hist;
FILE *f = fopen(&quot;distribution.dat&quot;);
hist.loadFromFile( f );
fclose(f);

double rnd = hist.random();</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>output vectors</TD><TD WIDTH=411>The <TT>cOutVector</TT> class can be used.
<PRE>
<FONT>cOutVector eed(&quot;End-to-end delay&quot;);

double d = msg-&gt;creationTime() - simTime();
eed.record( d );</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253>output scalars</TD><TD WIDTH=411>Output scalar file exists. You can write into it with <TT>recordScalar()</TT>:
<PRE>
<FONT>recordScalar(&quot;average delay&quot;, avg_delay);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_topo_parent()</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>cModule *parent = parentModule();</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_topo_child_&#133;(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>cSubModuleIterator</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_topo_.._assoc_(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>gate(i)/gate(name), 
gate-&gt;toGate()/fromGate()
gate-&gt;destinationGate()/sourceGate()
gate-&gt;ownerModule()</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pro_create(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>See dynamic module creation. Note that this is a more powerful tool than OPNET's dynamic processes in that you can also create compound modules.
</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>Prohandle</FONT>
</PRE>

</TD><TD WIDTH=411>Module ID. Given the module pointer, you can obtain module ID by<PRE>
<FONT>int id = mod-&gt;id();
</FONT>
</PRE>
<P>
And you can obtain module pointer from the ID:<PRE>
<FONT>cModule *mod = simulation.module(id);
</FONT>
</PRE>
<P>
An invalid ID is negative.
</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pro_invoke(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>Dynamically created modules do not need to be invoked, they live their own life. To dispatch messages to them, you can use <TT>sendDirect(&#133;)</TT>
</TD></TR>
<TR><TD WIDTH=253>
<PRE>
<FONT>op_pro_destroy(&#133;)
op_pro_destroy( self )</FONT>
</PRE>

</TD><TD WIDTH=411><PRE>
<FONT>deleteModule( module );
deleteModule();</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253>module memory, parent-to-child memory, argument memory to dynamic processes
</TD><TD WIDTH=411>Parent module can set pointers (<TT>void* </TT>data members) in the dynamically created module object any time, thus also right after creating it ( parent-to-child memory), right before sending a packet to it ( argument memory), and the pointer can refer to memory managed by the parent module ( module memory). 
<P>
An example for argument memory. Suppose the child module class has a public data member named <TT>argmem</TT>:
<PRE>
<FONT>class ChildModule : public cSimpleModule {
   &#133;
   public:
      void *argmem;
   &#133;
};
</FONT>
</PRE>
<P>
The parent module code would be:<PRE>
<FONT>childmod-&gt;argmem = argument_memory_ptr;
sendDirect( msg, childmod, 0.0, &quot;in&quot; );
</FONT>
</PRE>
<P>
Child module code would be:<PRE>
<FONT>msg = receive();
argument_memory_ptr = argmem;</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253><PRE>
<FONT>op_pro_valid(&#133;)</FONT>
</PRE>

</TD><TD WIDTH=411>Given the module id:<PRE>
<FONT>int valid = (id&gt;=0) &amp;&amp; simulation.exist(id);</FONT>
</PRE>

</TD></TR>
<TR><TD WIDTH=253></TD><TD WIDTH=411></TD></TR>
<TR><TD WIDTH=253>Environment files</TD><TD WIDTH=411>Configuration files. Default is <TT>omnetpp.ini</TT>. Multiple ini files and ini file inclusion are also supported.
</TD></TR>
<TR><TD WIDTH=253>Process Editor</TD><TD WIDTH=411>Your favourite text editor. Or <I>vi</I> :-).
</TD></TR>
<TR><TD WIDTH=253>Network Editor, Node Editor</TD><TD WIDTH=411>Any editor to write NED files.
<P>
GNED. Not very sophisticated yet though.
</TD></TR>
<TR><TD WIDTH=253>Simulation Tool</TD><TD WIDTH=411>Use the <TT>[Run 1]</TT>, <TT>[Run 2]</TT> etc. sections in <TT>omnetpp.ini</TT> do describe several runs with different parameters.
<P>
To create loops on different variables, you can use a shell script that creates a short ini file with the variable parameters, and include that file in <TT>omnetpp.ini</TT>.
</TD></TR>
<TR><TD WIDTH=253>probes, Probe Editor</TD><TD WIDTH=411>From the ini file, you can turn on/off <TT>cOutVector</TT> objects individually as well as assign result collection interval to them.
</TD></TR>
<TR><TD WIDTH=253>Analysis Tool</TD><TD WIDTH=411>Plove</TD></TR>
<TR><TD WIDTH=253>EMA</TD><TD WIDTH=411>Where you would normally use EMA, OMNeT++ NED files with parametrized topology are often enough.
<P>
Otherwise, you have two choices:<P>
a) write a program to generate NED files. Text-processing languages like perl and awk are great tools for that.<P>
b) write the network-building code in C++. You can look at the output of nedc for some idea how to do it.
</TD></TR>
</TABLE>
<HR><H1><A NAME="_Toc473901898">Appendix B: Parsec and OMNeT++</A>
</H1>
<H2><A NAME="_Toc473901899">What is PARSEC?</A></H2>
<P>
PARSEC is a very successful simulation language, with strong support
for parallel simulation. PARSEC bears some similarity to OMNeT++
in that it is also based on threads/coroutines. The language and
the software has been developed at the Parallel Computing Laboratory
of the University of California Los Angeles (UCLA), under the
leadership of Prof. Rajive Bagrodia. PARSEC has been used in a
number of simulation projects, for example in simulation of mobile
radio networks in a military environment.
<P>
It is best to quote the PARSEC User Manual, Release 1.1 (August
1998):
<P>
<I>PARSEC (for PARallel Simulation Environment for Complex programs)
is a C-based discrete event simulation language. It adopts the
process interaction approach to discrete event simulation. An
object (also referred to as a physical process) or a set of objects
in the physical system is represented by a logical process </I>[a
thread - roughly equivalent to an OMNeT++ simple module --Andras]<I>.
Interactions among physical processes (events) are modeled by
timestamped message exchanges among the corresponding logical
processes.</I>
<P>
<I>One of the important distinguishing features of PARSEC is its
ability to execute a discrete-event simulation model using several
different asynchronous parallel simulation protocols on a variety
of parallel architectures. [...] Thus, with few modifications,
a PARSEC program may be executed using the traditional sequential
(Global Event List) simulation protocol or one of many parallel
[...] protocols. </I>[In reality, PARSEC currently supports only
conservative PDES but not any optimistic protocol --Andras]
<P>
<I>In addition, PARSEC provides powerful message receiving constructs
that result in shorter and more natural simulation programs. [...]</I>
<P>
<I> The PARSEC language has been derived from the Maisie language,
but with several improvements, both in the syntax of the language
and in its execution environment.</I>
<P>
The PARSEC web site is at http://pcl.cs.ucla.edu/. It is very
impressive.
<H2><A NAME="_Toc473901900">What is inside the Parsec package?</A>
</H2>
<P>
When you download and install the PARSEC distribution, basically
you find:
<UL>
<LI>pcc (the Parsec compiler), and
<LI>2 variants of the Parsec runtime library
</UL>
<P>
This shows that PARSEC is strictly a simulation (and parallel
programming) language which is restricted to the area of entities<I>,</I>
messages, and the tasks centered around message sending and receiving.
It is difficult to compare to OMNeT++ which is more of a complete
simulation environment. In OMNeT++, the simulation library alone
covers much more functionality than the whole PARSEC. PARSEC has
a very efficient support for parallel execution.
<H2><A NAME="_Toc473901901">Parsec vs. the OMNeT++ simulation
kernel</A></H2>
<P>
In the further sections, I will give a brief overview of Parsec,
with special attention to the strong and weak sides compared to
OMNeT++. 
<P>
<B>NOTE:</B> I am doing my best, however, THIS IS NOT A REPLACEMENT
FOR THE PARSEC MANUAL. It is possible that there are errors in
this chapter. If you want to have a closer look at Parsec, you
must download and read the official Parsec manual from UCLA.
<P>
As it was mentioned earlier, we can only compare Parsec against
the OMNeT++ simulation kernel, that is, the functionality around
<TT>send...()</TT>, <TT>receive...()</TT>, <TT>wait()</TT> and
the coroutines (the <TT>activity()</TT> function), because Parsec
simply doesn't offer much more than that.
<P>
<B>The first look</B>
<P>
The PARSEC is a programming language based on C (<I>not</I> C++!).
PARSEC programs, in addition to normal C code, contain special
syntactic constructs, so they do not compile as C. You have to
invoke the PARSEC compiler (<TT>pcc</TT>) which parses the whole
program and translates it into true C code.
<P>
The main advantage of this solution is that the PARSEC language
is clean and really elegant.
<P>
Let us see a bit of PARSEC code:
<PRE>
<FONT>#include &lt;stdio.h&gt;
...

message job {
   int id;
   int count;
};

message add_to_your_sorc {
   ename id;
};
...

entity driver(int argc, char **argv) {
   ...
}
</FONT>
</PRE>
<P>
Two constructs stand out at once: <TT>message</TT> and <TT>entity</TT>.
The <TT>message</TT> constructs define message types, and are
translated to C structs. Entitities correspond to OMNeT++'s simple
modules, and the entity body is equivalent to the <TT>activity()</TT>
function. <TT>ename</TT> is a data type that holds entity references.
<P>
<B>Restricted use of C++</B>
<P>
Because the parser inside <TT>pcc</TT> is written for C, it is
<I>not possible to use any C++ constructs</I>. This means you
can NOT use:
<UL>
<LI>&quot;//&quot; comments, only &quot;/* */&quot;
<LI>class libraries directly (only wrapped into standard C functions)
</UL>
<P>
Today, when practically no one is programming in pure C, this
is a very serious limitation. Again, the limitation comes from
pcc itself: it doesn't understand any C++. It is irrelevant whether
you use a C or C++ compiler to compile pcc's output.
<P>
<B>The driver entity -- assembling the model by hand</B>
<P>
The <TT>driver</TT> entity is special; in a way it is similar
to the C <TT>main()</TT> function. PARSEC starts the simulation
by creating and running a driver entity. The main task of the
driver is to create all other entities in the simulation and provide
them with information they need (parameters values, etc). The
latter is done by sending to the entitities messages with the
necessary parameters.
<P>
PARSEC does not have a high-level topology description language
like NED in OMNeT++; instead, the driver entity is hand-coded
most of the time. (There was no mention of tools that could generate
the driver entity based on some higher-level description.).
<P>
OMNeT++ compound modules have no equivalent in PARSEC. All entities
are at the same level, there's no way to express hierarchy. 
<P>
PARSEC has no notion of module gates, and there are no connections
(in the OMNeT++ sense) among the entities. This means that when
sending messages, the receiving entity must be explicitly named.
Since the program contains no explicit topology information, an
entity initially has no information about its communication partners
(it knows no <TT>ename</TT>s exept its own). The usual practice
is that the driver entity sends the necessary enames in an initialization
message to each entity. (For illustration, see the <TT>add_to_your_sorc</TT>
message type from the above code fragment. The message name itself
is quite descriptive...)
<P>
The consequence of the lack of compound modules and module gates
is that it is a complicated and tricky task to set up networks
with but the most trivial topology. It is also very difficult
to write reusable simulation components without well-defined interfaces
and structuring (compound modules).
<P>
<B>Problems with splitting up the entity body</B>
<P>
During programming, the code of an entity may become so large
that it is no longer feasible to keep it within a single function
body. In OMNeT++ you can solve the problem by distributing the
simple module class's <TT>activity()</TT> code into new member
functions which are called from <TT>activity()</TT>, and moving
the some local variables of <TT>activity()</TT> into the module
class so that they can also be accessed by the new member functions.
<P>
The above approach doesn't work in Parsec, because Parsec is C-based
and entities are not C++ classes. Of course one may call ordinary
C functions from the entity body, but the nessessary parameters
must be passed in the argument list (or as pointers to data structures
in the entity).
<P>
Another solution in Parsec is to use a construct called <I>friend</I>
<I>functions</I> (not to be confused with C++ friend functions).
Parsec's friend functions may access the local variables of the
entity (quite strange in C, but much like an inner procedure in
Pascal...). However, the Parsec documentation does not recommend
using friend functions (they are slow); it says they are provided
for Maisie compatibility.
<P>
<B>Message sending</B>
<P>
Messages can be sent to other entities with the <I>send</I> construct:
<PRE>
<B><FONT>send</FONT></B><FONT> <I>message</I> <B>to</B> <I>dest-entity</I> <B>after</B> <I>delay</I>;
</FONT>
</PRE>
<P>
For example, creating a new message of type <TT>Request</TT> with
the parameters <TT>10</TT> and <TT>self</TT> (the current entity)
and sending it to <TT>entity2</TT> entity after a delay looks
like this:
<PRE>
<B><FONT>send</FONT></B><FONT> Request{10,<B>self</B>} <B>to</B> entity2 <B>after</B> 5;
</FONT>
</PRE>
<P>
This Parsec construct is totally equivalent in functionality to
OMNeT++'s <TT>sendDirect( <I><FONT>message</FONT></I>,
<I><FONT>delay</FONT></I>, <I><FONT>dest</FONT></I>-<I><FONT>module
</FONT></I>[,<I><FONT>dest</FONT></I>-<I><FONT>gate</FONT></I>])</TT>
call. Since Parsec has no equivalent of OMNeT++ gates, OMNeT++'s
other <TT>send()</TT> functions which send messages through a
gate are not present in Parsec.
<P>
<B>Message receiving constructs </B>
<P>
Parsec entities accept messages with the <I>receive</I> construct.
<I>Receive</I> has many forms: the elegance and power of the Parsec
language stems from the <I>receive</I> construct. Some illustrative
examples:
<PRE>
<B><FONT>receive</FONT></B><FONT> (Request req) {
    ...
} <B>or</B> <B>receive</B> (Release rel) {
    ...
} <B>or</B> <B>timeout</B> <B>in</B> (5) {  /*&quot;<B>in</B>&quot;: timeout with high priority*/
    ...
}
</FONT>
</PRE>
<P>
It is possible to add guards to the receive branches:
<PRE>
<B><FONT>receive</FONT></B><FONT> (Request req) <B>when</B> (req.units&lt;=units) {
    ...
} <B>or</B> <B>timeout</B> <B>after</B> (5) { /*&quot;<B>after</B>&quot;: timeout with low priority*/
    ...
}
</FONT>
</PRE>
<P>
These constructs have to be explicitly programmed in OMNeT++ using
<TT>while</TT> loops with <TT>receive()</TT> calls and <TT>if/switch</TT>
statements in its body. The reason OMNeT++ doesn't have this sort
of syntax and functionality is that it is impossible to express
with plain C/C++: one cannot avoid the need for a special precompiler.
Having to use a precompiler, however, causes some inconvenience
during program development, and in practice, there isn't as much
need for this sort of complex receive constructs that would justify
making it mandatory to use a precompiler for every source file.
<P>
One may wonder what happens to the messages which have arrived
already but have not been accepted by the entity yet because they
had no matching <I>receive</I> branch. Parsec stores those messages
in what it calls the <I>message buffer</I> of the entity. Parsec's
message buffer is practically the same as the put-aside queue
in OMNeT++.
<P>
Guards may contain the special expressions <TT>qhead(<I><FONT>msgtype</FONT></I>)</TT>,
<TT>qempty(<I><FONT>msgtype</FONT></I>)</TT>,
<TT>qlength(<I><FONT>msgtype</FONT></I>)</TT>
which refer to the messages in the message buffer. The programmer
perceives as if each message type had a separate message buffer:
<PRE>
<FONT>receive (Request req) when (qhead(Request).units&lt;=units);
receive (Request req) when (qempty(Release) &amp;&amp; req.units&lt;=units);
</FONT>
</PRE>
<P>
Note that the <TT>qhead()</TT>, <TT>qempty()</TT> and <TT>qlength()</TT>
operations seem to be all you can do with the message buffer,
while in OMNeT++ you have free access to the put-aside queue through
the <TT>cQueue</TT> member functions.
<P>
Parsec also has a <I>hold</I> statement which is functionally
equivalent to OMNeT++'s <TT>wait()</TT>:
<PRE>
<FONT>hold(5);
</FONT>
</PRE>
<P>
<B>Cancelling messages</B>
<P>
Parsec has no support for cancelling messages, that is, there
is no equivalent to OMNeT++'s <TT>cancelEvent()</TT>. The Parsec
team recommends different workarounds like keeping a list of valid
timers and checking messages against that.
<P>
A posting from the Parsec bulletin board:
<PRE>
<FONT>Re: Cancelling messages in PARSEC

Posted by Rich from al-bundy.cs.ucla.edu on November 30, 1999. 

Chano Gomez posted:
&gt; I would like to be able to cancel a message that has been already sent,
&gt; but that hasn't been received by the recipient (because the message
&gt; has been sent using the &quot;send message to entity after x&quot; clause).
&gt; 
&gt; Is this possible in PARSEC?

No.

&gt; I'd like to do this for activating and cancelling timers.

There are other ways to implement timers in Parsec, particularly 
if the timers are sent to &quot;self.&quot;  One way is to keep a list of
timeout values and set the X in &quot;timeout in (X)&quot; to the minimum in
the list.  (i.e. use timeout, don't send messages)  To cancel,
simply remove from the list.  Another way is to send to self, but
keep a list of cancelled messages (in a circular queue, for example).
When the message is received, check to see if it was cancelled, and 
if so, discard it.

Rich
</FONT>
</PRE>
<P>
<B>Simulation clock</B>
<P>
The PARSEC simulation clock is of integer type: optionally, <TT>unsigned
int</TT> or <TT>long long (long long</TT> is <I>not</I> a standard
ANSI C/C++ type). OMNeT++ uses <TT>double</TT>.
<P>
It is probably application-specific which is the better choice,
but in the case of a large simulation model put together from
components written with different time granularity in mind, <TT>double</TT>
seems a better choice because it is relative insensitive to the
choice of the time unit.
<P>
<B>Thread/coroutine handling</B>
<P>
Although the Parsec documentation says nothing, symbol names is
the Parsec runtime library give the impression that the thread/coroutine
implementation is quite similar in OMNeT++ and the single-processor
implementation of Parsec. On Unix systems, both simulators use
a portable coroutine library (proposed by Stig Kofoed, based on
setjmp/longjmp). On NT, Parsec seemingly uses the thread implementation
of the underlying operating system. 
<P>
One advantage of OMNeT++ is that it can tell you how much stack
space a module uses in fact (see the <TT>stackUsage()</TT> function),
so you can optimize the stack size. Parsec apparently doesn't
have this feature. 
<P>
The worst problem with coroutines/threads is that if you create
too many of them, you'll need a hell lot of memory. With the current
engineering workstations, it is practically impossible to create
more than a few times ten thousand entities in Parsec (this is
requires a few hundred megabytes of memory).
<P>
OMNeT++ has basically the same problem, but it gives you two escapes:
<OL>
<LI>optimize the stack sizes (by checking <TT>stackUsage()</TT>)
<LI>use <TT>handleMessage()</TT> for some modules (in very many
cases it is more convenient anyway)
</OL>
<P>
Parsec has no such escapes, so the problem may hit you hard.
<P>
<B>Comparison of PARSEC and OMNeT++ as parallel simulation tools</B>
<P>
A fundamental difference between Parsec and OMNeT++ is that Parser
supports <I>parallel simulation</I> (i.e. simulation on a multiprocessor)
while OMNeT++ supports <I>distributed simulation</I> (over several
hosts).
<UL>
<LI>If you do parallel simulation with Parsec, the whole simulation
will be a <I>single operating system process</I>. This process
will be a multithreaded process, with each thread running on a
physically different <I>processor</I> of the hardware. Each thread
will be responsible for simulating one segment of the model; different
threads communicate via <I>shared memory</I>, logically with PDES
protocols. This practically means that you can run Parsec parallel
simulation on <I>shared memory multiprocessors</I>.
<LI>Quite differently, OMNeT++ supports <I>distributed</I> <I>simulation</I>
where the simulation program consists of <I>separate</I> operating
system processes typically running on different <I>hosts</I> interconnected
via a LAN. These processes communicate by <I>passing messages</I>
over the LAN, by using the PVM library. 
</UL>
<P>
This difference accounts for the usage differences. While Parsec's
parallel simulation support is almost transparent to the user,
OMNeT++'s distributed simulations are inherently more difficult
to set up and manage (you have to install PVM, etc).
<P>
Parsec supports conservative PDES; OMNeT++ supports conservative
PDES and Statistical Synchronisation.
<H2><A NAME="_Toc473901902">Feature summary</A></H2>

<TABLE BORDER=1>
<TR><TD WIDTH=181><B>Feature</B></TD><TD WIDTH=192><B>OMNeT++</B>
</TD><TD WIDTH=282><B>PARSEC</B></TD></TR>
<TR><TD WIDTH=181><I><B>Programs, components:</B></I></TD><TD WIDTH=192>
</TD><TD WIDTH=282></TD></TR>
<TR><TD WIDTH=181>graphical model editor</TD><TD WIDTH=192>GNED
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>result analysis/plotting</TD><TD WIDTH=192>Plove
</TD><TD WIDTH=282><I>-</I></TD></TR>
<TR><TD WIDTH=181>interactive execution, tracing</TD><TD WIDTH=192>Tkenv
</TD><TD WIDTH=282><I>-</I></TD></TR>
<TR><TD WIDTH=181>parameter file</TD><TD WIDTH=192>omnetpp.ini
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>random numbers support</TD><TD WIDTH=192>seedtool
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181><I><B>Model structure</B></I></TD><TD WIDTH=192>
</TD><TD WIDTH=282></TD></TR>
<TR><TD WIDTH=181>encapsulation/grouping</TD><TD WIDTH=192>compound modules
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>connections</TD><TD WIDTH=192>yes (optionally: delay, data rate, bit error rate)
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>topology desctiption</TD><TD WIDTH=192>via NED, nedc
</TD><TD WIDTH=282>- (manually from the driver entity)</TD></TR>
<TR><TD WIDTH=181><I><B>Simulation methodology</B></I></TD><TD WIDTH=192>
</TD><TD WIDTH=282></TD></TR>
<TR><TD WIDTH=181>Precompiler</TD><TD WIDTH=192>- (no need, code is standard C++)
</TD><TD WIDTH=282>pcc (Parsec compiler)</TD></TR>
<TR><TD WIDTH=181>C++ support</TD><TD WIDTH=192>based on C++</TD>
<TD WIDTH=282>- (language based on C)</TD></TR>
<TR><TD WIDTH=181>alternative to coroutines/threads</TD><TD WIDTH=192>handleMessage()
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>complex message receiving constructs</TD><TD WIDTH=192>- (timeout only)
</TD><TD WIDTH=282>yes: filter by message type, timeout, guards, etc.
</TD></TR>
<TR><TD WIDTH=181>message types</TD><TD WIDTH=192>via subclassing cMessage or via cMessage + pars
</TD><TD WIDTH=282>via the message construct</TD></TR>
<TR><TD WIDTH=181>module gates, sending via gates</TD><TD WIDTH=192>yes
</TD><TD WIDTH=282>- (direct sending only)</TD></TR>
<TR><TD WIDTH=181>module parameters</TD><TD WIDTH=192>yes</TD>
<TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>dynamic module (entity) creation </TD><TD WIDTH=192>yes (also compound modules)
</TD><TD WIDTH=282>yes</TD></TR>
<TR><TD WIDTH=181><I><B>Simulation library</B></I></TD><TD WIDTH=192>
</TD><TD WIDTH=282></TD></TR>
<TR><TD WIDTH=181>statistics/histogram classes</TD><TD WIDTH=192>yes (cStdDev, 3 histogram classes, P<SUP>2</SUP> , k-split)
</TD><TD WIDTH=282><I>-</I></TD></TR>
<TR><TD WIDTH=181>routing support</TD><TD WIDTH=192>yes (cTopology)
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>FSM support</TD><TD WIDTH=192>yes (FSM macros)
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>support for output files</TD><TD WIDTH=192>yes (cOutVector, recordScalar(),...)
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181>container classes</TD><TD WIDTH=192>yes (cQueue, cArray,...)
</TD><TD WIDTH=282>-</TD></TR>
<TR><TD WIDTH=181><I><B>Parallel execution</B></I></TD><TD WIDTH=192>
</TD><TD WIDTH=282></TD></TR>
<TR><TD WIDTH=181>conservative</TD><TD WIDTH=192>yes</TD><TD WIDTH=282>yes (much more elaborate than in OMNeT++)
</TD></TR>
<TR><TD WIDTH=181>optimistic</TD><TD WIDTH=192>-</TD><TD WIDTH=282>-
</TD></TR>
<TR><TD WIDTH=181>statistical synchronization</TD><TD WIDTH=192>explicit support
</TD><TD WIDTH=282>possible, but no support</TD></TR>
</TABLE>
<P>
<H2><A NAME="_Toc473901903">Correspondence between Parsec and
OMNeT++</A></H2>

<TABLE BORDER=1>
<TR><TD WIDTH=332><B>PARSEC</B></TD><TD WIDTH=332><B>OMNeT++</B>
</TD></TR>
<TR><TD WIDTH=332>entity</TD><TD WIDTH=332>simple module (cSimpleModule)
</TD></TR>
<TR><TD WIDTH=332>message</TD><TD WIDTH=332>message (cMessage, cPacket,...)
</TD></TR>
<TR><TD WIDTH=332>message buffer of the entity</TD><TD WIDTH=332>put-aside queue
</TD></TR>
<TR><TD WIDTH=332>send <I>message</I> to <I>entity</I> after <I>delay</I>
</TD><TD WIDTH=332>sendDirect( <I>message</I>, <I>delay</I>, <I>module </I>[,<I>destgate</I>])
</TD></TR>
<TR><TD WIDTH=332>send <I>message</I> to self after <I>delay</I>
</TD><TD WIDTH=332>scheduleAt( <I>message</I>, simTime()+<I>delay</I>))
</TD></TR>
<TR><TD WIDTH=332>n/a
<P>
(Parsec has no equivalent of OMNeT++ gates)
</TD><TD WIDTH=332>send(<I>message</I>,<I>gate</I>)
<P>
sendDelayed(<I>message</I>,<I>gate</I>,<I>delay</I>)
</TD></TR>
<TR><TD WIDTH=332>hold( <I>delay</I> )</TD><TD WIDTH=332>wait( <I>delay</I> ) 
</TD></TR>
<TR><TD WIDTH=332>receive (<I>msgtype</I> <I>msg</I>) { ... }
</TD><TD WIDTH=332><I>msg</I> = receive()</TD></TR>
<TR><TD WIDTH=332>receive (<I>msgtype</I> <I>msg</I>) { ... }
<BR>
or timeout after (<I>delay</I>) { ... }
</TD><TD WIDTH=332><I>msg = </I>receive( <I>delay </I>)</TD></TR>
<TR><TD WIDTH=332>more complex <I>receive</I> constructs</TD>
<TD WIDTH=332>while<I> </I>{<I> msg=</I>receive()<I>; </I>if (...) ... }
</TD></TR>
</TABLE>
<P>
<HR><H1><A NAME="_Toc473901904">Appendix C: NED Language Grammar</A>
</H1>
<P>
The NED language, the network topology description language of
OMNeT++ will be given using the extended BNF notation.
<P>
Space, horizontal tab and new line characters counts as delimiters,
so one or more of them is required between two elements of the
description which would otherwise be unseparable. '//' (two slashes)
may be used to write comments that last to the end of the line.
The language only distinguishes between lower and upper case letters
in names, but not in keywords.
<P>
In this description, the {xxx...} notation stands for one or more
 xxx's separated with spaces, tabs or new line characters, and
{xxx,,,} stands for one or more xxx's, separated with a comma
and (optionally) spaces, tabs or new line characters.
<P>
For ease of reading, in some cases we use textual definitions.
The <I>networkdescription</I> symbol is the sentence symbol of
the grammar.
<P>
<B>notation meaning</B>
<P>
[a] 0 or 1 time a
<P>
{a} a
<P>
{a,,,} 1 or more times a, seperated by commas
<P>
{a...} 1 or more times a, seperated by spaces
<P>
a|b a or b
<P>
'a' the character a
<P>
<B>bold</B> keyword
<P>
<I>italic</I> identifier

<PRE>
<FONT>networkdescription ::=
	{ definition ... }


definition	::=
	  include
	| channeldefinition
	| simpledefinition
	| moduledefinition
	| networkdefinition

include ::=
	<B>INCLUDE</B> { fileName ,,, } ;

channeldefinition ::=
	<B>CHANNEL</B> <I>channeltype</I> 
	  [ <B>DELAY</B> numericvalue ] 
	  [ <B>ERROR</B> numericvalue ] 
	  [ <B>DATARATE</B> numericvalue ] <SUP>******
</SUP>	<B>ENDCHANNEL

</B>simpledefinition ::= 
	<B>SIMPLE</B> <I>simplemoduletype
</I>	  [ machineblock ] 
	  [ paramblock ]
	  [ gateblock ]
	<B>ENDSIMPLE</B> [ <I>simplemoduletype</I> ]

moduledefinition ::= 
	<B>MODULE</B> <I>compoundmoduletype
</I>	  [ machineblock<SUP>*</SUP> ] 
	  [ paramblock ]
	  [ gateblock ]
	  [ submodblock ]
	  [ connblock ]
	<B>ENDSIMPLE</B> [ <I>compoundmoduletype</I> ]

moduletype ::=
	<I>simplemoduletype</I> | <I>compoundmoduletype

</I>machineblock ::= 
	<B>MACHINES:</B> { <I>machine</I> ,,, } ;

paramblock ::=
	<B>PARAMETERS: </B>{ parameter ,,, } ;

parameter ::=
       <I>parametername
</I>     | <I>parametername</I> : <B>CONST </B>[ <B>NUMERIC </B>]
     | <I>parametername</I><B> : STRING
</B>     | <I>parametername</I><B> : BOOL
</B>     | <I>parametername</I><B> : CHAR
</B>     | <I>parametername</I><B> : ANYTYPE

</B>gateblock ::=
	<B>GATES:</B> 
	  [ <B>IN:</B> { gate ,,, } ; ]
	  [ <B>OUT:</B> { gate ,,, } ; ]

gate ::=
	<I>gatename</I> [ '[]' ]

submodblock ::=
	<B>SUBMODULES:</B> { submodule ... }

submodule ::=
	{ <I>submodulename</I> : <I>moduletype</I> [ vector ]
	  [ on_block<SUP>*</SUP> ... ] 
	  [ substparamblock ... ]
	  [ gatesizeblock ... ] } 
     | { <I>submodulename</I> : <I>parametername</I> [ vector ] <B>LIKE</B> <I>moduletype
</I>	  [ on_block<SUP>*</SUP> ... ] 
	  [ substparamblock ... ]
	  [ gatesizeblock ... ] } 


on_block<SUP>*</SUP> ::= 
	<B>ON </B>[ <B>IF</B> expression ]<B>:</B> { <I>on_machine</I> ,,, } ;

substparamblock	::= 
	<B>PARAMETERS </B>[ <B>IF</B> expression ]<B>:</B> 
</FONT>  { <I>substparamname</I><FONT> = substparamvalue,,, } ;

</FONT>substparamvalue ::=
	( [ <B>ANCESTOR</B> ] [ <B>REF</B> ] <I>name</I> )
	| parexpression

gatesizeblock ::= 
	<B>GATESIZES </B>[ <B>IF</B> expression ]<B>:</B> 
  { <I>gatename</I> vector ,,, } ;

connblock ::= 
	<B>CONNECTIONS </B>[ <B>NOCHECK</B> ]<B>:</B> { connection ,,, } ;

connection ::= 
	  normalconnection | loopconnection

loopconnection ::= 
	<B>FOR</B> { index ... } <B>DO</B> 
	 { normalconnection ,,, } ;
	<B>ENDFOR

</B>index ::= 
	<I>indexvariable</I> '=' expression &quot;...&quot; expression

normalconnection ::= 
	  { gate { --&gt; | &lt;-- }  gate [ <B>IF</B> expression ]}
	| {gate --&gt; channel<I> </I>--&gt; gate [ <B>IF</B> expression ]}
	| {gate &lt;-- channel &lt;-- gate [ <B>IF</B> expression ]}

channel ::=
	  <I>channeltype
	| </I>[<I> </I><B>DELAY</B><I> </I>expression ] [ <B>ERROR</B> expression ] [ <B>DATARATE</B><I> </I>expression ]<SUP> 
              ******

</SUP>gate ::= 
	[ <I>modulename</I> [vector] . ] <I>gatename</I> [vector]

networkdefinition ::=
	<B>NETWORK</B> <I>networkname</I> : <I>moduletype
</I>	  [ on_block ]
	  [ substparamblock ]
	<B>ENDNETWORK

</B>vector ::=	'[' expression ']'

parexpression ::=
	expression | otherconstvalue

expression	::= 
	  expression + expression
	| expression - expression
	| expression * expression
	| expression / expression
	| expression % expression
	| expression ^ expression
	| expression == expression
	| expression != expression
	| expression &lt; expression
	| expression &lt;= expression
	| expression &gt; expression
	| expression &gt;= expression
	| expression ? expression : expression
	| expression <B>AND</B> expression
	| expression <B>OR</B> expression
	| <B>NOT</B> expression
	| '(' expression ')'
	| <I>functionname</I> '(' [ expression ,,, ] ')' <SUP>***
</SUP>	| - expression
	| numconstvalue
	| inputvalue
	| [ <B>ANCESTOR</B> ] [ <B>REF</B> ] <I>parametername
</I>	| <B>SIZEOF</B><SUP>****</SUP> '(' <I>gatename</I> ')'
	| <B>INDEX</B><SUP>*****

</SUP>numconstvalue ::=
	<I>integerconstant</I> | <I>realconstant</I> | <I>timeconstant

</I>otherconstvalue ::= 
	  '<I>characterconstant'
</I>	| &quot;<I>stringconstant</I>&quot;
	| <B>TRUE</B> 
	| <B>FALSE

</B>inputvalue ::= 
	<B>INPUT</B> '(' default , &quot;<I>prompt-string&quot;</I> ')'

default ::= 
	expression | otherconstvalue
</PRE>
<P>
<SUP>*</SUP> used with distributed execution
<P>
<SUP>**</SUP> used with the statistical synchronisation method
<P>
<SUP>***</SUP> max. three arguments. The function name must be
declared in the C++ sources with the Define_Function macro.
<P>
<SUP>**** </SUP>Size of a vector gate.
<P>
<SUP>***** </SUP>Index in submodule vector.
<P>
<SUP>****** </SUP>Can appear in any order.<BR>
<HR><H1><A NAME="_Toc473901905">Appendix D: Class Library Reference</A>
</H1>
<H2><A NAME="_Toc473901906">What is documented here?</A></H2>
<P>
This is a fairly complete reference of the object library of OMNeT++.
Many details are not covered in this documentation. Only public
member functions of the classes are documented. Some of the classes
which are not visible to the user have been omitted, and of the
classes that are documented, some member functions are very briefly
or not at all described. However, I hope this material can be
used as a handy reference.
<H2><A NAME="_Toc473901907">Constants, types, simple functions</A>
</H2>
<P>
Header file: <TT>defs.h</TT> and <TT>util.h</TT> (<TT>sim</TT>
directory)
<H3><A NAME="_Toc473901908">Constants, types</A></H3>
<PRE>
<FONT>NO(cXX)
NOOBJ</FONT>
</PRE>
<P>
The <TT>NO(<I><FONT>classname</FONT></I>)</TT>
macro can be used for <TT>NULL</TT> pointers of a specific type.
For most classes in the simulation library, there is also a one-word
shorthand for <TT>NO(<I><FONT>classname</FONT></I>)</TT>:
<TT>NOOBJ</TT>, <TT>NOPAR</TT>, <TT>NOMSG</TT> etc.
<PRE>
<FONT>simtime_t
MAXTIME</FONT>
</PRE>
<P>
Type to measure model time (#defined to <TT>double</TT>); its
maximum value.
<PRE>
<FONT>PI</FONT>
</PRE>
<P>
The value of , 6.14159&#133; .
<H3><A NAME="_Toc473901909">Function typedefs</A></H3>
<PRE>
<FONT>typedef int (*CompareFunc)(cObject *, cObject *);</FONT>
</PRE>
<P>
Type of function used in a <TT>cQueue</TT> object to compare items.
See documentation on <TT>cQueue</TT> for more information.
<PRE>
<FONT>typedef bool (*ForeachFunc)(cObject *,bool);</FONT>
</PRE>
<P>
Type of function to be passed to <TT>forEach()</TT>. See <TT>cObject::forEach()</TT>
for more information.
<PRE>
<FONT>typedef double (*MathFunc)(...);
typedef double (*MathFuncNoArg)();
typedef double (*MathFunc1Arg)(double);
typedef double (*MathFunc2Args)(double,double);
typedef double (*MathFunc3Args)(double,double,double);</FONT>
</PRE>
<P>
Used by <TT>cPar</TT> and <TT>sXElem</TT>.
<PRE>
<FONT>typedef void (*VoidDelFunc)(void *);
typedef void *(*VoidDupFunc)(void *);</FONT>
</PRE>
<P>
Memory management functions for void* pointers. Used by <TT>cLinkedList</TT>
and <TT>cPar</TT>.
<H3><A NAME="_Toc473901910">Simulation time conversion functions</A>
</H3>
<PRE>
<FONT>char *simtimeToStr(simtime_t t, char *dest=NULL);</FONT>
</PRE>
<P>
Converts <TT>simtime_t</TT> (a <TT>double</TT>) to textual form
that contains hours, minutes, second, milliseconds and microseconds
like this: <TT>&quot;00h 34m 23s 130ms 230us&quot;</TT>.
<P>
If you do not provide a destination buffer for <TT>simtimeToStr()</TT>,
it will place the result into a static buffer that is overwritten
with each call.
<PRE>
<FONT>simtime_t strToSimtime( char *str );</FONT>
</PRE>
<P>
Converts a textually given simulation time (e.g. <TT>&quot;30s
152ms&quot;</TT>) to <TT>simtime_t</TT>. If the string cannot
be entirely interpreted, <TT>-1</TT> is returned.
<PRE>
<FONT>simtime_t strToSimtime0( char *&amp;str );</FONT>
</PRE>
<P>
Similar to <TT>strToSimtime()</TT>; it can be used if the time
string is a substring in a larger string. It only goes as far
as it can in <TT>str</TT>, then sets the <TT>str</TT> pointer
to the first character that could not be interpreted as part of
the time string, and returns the value. It never returns -1; if
nothing at the beginning of the string looked like simulation
time, it returns 0.
<H3><A NAME="_Toc473901911">Value-added string functions</A></H3>
<P>
These functions replace some of the <TT>&lt;string.h&gt;</TT>
functions. The difference is that they also accept <TT>NULL</TT>
pointers and treat them as pointers to an empty string &quot;&quot;
and use <TT>operator</TT> <TT>new</TT> instead of <TT>malloc()</TT>.
Use these functions instead of original <TT>&lt;string.h&gt;</TT>
versions!
<PRE>
<FONT>char *opp_strdup(char *);</FONT>
</PRE>
<P>
Duplicates the string. If the pointer passed is <TT>NULL</TT>
or points to a null string (<TT>&quot;&quot;</TT>), <TT>NULL</TT>
is returned.
<PRE>
<FONT>char *opp_strcpy(char *,char *);</FONT>
</PRE>
<P>
Same as the standard <TT>strcpy()</TT> function, except that <TT>NULL</TT>
pointers in the second argument are treated like pointers to a
null string (<TT>&quot;&quot;</TT>).
<PRE>
<FONT>int opp_strcmp(char *, char *);</FONT>
</PRE>
<P>
Same as the standard <TT>strcmp()</TT> function, except that <TT>NULL</TT>
pointers are treated like pointers to a null string (<TT>&quot;&quot;</TT>).
<PRE>
<FONT>bool opp_strmatch(char *, char *);</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the two strings are identical up to the
length of the shorter one. <TT>NULL</TT> pointers are treated
like pointers to a null string (<TT>&quot;&quot;</TT>).
<PRE>
<FONT>char *correct(char *);</FONT>
</PRE>
<P>
Returns the pointer passed as argument unchanged, or, if it was
<TT>NULL</TT>, returns a pointer to a null string (<TT>&quot;&quot;</TT>).
<PRE>
<FONT>char *opp_concat(char *s1, char *s2, char *s3=NULL, char *s4=NULL);</FONT>
</PRE>
<P>
Concatenates 2, 3, or 4 strings and places the result into a static
buffer and returns the buffer's pointer. The result's length shouldn't
exceed 255 characters.
<PRE>
<FONT>char *indexedname(char *buf, char *name, int index);</FONT>
</PRE>
<P>
Creates a string like <TT>&quot;component[35]&quot;</TT> into
<TT>buf</TT>, the first argument.
<H3><A NAME="_Toc473901912">Basic random number generation</A>
</H3>
<P>
OMNeT++ has a built-in pseudorandom number generator that gives
long int (32-bit) values.
<P>
Range:  1 ... 2<SUP>31</SUP>-2
<P>
Period length: 2<SUP>31</SUP>-2
<P>
Method: x=(x * 7<SUP>5</SUP>) mod (2<SUP>31</SUP>-1)
<P>
To check if it works correctly: starting with x[0]=1, then x[10000]=1,043,618,065
must hold. Required hardware: exactly 32-bit integer aritmetics.
<P>
Source: Raj Jain: The Art of Computer Systems Performance Analysis
(John Wiley &amp; Sons, 1991), pages 441-444, 455.
<P>
You can use the generator through the following functions:
<PRE>
<FONT>void opp_randomize();</FONT>
</PRE>
<P>
Sets the random number generator's seed to a random value.
<PRE>
<FONT>long randseed(long seed=0);</FONT>
</PRE>
<P>
Sets the random number generator's seed to the given value. Zero
cannot be used as seed.
<PRE>
<FONT>long intrand();</FONT>
</PRE>
<P>
Returns an integer random number in the range [0,<TT>INTRAND_MAX</TT>-1].
<PRE>
<FONT>long intrand(long r);</FONT>
</PRE>
<P>
Returns an integer random number in the range [0, r-1]  (works
if r &lt;&lt; <TT>INTRAND_MAX</TT>)
<PRE>
<FONT>double dblrand();</FONT>
</PRE>
<P>
Returns a random number in the range [0.0, 1.0).
<H3><A NAME="_Toc473901913">Random numbers from different distributions</A>
</H3>
<PRE>
<FONT>double uniform(double a, double b);</FONT>
</PRE>
<P>
Uniform distribution in the range <I>[a,b)</I>.
<PRE>
<FONT>double intuniform(double a, double b);</FONT>
</PRE>
<P>
An integer with uniform distribution in the range <I>[a,b]</I>.
Note that the function can return also <TT>a</TT> or <TT>b</TT>.
<PRE>
<FONT>double exponential(double mean);</FONT>
</PRE>
<P>
Exponential distribution (with parameter <I>1/mean</I>).
<PRE>
<FONT>double normal(double mean, double variance);</FONT>
</PRE>
<P>
Normal distribution with mean and variance given.
<PRE>
<FONT>double truncnormal(double mean, double variance);</FONT>
</PRE>
<P>
Normal distribution truncated to nonnegative values; this is done
by discarding negative values until a nonnegative comes.
<H3><A NAME="_Toc473901914">Miscellaneous</A></H3>
<PRE>
<FONT>Min(a,b);
Max(a,b);</FONT>
</PRE>
<P>
Macros returning the minimum/maximum of two values.
<PRE>
<FONT>bool equal(double a, double b, double limit);</FONT>
</PRE>
<P>
Tests equality of two <TT>double</TT>s, with the given precision.
Returns <TT>true</TT> if <I>fabs(a-b)&lt;limit</I>.
<PRE>
<FONT>bool lowmemory();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if free space on the heap is getting too
low.
<PRE>
<FONT>ASSERT(condition);</FONT>
</PRE>
<P>
Makes sure the condition holds (evaluates to nonzero). Otherwise,
it stops the simulation with a detailed error message. Use <TT>ASSERT()</TT>
to verify your program works correctly and what you assume about
program state is really true.
<H3><A NAME="_Toc473901915">String class</A></H3>
<PRE>
<FONT>class opp_string;</FONT>
</PRE>
<P>
A value-added version of <TT>char*</TT>. Has only one data member,
a <TT>char*</TT> pointer. Added value is automatic allocation/deallocation
(through <TT>opp_strdup</TT>/<TT>delete</TT>). A string object
has its own (<TT>opp_strdup()</TT>'ped) copy of the string.
<P>
Recommended use: as class member, where otherwise the class members
would have to call <TT>opp_strdup()</TT> and delete for the <TT>char*</TT>
member.
<P>
It is intentionally kept very simple. Usable wherever <TT>char*</TT>
is needed. Its only data member is the <TT>char*</TT> pointer
so <TT>string</TT> is even usable with <TT>printf()</TT> which
doesn't do conversion to <TT>char*</TT>. To keep this very valuable
property, <I>don't</I> add any other <I>data</I> members or any
<I>virtual</I> functions.(Virtual functions would add a virtual
table pointer to objects.)
<P>
Example usage:
<PRE>
<FONT>opp_string a, string b(&quot;foo&quot;);
a = &quot;bar&quot;;
a = b;
char *s = a;
printf(&quot;string: `%s'\n&quot;, a );</FONT>
</PRE>
<P>
Member functions:
<PRE>
<FONT>opp_string();
opp_string(char *s);
~opp_string();</FONT>
</PRE>
<P>
String creation, destruction.
<PRE>
<FONT>operator char *();</FONT>
</PRE>
<P>
Returns pointer to the string.
<PRE>
<FONT>char *operator=(char *s);</FONT>
</PRE>
<P>
Deletes the old value and <TT>opp_strdup()</TT>'s the new value
to create the object's own copy.
<H2><A NAME="_Toc473901916">Declaration/registration macros</A>
</H2>
<P>
Header file: <TT>ctypes.h</TT> (<TT>sim</TT> directory)
<PRE>
<FONT>Network(NAME,SETUPFUNCTION)</FONT>
</PRE>
<P>
Network declaration macro, it can be found in code generated by
the NEDC compiler. The use of this macro allows the creation of
a network when only its name is avaliable as a string. (Typically,
the name of the network to be simulated is read from the configuration
file.)
<P>
The macro expands to the definition of a <TT>cNetworkType</TT>
object.
<PRE>
<FONT>Define_Link(NAME,DELAY,ERROR,DATARATE)</FONT>
</PRE>
<P>
Link type definition. The macro expands to the definition of a
<TT>cLinkType</TT> object; the last three arguments are pointers
to functions which dynamically create <TT>cPar</TT> objects an
return their pointers.
<PRE>
<FONT>Define_Function(FUNCTION,ARGCOUNT)</FONT>
</PRE>
<P>
Registers a mathematical function that takes 0, 1, 2 or 3 <TT>double</TT>
arguments and returns a <TT>double</TT>. The use of this macro
allows the function to be used in expressions inside NED network
descriptions. 
<P>
The commonly used <TT>&lt;math.h&gt;</TT> functions have <TT>Define_Function()</TT>
lines in the OMNeT++ simulation kernel sources.
<PRE>
<FONT>Register_Class(CLASSNAME)</FONT>
</PRE>
<P>
Registers a class for use with the createOne() function:
<PRE>
<FONT>cObject *createOne(char *classname);</FONT>
</PRE>
<P>
This function creates an object of the type given by the string
argument. createOne() is used by the distributed execution part
of OMNeT++, for  unpacking objects from a buffer that was sent
over from another machine/processor.
<P>
Each class that should be able to travel between machines/processors
should be registered with the Register_Class macro in one of the
C++ source files.
<P>
 (The Register_Class macro expands to the definition of a <TT>cClassRegister</TT>
object.) 
<PRE>
<FONT>Interface(CLASSNAME)
  Gate(NAME,TYPE)
  Parameter(NAME,TYPES)
  Machine(NAME)
End</FONT>
</PRE>
<P>
Simple module declaration macro. Gate types can be 'Input' or
'Output', parameter types can be 'Anytype' or 'Numeric'.
<PRE>
<FONT>Module_Class_Members(CLASSNAME,BASECLASS,STACKSIZE)</FONT>
</PRE>
<P>
This macro facilitates the declaration of a simple module type's
class. The macro is used like this:
<PRE>
<FONT>class CLASSNAME : public cSimpleModule
{
   Module_Class_Members(CLASSNAME,cSimpleModule,8192)
   virtual void activity();
};</FONT>
</PRE>
<P>
The macro expands to the definition of member functions which
the user does not need to worry about: constructors, destructor,
<TT>className()</TT> function etc. The user can derive the new
class from an existing simple module class (not only <TT>cSimpleModule</TT>),
add new data members and add/redefine member functions as needed.
<PRE>
<FONT>Define_Module(CLASSNAME)
Define_Module_Like(CLASSNAME, INTERFACENAME)</FONT>
</PRE>
<P>
The use of this macro allows the creation of a module (simple
or compound) when only its name is avaliable as a string. The
macro expands to the definition a <TT>cModuleType</TT> object
(and some functions it needs).
<P>
The NEDC compiler generates <TT>Define_Module()</TT> lines for
all compound modules. However, it is the user's responsibility
to put <TT>Define_Module()</TT> lines for all simple module types
into one of the C++ sources.
<H2><A NAME="_Toc473901917">Common properties for all classes:
<TT><FONT SIZE=5>cObject</FONT></TT></A></H2>
<P>
Header file: <TT>cobject.h</TT> (<TT>sim</TT> directory)
<P>
<TT>cObject</TT> is the base class for almost all classes in the
OMNeT++ library. <TT>cObject</TT> provides a name member (a dynamically
allocated string) and a number of virtual functions. These functions:
<UL>
<LI> either provide a default behaviour (mostly good for all derived
classes);
<LI> or they are expected to be redefined in all derived classes.
</UL>
<P>
Read this section carefully if you plan to create new classes.
<H3><A NAME="_Toc473901918">class <TT><FONT SIZE=4>cObject</FONT></TT></A>
</H3>
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cObject(cObject&amp; obj);</FONT>
</PRE>
<P>
Copy constructor. In derived classes, it is usually implemented
as <TT>{operator=(obj);}</TT>.
<PRE>
<FONT>cObject(char *s, cObject *h);</FONT>
</PRE>
<P>
Creates a <TT>cObject</TT> with the given name. The owner will
be the <TT>h</TT> object (if the pointer is not <TT>NULL</TT>),
that is, the constructor contains a <TT>setOwner( h )</TT> call.
<PRE>
<FONT>virtual ~cObject();</FONT>
</PRE>
<P>
Virtual destructor. Deletes the name and notifies the user interface
that the object has been destructed.
<PRE>
<FONT>virtual cObject *dup();</FONT>
</PRE>
<P>
Duplicates the object and returns a pointer to the new one. In
derived classes, it is usually implemented as <TT>{return new
cObject(*this);}</TT>.
<PRE>
<FONT>cObject&amp; operator=(cObject&amp; o);</FONT>
</PRE>
<P>
The assignment operator. Most derived classes contain a <TT>cSomeClass&amp;</TT><I>
</I><TT>cSomeClass:: operator=(cSomeClass&amp;)</TT> function.
The assignment operators do not copy the object name. If you want
to do so, you can copy it be hand: <TT>setName(o.name());</TT>
<PRE>
<FONT>void *operator new(size_t m);</FONT>
</PRE>
<P>
<TT>cObject</TT>'s <TT>operator new</TT> does more than the global
<TT>new()</TT><I>.</I> It cooperates with <TT>cObject</TT>'s constructor
to determine the storage class of the object (static, auto or
dynamic).
<PRE>
<FONT>char storage();</FONT>
</PRE>
<P>
Returns the storage class of the object. The return value is one
of the characters <TT>S/A/D</TT> which stand for static, auto
and dynamic, respectively.
<PRE>
<FONT>void destruct();</FONT>
</PRE>
<P>
Direct call to the virtual destructor.
<P>
<B>Name member</B>
<PRE>
<FONT>virtual void setName(char *s);</FONT>
</PRE>
<P>
Sets object's name. The object creates its own copy of the string.
<TT>NULL</TT> pointer may also be passed.
<PRE>
<FONT>char *name();</FONT>
</PRE>
<P>
Returns pointer to the object's name. The function never returns
<TT>NULL</TT>; rather, it returns ptr to &quot;&quot;.
<PRE>
<FONT>virtual char *fullName();</FONT>
</PRE>
<P>
To be redefined in descendants. E.g., see <TT>cModule::fullName()</TT>.
<PRE>
<FONT>virtual char *fullPath(int l);</FONT>
</PRE>
<P>
Returns the name of the object with its place in the object ownership
hierarchy (<TT>&quot;net.comp.modem[5].baud-rate&quot;</TT>).
See also <TT>cModule::fullPath()</TT>.
<PRE>
<FONT>bool isName(char *s);</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the object's name is identical with the
string passed.
<P>
<B>User interface information functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns a pointer to the class name string, <TT>&quot;cObject&quot;</TT>.
In derived classes, usual implementation is <TT>{return &quot;classname&quot;;}</TT>.
<PRE>
<FONT>virtual void info(char *buf);</FONT>
</PRE>
<P>
Copies a short description of the object into <TT>buf</TT>. This
function is used by the graphical user interface (TkEnv). See
also <I>Functions supporting snapshots</I>.
<PRE>
<FONT>virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Returns the name of the class which can create inspector windows
for objects of this class (e.g. in Tkenv).
<P>
<B>Ownership control</B>
<PRE>
<FONT>virtual cObject *defaultOwner();</FONT>
</PRE>
<P>
This function should return a pointer to the default owner of
the object. The function is used by the <TT>drop()</TT><I> </I>member
function, redefined in <TT>cObject</TT>-descendant container classes.
<PRE>
<FONT>cObject *owner();</FONT>
</PRE>
<P>
Returns pointer to the owner of the object.
<PRE>
<FONT>void setOwner(cObject *newowner);</FONT>
</PRE>
<P>
Sets the owner pointer of the object. See documentation of <TT>cHead</TT>
for more information.
<P>
<B>Operations to be used by container classes derived from </B><TT><B><FONT>cObject</FONT></B></TT>
<PRE>
<FONT>void takeOwnership(bool tk);
bool takeOwnership();</FONT>
</PRE>
<P>
Sets/returns the flag which determines whether the container object
should automatically take ownership of the objects that are inserted
into it.
<PRE>
<FONT>void take(cObject *obj);</FONT>
</PRE>
<P>
The function called by the container object when it takes ownership
of the <TT>obj</TT> object that is inserted into it. Implementation:
<TT>obj-&gt;setOwner( this )</TT>.
<PRE>
<FONT>void drop(cObject *obj);</FONT>
</PRE>
<P>
The function called by the container object when <TT>obj</TT>
is removed from the container -- releases the ownership of the
object and hands it over to its default owner. Implementation:
<BR>
<TT>obj-&gt;setOwner( obj-&gt;defaultOwner() );</TT>
<PRE>
<FONT>void free(cObject *obj);</FONT>
</PRE>
<P>
The function is called when the container object has to delete
the contained object <TT>obj</TT>. It the object was dynamically
allocated (by <TT>new</TT>), it is deleted, otherwise (e.g., if
it is a global or a local variable) it is just removed from the
ownership hierarchy. Implementation:<BR>
<TT>{if(obj-&gt;storage()=='D') delete obj; else obj-&gt;setOwner(NULL);}</TT>
<P>
<B>Load/store operations</B>
<P>
The load/store operations are used when running OMNeT++ on multiple
processors. They are used to exchange data between two instances
of OMNeT++ running in different processes (and possibly different
processors), using the statistical synchronisation method. Currently,
this is implemented over PVM (Parallel Virtual Machine version
3).
<PRE>
<FONT>virtual int netPack(char * type=NULL);
virtual int netUnpack();</FONT>
</PRE>
<P>
These functions are expected to be redefined in all derived objects.
In OMNeT++'s PVM interface, they call <TT>pvm_pkint()</TT>, <TT>pvm_upkint()</TT>
etc. functions.
<P>
<B>Functions supporting snapshots</B>
<PRE>
<FONT>virtual void writeTo(ostream&amp; os);</FONT>
</PRE>
<P>
This function is called internally by <TT>cSimpleModule::snapshot()</TT>.
It writes out info about the object into the stream. Relies on
<TT>writeContents()</TT>. <TT>writeTo()</TT> does not need to
be redefined.
<PRE>
<FONT>virtual void writeContents(ostream&amp; os);</FONT>
</PRE>
<P>
This function is called by internally <TT>writeTo()</TT>. It is
expected to write textual information about the object and other
objects it contains to the stream. The default version (<TT>cObject::writeContents()</TT>)
uses forEach to call <TT>info()</TT> for contained objects. Redefine
as needed.
<P>
<B>Other functions</B>
<PRE>
<FONT>static int cmpbyname(cObject *one,cObject *other);</FONT>
</PRE>
<P>
This function compares to objects by name. It can be used in a
priority queue (class <TT>cQueue</TT>) as a sorting criterion.
<P>
<B>The </B><TT><B><FONT>forEach()</FONT></B></TT>
mechanism
<PRE>
<FONT>virtual void forEach(ForeachFunc f);</FONT>
</PRE>
<P>
Makes sense with container objects derived from <TT>cObject</TT>.
Calls the <I>f</I> function recursively for each object contained
in this object.
<P>
<U><B>The </B></U><TT><U><B><FONT>forEach()</FONT></B></U></TT><U><B>
mechanism</B></U>
<P>
The <TT>forEach()</TT> mechanism implemented in OMNeT++ is very
special and slightly odd. The passed function is called for each
object twice: once on entering and once on leaving the object.
In addition, after the first ('entering') call to the function,
it signals with its return value whether it wants to go deeper
in the contained objects or not.
<P>
Functions passed to <TT>forEach()</TT> will use static variables
to store other necessary information. (Yes, this limits their
recursive use :-( ).
<P>
<TT>forEach()</TT> takes a function <TT>do_fn</TT> (of <TT>ForeachFunc</TT>
type) with 2 arguments: a <TT>cObject*</TT> and a <TT>bool</TT>.
First, <TT>forEach()</TT> should call <TT>do_fn(this,true)</TT>
to inform the function about entering the object. Then, if this
call returned <TT>true</TT>, it must call <TT>forEach(do_fn)</TT>
for every contained object. Finally, it must call <TT>do_fn(this,false)</TT>
to let <TT>do_fn</TT> know that there's no more contained object.
<P>
Functions using <TT>forEach()</TT> work in the following way:
they call <TT>do_fn(NULL, false, &lt;additional args&gt;)</TT>
to initialize the static variables inside the function with the
additional args passed. Then they call <TT>forEach(do_fn)</TT>
for the given object. Finally, read the results by calling <TT>do_fn(NULL,
false, &lt;additional args&gt;)</TT>, where additional args can
be pointers where the result should be stored. <TT>ForeachFuncs</TT>
mustn't call themselves recursively!
<P>
<I>(I know this all is kind of weird, but I wrote it a long ago.
Changing it now would take quite some work, and after all, it
works..)</I>
<P>
<B>Member functions based on </B><TT><B><FONT>forEach()</FONT></B></TT>
<PRE>
<FONT>cObject *findObject(char *s, bool deep=true);</FONT>
</PRE>
<P>
Finds the object with the given name in a container object and
returns a pointer to it or <TT>NULL</TT> if the object hasn't
been found. If <TT>deep</TT> is <TT>false</TT>, only objects directly
contained will be searched, otherwise the function searches the
whole subtree for the object.
<PRE>
<FONT>bool ishe_there(cObject *obj);</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the given object <TT>obj</TT> is contained
in this object's subtree.
<H2><A NAME="_Toc473901919">Module classes: <TT><FONT SIZE=5>cModule</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cCompoundModule</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cSimpleModule</FONT></TT></A></H2>
<P>
Header file: <TT>cmodule.h</TT> (<TT>sim</TT> directory)
<P>
There are three module classes. <TT>cModule</TT> is the common
base class for all module classes. It contains data and functions
to manage the module hierarchy in a network and handles parameters
and gates. <TT>cModule</TT> is used only as a base class: no instance
of <TT>cModule</TT> is ever created. <TT>cCompoundModule</TT>
is derived from <TT>cModule</TT> and represents compound modules
in networks. cCompoundmod has no added functionality over <TT>cModule</TT>.
<TT>cSimpleModule</TT> is also a descendant of <TT>cModule</TT>
and is a base class for all simple module classes.
<P>
<CENTER><IMG SRC="img00020.gif"></CENTER>
<H3><A NAME="_Toc473901920">class <TT><FONT SIZE=4>cModule</FONT></TT></A>
</H3>
<P>
<TT>cModule</TT> contains data and functions to manage the module
hierarchy in a network. It also stores and controls module parameters
and gates.
<P>
<B>Construction, destruction, copying</B>
<P>
The user normally doesn't create new modules directly, so these
member functions are not documented here.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className()</FONT>
</PRE>
<P>
Returns pointer to the class name string, <TT>&quot;cModule&quot;</TT>.
<PRE>
<FONT>virtual char *fullName();</FONT>
</PRE>
<P>
Returns full name of the module in a static buffer, in the form
<TT>&quot;name&quot;</TT> or <TT>&quot;name[index]&quot;</TT>.
<PRE>
<FONT>virtual char *fullPath(int l);</FONT>
</PRE>
<P>
Returns full path from the system module to the module in a static
buffer, in the form <TT>&quot;system_module.submodule[1].subsubmodule.name[index]&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<P>
<B>Member functions</B>
<PRE>
<FONT>bool isSimple() = 0;</FONT>
</PRE>
<P>
Pure virtual function. It is redefined in <TT>cSimpleModule</TT>
to return <TT>true</TT> and in <TT>cCompoundModule</TT> to return
<TT>false</TT>.
<PRE>
<FONT>bool isOnLocalMachine();</FONT>
</PRE>
<P>
Used with parallel execution: determines if the module is on the
local machine. See the user manual for more info.
<PRE>
<FONT>int id();</FONT>
</PRE>
<P>
Returns the index of the module in the module vector (<TT>cSimulation</TT>
simulation).
<PRE>
<FONT>cModule* parentModule();</FONT>
</PRE>
<P>
Returns reference to the module's parent.
<PRE>
<FONT>int index();</FONT>
</PRE>
<P>
Returns the index of the module if it is multiple, otherwise 0.
<PRE>
<FONT>int size();</FONT>
</PRE>
<P>
Returns the size of the multiple module, or 1.
<P>
<B>Module gates</B>
<PRE>
<FONT>int gates();</FONT>
</PRE>
<P>
Returns total number of module gates.
<PRE>
<FONT>cGate&amp; gate(int g);</FONT>
</PRE>
<P>
Returns reference to the gate identified with its index g. Returns
<TT>*NULL</TT> if the gate doesn't exist.
<PRE>
<FONT>cGate&amp; gate(char *s,int sn=0);</FONT>
</PRE>
<P>
Returns reference to the gate specified by name and index (if
multiple gate). Returns <TT>*NULL</TT> if the gate doesn't exist.
<PRE>
<FONT>int findGate(char *s, int sn=0);</FONT>
</PRE>
<P>
Returns index of the gate specified by name and index (if multiple
gate). Returns -1 if the gate doesn't exist.
<P>
<B>Module parameters</B>
<PRE>
<FONT>int params();</FONT>
</PRE>
<P>
Returns total number of the module's parameters.
<PRE>
<FONT>cPar&amp; par(int p);</FONT>
</PRE>
<P>
Returns reference to the module parameter identified with its
index <TT>p</TT>. Returns <TT>*NULL</TT> if the object doesn't
exist.
<PRE>
<FONT>cPar&amp; par(char *name);</FONT>
</PRE>
<P>
Returns reference to the module parameter specified with its name.
Returns <TT>*NULL</TT> if the object doesn't exist.
<PRE>
<FONT>int findPar(char *s);</FONT>
</PRE>
<P>
Returns index of the module parameter specified with its name.
Returns -1 if the object doesn't exist.
<PRE>
<FONT>cPar&amp; ancestorPar(char *name);</FONT>
</PRE>
<P>
Searches for the parameter in the parent modules, up to the system
module. It the parameter is not found, an error message is generated.
<P>
<B>Warning messages</B>
<PRE>
<FONT>bool warnings();</FONT>
</PRE>
<P>
Warning messages can be enabled/disabled individually for each
module. This function returns the warning status for this module:
<TT>true</TT>=enabled, <TT>false</TT>=disabled.
<PRE>
<FONT>void setWarnings(bool wr);</FONT>
</PRE>
<P>
Enables or disables warnings for this module: <TT>true</TT>=enable,
<TT>false</TT>=disable.
<P>
<B>Other functions</B>
<PRE>
<FONT>bool checkInternalConnections();</FONT>
</PRE>
<P>
For compound modules, it checks if all gates are connected inside
the module (it returns <TT>true</TT> if they are OK); for simple
modules, it returns <TT>true</TT>.
<PRE>
<FONT>virtual void scheduleStart(simtime_t t) = 0;</FONT>
</PRE>
<P>
Pure virtual function; it is redefined in both <TT>cCompoundModule</TT>
and <TT>cSimpleModule</TT>. It creates starting message for dynamically
created module (or recursively for its submodules). See the user
manual for explanation how to use dynamically created modules.
<PRE>
<FONT>virtual void deleteModule() = 0;</FONT>
</PRE>
<P>
Pure virtual function; it is redefined in both <TT>cCompoundModule</TT>
and <TT>cSimpleModule</TT>. Deletes a dyamically created module
and recursively all its submodules.
<H3><A NAME="_Toc473901921">class <TT><FONT SIZE=4>cCompoundModule</FONT></TT></A>
</H3>
<P>
<B>Redefined member functions</B>
<PRE>
<FONT>bool isSimple();</FONT>
</PRE>
<P>
Returns <TT>false</TT>.
<PRE>
<FONT>virtual void scheduleStart(simtime_t t);</FONT>
</PRE>
<P>
Calls <TT>scheduleStart()</TT> recursively for all its (immediate)
submodules. This is used with dynamically created modules.
<PRE>
<FONT>virtual void deleteModule();</FONT>
</PRE>
<P>
Calls <TT>deleteModule()</TT> for all its submodules and then
deletes itself.
<H3><A NAME="_Toc473901922">class <TT><FONT SIZE=4>cSimpleModule</FONT></TT></A>
</H3>
<P>
<TT>cSimpleModule</TT> is derived from <TT>cModule</TT> and is
a base class for all simple module classes. Most important, <TT>cSimpleModule</TT>
has a virtual member function called <TT>activity()</TT> that
is to be redefined in descendants -- this is the module function.
All basic functions associated with the simulation such as sending
and receiving messages are implemented as cSimpleMod's member
functions. The module functions are run as coroutines during simulation.
Coroutines are brought to <TT>cSimpleModule</TT> from another
base class called <TT>cCoroutine</TT>.
<P>
<B>Construction, destruction, copying</B>
<P>
The user normally doesn't create new modules directly, so these
member functions are not documented here.
<P>
<B>Redefined member functions</B>
<PRE>
<FONT>virtual char *className()</FONT>
</PRE>
<P>
Returns pointer to the class name string, <TT>&quot;cSimpleModule&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<PRE>
<FONT>bool isSimple();</FONT>
</PRE>
<P>
Returns <TT>true</TT>.
<PRE>
<FONT>virtual void scheduleStart(simtime_t t);</FONT>
</PRE>
<P>
Creates a starting message for the module.
<PRE>
<FONT>virtual void deleteModule();</FONT>
</PRE>
<P>
Deletes a dynamically created module.
<P>
<B>Public data members</B>
<PRE>
<FONT>cQueue putAsideQueue;</FONT>
</PRE>
<P>
Represents the put-aside queue (where the simulator puts unexpected
messages that arrive to the module). The putaside-queue is configured
to sort the messages by arrival time and priority, like the event
queue does. You can freely use the contents of the putaside-queue;
the simulator kernel does not do anything with it, it only inserts
messages. See class <TT>cQueue</TT> and the functions <TT>cSimpleModule::wait()</TT>,
<TT>cSimpleModule::receiveNewOn()</TT>, <TT>cSimpleModule::receive()</TT>
for more information.
<PRE>
<FONT>cHead locals;</FONT>
</PRE>
<P>
List of local variables of module function. You do not normally
need to care about this object.
<PRE>
<FONT>cHead members;</FONT>
</PRE>
<P>
Data members of derived classes. If you derive a class from <TT>cSimpleModule</TT>
and add object members, you should call <TT>object-&gt;setOwner(
members )</TT> for each <TT>object</TT> you add.
<P>
<B>The module funcion</B>
<PRE>
<FONT>virtual void activity();</FONT>
</PRE>
<P>
Contains the module function. It is empty in <TT>cSimpleModule</TT>
and should be redefined in descendants.
<P>
<B>Getting the current simulation time</B>
<PRE>
<FONT>simtime_t simTime();</FONT>
</PRE>
<P>
Returns the current simulation time (that is, the arrival time
of the last message returned by a <TT>receiveNew()</TT> call).
<P>
<B>Sending messages</B>
<PRE>
<FONT>int send(cMessage *msg, int g);</FONT>
</PRE>
<P>
Sends a message through the gate given with its index.
<PRE>
<FONT>int send(cMessage *msg, char *s, int sn=0);</FONT>
</PRE>
<P>
Sends a message through the gate given with its name and index
(if multiple gate).
<PRE>
<FONT>int sendDelayed(cMessage *msg, double delay, int g);</FONT>
</PRE>
<P>
Sends a message through the gate given with its index as if it
was sent delay seconds later.
<PRE>
<FONT>int sendDelayed(cMessage *msg, double delay, char *s, int sn=0);</FONT>
</PRE>
<P>
Sends a message through the gate given with its name and index
(if multiple gate) as if it was sent delay seconds later.
<PRE>
<FONT>int scheduleAt(simtime_t t, cMessage&amp; msg);</FONT>
</PRE>
<P>
Inserts the given message into the Future Event Set and schedules
it to be returned at time t. This function can be used to implement
timers.
<PRE>
<FONT>cMessage *cancelEvent(cMessage *msg);</FONT>
</PRE>
<P>
Removes the given message from the message queue. The message
needs to have been sent using the <TT>scheduleAt()</TT> function.
This function can be used to cancel a timer implemented with <TT>scheduleAt()</TT>.
<P>
<B>Receiving new messages</B>
<PRE>
<FONT>cMessage *receiveNew(simtime_t t=MAXTIME);</FONT>
</PRE>
<P>
Removes the next message from the event queue and returns a pointer
to it. If there is no message in the event queue, the function
waits with t timeout until a message will be available. If the
timeout expires and there is still no message in the queue, the
function returns <TT>NULL</TT>.
<PRE>
<FONT>cMessage *receiveNewOn(char *s, int sn=0, simtime_t t=MAXTIME);</FONT>
</PRE>
<P>
The same as <TT>receiveNew()</TT>, except that it returns the
next message that arrives on the gate specified with its name
and index. All messages received meanwhile are inserted into the
put-aside queue. If the timeout expires and there is still no
such message in the queue, the function returns <TT>NULL</TT>.
<P>
In order to process messages that may have been put in the put-aside
queue, the user is expected to call <TT>receive()</TT> or <TT>receiveOn()</TT>,
or to examine the put-aside queue directly sometime.
<PRE>
<FONT>cMessage *receiveNewOn(int g, simtime_t t=MAXTIME);</FONT>
</PRE>
<P>
Same as the previous function except that the gate must be specified
with its index in the gate array. Using this function instead
the previous one may speed up the simulation if the function is
called frequently.
<PRE>
<FONT>bool isThereMessage();</FONT>
</PRE>
<P>
Tells if the next message in the event queue is for the same module
and has the same arrival time. (Returns <TT>true</TT> only if
two or more messages arrived to the module at the same time.)
<P>
<B>Getting messages from the put-aside queue or the event queue</B>
<PRE>
<FONT>cMessage *receive(simtime_t t=MAXTIME);</FONT>
</PRE>
<P>
Returns the first message from the put-aside queue or, if it is
empty, calls <TT>receiveNew()</TT> to return a message from the
event queue with the given timeout. Note that the arrival time
of the message returned by <TT>receive()</TT> can be earlier than
the current simulation time.
<PRE>
<FONT>cMessage *receiveOn(char *s, int sn=0, simtime_t t=MAXTIME);</FONT>
</PRE>
<P>
Scans the put-aside queue for the first message that has arrived
on the gate specified with its name and index. If there is no
such message in the put-aside queue, calls <TT>receiveNew()</TT>
to return a message from the event queue with the given timeout.
Note that the arrival time of the message returned by <TT>receive()</TT>
can be earlier than the current simulation time.
<PRE>
<FONT>cMessage *receiveOn(int g, simtime_t t=MAXTIME);</FONT>
</PRE>
<P>
Same as the previous function except that the gate must be specified
with its index in the gate array. Using this function instead
the previous one may speed up the simulation if the function is
called frequently.
<P>
<B>Waiting</B>
<PRE>
<FONT>void wait(simtime_t time);</FONT>
</PRE>
<P>
Wait for given interval. The messages received meanwhile are inserted
into the put-aside queue.
<P>
<B>Stopping the module or the simulation</B>
<PRE>
<FONT>void end();</FONT>
</PRE>
<P>
Ends the run of the simple module. The simulation is not stopped
(unless this is the last running module.)
<PRE>
<FONT>void endSimulation();</FONT>
</PRE>
<P>
Causes the whole simulation to stop.
<P>
<B>Help for tracing and debugging</B>
<PRE>
<FONT>bool snapshot(cObject *obj = &amp;simulation, char *label = NULL);</FONT>
</PRE>
<P>
To be called from module functions. Outputs textual information
about all objects of the simulation (including the objects created
in module functions by the user!) into the snapshot file. The
output is detailed enough to be used for debugging the simulation:
by regularly calling <TT>snapshot()</TT>, one can trace how the
values of variables, objects changed over the simulation. The
arguments: <TT>label</TT> is a string that will appear in the
output file; <TT>obj</TT> is the object whose inside is of interest.
By default, the whole simulation (all modules etc) will be written
out.
<P>
Tvenv and Tkenv also supports making snapshots manually, from
menu.
<P>
See also class <TT>cWatch</TT> and the <TT>WATCH()</TT> macro.
<PRE>
<FONT>void setPhase(char *s);</FONT>
</PRE>
<P>
Sets the phase string (the function creates a copy of the string).
The string can be displayed in user interfaces which support tracing
/ debugging (currently only Tvenv, the Turbo Vision environment
for DOS) and the string can contain information that tells the
user what the module is currently doing.
<PRE>
<FONT>char *phase();</FONT>
</PRE>
<P>
Returns pointer to the current phase string.
<PRE>
<FONT>void pause(char *s);</FONT>
</PRE>
<P>
If the user interface supports step-by-step execution (currently
only Tvenv does so), one can stop execution at each <TT>receive()</TT>
call of the module function and examine the objects, variables,
etc. If the state of simulation between <TT>receive()</TT> calls
is also of interest, one can use <TT>pause()</TT> calls. The string
argument (if given) sets the phase string, so <TT>pause(&quot;here&quot;)</TT>
is the same as <TT>setPhase(&quot;here&quot;); pause()</TT>.
<PRE>
<FONT>void breakpoint(char *label);</FONT>
</PRE>
<P>
Specifies a breakpoint. During simulation, if execution gets to
a <TT>breakpoint()</TT> call (and breakpoints are active etc.),
the simulation will be stopped, if the user interface can handle
breakpoints. Currently, only Tvenv supports the use of breakpoints.
<P>
<B>Non-typed heap allocation/deallocation for module functions</B>
<PRE>
<FONT>void *memAlloc(size_t m);</FONT>
</PRE>
<P>
Dynamic memory allocation. This function should be used instead
of the global <TT>::malloc()</TT> from inside the module function
(<TT>activity()</TT>), if deallocation by the simple module constructor
is not provided. 
<P>
Dynamic allocations are discouraged in general unless you put
the pointer into the class declaration of the simple module class
and provide a proper destructor. Or, you can use container classes
(<TT>cArray</TT>, <TT>cQueue</TT>)!
<PRE>
<FONT>void memFree(void *&amp;p);</FONT>
</PRE>
<P>
Frees a memory block reserved with the <TT>malloc()</TT> described
above and <TT>NULL</TT>s the pointer.
<H2><A NAME="_Toc473901923">Message classes: <TT><FONT SIZE=5>cMessage
</FONT></TT><FONT SIZE=5>and</FONT><TT><FONT SIZE=5> cPacket</FONT></TT></A>
</H2>
<P>
Header file: <TT>cmessage.h, cpacket.h</TT> (sim directory)
<P>
<TT>cMessage</TT> is the message class in OMNeT++. <TT>cMessage</TT>
can be assigned a name (a property inherited from <TT>cObject</TT>)
and it has other attributes, including message kind, length, priority,
error flag and time stamp.
<P>
After being sent through a channel, <TT>cMessage</TT> also remembers
the sending and delivery times and its source module. <TT>cMessage</TT>
holds a <TT>cArray</TT> which means that a <TT>cMessage</TT> can
be attached any number of objects. These objects will typically
be of <TT>cPar</TT> type, but other types are also possible.
<H3><A NAME="_Toc473901924">Message base class: <TT><FONT SIZE=4>cMessage</FONT></TT></A>
</H3>
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cMessage(cMessage&amp; msg);</FONT>
</PRE>
<P>
Copy constructor, creates an exact copy of the argument <TT>msg</TT>.
<PRE>
<FONT>cMessage(char *name=NULL, int k=0, int len=1, int pri=0, bool err=false);</FONT>
</PRE>
<P>
Constructor. It accepts name, message kind, length, priority and
error flag as arguments.
<PRE>
<FONT>virtual cObject *dup()
cMessage&amp; operator=(cMessage&amp; msg);</FONT>
</PRE>
<P>
Duplication and the assignment operator work all right with <TT>cMessage</TT>.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className()</FONT>
</PRE>
<P>
Returns pointer to the class name string, <TT>&quot;cMessage&quot;</TT>.
<P>
<B>Message properties</B>
<PRE>
<FONT>void setKind(int k);</FONT>
</PRE>
<P>
Sets message kind.  The message kind member is not used by OMNeT++,
it can be used freely by the user. 
<PRE>
<FONT>void setPriority(int p);</FONT>
</PRE>
<P>
Sets message priority.  The priority member is used when the simulator
inserts messages in the message queue (FES) to order messages
with identical arrival time values.
<PRE>
<FONT>void setLength(long l);</FONT>
</PRE>
<P>
Sets message length. When the message is transmitted through a
channel, its error flag will be set with a probability depending
on the length of the message and the channel's bit error rate.
<PRE>
<FONT>void setError(bool err);</FONT>
</PRE>
<P>
Directly sets the message's error flag.
<PRE>
<FONT>void setTimestamp();</FONT>
</PRE>
<P>
Sets the message's time stamp to the current simulation time.
<PRE>
<FONT>void setTimestamp(simtime_t stamp);</FONT>
</PRE>
<P>
Directly sets the message's time stamp.
<PRE>
<FONT>int kind();</FONT>
</PRE>
<P>
Returns message kind. The message kind member is not used by OMNeT++,
it can be used freely by the user.
<PRE>
<FONT>int priority();</FONT>
</PRE>
<P>
Returns message priority.  The priority member is not used by
OMNeT++, it can be used freely by the user. 
<PRE>
<FONT>long length();</FONT>
</PRE>
<P>
Returns message length.
<PRE>
<FONT>bool hasBitError();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if error flag is set, <TT>false</TT> otherwise.
<PRE>
<FONT>simtime_t timestamp();</FONT>
</PRE>
<P>
Returns the message's time stamp.
<P>
<B>Message encapsulation</B>
<PRE>
<FONT>void encapsulate(cMessage *msg);</FONT>
</PRE>
<P>
Encapsulates <TT>msg</TT> in the message. <TT>msg-&gt;length()</TT>
will be added to the length of the message.
<PRE>
<FONT>cMessage *decapsulate();</FONT>
</PRE>
<P>
Decapsulates a message from the message object. The length of
the message will be decreased accordingly, exept if it was zero.
If the length would become negative, an error occurs.
<PRE>
<FONT>cMessage *encapsulatedMsg();</FONT>
</PRE>
<P>
Returns a pointer to the encapsulated message, or <TT>NULL</TT>.
<P>
<B>Info about sending/scheduling</B>
<PRE>
<FONT>int senderModuleId();</FONT>
</PRE>
<P>
Returns sender module's index in the module vector or -1 if the
message hasn't been sent/scheduled yet.
<PRE>
<FONT>int senderGateId();</FONT>
</PRE>
<P>
Returns index of gate sent through in the sender module or -1
if the message hasn't been sent/scheduled yet.
<PRE>
<FONT>int arrivalModuleId();</FONT>
</PRE>
<P>
Returns receiver module's index in the module vector or -1 if
the message hasn't been sent/scheduled yet.
<PRE>
<FONT>int arrivalGateId();</FONT>
</PRE>
<P>
Returns index of gate the message arrived on in the sender module
or -1 if the message hasn't sent/scheduled yet.
<PRE>
<FONT>cGate *senderGate()
cGate *arrivalGate()</FONT>
</PRE>
<P>
Returns pointers to the gate from which the message was sent and
on which gate it arrived. A <TT>NULL</TT> pointer is returned
for new (unsent) messages and messages sent via <TT>scheduleAt()</TT>.
<PRE>
<FONT>simtime_t creationTime();</FONT>
</PRE>
<P>
Returns time when the message was created.
<PRE>
<FONT>simtime_t sendingTime();</FONT>
</PRE>
<P>
Returns time when the message was sent/scheduled or 0 if the message
hasn't been sent yet.
<PRE>
<FONT>simtime_t arrivalTime();</FONT>
</PRE>
<P>
Returns time when the message has arrived or 0 if the message
hasn't been sent/scheduled yet.
<PRE>
<FONT>bool arrivedOn(int g);</FONT>
</PRE>
<P>
Return <TT>true</TT> if the message has arrived through gate <TT>g</TT>.
<PRE>
<FONT>bool arrivedOn(char *s, int g=0);</FONT>
</PRE>
<P>
Return <TT>true</TT> if the message has arrived through the gate
given with its name and index (if multiple gate).
<P>
<B>Parameters and attached objects</B>
<PRE>
<FONT>cArray&amp; parList();</FONT>
</PRE>
<P>
Returns the <TT>cArray</TT> member of the message which holds
the parameters and other attached objects. Parameters can be inserted,
retreived, looked up or deleted through <TT>cArray</TT>'s member
functions.
<PRE>
<FONT>cPar&amp; addPar(cPar&amp; p);
cPar&amp; addPar(char *name);</FONT>
</PRE>
<P>
Convenience functions, add a parameter to the message's parameter
list.
<PRE>
<FONT>cPar&amp; par(int index);</FONT>
</PRE>
<P>
Convenience function, returns the <TT>index</TT>th object in the
message's parameter list, converting it to a <TT>cPar</TT>.
<PRE>
<FONT>cPar&amp; par(char *name);</FONT>
</PRE>
<P>
Convenience function, returns the object with the given name in
the message's parameter list, converting it to a <TT>cPar</TT>.
<PRE>
<FONT>int hasPar(char *name);</FONT>
</PRE>
<P>
Convenience function, returns true if there's an object with the
given name in the message's parameter list..
<PRE>
<FONT>int findPar(char *name);</FONT>
</PRE>
<P>
Convenience function, returns the index of the parameter with
the given name in the message's parameter list, or -1 if it could
not be found.
<P>
<B>Miscellaneous functions</B>
<PRE>
<FONT>static int cmpbydelivtime(cObject *one, cObject *other);</FONT>
</PRE>
<P>
Static function that compares two messages by their delivery times,
then by their priorities.
<PRE>
<FONT>static int cmpbypriority(cObject *one, cObject *other);</FONT>
</PRE>
<P>
Static function that compares two messages by their priority.
It can be used to sort messages in a priority queue.
<H3><A NAME="_Toc473901925">Network packet class: <TT><FONT SIZE=4>cPacket</FONT></TT></A>
</H3>
<P>
<TT>cPacket</TT> is not yet documented here. See the User Manual.
<H2><A NAME="_Toc473901926">Module gate class: <TT><FONT SIZE=5>cGate</FONT></TT></A>
</H2>
<P>
Header file: <TT>cmodule.h</TT> (<TT>sim</TT> directory)
<P>
<TT>cGate</TT> object are created and managed by modules; the
user typically does not want to directly create or destroy <TT>cGate</TT>
objects. However, they are important if a simple module algorithm
needs to know about its surroundings.
<H3><A NAME="_Toc473901927">class <TT><FONT SIZE=4>cGate</FONT></TT></A>
</H3>
<P>
<B>Construction, destruction, copying</B>
<P>
These functions are not documented here since they are considered
internal to the simulation library.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className()</FONT>
</PRE>
<P>
Returns pointer to the class name string, <TT>&quot;cGate&quot;</TT>.
<P>
<B>Gate identity</B>
<PRE>
<FONT>int size()</FONT>
</PRE>
<P>
If the gate is in a gate array, returns the size of the vector;
otherwise, it returns 1.
<PRE>
<FONT>int index()</FONT>
</PRE>
<P>
If the gate is in a gate array, returns the gate's position in
it; otherwise, it returns 0.
<PRE>
<FONT>void setIndex(int sn, int vs)</FONT>
</PRE>
<P>
Specifies that the gate is at index <TT>sn</TT> in a gate array
of size <TT>vs</TT>. This function should not be directly called
by the user.
<PRE>
<FONT>char type()</FONT>
</PRE>
<P>
Returns the gate's type: <TT>'I'</TT> for input and <TT>'O'</TT>
for output.
<PRE>
<FONT>cModule *ownerModule()</FONT>
</PRE>
<P>
Returns a pointer to the owner module of the gate.
<PRE>
<FONT>int id()</FONT>
</PRE>
<P>
Returns the position of the gate in the vector of all gates of
the module.
<PRE>
<FONT>void setOwnerModule(cModule *m, int g)</FONT>
</PRE>
<P>
Specifies that the gate is owned by module <TT>m</TT>, and it
is at index <TT>g</TT> in the gate vector. This function should
not be directly called by the user.
<P>
<B>Link parameters</B>
<PRE>
<FONT>cLinkType *link()</FONT>
</PRE>
<P>
Returns the link type of the gate, if it has one.
<PRE>
<FONT>cPar *delay()
cPar *error()
cPar *datarate()</FONT>
</PRE>
<P>
Return pointers to the delay, bit error rate and datarate parameters
of the link. Links are one-directional; these parameters are only
stored at their starting side.
<PRE>
<FONT>void setLink(cLinkType *l)</FONT>
</PRE>
<P>
Sets the parameters of the link to those specified by the link
type.
<PRE>
<FONT>void setDelay(cPar *p)
void setError(cPar *p)
void setDataRate(cPar *p)</FONT>
</PRE>
<P>
Set the parameters of the link. Ownership of <TT>cPar</TT> objects
are handled according to the ownership flag (that is set by <TT>takeOwnership()</TT>).
<P>
<B>Topology</B>
<PRE>
<FONT>bool isConnected()</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the gate is connected.
<PRE>
<FONT>cGate *fromGate()
cGate *toGate()</FONT>
</PRE>
<P>
For a compound module gate, it returns the previous and the next
gate in the series of connections (the route) that contains this
gate. For simple module gates, only one of the functions will
return non-<TT>NULL</TT> value.
<PRE>
<FONT>void setFrom(cGate *g)
void setTo(cGate *g)</FONT>
</PRE>
<P>
Redirect gates. This function will rarely be needed; unless maybe
for dynamically created modules.
<PRE>
<FONT>cGate *sourceGate()
cGate *destinationGate()</FONT>
</PRE>
<P>
Return the ultimate source and destination of the series of connections
(the route) that contains this gate.
<PRE>
<FONT>int routeContains(cModule *m, int g=-1)</FONT>
</PRE>
<P>
Determines if a given module is in the route that this gate is
in.
<PRE>
<FONT>bool isRouteOK()</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the route that this gate is in is complete;
i.e., if it starts and arrives at a simple module.
<PRE>
<FONT>void deliver(cMessage *msg)</FONT>
</PRE>
<P>
This function is called internally by the <TT>send()</TT> functions
to deliver the message to its destination.
<H2><A NAME="_Toc473901928">Value holding class: <TT><FONT SIZE=5>cPar</FONT></TT></A>
</H2>
<P>
Header file: <TT>cpar.h</TT> (<TT>sim</TT> directory)
<P>
Parameter classes are designed to hold a value. Many types are
available:
<UL>
<LI>string
<LI>boolean
<LI>long int
<LI>double
<LI>function
<LI>expression
<LI>distribution
<LI>void* pointer
<LI>object pointer
<LI>indirect value
</UL>
<P>
<FONT></FONT>
<P>
For all types, an <I>input flag</I> can be set. In this case,
the user will be asked to enter the value when the object's value
is first used. The <I>prompt string</I> can also be specified
for <TT>cPar</TT>. If no prompt string is given, the object's
name will be displayed as prompt text.
<H3><A NAME="_Toc473901929">class <TT><FONT SIZE=4>cPar</FONT></TT></A>
</H3>
<P>
<B>Construction, destruction, copying</B>
<P>
In constructor calls where a <TT>type</TT> argument (a character)
is present, the type must match the argument list, e.g. if the
argument list contains <TT>char *s</TT>, the type must be <TT>'S'</TT>.
<PRE>
<FONT>cPar(cPar&amp; other);</FONT>
</PRE>
<P>
Copy constructor, creates an exact copy of the argument.
<PRE>
<FONT>cPar(char *name=NULL);</FONT>
</PRE>
<P>
Constructor, creates a <TT>cPar</TT> with the given name and long
(<TT>'L'</TT>) as default type.
<PRE>
<FONT>cPar(char *name, cPar&amp; other);</FONT>
</PRE>
<P>
Constructor, creates a copy of the second argument with another
name.
<PRE>
<FONT>virtual cObject *dup()</FONT>
</PRE>
<P>
Duplicates the object and returns a pointer to the new one.
<PRE>
<FONT>cPar&amp; operator=(cPar&amp; otherpar);</FONT>
</PRE>
<P>
The assignment operator works with <TT>cPar</TT> objects.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className()</FONT>
</PRE>
<P>
Returns pointer to the class name string, <TT>&quot;cPar&quot;</TT>.
<P>
<B>Member functions handling type, input flag and prompt</B>
<PRE>
<FONT>char type();</FONT>
</PRE>
<P>
Returns type character. If the &quot;real&quot; type is <TT>'I'</TT>,
it returns the type of the object it is indirected to (for example,
<TT>'D'</TT>, <TT>'L'</TT>, etc.)
<PRE>
<FONT>char *prompt();</FONT>
</PRE>
<P>
Returns the prompt text or <TT>NULL</TT>.
<PRE>
<FONT>void setPrompt(char *s);</FONT>
</PRE>
<P>
Sets the prompt text.
<PRE>
<FONT>void setInput(bool ip);</FONT>
</PRE>
<P>
Sets (<TT>ip=true</TT>) or clears (<TT>ip=false</TT>) the input
flag.
<PRE>
<FONT>bool isInput();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the parameter is of input type (the input
flag is set).
<PRE>
<FONT>bool changed();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the value has changed since the last
<TT>changed()</TT> call.
<P>
<B>Conversion from/to text</B>
<PRE>
<FONT>virtual bool setFromText(char *text, char type);</FONT>
</PRE>
<P>
This function tries to interpret the argument text as a <TT>type</TT>
typed value. <TT>type=='?'</TT> means that the type is to be auto-selected.
On success, <TT>cPar</TT> is updated with the new value and <TT>true</TT>
is returned, otherwise the function returns <TT>false</TT>. No
error message is generated.
<PRE>
<FONT>virtual void getAsText(char *buf, int maxlen);</FONT>
</PRE>
<P>
Places the value in text format it into buffer <TT>buf</TT> which
is <TT>maxlen</TT> characters long.
<P>
<B>Setting the value</B>
<PRE>
<FONT>cPar&amp; setValue(char tp, char *s);</FONT>
</PRE>
<P>
Sets the value stored in the object. The new type specified in
<TT>tp</TT> must be string (S).
<PRE>
<FONT>cPar&amp; setValue(char tp, long l);</FONT>
</PRE>
<P>
Sets the value stored in the object. The new type specified in
<TT>tp</TT> can be boolean (B) or long (L).
<PRE>
<FONT>cPar&amp; setValue(char tp, double d);</FONT>
</PRE>
<P>
Sets the value stored in the object. The new type specified in
<TT>tp</TT> can be long (L), or double (D).
<PRE>
<FONT>cPar&amp; setValue(char tp, cObject *obj);</FONT>
</PRE>
<P>
Sets the value stored in the object. The new type specified in
<TT>tp</TT> must be object pointer (O).
<PRE>
<FONT>cPar&amp; setValue(char tp, void *p);</FONT>
</PRE>
<P>
Sets the value stored in the object. The new type specified in
<TT>tp</TT> must be void* pointer (P).
<PRE>
<FONT>cPar&amp; setValue(char tp, cStatistic *res);</FONT>
</PRE>
<P>
Sets the value stored in the object. The new type specified in
<TT>tp</TT> must be distribution (T).
<PRE>
<FONT>cPar&amp; setValue(char tp, sXElem *x, int n);</FONT>
</PRE>
<P>
Sets the value stored in the object. The new type specified in
<TT>tp</TT> must be expression (X). The expression must be converted
to reversed Polish form and stored in the vector of size <TT>n</TT>
pointed to by <TT>x</TT>. See documentation of <TT>sXElem</TT>
at the end of this section for more information.
<P>
<B>Retrieving the value</B>
<PRE>
<FONT>char *stringValue();</FONT>
</PRE>
<P>
Returns value as <TT>char*</TT>. Only for string (S) type.
<PRE>
<FONT>bool boolBalue();</FONT>
</PRE>
<P>
Returns value as <TT>bool</TT>. Converts from types Boolean (B)
and long (L).
<PRE>
<FONT>long longValue();</FONT>
</PRE>
<P>
Returns value as <TT>long</TT>. Converts from types long (L),
double (D), Boolean (B), function (F), distribution (T) and expression
(X).
<PRE>
<FONT>double doubleValue();</FONT>
</PRE>
<P>
Returns value as <TT>double</TT>. Converts from types long (L),
double (D), function (F), Boolean (B), distribution (T) and expression
(X).
<PRE>
<FONT>cObject *objectValue();</FONT>
</PRE>
<P>
Returns value as pointer to <TT>cObject</TT>. Type must be pointer
(O).
<PRE>
<FONT>void *pointerValue();</FONT>
</PRE>
<P>
Returns value as pointer to <TT>cObject</TT>. Type must be pointer
(P).
<P>
<B>Other functions</B>
<PRE>
<FONT>cPar&amp; read();</FONT>
</PRE>
<P>
Reads the object value from the ini file or from the user.
<PRE>
<FONT>void convertToConst();</FONT>
</PRE>
<P>
Replaces the object value with its evaluation (a <TT>double</TT>).
Implemented as something like <TT>setValue('D', this-&gt;doubleValue())</TT>.
<PRE>
<FONT>void configPointer(VoidDelFunc delfunc, VoidDupFunc dupfunc, size_t size = 0);</FONT>
</PRE>
<P>
Configures memory management for the void* pointer ('P') type.
Similar to <TT>cLinkedList</TT>'s <TT>configPointer()</TT> function.
<TABLE BORDER=1>
<TR><TD WIDTH=96><B>delete func.</B></TD><TD WIDTH=89><B>dupl.func.</B>
</TD><TD WIDTH=92><B>itemsize</B></TD><TD WIDTH=317><B>behaviour</B>
</TD></TR>
<TR><TD WIDTH=96><TT>NULL</TT></TD><TD WIDTH=89><TT>NULL</TT>
</TD><TD WIDTH=92><TT>0</TT></TD><TD WIDTH=317>Pointer is treated as mere pointer - no memory management. Duplication copies the pointer, and deletion does nothing.
</TD></TR>
<TR><TD WIDTH=96><TT>NULL</TT></TD><TD WIDTH=89><TT>NULL</TT>
</TD><TD WIDTH=92>&gt;0 size</TD><TD WIDTH=317>Plain memory management. Duplication is done with <TT>new char[size]+memcpy()</TT>, and deletion is done via <TT>delete</TT>.
</TD></TR>
<TR><TD WIDTH=96><TT>NULL</TT> or user's delete func.</TD><TD WIDTH=89>user's dupfunc.
</TD><TD WIDTH=92>indifferent</TD><TD WIDTH=317>Sophisticated memory management. Duplication is done by calling the user-supplied duplication function, which should do the allocation and the appropriate copying. Deletion is done by calling the user-supplied delete function, or the delete operator if it is not supplied.
</TD></TR>
</TABLE>
<P>
<PRE>
<FONT>static int cmpbyvalue(cObject *one, cObject *other);</FONT>
</PRE>
<P>
Compares two <TT>cPar</TT>s by their value if they are numeric.
This function can be used to sort <TT>cPar</TT> objects in a priority
queue. 
<P>
<B>Handling indirection</B>
<PRE>
<FONT>cPar *indirection();</FONT>
</PRE>
<P>
Returns <TT>NULL</TT> if the <TT>cPar</TT>'s value is not indirected
to another <TT>cPar</TT>; otherwise it returns the pointer of
that <TT>cPar</TT>. This function is the only way to determine
if an object is indirected or not (<TT>type()</TT> returns the
type of the other <TT>cPar</TT>: <TT>'D'</TT>, <TT>'L'</TT> etc).
<PRE>
<FONT>void cancelIndirection();</FONT>
</PRE>
<P>
Break the indirection. The new type will be <TT>long</TT> (<TT>'L'</TT>).
<P>
<B>Assignment and conversion operators</B>
<P>
This set of overloaded operators provides assignment and conversion
for fundamental data types.
<PRE>
<FONT>cPar&amp; operator=(char c);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('C',(int)c)</TT>.
<PRE>
<FONT>cPar&amp; operator=(unsigned char c);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('C',(int)c)</TT>.
<PRE>
<FONT>cPar&amp; operator=(char *s);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('S',s)</TT>.
<PRE>
<FONT>cPar&amp; operator=(int i);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('L',(long)i)</TT>.
<PRE>
<FONT>cPar&amp; operator=(unsigned int i);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('L',(long)i)</TT>.
<PRE>
<FONT>cPar&amp; operator=(long l);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('L',l)</TT>.
<PRE>
<FONT>cPar&amp; operator=(unsigned long l);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('L',(long)l)</TT>.
<PRE>
<FONT>cPar&amp; operator=(double d);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('D',d)</TT>.
<PRE>
<FONT>cPar&amp; operator=(long double d);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('D',(double)d)</TT>.
<PRE>
<FONT>cPar&amp; operator=(cObject *obj);</FONT>
</PRE>
<P>
Equivalent to <TT>setValue('P',obj)</TT>.
<PRE>
<FONT>operator char*();</FONT>
</PRE>
<P>
Equivalent to <TT>stringValue()</TT>.
<PRE>
<FONT>operator int();</FONT>
</PRE>
<P>
Equivalent to <TT>longValue()</TT>.
<PRE>
<FONT>operator unsigned int();</FONT>
</PRE>
<P>
Equivalent to <TT>longValue()</TT>.
<PRE>
<FONT>operator long();</FONT>
</PRE>
<P>
Equivalent to <TT>longValue()</TT>.
<PRE>
<FONT>operator unsigned long();</FONT>
</PRE>
<P>
Equivalent to <TT>longValue()</TT>.
<PRE>
<FONT>operator double();</FONT>
</PRE>
<P>
Equivalent to <TT>doubleValue()</TT>.
<PRE>
<FONT>operator long double();</FONT>
</PRE>
<P>
Equivalent to <TT>doubleValue()</TT>.
<PRE>
<FONT>operator cObject *();</FONT>
</PRE>
<P>
Equivalent to <TT>pointerValue()</TT>.
<H3><A NAME="_Toc473901930">Overloaded arithmetic operators for
<TT><FONT SIZE=4>cPar</FONT></TT></A></H3>
<P>
The following operators are overloaded: <TT>&lt;, &gt;, &lt;=,
&gt;=, +, -, *</TT> and <TT>/</TT>. These operators help using
<TT>cPar</TT> objects in arithmetic expressions with the same
syntax as internal numeric types. Two different sets of overloaded
arithmetic operators are provided, mutually excluding the other.
One works through converting the <TT>cPar</TT> to <TT>double</TT>,
and the other through converting to <TT>long</TT>. The <TT>double</TT>
version is the default, but you can choose the other set by defining
<TT>LONG_CPAR_OPERATIONS</TT> before including <TT>cpar.h</TT>.
If neither set is needed, define <TT>NO_CPAR_OPERATIONS</TT>!
<H3><A NAME="_Toc473901931">struct <TT><FONT SIZE=4>sXElem</FONT></TT></A>
</H3>
<P>
If the value of the <TT>cPar</TT> is of expression type, the expression
must be converted to reversed Polish form. The reversed Polish
form expression is stored in a vector of <TT>sXElem</TT> structures.
<TT>sXElem</TT> is not a descendant of <TT>cObject</TT>.
<PRE>
<FONT>void operator=(int _i);
void operator=(long _l);
void operator=(double _d);</FONT>
</PRE>
<P>
Effect during evaluation of the expression: pushes the given number
(which is converted to <TT>double</TT>) on the evaluation stack.
<PRE>
<FONT>void operator=(cPar *_v);</FONT>
</PRE>
<P>
Effect during evaluation of the expression: takes the value of
the <TT>cPar</TT> object  (a <TT>double</TT>) and pushes the value
on the evaluation stack. The <TT>cPar</TT> is an &quot;external&quot;
one: its ownership does not change. This is how NED-language REF
parameters in expressions are handled.
<PRE>
<FONT>void operator=(cPar&amp; _r);</FONT>
</PRE>
<P>
Effect during evaluation of the expression: takes the value of
the <TT>cPar</TT> object  (a <TT>double</TT>) and pushes the value
on the evaluation stack. The <TT>cPar</TT> which evaluates this
expression will copy the <TT>cPar</TT> for itself.
<PRE>
<FONT>void operator=(char _op);</FONT>
</PRE>
<P>
The argument can be:
<TABLE BORDER=1>
<TR><TD WIDTH=114><CENTER><TT>+ - * /</TT></CENTER></TD><TD WIDTH=330>add, subtract, multiply, divide
</TD></TR>
<TR><TD WIDTH=114><CENTER><TT>% ^ </TT></CENTER></TD><TD WIDTH=330>modulo, power of
</TD></TR>
<TR><TD WIDTH=114><CENTER><TT>= ! </TT></CENTER></TD><TD WIDTH=330>equal, not equal
</TD></TR>
<TR><TD WIDTH=114><CENTER><TT>&gt; }</TT></CENTER></TD><TD WIDTH=330>greater, greater or equal
</TD></TR>
<TR><TD WIDTH=114><CENTER><TT>&lt; {</TT></CENTER></TD><TD WIDTH=330>less, less or equal
</TD></TR>
<TR><TD WIDTH=114><CENTER><TT>?</TT></CENTER></TD><TD WIDTH=330>inline if (C language's <TT>(cond ? a : b)</TT>
</TD></TR>
</TABLE>
<P>
Effect during evaluation of the expression: two items (or three,
with <TT>'?'</TT>) are popped out of the stack, the given operator
is applied to them and the result is pushed back on the stack.
<PRE>
<FONT>void operator=(MathFuncNoArg f);
void operator=(MathFunc1Arg f);
void operator=(MathFunc2Args f);
void operator=(MathFunc3Args f);</FONT>
</PRE>
<P>
The argument can be a pointer to a function that takes (0, 1,
2, or 3) <TT>double</TT> arguments and returns a <TT>double</TT>
(e.g. <TT>sqrt()</TT>). Effect during evaluation of the expression:
the given number of <TT>double</TT>s are popped from the stack,
the given function is called with them as arguments, and the return
value is pushed back on the stack. See also the <TT>cFunctionType</TT>
class and the <TT>Define_Function()</TT> macro.
<P>
The OMNeT++ functions generating random variables of different
distributions can also be used in <TT>sXElem</TT> expressions.
<H2><A NAME="_Toc473901932">Object container classes: <TT><FONT SIZE=5>cArray</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cQueue</FONT></TT><FONT SIZE=5>, </FONT><TT><FONT SIZE=5>cHead</FONT></TT></A>
</H2>
<P>
Header files: <TT>carray.h, cqueue.h </TT> (<TT>sim</TT> directory)
<P>
There are four container classes: <TT>cArray</TT> and <TT>cQueue</TT>,
<TT>cHead</TT>.
<H3><A NAME="_Toc473901933">class <TT><FONT SIZE=4>cArray</FONT></TT></A>
</H3>
<P>
<TT>cArray</TT> is a container object that holds objects derived
from <TT>cObject</TT>. <TT>cArray</TT> stores the pointers of
the objects inserted instead of making copies. <TT>cArray</TT>
works as an array, but if it gets full, it grows automatically
by a specified delta. Ownership of contained objects (responsibility
of deletion) can be specified per-object basis (see <TT>cObject::takeOwnership()</TT>).
Default is that <TT>cArray</TT> takes the ownership of each object
inserted (that is, <TT>takeOwnership(true)</TT>).
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cArray(cArray&amp; list);</FONT>
</PRE>
<P>
Copy constructor. Contained objects that are owned by <TT>cArray</TT>
(that is, whose <TT>owner()</TT> is the <TT>cArray</TT>) will
be duplicated so that the new <TT>cArray</TT> will have its own
copy of them.
<PRE>
<FONT>cArray(char *name=NULL, int siz=0, int dt=10, cHead *h=&amp;locals);</FONT>
</PRE>
<P>
Constructor. It takes the object name, the initial vector size,
delta and the pointer to the list it should join as argument.
<PRE>
<FONT>virtual ~cArray();</FONT>
</PRE>
<P>
Destructor. The contained objects that were owned by the container
will be deleted.
<PRE>
<FONT>virtual cObject *dup();
cArray&amp; operator=(cArray&amp; list);</FONT>
</PRE>
<P>
Duplication and assignment work all right with <TT>cArray</TT>.
Contained objects that are owned by <TT>cArray</TT> will be duplicated
so that the new <TT>cArray</TT> will have its own copy of them.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns pointer to the class name string,<TT>&quot;cArray&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<PRE>
<FONT>virtual void forEach(ForeachFunc f);</FONT>
</PRE>
<P>
Calls the given function for each object contained.
<P>
<B>Member functions:</B>
<PRE>
<FONT>int items();</FONT>
</PRE>
<P>
Returns the index of last used position+1.
<PRE>
<FONT>void clear();</FONT>
</PRE>
<P>
As a result, the container will be empty. Contained objects that
were owned by the container will be deleted.
<PRE>
<FONT>int add(cObject *obj);</FONT>
</PRE>
<P>
Inserts a new object into the array. Only the pointer of the object
will be stored. The return value is the object's index in the
array.
<PRE>
<FONT>int addAt(int m, cObject *obj);</FONT>
</PRE>
<P>
Inserts a new object into the array, at the given position. If
the position is occupied, the function generates an error message.
<PRE>
<FONT>int find(cObject *obj);</FONT>
</PRE>
<P>
Searches the array for the pointer of the object passed and returns
the index of the first match. If the object wasn't found, -1 is
returned.
<PRE>
<FONT>int find(char *s);</FONT>
</PRE>
<P>
Returns the index of the first item in the array that has the
name pointed to by <TT>s</TT> (<TT>cObject::isName()</TT> is used.)
If no such item was found, -1 is returned.
<PRE>
<FONT>cObject *get(int m);</FONT>
</PRE>
<P>
Returns reference to the <TT>m</TT>th object in the array or null
pointer if the <TT>m</TT>th position is not used.
<PRE>
<FONT>cObject *get(char *s);</FONT>
</PRE>
<P>
Returns reference to the first object in the array with name <TT>s</TT>
or null reference (<TT>*NOOBJ</TT>) if no object with the given
name was found.
<PRE>
<FONT>cObject *operator[](int m);
cObject *operator[](char *s);</FONT>
</PRE>
<P>
The same as <TT>get(int)</TT>/<TT>get(char *)</TT>. With the indexing
operator, <TT>cArray</TT> can be used as a vector.
<PRE>
<FONT>bool exist(int m);
bool exist(char *s);</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the value returned by <TT>get(int)</TT>/<TT>get(char
*)</TT> would not be null reference <TT>(*NOOBJ)</TT>.
<PRE>
<FONT>cObject *remove(int m);
cObject *remove(char *s);</FONT>
</PRE>
<P>
Removes the object given with its index/name from the container.
(If the object was owned by the container, <TT>drop()</TT> is
called.)
<H3><A NAME="_Toc473901934">class <TT><FONT SIZE=4>cQueue</FONT></TT></A>
</H3>
<P>
<TT>cQueue</TT> is a container class that can hold objects derived
from <TT>cObject</TT>. <TT>cQueue</TT> acts as a priority queue.
The user must provide a function that can compare two objects.
If no such function is given, <TT>cQueue</TT> implements a FIFO.
Order (ascending or descending) can be specified and will be interpreted
as in the figure:
<P>
<CENTER><IMG SRC="img00021.gif"></CENTER>
<P>
Ownership of contained objects (responsibility of deletion) can
be specified per-object basis (see <TT>cObject::takeOwnership()</TT>).
Default is that <TT>cQueue</TT> takes the ownership of each object
inserted (that is, <TT>takeOwnership(true)</TT>).
<P>
<B>The sorting function </B>
<PRE>
<FONT>int CompareFunc(cObject&amp; a, cObject&amp; b);</FONT>
</PRE>
<P>
User-supplied sorting functions must have a declaration like the
one shown above and they must return a negative value if a&lt;b,
0 if a==b and a positive value if a&gt;b.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cQueue(cQueue&amp; queue);</FONT>
</PRE>
<P>
Copy constructor. Contained objects that are owned by the queue
will be duplicated so that the new queue will have its own copy
of them.
<PRE>
<FONT>cQueue(char *name=NULL, CompareFunc cmp=NULL, bool a=false, cHead *h=&amp;locals);</FONT>
</PRE>
<P>
Constructor. It accepts the object name, the address of the comparing
function, the sorting order (ascending=<TT>true</TT>, descending=<TT>false</TT>)
and the list the object will join.
<PRE>
<FONT>virtual ~cQueue();</FONT>
</PRE>
<P>
Destructor. Deletes all contained objects that were owned by it.
<PRE>
<FONT>virtual cObject *dup();
cQueue&amp; operator=(cQueue&amp; queue);</FONT>
</PRE>
<P>
Duplication and assignment work all right with <TT>cQueue</TT>.
Contained objects that are owned by the queue will be duplicated
so that the new queue will have its own copy of them.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns pointer to the class name string,<TT>&quot;cQueue&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<PRE>
<FONT>virtual void forEach(ForeachFunc f);</FONT>
</PRE>
<P>
Calls the given function for each object contained.
<P>
<B>Member functions</B>
<PRE>
<FONT>void setup(CompareFunc cmp=NULL, bool a=false);</FONT>
</PRE>
<P>
Changes the sort function and the sorting order. Doesn't re-sort
the contents of the queue!
<PRE>
<FONT>void clear();</FONT>
</PRE>
<P>
As a result, the container will be empty. Contained objects that
were owned by the queue will be deleted.
<PRE>
<FONT>int length();</FONT>
</PRE>
<P>
Returns the number of objects contained in the queue.
<PRE>
<FONT>bool empty();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the queue is empty.
<PRE>
<FONT>void insert(cObject *obj);</FONT>
</PRE>
<P>
Inserts the given object into the queue, maintaining the sorting
order.
<PRE>
<FONT>void insertBefore(cObject *obj, cObject *where);
void insertAfter(cObject *obj, cObject *where);</FONT>
</PRE>
<P>
Inserts exactly before and after the given object.
<PRE>
<FONT>cObject *tail();</FONT>
</PRE>
<P>
Returns pointer to the last object in the queue or <TT>NULL</TT>
if the queue is empty.
<PRE>
<FONT>cObject *pop();</FONT>
</PRE>
<P>
Unlinks and returns the last object in the queue.
<PRE>
<FONT>cObject *remove(cObject *obj);</FONT>
</PRE>
<P>
Unlinks and returns the object given.
<H3><A NAME="_Toc473901935">class <TT><FONT SIZE=4>cQueueIterator</FONT></TT></A>
</H3>
<P>
To examine each element in the queue, the <TT>cQueueIterator</TT>
iterator class can be used. Once a <TT>cQueueIterator</TT> object
is created for the queue (the <TT>cQueue</TT> object), the ++
and -- operators can be used to step from one element of the list
to the next/previous one. <TT>cQueueIterator</TT> is not a descendant
of <TT>cObject</TT> or <TT>cIterator</TT>.
<PRE>
<FONT>cQueueIterator(cQueue&amp; q, int a=1);</FONT>
</PRE>
<P>
Constructor, <TT>cIterator</TT> will walk on the queue passed
as argument. The current object will be the first (if a==1) or
the last (a==0) object in the queue.
<PRE>
<FONT>void init(cQueue&amp; q, int a=1);</FONT>
</PRE>
<P>
Reinitializes the iterator object.
<PRE>
<FONT>cObject *operator()();</FONT>
</PRE>
<P>
Returns the current object.
<PRE>
<FONT>bool end();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if we have reached the end of the queue.
<PRE>
<FONT>cObject&amp; operator++(int);
cObject&amp; operator--(int);</FONT>
</PRE>
<P>
Steps to the next/previous object in the queue.
<H3><A NAME="_Toc473901936">Inline functions</A></H3>
<P>
The following inline functions are for finding objects by name.
<PRE>
<FONT>inline cNetworkType *findNetwork(char *s);</FONT>
</PRE>
<P>
Equals <TT>(cNetworkType *)networks.find(s);</TT>
<PRE>
<FONT>inline cModuleType *findModuleType(char *s)</FONT>
</PRE>
<P>
Equals <TT>(cModuleType *)modtypes.find(s);</TT>
<PRE>
<FONT>inline cLinkType *findLink(char *s);</FONT>
</PRE>
<P>
Equals <TT>(cLinkType *)linktypes.find(s);</TT>
<PRE>
<FONT>inline cFunctionType *findFunction(char *s);</FONT>
</PRE>
<P>
Equals <TT>(cFunctionType *)functions.find(s);</TT>
<H3><A NAME="_Toc473901937">class <TT><FONT SIZE=4>cHead</FONT></TT></A>
</H3>
<P>
<TT>cHead</TT> is the head of a <TT>cObject</TT> chain. <TT>cObject</TT>
and its derived classes contain pointers that enable the objects
to be a node in a double-linked list. <TT>cObject</TT> has member
functions to link and unlink to and from double-linked lists (See
documentation on <TT>cObject::setOwner()</TT>) The head of such
lists is always a <TT>cHead</TT> object. The lists are a means
that provide that each object in the system is part of an object
tree and can be accessed through pointers starting from a given
point. The existence of such hierarchy is necessary for a user
interface where we want each object to be 'visible' to the user.
It is also unavoidable when we want the simulation to be restartable
(we need to destroy objects created by the running simulation
to start a new one). Last, it enables that all objects can be
reached through <TT>forEach()</TT> on which many algorithms rely
(e.g. <TT>saveresults()</TT>).
<P>
For <TT>cHead</TT>, the <TT>dup()</TT> and <TT>operator=()</TT>
functions are NOT implemented. <TT>dup()</TT> would require that
every object in the list be duplicated. Since <TT>cHead</TT> is
mostly an internal class and is NOT intended for use by the programmer
as a container class, the <TT>dup()</TT> operation was considered
unnecessary.
<P>
<B>Construction, destruction, copying:</B>
<PRE>
<FONT>cHead(char *name=NULL, cHead *h=&amp;locals, bool init=true );</FONT>
</PRE>
<P>
Constructor. Accepts the object name, the head of the list it
should join and a parameter that tells <TT>cHead</TT> if it should
initialize the pointers to the list.
<PRE>
<FONT>virtual ~cHead();</FONT>
</PRE>
<P>
The destructor deletes all objects in the list that were created
on the heap.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns the pointer to the class name string, <TT>&quot;cHead&quot;</TT>.
<PRE>
<FONT>virtual void forEach(ForeachFunc f);</FONT>
</PRE>
<P>
Calls the function passed for each object in the list.
<P>
<B>Member functions:</B>
<PRE>
<FONT>cObject *find(char *s);</FONT>
</PRE>
<P>
Searches the list for an object with the given name and returns
its pointer. If no such object was found, <TT>NULL</TT> is returned.
<PRE>
<FONT>int count();</FONT>
</PRE>
<P>
Returns the number of objects in the list.
<H3><A NAME="_Toc473901938">struct <TT><FONT SIZE=4>cIterator</FONT></TT></A>
</H3>
<P>
To examine each element in the list, the <TT>cIterator</TT> iterator
class can be used. Once a <TT>cIterator</TT> object is created
for the list (for the <TT>cHead</TT> object), the ++ operator
can be used to step from one element of the list to the next one.
<TT>cIterator</TT> is not a descendant of <TT>cObject</TT>.
<PRE>
<FONT>cIterator(cHead&amp; h);</FONT>
</PRE>
<P>
Constructor, <TT>cIterator</TT> will walk on the list passed as
argument. The current object will be the first one in the list.
<PRE>
<FONT>void init(cHead&amp; h);</FONT>
</PRE>
<P>
Reinitializes the iterator object.
<PRE>
<FONT>cObject *operator()();</FONT>
</PRE>
<P>
Returns a pointer to the current object.
<PRE>
<FONT>bool end();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if we reach the end of the list.
<PRE>
<FONT>cObject&amp; operator++(int);</FONT>
</PRE>
<P>
Advances to the next object in the list.
<H2><A NAME="_Toc473901939">Non-object container classes: <TT><FONT SIZE=5>cLinkedList</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>cBag</FONT></TT></A></H2>
<P>
There are two non-object container classes:<TT> cLinkedList</TT>
and <TT>cBag</TT>. The first one parallels with <TT>cQueue</TT>,
the second one with <TT>cArray</TT>.
<H3><A NAME="_Toc473901940">class <TT><FONT SIZE=4>cLinkedList</FONT></TT></A>
</H3>
<P>
<TT>cLinkedList</TT> is a container class that can holds non-object
items. <TT>cLinkedList</TT> acts very similar to <TT>cQueue</TT>.
<P>
Memory management of contained items is controlled by the <TT>configPointer()</TT>
function. As default, pointers are treated as mere pointers, so
items are never duplicated or deleted.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cLinkedList(cLinkedList&amp; llist);</FONT>
</PRE>
<P>
Copy constructor. Contained items that are owned by the list will
be duplicated using the function passed in <TT>configPointer()</TT>
so that the new list will have its own copy of them. By default,
there's no duplication function so only the pointers are copied.
<PRE>
<FONT>cLinkedList(char *name=NULL);</FONT>
</PRE>
<P>
Constructor. It accepts the object name.
<PRE>
<FONT>virtual ~cLinkedList();</FONT>
</PRE>
<P>
Destructor calls <TT>clear()</TT>.
<PRE>
<FONT>virtual cObject *dup();
cLinkedList&amp; operator=(cLinkedList&amp; llist);</FONT>
</PRE>
<P>
Duplication and assignment work all right with <TT>cLinkedList</TT>.
Contained items are treated as configured with <TT>configPointer()</TT>.
By default, only pointers are copied.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns pointer to the class name string,<TT>&quot;cLinkedList&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<P>
<B>Member functions</B>
<PRE>
<FONT>void configPointer(VoidDelFunc delfunc, VoidDupFunc dupfunc, size_t size = 0);</FONT>
</PRE>
<P>
Configures memory management for contained items. Similar to <TT>cPar</TT>'s
<TT>configPointer()</TT> function.
<TABLE BORDER=1>
<TR><TD WIDTH=96><B>delete func.</B></TD><TD WIDTH=89><B>dupl.func.</B>
</TD><TD WIDTH=92><B>itemsize</B></TD><TD WIDTH=317><B>behaviour</B>
</TD></TR>
<TR><TD WIDTH=96><TT>NULL</TT></TD><TD WIDTH=89><TT>NULL</TT>
</TD><TD WIDTH=92><TT>0</TT></TD><TD WIDTH=317>Pointer is treated as mere pointer - no memory management. Duplication copies the pointer, and deletion does nothing.
</TD></TR>
<TR><TD WIDTH=96><TT>NULL</TT></TD><TD WIDTH=89><TT>NULL</TT>
</TD><TD WIDTH=92>&gt;0 size</TD><TD WIDTH=317>Plain memory management. Duplication is done with <TT>new char[size]+memcpy()</TT>, and deletion is done via <TT>delete</TT>.
</TD></TR>
<TR><TD WIDTH=96><TT>NULL</TT> or user's delete func.</TD><TD WIDTH=89>user's dupfunc.
</TD><TD WIDTH=92>indifferent</TD><TD WIDTH=317>Sophisticated memory management. Duplication is done by calling the user-supplied duplication function, which should do the allocation and the appropriate copying. Deletion is done by calling the user-supplied delete function, or the delete operator if it is not supplied.
</TD></TR>
</TABLE>
<P>
<PRE>
<FONT>void clear();</FONT>
</PRE>
<P>
As a result, the container will be empty. Contained items will
be deleted as configured by <TT>configPointer()</TT>.
<PRE>
<FONT>int length();</FONT>
</PRE>
<P>
Returns the number of items contained in the list.
<PRE>
<FONT>bool empty();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the list is empty.
<PRE>
<FONT>void insert(void *p);</FONT>
</PRE>
<P>
Inserts the given object into the list, maintaining the sorting
order.
<PRE>
<FONT>void insertBefore(void *p, void *where);
void insertAfter(cObject *p, void *where);</FONT>
</PRE>
<P>
Inserts exactly before and after the given item.
<PRE>
<FONT>void *tail();</FONT>
</PRE>
<P>
Returns the last item in the list or null pointer if the list
is empty.
<PRE>
<FONT>void *pop();</FONT>
</PRE>
<P>
Unlinks and returns the last item in the list.
<PRE>
<FONT>void *remove(void *obj);</FONT>
</PRE>
<P>
Unlinks and returns the given item.
<H3><A NAME="_Toc473901941">class <TT><FONT SIZE=4>cLinkedListIterator</FONT></TT></A>
</H3>
<P>
To examine each element in the list, the <TT>cLinkedListIterator</TT>
iterator class can be used. Once a <TT>cLinkedListIterator</TT>
object is created for the list (the <TT>cLinkedList</TT> object),
the ++ and -- operators can be used to step from one element of
the list to the next/previous one. <TT>cLinkedListIterator</TT>
is not a descendant of <TT>cObject</TT> or <TT>cIterator</TT>.
<PRE>
<FONT>cLinkedListIterator(cLinkedList&amp; ll, int a=1);</FONT>
</PRE>
<P>
Constructor, <TT>cIterator</TT> will walk on the list passed as
argument. The current item will be the first (if a==1) or the
last (a==0) item in the list.
<PRE>
<FONT>void init(cLinkedList&amp; q, int a=1);</FONT>
</PRE>
<P>
Reinitializes the iterator object.
<PRE>
<FONT>void *operator()();</FONT>
</PRE>
<P>
Returns the current item.
<PRE>
<FONT>bool end();</FONT>
</PRE>
<P>
Returns <TT>true</TT> if we have reached the end of the list.
<PRE>
<FONT>void *operator++(int);
void *operator--(int);</FONT>
</PRE>
<P>
Steps to the next/previous object in the list.
<H3><A NAME="_Toc473901942">class <TT><FONT SIZE=4>cBag</FONT></TT></A>
</H3>
<P>
<TT>cBag</TT> is a container class which is designed to hold non-<TT>cObject</TT>
items without constructors/destructors (ints, <TT>double</TT>s,
small structs etc.). <TT>cBag</TT> stores full, bit-by-bit copies
of the items inserted (and not the pointers). <TT>cBag</TT> works
as an array, but if it gets full, it grows automatically by a
specified delta.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cBag(cBag&amp; bag);</FONT>
</PRE>
<P>
Copy constructor.
<PRE>
<FONT>cBag(char *name=NULL, int esiz=1,int siz=0,int delt=5, cHead *h=&amp;locals);</FONT>
</PRE>
<P>
Constructor. It takes the object name, the size of an item in
bytes, the initial vector size, delta and the pointer to the list
it should join as argument.
<PRE>
<FONT>virtual ~cBag();</FONT>
</PRE>
<P>
Destructor. The items in the object will be deleted.
<PRE>
<FONT>virtual cObject *dup();
cBag&amp; operator=(cBag&amp; bag);</FONT>
</PRE>
<P>
Duplication and assignment work all right with <TT>cBag</TT>.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns a pointer to the class name string, <TT>&quot;cBag&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<P>
<B>Member functions:</B>
<PRE>
<FONT>void setup(int esiz,int siz, int delt=5);</FONT>
</PRE>
<P>
Clears the current contents and changes element size, initial
array size and delta parameters.
<PRE>
<FONT>void clear();</FONT>
</PRE>
<P>
Clears the whole contents of the <TT>cBag</TT>.
<PRE>
<FONT>int items();</FONT>
</PRE>
<P>
Returns the index of last used position+1.
<PRE>
<FONT>int add(void *data);</FONT>
</PRE>
<P>
Inserts a new item into the array. A copy will be made of the
item pointed to by <TT>obj</TT>. The return value is the item's
index in the array.
<PRE>
<FONT>int addAt(int pos, void *data);</FONT>
</PRE>
<P>
Inserts a new item into the array at the given position.
<PRE>
<FONT>int find(void *data);</FONT>
</PRE>
<P>
Returns the index of the first item in the array that equals the
item pointed to by <TT>obj</TT>. The comparison is done byte-by-byte.
If no such item was found, -1 is returned.
<PRE>
<FONT>void *get(int m);</FONT>
</PRE>
<P>
Returns a pointer to the <TT>m</TT>th item in the array or <TT>NULL</TT>
if the <TT>m</TT>th position is not used.
<PRE>
<FONT>void *operator[](int m);</FONT>
</PRE>
<P>
The same as <TT>get(int m)</TT>. With the indexing operator, <TT>cBag</TT>
can be used as a vector.
<PRE>
<FONT>bool isUsed(int m);</FONT>
</PRE>
<P>
Returns <TT>true</TT> if the <TT>m</TT>th position exists and
an item was inserted there.
<PRE>
<FONT>bool remove(int m);</FONT>
</PRE>
<P>
Deletes the <TT>m</TT>th position in the array. Returns <TT>true</TT>
if the <TT>m</TT>th position was used (i.e. it was actually deleted.)
<H3><A NAME="_Toc473901943">Class <TT><FONT SIZE=4>cWatch</FONT></TT></A>
</H3>
<P>
Header file: <TT>carray.h</TT> (<TT>sim</TT> directory)
<P>
<TT>cWatch</TT> is an object shell for an ordinary <TT>char</TT>,
<TT>int</TT>, <TT>long</TT>, <TT>double</TT>, <TT>char*</TT> or
<TT>cObject*</TT> variable in the module functions. It is provided
for the following reason: the <TT>cSimpleModule::snapshot()</TT>
call outputs every object of the simulation into a text file,
which is excellent for debugging. Unfortunately, ordinary variables
(<TT>int</TT>, <TT>char</TT> types etc) do not appear in the snapshot
file. <TT>cWatch</TT> helps this. Use it like this:
<PRE>
<FONT>int samples;
new cWatch( &quot;samples&quot;, samples );
</FONT>
</PRE>
<P>
Now, the <TT>cWatch</TT> object will make the samples variable
appear in the snapshot file.
<P>
The second line can be shortened using the WATCH macro:
<PRE>
<FONT>WATCH( samples );</FONT>
</PRE>
<P>
<B>Constructors:</B>
<PRE>
<FONT>cWatch(cWatch&amp; vs);
cWatch(char *name, char&amp; c);
cWatch(char *name, int&amp;  i);
cWatch(char *name, long&amp; l);
cWatch(char *name, double&amp; d);
cWatch(char *name, char* &amp;s);
cWatch(char *name, cObject* &amp;o);</FONT>
</PRE>
<P>
Initialize the shell to hold the given variable.
<PRE>
<FONT>virtual char *className();
virtual cObject *dup();
...</FONT>
</PRE>
<P>
All usual virtual functions redefined.
<PRE>
<FONT>virtual void info(char *buf);
virtual void writeContents(ostream&amp; os);</FONT>
</PRE>
<P>
These functions are redefined to display the value of the variable.
Output is like this: <TT>&quot;int samples = 12 (12U, 0xC)&quot;</TT>
<PRE>
<FONT>virtual void printTo(char *s);</FONT>
</PRE>
<P>
Does actual work for <TT>info()</TT> and <TT>writeContents()</TT>.
<H2><A NAME="_Toc473901944">Output vector class: <TT><FONT SIZE=5>cOutVector</FONT></TT></A>
</H2>
<P>
Header file: <TT>coutvect.h</TT> (<TT>sim</TT> directory)
<P>
There are two classes: <TT>cOutVector</TT> and <TT>cOutFileMgr</TT>.
<TT>cOutFileMgr</TT> and <TT>cOutVector</TT> work together to
allow the user save several &quot;series&quot; or &quot;output
vectors&quot; (a series of numbers or number pairs which are produced
during simulation as results) to a common file called &quot;output
vector file&quot; or simply &quot;output file&quot;.
<P>
Users don't need to use <TT>cOutFileMgr</TT> directly. There is
only one instance of <TT>cOutFileMgr</TT> (in <TT>cSimulation</TT>),
it stores the common file pointer and gives out unique identifiers
to <TT>cOutVector</TT> objects.
<P>
There can be several <TT>cOutVector</TT>s, each one handles one
output vector. Data are written into a common file.
<P>
The output file is ASCII and can be read by a spreadsheet etc.
It should cause no problem to sort out values for one particular
output vector.
<H3><A NAME="_Toc473901945">class <TT><FONT SIZE=4>cOutVect</FONT></TT></A>
</H3>
<P>
<TT>cOutVect</TT> is responsible for writing simulation data (an
output vector) to a file. A <TT>cOutVect</TT> object can write
<TT>double</TT>s or pair of <TT>double</TT>s to the &quot;statistical
output file&quot;. The file consists of label lines and data lines.
<P>
Here are some sample lines:
<PRE>
<FONT>vector  5  &quot;subnet[4].term[12]&quot;  &quot;response time&quot;  1
5  12.895  2355.66666666
5  14.126  4577.66664666
vector 6  &quot;subnet[4].srvr&quot;  &quot;queuelen+queuingtime&quot;  2
6  16.960  2.00000000000  .63663666
5  23.086  2355.66666666
6  24.026  8.00000000000  .44766536</FONT>
</PRE>
<P>
There are label lines (beginning with &quot;vector&quot;) and
data lines.
<P>
A label line introduces a new vector. The columns: &quot;vector&quot;,
vector ID, module of creation, name of <TT>cOutVector</TT> object,
number of data (single numbers or pairs will be written).
<P>
Columns of a data line: vector ID, actual simulation time, one
or two <TT>double</TT> values.
<P>
One can use UNIX tools like sed, awk or perl to extract a particular
vector etc. from the file, or/and read it in spreadsheets like
Excel.
<P>
The <TT>cOutVector::record()</TT> member is used to output a value
(or a value pair). This will generate a data line in the file,
unless the output vector is disabled or the current simulation
time is outside a specified interval (see member functions).
<P>
<B>Construction, destruction, copying:</B>
<PRE>
<FONT>cOutVector(cOutVector&amp; r)</FONT>
</PRE>
<P>
Copy constructor.
<PRE>
<FONT>cOutVector (char *s=NULL, int tupl=1)</FONT>
</PRE>
<P>
Constructor. Accepts the object name and the multiplicity of the
data it should write to the file at a time. Possible values of
tuple are 1 or 2.
<PRE>
<FONT>virtual ~cOutVector()</FONT>
</PRE>
<P>
Destructor. 
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className()</FONT>
</PRE>
<P>
Returns a pointer to the class name <TT>&quot;cOutVector&quot;</TT>.
<PRE>
<FONT>virtual cObject *dup()</FONT>
</PRE>
<P>
Dupping does not make much sense, not implemented.
<PRE>
<FONT>virtual void info(char *buf)</FONT>
</PRE>
<P>
Redefined.
<P>
<B>Member functions</B>
<PRE>
<FONT>void record (double value)</FONT>
</PRE>
<P>
Records one data to the file. It can be used only in the case
if the instance of <TT>cOutVect</TT> was created with tupl=1,
otherwise it gives an error message.
<PRE>
<FONT>void record (double value1, double value2)</FONT>
</PRE>
<P>
Records two values to the file. It can be used only in the case
if the instance of <TT>cOutVect</TT> was created with tupl=2,
otherwise it gives an error message.
<PRE>
<FONT>void enableWrite()</FONT>
</PRE>
<P>
Makes writing to the file enabled. It is enabled by default.
<PRE>
<FONT>void disableWrite()</FONT>
</PRE>
<P>
Makes writing to the file disabled. It is enabled by default.
<PRE>
<FONT>void setStartTime(simtime_t t);</FONT>
</PRE>
<P>
Sets StartTime to t. Data is recorded to the file only if simulation
time &gt; StartTime. The default value of StartTime is 0.
<PRE>
<FONT>void setStopTime(simtime_t t);</FONT>
</PRE>
<P>
Sets StopTime to t. Data is recorded to the file only if the simulation
time &lt; StopTime. The default value of StopTime is 0 which means
no Stoptime.
<H3><A NAME="_Toc473901946">class <TT><FONT SIZE=4>cOutFileMgr</FONT></TT></A>
</H3>
<P>
This class is responsible for handling the output file for cOutVectors.
Users don't need to use <TT>cOutFileMgr</TT> directly, only through
<TT>cOutVect</TT>.
<P>
<B>Constructor, destructor, copying</B>
<PRE>
<FONT>cOutFileMgr(char *s=NULL)</FONT>
</PRE>
<P>
Constructor.
<PRE>
<FONT>virtual ~cOutFileMgr()</FONT>
</PRE>
<P>
Destructor. Closes the output file if it is still open.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className()</FONT>
</PRE>
<P>
Returns a pointer to the class name <TT>&quot;cOutFileMgr&quot;</TT>.
<P>
<B>Member functions</B>
<PRE>
<FONT>void setFileName(char *s)</FONT>
</PRE>
<P>
Sets the name of the statistical output file. This name will be
set at the time of the next call of openFile().
<PRE>
<FONT>void openFile()</FONT>
</PRE>
<P>
Opens the statistical output file with the currently set fileName.
<PRE>
<FONT>void closeFile()</FONT>
</PRE>
<P>
Closes the statistical output file
<PRE>
<FONT>long getNewID()</FONT>
</PRE>
<P>
Returns a unique ID for constructiong a new <TT>cOutVect</TT>
object. The user should not explicitly call this function.
<PRE>
<FONT>FILE *getHandle()</FONT>
</PRE>
<P>
Returns the file pointer of the statistical output file.
<H2><A NAME="_Toc473901947">Statistical data collection: <TT><FONT SIZE=5>cStatistic</FONT></TT><FONT SIZE=5>
and derived classes</FONT></A></H2>
<P>
Header file: <TT>cstat.h</TT> (<TT>sim</TT> directory)
<P>
The statistical data collection classes: <TT>cStatistic</TT>,
<TT>cStdDev</TT>, <TT>cWeightedStdDev</TT>, <TT>cDensityEstBase</TT>,
<TT>cHistogramBase</TT>, <TT>cVarHistogram</TT>,<TT> cEqDHistogramBase</TT>,
 <TT>cLongHistogram</TT>, <TT>cDoubleHistogram, cPSquare</TT>.
and <TT>cKSplit</TT>. 
<P>
Several of those are abstract classes. The ones which are not
are:<TT> cStdDev</TT>, <TT>cVarHistogram</TT>,  <TT>cLongHistogram</TT>,
<TT>cDoubleHistogram, cPSquare</TT>. and <TT>cKSplit</TT>.
<P>
<CENTER><IMG SRC="img00022.gif"><BR>
Fig.4.1. Hierarchy of statistics collection classes</CENTER>
<H3><A NAME="_Toc473901948">class <TT><FONT SIZE=4>cStatistic</FONT></TT></A>
</H3>
<P>
<TT>cStatistic</TT> is the base class for all statistical data
collection classes. <TT>cStatistic</TT> itself adds no data members
or algorithms to <TT>cObject</TT>, it only defines virtual functions
that will be redefined in descendants. No instance of <TT>cStatistic</TT>
can be created.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cStatistic(cStatistic&amp; r);</FONT>
</PRE>
<P>
Copy constructor.
<PRE>
<FONT>cStatistic(char *s=NULL);</FONT>
</PRE>
<P>
Constructor, creates an object with the given name
<PRE>
<FONT>virtual ~cStatistic();</FONT>
</PRE>
<P>
The destructor does nothing.
<PRE>
<FONT>cStatistic&amp; operator=(cStatistic&amp; res)</FONT>
</PRE>
<P>
The assignment operator is present since descendants may refer
to it.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns a pointer to the class name string, <TT>&quot;cStatistic&quot;</TT>.
<P>
<B>New non-virtual member functions</B>
<PRE>
<FONT>void setGenK(int gen_nr);</FONT>
</PRE>
<P>
Sets the index of the random number generator to use when the
object has to generate a random number based on the statistics
stored.
<PRE>
<FONT>void addTransientDetection(cTransientDetection *object);
void addAccuracyDetection(cAccuracyDetection *object);</FONT>
</PRE>
<P>
Assigns transient and accuracy detection objects to the statistic
object.
<PRE>
<FONT>cTransientDetection *transientDetectionObject();
cAccuracyDetection  *accuracyDetectionObject();</FONT>
</PRE>
<P>
Returns the assigned transient and accuracy detection objects.
<P>
<B>New virtual member functions</B>
<P>
These pure virtual functions provide a common interface to all
<TT>cStatistic</TT> classes. 
<PRE>
<FONT>void collect(double val);</FONT>
</PRE>
<P>
Collect one value.
<PRE>
<FONT>virtual long samples();
virtual double min();
virtual double max();
virtual double mean();
virtual double variance();
virtual double stddev();</FONT>
</PRE>
<P>
In derived classes, these functions return the number of values
collected, the smallest/largest value, the mean and the standard
deviation of the collected data, respectively.
<PRE>
<FONT>virtual double random();</FONT>
</PRE>
<P>
The function generates a random number based on the collected
data.
<PRE>
<FONT>virtual void clearResult();</FONT>
</PRE>
<P>
This function should be redefined in derived classes to clear
the results collected so far.
<PRE>
<FONT>virtual void saveToFile(FILE *);</FONT>
</PRE>
<P>
Writes the contents of the object into a text file.
<PRE>
<FONT>virtual void loadFromFile(FILE *);</FONT>
</PRE>
<P>
Reads the object data from a file written out by <TT>saveToFile()</TT>(or
written &quot;by hand&quot;)
<H3><A NAME="_Toc473901949">class <TT><FONT SIZE=4>cStdDev</FONT></TT></A>
</H3>
<P>
<TT>cStdDev</TT> is designed to collect <TT>double</TT>s and calculate
data such as the minimum/maximum value, the mean and the standard
deviation for them.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cStdDev(cStdDev&amp; r);
cStdDev(char *s=NULL);
virtual ~cStdDev();
virtual cObject *dup();
cStdDev&amp; operator=(cStdDev&amp; res);</FONT>
</PRE>
<P>
Constructors, destructor, duplication and assignment.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns a pointer to the class name string, <TT>&quot;cStdDev&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();
virtual void writeContents(ostream&amp; os);</FONT>
</PRE>
<P>
Redefined <TT>cObject</TT> functions.
<PRE>
<FONT>void collect(double val);
virtual void clearResult();
virtual long samples();
virtual double min();
virtual double max();
virtual double mean();
virtual double stddev();
virtual double variance();
virtual void saveToFile(FILE *);
virtual void loadFromFile(FILE *);</FONT>
</PRE>
<P>
Redefined <TT>cStatistic</TT> functions.
<PRE>
<FONT>virtual double random();</FONT>
</PRE>
<P>
Redefined <TT>cStatistic</TT> function. <TT>cStdDev</TT>'s random
number generator returns numbers of normal disribution with the
current mean and standard deviation.
<H3><A NAME="_Toc473901950">class <TT><FONT SIZE=4>cWeightedStdDev</FONT></TT></A>
</H3>
<P>
<TT>cWeightedStdDev</TT> is designed to collect <TT>double</TT>s
and calculate weighted statistics of them.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cWeightedStdDev(cWeightedStdDev&amp; r);
cWeightedStdDev(char *s=NULL);
virtual ~cWeightedStdDev();
virtual cObject *dup();
cWeightedStdDev&amp; operator=(cWeightedStdDev&amp; res);</FONT>
</PRE>
<P>
Constructors, destructor, duplication and assignment.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns a pointer to the class name string, <TT>&quot;cWeightedStdDev&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();
virtual void writeContents(ostream&amp; os);</FONT>
</PRE>
<P>
Redefined <TT>cObject</TT> functions.
<PRE>
<FONT>void collect2(double val, double weight);</FONT>
</PRE>
<P>
New member function.
<PRE>
<FONT>virtual void clearResult();
virtual long weights();
virtual double min();
virtual double max();
virtual double mean();
virtual double stddev();
virtual double variance();
virtual void saveToFile(FILE *);
virtual void loadFromFile(FILE *);</FONT>
</PRE>
<P>
Redefined <TT>cStdDev</TT> functions.
<PRE>
<FONT>virtual double random();</FONT>
</PRE>
<P>
<TT>cWeightedStdDev</TT>'s random number generator returns numbers
of normal disribution with the current mean and standard deviation.
<H3><A NAME="_Toc473901951">class <TT><FONT SIZE=4>cDensityEstBase</FONT></TT></A>
</H3>
<P>
Common base class for density estimation classes. Provides several
pure virtual functions, so it is an abstract class, no instances
can be created.
<P>
For the histogram classes, you need to specify the number of cells
and the range. Range can either be set explicitly or you can choose
automatic range determination. 
<P>
Automatic range estimation works in the following way:
<OL>
<LI>The first few (<I>num_firstvals</I>) observations are stored.
<LI>After having collected a given number of samples, the actual
histogram is set up. The range (<I>min</I>, <I>max</I>) of the
initial values is expanded <I>range_ext_factor</I> times, and
the result will become the histogram's range (<I>rangemin</I>,
<I>rangemax</I>). Based on the range, the cells are layed out.
Then the initial values that have been stored up to this point
will be transferred into the new histogram structure and their
store is deleted -- this is done by the <TT>transform()</TT> function.
</OL>
<P>
You may also explicitly specify the lower or upper limit and have
the other end of the range extimated automatically. The <TT>setRange...()</TT>
member functions of <TT>cDensityEstBase</TT> deal with setting
up the histogram range. It also provides pure virtual functions
<TT>transform()</TT> etc.
<P>
Subsequent observations are placed in the histogram structure.
If an observation falls out of the histogram range, the <I>underflow</I>
or the <I>overflow</I> <I>cell</I> is incremented.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cDensityEstBase(cDensityEstBase&amp; r);
cDensityEstBase (char *s=NULL);
virtual ~cDensityEstBase();
cDensityEstBase&amp; operator=(cDensityEstBase&amp; res);</FONT>
</PRE>
<P>
Constructors, destructor, assignment.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className()
virtual void writeContents(ostream&amp; os);
virtual void collect(double val);
virtual void clearResult();
virtual void saveToFile(FILE *);
virtual void loadFromFile(FILE *);</FONT>
</PRE>
<P>
<B>New virtual functions</B>
<PRE>
<FONT>virtual bool transformed();
virtual void transform();</FONT>
</PRE>
<P>
First one returns whether the object is transformed or not; second
one forces a transformation.
<PRE>
<FONT>virtual unsigned cells();
virtual double basepoint(unsigned k);
virtual unsigned cell(unsigned k);
virtual double cellPDF(unsigned k);</FONT>
</PRE>
<P>
Obtaining histogram data out of the object.
<PRE>
<FONT>virtual void setRange(double lower, double upper);
virtual void setRangeAuto(int num_firstvals, 
double range_ext_fact);
virtual void setRangeAutoLower(double upper, 
int num_firstvals, double range_ext_fact);
virtual void setRangeAutoUpper(double lower, 
int num_firstvals, double range_ext_fact);
virtual void setNumFirstVals(int num_firstvals);</FONT>
</PRE>
<P>
Range setting.
<PRE>
<FONT>virtual double pdf(double x) = 0;
virtual double cdf(double x) = 0;</FONT>
</PRE>
<P>
Density function and cumulated density function at a given <I>x</I>.
<PRE>
<FONT>virtual unsigned long underflowCell()
virtual unsigned long overflowCell()</FONT>
</PRE>
<P>
Returns number of observations that fall out of the histogram
range.
<H3><A NAME="_Toc473901952">Class <TT><FONT SIZE=4>cHistogramBase</FONT></TT></A>
</H3>
<P>
Base class for histogram classes.
<H3><A NAME="_Toc473901953">Class <TT><FONT SIZE=4>cVarHistogram</FONT></TT></A>
</H3>
<P>
Variable bin size histogram You may add cell (bin) boundaries
manually, or .let the object create cells with equal number of
observations in them (or as close to that as possible).
<P>
<B>Constructor</B>
<PRE>
<FONT>cVarHistogram(char *s=NULL, int numcells=11,
int transformtype=HIST_TR_AUTO_EPC_DBL);</FONT>
</PRE>
<P>
The third argument can be one of <TT>HIST_TR_NO_TRANSFORM</TT>,
<TT>HIST_TR_AUTO_EPC_DBL</TT>, <TT>HIST_TR_AUTO_EPC_INT</TT>.
<P>
<B>New member function</B>
<PRE>
<FONT>virtual void addBinBound(double x);</FONT>
</PRE>
<P>
If <TT>HIST_TR_NO_TRANSFORM</TT> was passed in the constructor
call, you may specify cell (bin) bounds manually before collection
starts.
<H3><A NAME="_Toc473901954">Class <TT><FONT SIZE=4>cEqdHistogramBase</FONT></TT></A>
</H3>
<P>
Base class for equal cell size histograms.
<H3><A NAME="_Toc473901955">class <TT><FONT SIZE=4>cLongHistogram</FONT></TT></A>
</H3>
<P>
<TT>cLongHistogram</TT> is derived from <TT>cEqdHistogramBase</TT>
which contains most of the functionality. The histogram is set
up in the following way:
<UL>
<LI>the cell size is always integer: 1, 2, 3 etc.
<LI><I>rangemin</I>, <I>rangemax</I> and the cell boundaries are
at halfs. For example 1.5, 10.5. This is done so to prevent misunderstandings.
<LI>the number of cells is exactly <I>num_cells</I>
<LI>the <I>range_ext_factor</I> is also kept. The actual histogram
range will be: (<I>min</I>, <I>max</I>) extended <I>range_ext_factor</I>
times and rounded up to the nearest integer multiple of <I>num_cells</I>.
</UL>
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cLongHistogram(cLongHistogram&amp; r);</FONT>
</PRE>
<P>
Copy constructor.
<PRE>
<FONT>cLongHistogram(char *s=NULL, unsigned num_cells=10)</FONT>
</PRE>
<P>
Constructor that takes the object name and the number of cells.
<PRE>
<FONT>virtual ~cLongHistogram();</FONT>
</PRE>
<P>
Destructor.
<PRE>
<FONT>virtual cObject *dup();
cLongHistogram&amp; operator=(cLongHistogram&amp; res);</FONT>
</PRE>
<P>
Duplication and assignment work all right with <TT>cLongHistogram</TT>.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns a pointer to the class name string, <TT>&quot;cLongHistogram&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<PRE>
<FONT>virtual void transform();</FONT>
</PRE>
<P>
If the result collection is in the first phase, transforms the
values into histogram. If already in the second phase, the function
does nothing.
<PRE>
<FONT>virtual unsigned cells();</FONT>
</PRE>
<P>
Returns the number of cells.
<PRE>
<FONT>virtual double basepoint(unsigned k);</FONT>
</PRE>
<P>
Returns the kth basepoint.
<PRE>
<FONT>virtual unsigned cell(unsigned k);</FONT>
</PRE>
<P>
Returns the number of samples that fell into the kth subinterval.
<PRE>
<FONT>virtual double cellPDF(unsigned k);</FONT>
</PRE>
<P>
Returns the calculated PDF in the kth subinterval.
<PRE>
<FONT>virtual double random();</FONT>
</PRE>
<P>
Returns a random number based on the distribution collected. If
no values have been collected, it returns 0; when in initial collection
phase, it returns one of the stored observations; after the histogram
has been set up, a random integer is returned.
<PRE>
<FONT>virtual void clearResult ();</FONT>
</PRE>
<P>
Clears all results collected so far.
<H3><A NAME="_Toc473901956">class <TT><FONT SIZE=4>cDoubleHistogram</FONT></TT></A>
</H3>
<P>
<TT>cDoubleHistogram</TT> is derived from <TT>cEqdHistogramBase</TT>;
see that for more information.
<P>
<B>Construction, destruction, copying</B>
<PRE>
<FONT>cDoubleHistogram(cDoubleHistogram&amp; r);</FONT>
</PRE>
<P>
Copy constructor
<PRE>
<FONT>cDoubleHistogram (char *s=NULL, unsigned int num_cells=10);</FONT>
</PRE>
<P>
Constructor that takes the object name, the number of subintervals
and the range factor as argument.
<PRE>
<FONT>virtual ~cDoubleHistogram();</FONT>
</PRE>
<P>
Destructor.
<PRE>
<FONT>virtual cObject *dup();
cDoubleHistogram&amp; operator=(cDoubleHistogram&amp; res);</FONT>
</PRE>
<P>
Duplication and assignment work all right with <TT>cDoubleHistogram</TT>.
<P>
<B>Redefined virtual functions</B>
<PRE>
<FONT>virtual char *className();</FONT>
</PRE>
<P>
Returns a pointer to the class name string, <TT>&quot;cDoubleHistogram&quot;</TT>.
<PRE>
<FONT>virtual void info(char *buf);
virtual char *inspectorFactoryName();</FONT>
</PRE>
<P>
Redefined.
<PRE>
<FONT>virtual void writeContents(ostream&amp; os);</FONT>
</PRE>
<P>
Writes the object contents to the stream.
<PRE>
<FONT>virtual void transform();</FONT>
</PRE>
<P>
If the result collection is in the first phase, transforms the
values into histogram. If already in the second phase, the function
does nothing.
<PRE>
<FONT>virtual unsigned cells();</FONT>
</PRE>
<P>
Returns the number of cells.
<PRE>
<FONT>virtual double basepoint(unsigned k);</FONT>
</PRE>
<P>
Returns the <I>k</I>th basepoint.
<PRE>
<FONT>virtual unsigned cell(unsigned k);</FONT>
</PRE>
<P>
Returns the number of samples that fell into the kth subinterval.
<PRE>
<FONT>virtual double cellPDF(unsigned k);</FONT>
</PRE>
<P>
Returns the calculated PDF in the kth subinterval.
<PRE>
<FONT>virtual double random();</FONT>
</PRE>
<P>
Returns a random number based on the distribution collected. If
no values have been collected, it returns 0; when in initial collection
phase, it returns one of the stored observations; after the histogram
has been set up, a random integer is returned.
<PRE>
<FONT>virtual void clearResult();</FONT>
</PRE>
<P>
Clears the distribution collected so far.
<H2><A NAME="_Toc473901957">The P<SUP>2</SUP> and k-split algorithms:
<TT><FONT SIZE=5>cPSquare, cKSplit</FONT></TT></A></H2>
<P>
Header file: <TT>cpsquare.h, cksplit.h</TT> (<TT>sim</TT> directory)
<H3><A NAME="_Toc473901958">class <TT><FONT SIZE=4>cPSquare</FONT></TT></A>
</H3>
<P>
Implements the P<SUP>2</SUP> algorithm.
<H3><A NAME="_Toc473901959">class <TT><FONT SIZE=4>cKSplit</FONT></TT></A>
</H3>
<P>
Implements the k-split algorithm.
<H2><A NAME="_Toc473901960">Transient and result accuracy detection</A>
</H2>
<P>
Header file: <TT>cdetect.h</TT> (<TT>sim</TT> directory)
<P>
Detection of the end of the transient period and a certain result
accuracy is supported by OMNeT++. The user can attach transient
detection and result accuracy objects to a result object (<TT>cStatistic</TT>'s
descendants).
<H3><A NAME="_Toc473901961">class <TT><FONT SIZE=4>cTransientDetection</FONT></TT></A>
</H3>
<P>
Virtual base class for transient detection.
<H3><A NAME="_Toc473901962">class <TT><FONT SIZE=4>cTDExpandingWindows</FONT></TT></A>
</H3>
<P>
An algorithm for transient detection. Uses sliding window approach
with two windows, and checks the difference of the two averages
to see if the transient period is over.
<H3><A NAME="_Toc473901963">class <TT><FONT SIZE=4>cAccuracyDetection</FONT></TT></A>
</H3>
<P>
Virtual base class for result accuracy detection.
<H3><A NAME="_Toc473901964">class <TT><FONT SIZE=4>cADByStddev</FONT></TT></A>
</H3>
<P>
An algorithm for result accuracy detection. The actual algorithm:
divide the standard deviation by the square of the number of values
and check if this is small enough.
<H2><A NAME="_Toc473901965">Finite State Machine: <TT><FONT SIZE=5>cFSM</FONT></TT></A>
</H2>
<P>
<TT>cFSM</TT> is not yet documented here. See the User Manual.
<H2><A NAME="_Toc473901966">Routing support: <TT><FONT SIZE=5>cTopology</FONT></TT></A>
</H2>
<P>
<TT>cTopology</TT> is not yet documented here. See the User Manual.
<H2><A NAME="_Toc473901967">The user interface: <TT><FONT SIZE=5>cEnvir</FONT></TT><FONT SIZE=5>
and </FONT><TT><FONT SIZE=5>ev</FONT></TT></A></H2>
<P>
Header file: <TT>cenvir.h</TT> (<TT>envir</TT> directory)
<P>
<TT>cEnvir</TT> is the user interface class. <TT>cEnvir</TT> is
not a descendant of <TT>cObject</TT> and there is only one instance
of <TT>cEnvir</TT>, <TT>ev</TT>. <TT>ev</TT> is a static object.
All I/O is done via the member functions of <TT>ev</TT>. 
<H3><A NAME="_Toc473901968">class <TT><FONT SIZE=4>cEnvir</FONT></TT></A>
</H3>
<P>
<B>Construction, destruction</B>
<PRE>
<FONT>cEnvir();
~cEnvir();</FONT>
</PRE>
<P>
The constructor and the destructor in most cases do nothing.
<P>
<B>User interface functions</B>
<PRE>
<FONT>void inspect(cObject *object);</FONT>
</PRE>
<P>
Creates an inspector window for the object.
<PRE>
<FONT>void objectDeleted(cObject *object);</FONT>
</PRE>
<P>
Notifies the environment that the object no longer exists. The
user interface should close all inspector windows for the object
and remove it from object lists currently displayed. <TT>cObject</TT>'s
destructor automatically calles this function.
<PRE>
<FONT>void messageSent(cMessage&amp; msg);</FONT>
</PRE>
<P>
Notifies the environment that a message has been sent. The user
interface then can display the message in a text window, animate
the message's travel in the network's drawing. activate conditional
breakpoints and so on. This function is automatically called right
after <TT>cSimpleModule</TT>'s <TT>send()</TT> placed the message
into the future events' queue.
<P>
<B>Module function I/O</B>
<PRE>
<FONT>void printfmsg(char *fmt,...);</FONT>
</PRE>
<P>
Displays a message in dialog box. This function should not be
used too much by simple modules, if ever.
<PRE>
<FONT>void printf(char *fmt=&quot;\n&quot;,...);</FONT>
</PRE>
<P>
Simple modules can output text into their own window through this
function. The text  is expected in <TT>printf()</TT> format (format
string + arguments).
<PRE>
<FONT>void puts(char *s);</FONT>
</PRE>
<P>
Similar to <TT>cEnvir::printf()</TT>, but just writes out its
argument string with no formatting.
<PRE>
<FONT>bool askf(char *buf, int len, char *profmt,...);</FONT>
</PRE>
<P>
Pops up a dialog, displays the message given in 'profmt' and following
arguments in <TT>printf()</TT> format and reads a line (maximum
<TT>len</TT> characters) from the user into the buffer 'buf'.
Returns <TT>true</TT> if the user pressed the Cancel button.
<PRE>
<FONT>bool gets(char *prompt, char *buf, int len=255);</FONT>
</PRE>
<P>
Similar to <TT>cEnvir::askf()</TT>, but just writes out the prompt
message string with no formatting.
<PRE>
<FONT>bool askyesno(char *msgfmt,...);</FONT>
</PRE>
<P>
Puts a yes/no question to the user. The question itself  is expected
in the <TT>printf()</TT> format (format string + arguments). The
<TT>true</TT> return value means yes, <TT>false</TT> means no.
<PRE>
<FONT>cEnvir&amp; prompt(char *s);</FONT>
</PRE>
<P>
Sets the prompt for subsequent <TT>&gt;&gt;</TT> operators. There
is only one global prompt text that is shared between all simple
modules, so between setting the prompt string and asking the user,
no <TT>receive()</TT>, <TT>peekmsg()</TT>, <TT>messages()</TT>
or <TT>wait()</TT> call is recommended. Or, the user may experience
funny things. . .
<PRE>
<FONT>char *prompt();</FONT>
</PRE>
<P>
Returns the prompt string.
<P>
<B>Overloaded operators</B>
<P>
Overloaded operators provide iostream-like I/O for <TT>cEnvir</TT>.
<PRE>
<FONT>inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, signed char *s);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, unsigned char *s);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, unsigned char c);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, signed char c);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, short i);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, unsigned short i);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, int i);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, unsigned int i);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, long l);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, unsigned long l);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, float f);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, double d);
inline cEnvir&amp; operator&lt;&lt; (cEnvir&amp; ev, long double d);</FONT>
</PRE>
<P>
Output operators for all fundamental data types.
<PRE>
<FONT>inline cEnvir&amp; operator* (cEnvir&amp; ev, signed char *s);
inline cEnvir&amp; operator* (cEnvir&amp; ev, unsigned char *s);</FONT>
</PRE>
<P>
The <TT>*</TT> operator can be used to replace <TT>ev.prompt()</TT>.
For example: 
<PRE>
<FONT>			ev * &quot;How many?&quot; &gt;&gt; n;
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, signed char *s);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, unsigned char *s);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, char&amp; c);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, unsigned char&amp; c);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, short&amp; i);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, int&amp; i);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, long&amp; l);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, unsigned short&amp; i);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, unsigned int&amp; i);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, unsigned long&amp; l);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, float&amp; f);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, double&amp; d);
inline cEnvir&amp; operator&gt;&gt; (cEnvir&amp; ev, long double&amp; d);</FONT>
</PRE>
<P>
Input operators for all fundamental data types. But beware, each
&gt;&gt; operator reads a whole line!
<H2><A NAME="_Toc473901969">Classes not described in this reference</A>
</H2>
<P>
<TT><B><FONT>cSimulation</FONT></B></TT>
<P>
A class that holds the module tree of the network being simulated.
It has only one instance, simulation.
<P>
<TT><B><FONT>cModuleType</FONT></B></TT>
<P>
Class for simple module types.
<P>
<TT><B><FONT>cLinkType</FONT></B></TT>
<P>
Class for channel types.
<P>
<TT><B><FONT>cFunctionType</FONT></B></TT>
<P>
Class for function types. Used by the code generated by NEDC.
<P>
<TT><B><FONT>cNetworkType</FONT></B></TT>
<P>
Class for pre-compiled networks.
<P>
<TT><B><FONT>cClassRegister</FONT></B></TT>
<P>
Class for registering a class.
<HR><H1><A NAME="_Toc473901970">References</A></H1>
<P>
<B>Simulation-related</B>
<P>
[JAIN91] Jain, Raj: <I>The Art of Computer Systems Performance
Analysis</I>. Wiley, New York, 1991.
<P>
[BFS86] Bratley P., Fox, B. L. and Schrage, L. E.: <I>A Guide
to Simulation</I>. Springer-Verlag, New York, 1986.
<P>
[JCH85] Jain, Raj and Chlamtac, Imrich: <I>The P<SUP>2</SUP> Algorithm
for Dynamic Calculation of Quantiles and Histograms without Storing
Observations</I>, Communications of the ACM, 28(10), 1076-1085,
1985.
<P>
[PON91] Pongor, Gy<FONT>&ouml;rgy</FONT>:
<I>OMNET: An Object-Oriented Network Simulator</I>. 1991 ??
<P>
[PON92] Pongor, Gy<FONT>&ouml;rgy</FONT>:
<I>Statistical Synchronisation: A Different Approach of Parallel
Discrete Event Simulation</I>. Lappeenranta University of Technology,
Data Communications Laboratory, Lappeenranta, Finland, 1992
<P>
[PON93] Pongor, Gy<FONT>&ouml;rgy</FONT>:
<I>On the Efficiency of the Statistical Synchronisation Method</I>.
European Simulation Symposium (ESS'93), Delft, The Netherlands,
Oct. 25-28, 1993
<P>
[KOF95] Kofoed, Stig: <I>Portable Multitasking in C++</I>. Dr.
Dobb's Journal, November 1995.  <TT>ftp://ftp.mv.com/pub/ddj/1995/1995.11/mtask.zip</TT>
<P>
<B>OMNeT++-related research papers</B>
<P>
[VAR98a] <I>&quot;K-split - On-Line Density Estimation for Simulation
Result Collection&quot;</I>. Andr&aacute;s Varga. To appear in
the Proceedings of the European Simulation Symposium (ESS'98).
October 26-28, 1998. Nottingham, UK.
<P>
[VAR98b] <I>&quot;Parametrized Topologies for Simulation Programs&quot;</I>.
Andr&aacute;s Varga. In the Proceedings of the Western Multiconference
on Simulation (WMC'98) / Communication Networks and Distributed
Systems (CNDS'98). January 11-14, 1998. San Diego, CA.
<P>
[V&amp;F97] <I>&quot;The K-Split Algorithm for the PDF Approximation
of Multi-Dimensional Empirical Distributions without Storing Observations&quot;</I>.
Andr&aacute;s Varga and Babak Fakhamzadeh. In Proceedings of the
9th European Simulation Symposium (ESS'97), pp.94-98. October
19-22 1997, Passau, Germany.
<P>
[V&amp;P97] <I>&quot;Flexible Topology Description Language for
Simulation Programs&quot;</I>. Andr&aacute;s Varga and Gy&ouml;rgy
Pongor. In Proceedings of the 9th European Simulation Symposium
(ESS'97), pp.225-229. October 19-22 1997, Passau, Germany.
<P>
<B>Former OMNeT++ documents</B>
<P>
[OMN1] Vass Zolt&aacute;n.: <I>PVM Extension of OMNeT++ to Support
Statistical Synchronisation</I>. Diploma Thesis, Technical University
of Budapest, 1996 (in Hungarian).
<P>
[OMN2] Andr&eacute; Maurits, George van Montfort and Gerard van
de Weerd: <I>OMNeT++ extensions and examples</I>. Technical University
of Budapest, Dept. of Telecommunications, 1995.
<P>
[OMN3] Jan Heijmans, Alex Paalvast, Robert van der Leij: <I>Network
simulation using the JAR compiler for the OMNeT++ simulation system</I>.
Technical University of Budapest, Dept. of Telecommunications,
1995.
<P>
[OMN4] Varga Andr<FONT>&aacute;s</FONT>.:
<I>OMNeT++ - Portable User Interface for the OMNeT++ Simulation
System</I>. Diploma Thesis, Technical University of Budapest,
1994 (in Hungarian).
<P>
[OMN5] Lencse G&aacute;bor: <I>Graphical Network Editor for OMNeT++</I>.
Diploma Thesis, Technical University of Budapest, 1994 (in Hungarian).
<P>
[OMN6] Varga Andr<FONT>&aacute;s</FONT>.:
<I>OMNeT++ - Portable Simulation Environment in C++</I>. TDK work,
Technical University of Budapest, 1992 (in Hungarian).
<P>
<B>Other simulation software</B>
<P>
TBD
<P>
<B>C++ language</B>
<P>
Too many books to list.
<P>
<B>Cyg-Win32</B>
<P>
[CYGWIN] <TT>http://sourceware.cygnus.com/cygwin/top.html</TT>
<P>
<B>DJGPP</B>
<P>
[DJGPP1] Official DJGPP Home Page: <TT>http://www.delorie.com/djgpp</TT>
<P>
<B>PVM</B>
<P>
[PVM1] The Official PVM Home Page. <TT>http://www.epm.ornl.gov/pvm/pvm_home.html</TT>
<P>
[PVM2] <TT>http://www.sp2.uni-c.dk/PVM/PvmIntro.html</TT>
<P>
[PVM3] <TT>http://www.cse.ogi.edu/DISC/projects/mist/related-work/pvm.html</TT>
<P>
<B>Turbo Vision</B>
<P>
[TV1] <I>Borland C++ 3.1 Manuals</I>. Borland International, 1992.
<P>
[TV2] The TVPlus Archieve. <TT>http://wvnvm.wvnet.edu/~u6ed4/tvhome.htm</TT>
<P>
[TV3] Sierwald, Joern: 32-bit Portable Turbo Vision. <TT>http://wvnvm.wvnet.edu/~u6ed4/tvptsier.htm</TT>
<P>
<B>TCL/TK</B>
<P>
[TCLTK1] Welch, Brent: <I>Practical Programming in Tcl and Tk</I>.
Prentice-Hall, 1995
<P>
[TCLTK2] HyperTcl. <TT>http://web.cs.ualberta.ca/~wade/HyperTcl/</TT>
<P>
[TCLTK3] TCL WWW Info. <TT>http://www.sco.com/Technology/tcl/Tcl.html</TT>
<P>
<B>Gnuplot</B>
<P>
[GPLOT1] Brief tutorial:<BR>
<TT>http://nacphy.physics.orst.edu/DATAVIS/datavis.html</TT>
<P>
[GPLOT2] Reference:<BR>
<TT>http://www.cm.cf.ac.uk/Latex/Gnuplot/gnuplot.html</TT>
<P>
[PMTV1] PlotMTV:<BR>
<TT>http://cauchy.math.edu/workshop/Plotmtv/plotmtv.html</TT>
<P>
<B>Xmgr</B>
<P>
[XMGR1] Brief tutorial:<BR>
<TT>http://nacphy.physics.orst.edu/DATAVIS/xmgr.html<BR>
<BR>
</TT>


</BODY>
</HTML>
