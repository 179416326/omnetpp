<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "custom-docbook.dtd">
<chapter id="_custom_wizards">

<title>Custom wizards</title>
<section id="_motivation">
<title>MOTIVATION</title>
<simpara>TODO: mire szolgal; kinek kellene ilyet csinalni es mi celbol&#8230;</simpara>
<simpara>The OMNeT<literal> IDE offers several wizards via the File|New menu: New OMNeT</literal>
Project, New Simple Module, New Compound Module, New Ini File, and so on.
By default these wizards already offer useful functionality to the user,
but using the information in this chapter, it is possible to add to them
new UI elements and content templates that are specific to simulation models.
For example, one can create a New INET Ad-Hoc Network wizard, a New MiXiM
Simulation Wizard, an Import INET Network From CSV File wizard, a
New MiXiM Radio Model wizard, and so on.</simpara>
<simpara>These wizards can be prepared with low effort and without any Java or C++
programming, and can be distributed with the corresponding model framework
(i.e. INET or MiXiM). When end users import the model framework project
into the IDE, the wizards get automatically contributed to the corresponding
wizard dialogs; the end user does not need to install them or otherwise do
anything to deploy the wizards.</simpara>
<simpara>When you are writing a model framework which will be available for the
general public, wizards are a great way to teach your users about your
simulation model. While documentation and example simulations are somewhat
passive ways of educating your users, wizards are more interactive and
encourage users to experiment with the model and explore its capabilities.
The right set of capable wizards can give a jump start to users, and
emphasizes learning by doing.</simpara>
</section>
<section id="_overview">
<title>OVERVIEW</title>
<simpara>Custom wizards are read from the templates/ folder of OMNeT++ projects.</simpara>
<simpara>Wizards are implemented by mixing a templating engine (for generating
the output files) and a GUI description language (for custom wizard pages).
Because of the use of a templating engine, we&#8217;ll also refer to custom
wizards are "content templates".</simpara>
<simpara>In the templates/ folder, every subfolder that contains a template.properties
file is treated as a content template. (Other folders are ignored.) Every
content template folder may contain several types of files: the
template.properties file contains general information about the wizard;
*.ftl files are template files that will be copied (without the .ftl extension)
into the target folder after template variable substitution; *.xswt files
describe custom wizard pages. More rarely used files are *.fti (template
include) files included by *.ftl files; and *.jar files that can be used
to extend the wizard&#8217;s functionality with dynamically loaded Java code.
All other files are regarded as files that have to be copied into the
target folder verbatim when the wizard runs. The wizard folder may contain
subdirectories which may also contain files of the above type (except
template.properties of course).</simpara>
<simpara>When the template is used, the contents of the template folder (and subfolders)
will be copied over into the new project preserving the directory structure,
with the exception of template.properties and other known special-purpose files.
(It is also possible to specify other files and folders to ignore during copying.)</simpara>
<simpara>Files with the ".ftl" extension are regarded as templates, and they will undergo
template processing (and the ".ftl" extension gets chopped off) before copying.
Other files are copied verbatim.</simpara>
<simpara>When the wizard is being used, a pool of variables is kept by the wizard dialog.
These variables are the ones which will be eventually substituted into the <emphasis role="strong">.ftl
lines in the template.propeties files; they can get displayed and/or edited
on custom wizard pages; and eventually they get substituted into *.ftl files.
Some variables have special meaning and are interpreted by the wizard dialog
(e.g. the nedSrcFolders variable determines which folders get denoted as
NED Source Folders by the New OMNeT++ Project wizard). Variables can be used
to generate output file names, can be used as input file names, and can serve
as input and working variables for arbitrarily complex algorithms programmed
in the template (</emphasis>.ftl) files.</simpara>
</section>
<section id="_template_processing">
<title>TEMPLATE PROCESSING</title>
<simpara>Template processing uses the FreeMarker library (<ulink url="http://freemarker.org">http://freemarker.org</ulink>), and
all template syntax supported by FreeMarker can be used. Especially, variable</simpara>
<simpara>The FreeMarker language also offers constructs that make it a full programming
language: variable assigments, conditionals, loops, switch statement,
functions, macros, expression evaluation, built-in operators, etc, as well
as access to fields and methods of classes defined in Java. This means that
any algorithm can be expressed in the FreeMarker language, and if that would
not be enough, one can also pull in existing or custom-written Java libraries.</simpara>
<simpara>The following variables are predefined:</simpara>
<variablelist>
<varlistentry>
<term>
templateName
</term>
<listitem>
<simpara>
name of the template (see later)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateDescription
</term>
<listitem>
<simpara>
template description (see later)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateCategory
</term>
<listitem>
<simpara>
template category (see later)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
date
</term>
<listitem>
<simpara>
current date in yyyy-mm-dd format
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
year
</term>
<listitem>
<simpara>
year in yyyy format
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
author
</term>
<listitem>
<simpara>
user name ("user.name" Java system property)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
licenseCode
</term>
<listitem>
<simpara>
license identifier for the @license NED property
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
licenseText
</term>
<listitem>
<simpara>
copyright notice for the given license
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
bannerComment
</term>
<listitem>
<simpara>
banner comment for source files; includes license text
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateFolderName
</term>
<listitem>
<simpara>
name of the folder in which the template files are
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateFolderPath
</term>
<listitem>
<simpara>
workspace path of the folder in which the template files are
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateProject
</term>
<listitem>
<simpara>
name of the project that defines the template
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The New OMNeT++ Project wizard also defines the following variables:</simpara>
<variablelist>
<varlistentry>
<term>
projectName, rawProjectName
</term>
<listitem>
<simpara>
                        the project name, "as is"
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
ProjectName
</term>
<listitem>
<simpara>
sanitized project name with first letter capitalized
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
projectname
</term>
<listitem>
<simpara>
sanitized project name in all lowercase
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
PROJECTNAME
</term>
<listitem>
<simpara>
sanitized project name in all uppercase
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>sanitization means making the name suitable as a NED or C/C++ identifier
(spaces, punctuation and other unfit chars replaced with underscore, etc.)</simpara>
<simpara>Other variables may come from custom template pages, see later.</simpara>
</section>
<section id="_the_template_properties_file">
<title>THE TEMPLATE.PROPERTIES FILE</title>
<simpara>The template.properties file is a standard Java property file (key=value syntax).
That file can be used to supply a template name, a template description,
and various other options.</simpara>
<simpara>Recognized property file keys:</simpara>
<variablelist>
<varlistentry>
<term>
templateName
</term>
<listitem>
<simpara>
The template&#8217;s display name; defaults to the folder name.
                This is the name that appears in the wizard&#8217;s template selection
                page.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateDescription
</term>
<listitem>
<simpara>
                Description of the template. This may appear as a tooltip
                or in a description pane in the wizard.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateCategory
</term>
<listitem>
<simpara>
                Template category is used for organizing the templates into a
                tree in the wizard&#8217;s template selection page. Defaults to the
                name of the project that provides the template.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
templateImage
</term>
<listitem>
<simpara>
                Name of the icon that appears with the name in the wizard&#8217;s
                template selection page.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
supportedWizardTypes
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of wizard types (e.g.
                "nedfile", "simplemodule", "project", "inifile") that
                this template supports. More about this later.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
ignoreResources
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of non-template files or
                folders; those files won&#8217;t get copied over to the new project.
                Wildcards are accepted. The template.properties file and
                custom wizard page files automatically count as nontemplates,
                so they don&#8217;t have to be listed.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The "New OMNeT++ Project" wizard also recognizes the following options. These
options can be overridden from custom wizard pages.</simpara>
<variablelist>
<varlistentry>
<term>
addProjectReference
</term>
<listitem>
<simpara>
                True or false; defaults to true. If true, the template&#8217;s project
                will be added to the referenced projects list of the new project.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
sourceFolders
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of C++ source folders
                to be created and configured. By default, none.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
nedSourceFolders
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of NED source folders
                to be created and configured. By default, none.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
makemakeOptions
</term>
<listitem>
<simpara>
                Comma-separated list of items in the syntax "folder:options",
                or a JSON-syntax map of strings; it sets opp_makemake options
                for the given folders. There is no default.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>There are additinal options for adding custom pages into the wizard, as described
in the next section.</simpara>
</section>
<section id="_custom_wizard_pages">
<title>CUSTOM WIZARD PAGES</title>
<simpara>The following properties can be used to define custom pages in the wizard. &lt;i&gt; is
an integer page ID; their ordering defines the order of wizard pages.</simpara>
<variablelist>
<varlistentry>
<term>
page.&lt;i&gt;.file
</term>
<listitem>
<simpara>
                The name of the XSWT file that describes the wizard page layout.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
page.&lt;i&gt;.title
</term>
<listitem>
<simpara>
                Title of the wizard page, displayed in the page&#8217;s title area.
                Defaults to the template name.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
page.&lt;i&gt;.description
</term>
<listitem>
<simpara>
                Description of the wizard page, shown in the dialog&#8217;s title area
                below the title. Defaults to text in the format "Page 1 of 3".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
page.&lt;i&gt;.condition
</term>
<listitem>
<simpara>
                A condition for showing the page. If it evaluates to false, the
                page will be skipped when it would normally come in the page
                sequence of the wizard. This makes it possible not only to skip
                pages, but also to show different pages based on some choice
                or choices the user made earlier in the wizard (decision tree).
                The condition will be evaluated by the template engine, so any
                valid FreeMarker expression that can produce true or "true" as
                a result will do. The expression must be supplied without the
                ${ and } marks: the string you enter will be substituted into
                "${( &lt;condition&gt; )?string}" string (will replace "&lt;condition&gt;"),
                and evaluate as such. An example will be provided later.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>All property file entries are available as template variables too. Also, most
property values may refer to other property values or template variables, using</simpara>
<simpara>Custom wizard pages are defined in XSWT (<ulink url="http://xswt.sourceforge.net">http://xswt.sourceforge.net</ulink>,
<ulink url="http://www.coconut-palm-software.com/the_new_visual_editor/doku.php?id=xswt:home">http://www.coconut-palm-software.com/the_new_visual_editor/doku.php?id=xswt:home</ulink>).</simpara>
<note><simpara>In the future, Java-based custom wizard pages will also be supported.
        XSWT has the advantage that it maps one-to-one to SWT, and a .xswt file
        can be easily machine-translated to equivalent Java source code. Another
        advantage of XSWT is that it supports custom widgets and classes seamlessly,
        via a Java-like import resolution mechanism and the use of Java reflection.</simpara></note>
<note><simpara>Currently we use XSWT 1.1.2. Newer XSWT integration builds from
        <ulink url="http://www.coconut-palm-software.com/~xswt/integration/plugins/">http://www.coconut-palm-software.com/~xswt/integration/plugins/</ulink>
        did not work out well.</simpara></note>
</section>
<section id="_binding_of_template_variables_to_widgets">
<title>BINDING OF TEMPLATE VARIABLES TO WIDGETS</title>
<simpara>XSWT allows one to tag widgets with id attributes. Widget IDs will become the
names of template variables, with the values being the content of widgets.
For example, text widgets (org.eclipse.swt.widgets.Text) provide a string value
(Java type "String"), while checkboxes and radio buttons provide a boolean
(Java type "Boolean").</simpara>
<simpara>XSWT also allows filling up the widgets with default values, but this feature
should be used with care, because the defaults set in XSWT may not make it
to the file templates! This is so because if the user clicks Finish early,
the rest of the wizard pages (and their widgets) may not be created at all,
so values set in the XSWT will take no effect.</simpara>
<simpara>For this reason, defaults should ALWAYS be set in the property file. To do so,
simply use a key with the ID of the widget; those values will be written
into the wizard page when the page is created. For example, if you have a
text widget with id="numNodes" and a checkbox with id="generateTraffic", then
the following lines</simpara>
<literallayout class="monospaced">numNodes = 100
generateTraffic = true</literallayout>
<simpara>will fill in the text widget with "100" and select the checkbox. Widgets that
do not have such lines in the propery file will be left alone.</simpara>
<simpara>Compound data structures (arrays, maps, and any combination of them) can be
specified in the JSON syntax (<ulink url="http://json.org">http://json.org</ulink>). They can be iterated over
in the templates, and can be used as input/output for custom compound widgets.
Examples:</simpara>
<literallayout class="monospaced">apps = ["ftp", "smtp", "news"]
layers = {"datalink":"ieee80211", "network":"ip", "transport":["tcp","udp"]}</literallayout>
<simpara>The property file takes precedence over values in the XSWT file.</simpara>
</section>
<section id="_xswt_data_binding">
<title>XSWT DATA BINDING</title>
<simpara>This is the way how values get transferred between widgets and template
variables (R=read, W=write):</simpara>
<variablelist>
<varlistentry>
<term>
Button
</term>
<listitem>
<simpara>
This SWT class represents buttons, checkboxes and radio
                buttons, depending on its style attribute (SWT.PUSH,
                SWT.CHECK, SWT.RADIO).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: the string "true" selects the checkbox/radiobutton,
                   everything else clears it.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns a Boolean.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Combo, CCombo
</term>
<listitem>
<simpara>
Represent a combo box and a custom combo box. It can be
                made read-only (with the SWT.READ_ONLY style); a read-only
                combo only allows list selection but no manual editing.
                The list items can be specified from XSWT. Variables only
                work with the textedit part (cannot add/remove list items).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: the string value gets written into the combo. If the combo
                   is read-only and contains no such item, nothing happens.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the currently selected item as string.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
DateTime
</term>
<listitem>
<simpara>
A widget for editing date/time.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string in the following format: "yyyy-mm-dd hh:mm:ss".
                   If the string is not in the right format, an error occurs.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns a string in the same format, "yyyy-mm-dd hh:mm:ss".
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Label
</term>
<listitem>
<simpara>
Label widget (not interactive).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: sets the label to the string
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the label
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
List
</term>
<listitem>
<simpara>
A listbox widget that allows selection of one or more items,
                depending on the style attribute (SWT.SINGLE or SWT.MULTI).
                List items can be specified from XSWT. Template variables only
                work with the selection (cannot add/remove list items).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with comma-separated items, and selects the
                   corresponding item(s) in the listbox. Items that are not
                   among the listbox items are ignored.
</simpara>
</listitem>
<listitem>
<simpara>
R: Returns a string array object (String[]) that can be
                   iterated over in the template.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Link
</term>
<listitem>
<simpara>
A label with hyperlink-like functionality; not very useful for
                our purposes. Handled similarly to Label.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Scale
</term>
<listitem>
<simpara>
A graphical widget for selecting a numeric value.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts strings with an integer value. Non-numeric strings
                   will cause an error (a message dialog will be displayed).
</simpara>
</listitem>
<listitem>
<simpara>
R: returns an Integer which can be used in arithmetic
                   expressions in the template.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Slider
</term>
<listitem>
<simpara>
A scrollbar-like widget for selecting a positive numeric value.
                Handled in a similar way as Scale.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Spinner
</term>
<listitem>
<simpara>
Similar to a textedit, but contains little up and down arrows,
                and can be used to input an integer number.
                Handled in a similar way as Scale.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
StyledText
</term>
<listitem>
<simpara>
A textedit widget which allows displaying and editing of
                styled text. Handled similarly to Text.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Text
</term>
<listitem>
<simpara>
A textedit widget. It can be single-line or multi-line,
                depending on the style attribute (SWT.SINGLE, SWT.MULTI).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a (potentially multi-line) string.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the edited text as a string.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<simpara>Table and tree widgets are currently not supported in a useful way, the main
reason being that SWT Tables and Trees are not editable by default.</simpara>
<simpara>Some non-interactive widgets which cannot be connected to template variables
but are useful in forms as structuring elements are: Composite, Group, Sash,
TabFolder/TabItem.</simpara>
</section>
<section id="_conditional_custom_pages">
<title>CONDITIONAL CUSTOM PAGES</title>
<simpara>Now that templating and XSWT were covered, we can revisit how one can use page
conditions. Consider the following practical example:</simpara>
<simpara>Suppose a wizard for wireless networks. On the first page of the wizard there
is a "[] configure routing" checkbox with the ID "wantRouting". If this
checkbox gets selected, you want to display a second page where the user can
select a routing protocol, then further configuration pages depending on
the particular routing protocol the user chose. To achieve this, you would
add the following lines to template.properties:</simpara>
<literallayout class="monospaced">page.1.title = General   &lt;-- page with the "wantRouting" checkbox
page.2.title = Choose Routing Protocol  &lt;-- page with the "protocol" combobox
page.3.title = AODV Options
page.4.title = DSDV Options</literallayout>
<literallayout class="monospaced">page.2.condition = wantRouting
page.3.condition = wantRouting &amp;&amp; protocol=="AODV"
page.4.condition = wantRouting &amp;&amp; protocol=="DSDV"</literallayout>
<simpara>You get the idea.</simpara>
</section>
<section id="_wizard_types">
<title>WIZARD TYPES</title>
<simpara>The IDE offers several OMNeT<literal>-related wizard dialogs: New OMNeT</literal> Project,
New NED File, New Simple Module, and so on. Every content template can
contribute to one or more of those wizard dialogs. The template author
has to list the supported wizards in the supportedWizardTypes property file
entry. Values are:</simpara>
<itemizedlist>
<listitem>
<simpara>
project
</simpara>
</listitem>
<listitem>
<simpara>
simulation
</simpara>
</listitem>
<listitem>
<simpara>
nedfile
</simpara>
</listitem>
<listitem>
<simpara>
inifile
</simpara>
</listitem>
<listitem>
<simpara>
msgfile
</simpara>
</listitem>
<listitem>
<simpara>
simplemodule
</simpara>
</listitem>
<listitem>
<simpara>
compoundmodule
</simpara>
</listitem>
<listitem>
<simpara>
network
</simpara>
</listitem>
<listitem>
<simpara>
wizard
</simpara>
</listitem>
</itemizedlist>
<simpara>A possible setting in the template.properties file is:
supportedWizardTypes = project, simulation, nedfile, network</simpara>
<simpara>In turn, the wizard will set the wizardType template variable when it executes,
so template code can check under which wizard it runs (using &lt;#if&gt;..&lt;/#if&gt;), and
act accordingly.</simpara>
<simpara>Specific wizard dialogs will also define extra variables for use in the
templates, e.g. the wizard types that create a single file will put the
newFileName variable into the context.</simpara>
<simpara>In the next sections we describe the individual wizard types.</simpara>
<section id="_project">
<title>"project"</title>
<simpara>Presented in the "New OMNeT++ Project" dialog. Extra variables:
  nedPackageName
  withCplusplusSupport</simpara>
</section>
<section id="_simulation">
<title>"simulation"</title>
<simpara>TODO</simpara>
</section>
<section id="_nedfile">
<title>"nedfile"</title>
<simpara>TODO</simpara>
</section>
<section id="_inifile">
<title>"inifile"</title>
<simpara>TODO</simpara>
</section>
<section id="_msgfile">
<title>"msgfile"</title>
<simpara>TODO</simpara>
</section>
<section id="_simplemodule">
<title>"simplemodule"</title>
<simpara>TODO</simpara>
</section>
<section id="_compoundmodule">
<title>"compoundmodule"</title>
<simpara>TODO</simpara>
</section>
<section id="_network">
<title>"network"</title>
<simpara>TODO</simpara>
</section>
<section id="_wizard">
<title>"wizard"</title>
<simpara>TODO show how to write templates that are suitable for more than one wizard.</simpara>
</section>
</section>
<section id="_using_custom_widget_classes">
<title>USING CUSTOM WIDGET CLASSES</title>
<simpara>Since XSWT works via Java reflection, your own custom widgets can be used
the forms very much like normal SWT widgets. No glue or registration code
is needed, just add their package to the &lt;import&gt; tags at the top of the XSWT
file.</simpara>
<simpara>However, some Java code is needed so that the wizard knows how to write
template variables into your wigets and how to extract them after editing.
This functionality can be added via the org.omnetpp.cdt.wizard.IWidgetAdapter
interface. This interface must be implemented either by the widget class
itself, or by a class named &lt;widgetclass&gt;Adapter in the same package.
The interface has methods to tell whether the adapter supports a given widget,
to read the value out of the widget, and to write a value into the widget.</simpara>
<simpara>In addition to basic data types (Boolean, Integer, Double, String, etc),
it is possible to use compound data types as well, i.e. those composed of
the List and Map interfaces of the Java Collections API. The default values
can be given in the template.properties file in the JSON notation, and the
result can be used in the templates (iteration via &lt;#list&gt;, etc).</simpara>
</section>
<section id="_using_external_java_code">
<title>Using External Java Code</title>
<simpara>Jar files placed into the plugins/ subdirectory of an OMNeT++ project will be
loaded automatically, and will be avalable for all templates. Jar files in
that directory may be plain Java jars and Eclipse plug-in jars. (The latter
makes it also possible to contribute new functionality into the IDE via
various extension points, but this is outside the scope of this discussion
about wizards.)</simpara>
<simpara>In addition, jar files placed in the folder of the template will
be loaded automatically when the template is used, and the classes in it will
be available for that template. Custom SWT widget classes can be imported and
used in XSWT forms, and other code can be used in the template files via the
bean wrapper (e.g. ${classes["org.example.SomeClass"].someStaticMethod(&#8230;)},
see the example wizards.)</simpara>
</section>
<section id="_utility_classes_available_from_the_templates">
<title>UTILITY CLASSES AVAILABLE FROM THE TEMPLATES</title>
<simpara>The following Java classes have been added to the context:
  Math          java.lang.Math
  FileUtils     U
  StringUtils   org.apache.commons.lang.StringUtils
  CollectionUtils       org.apache.commons.lang.CollectionUtils
  IDEUtils      TODO
  LangUtils     TODO</simpara>
<simpara>Example template code:</simpara>
<literallayout class="monospaced">The value of 10*cos(0.2) is ${10*Math.cos(0.2)}.</literallayout>
<literallayout class="monospaced">The words of the sentence '${sentence}':
&lt;#list StringUtils.split(sentence) as word&gt;
   ${word}
&lt;/#list&gt;</literallayout>
<literallayout class="monospaced">Properties in the file ${filename}:
&lt;#assign props = FileUtils.readPropertyFile(filename)&gt;
&lt;#list props?keys as key&gt;
   ${key} ==&gt; ${props.get(key)}
&lt;/#list&gt;</literallayout>
<section id="_math">
<title>Math:</title>
<simpara>Represents the Java Math class, which contains mathematical functions.
See <ulink url="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Math.html">http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Math.html</ulink></simpara>
<simpara>Math functions:</simpara>
<variablelist>
<varlistentry>
<term>
double cos(double x)
</term>
<term>
double sin(double x)
</term>
<term>
double pow(double x, double y)
</term>
<listitem>
<simpara>
  etc.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_fileutils">
<title>FileUtils:</title>
<simpara>Contains utility functions for reading files in the following formats: XML,
JSON, CSV, property file, and functions to read and return a text file
as a single string, as an array of lines, and as a an array of string arrays
(where string arrays were created by splitting each by whitespace).</simpara>
<simpara>There are two sets of functions, one works on files in the Eclipse workspace,
and the other files on "external" files, i.e. files in the file system.
Files are interpreted in the Java platform&#8217;s default encoding (unless XML files,
which specify their own encoding.)</simpara>
<simpara>FileUtils functions:</simpara>
<variablelist>
<varlistentry>
<term>
org.w3c.dom.Document readXMLFile(String fileName)
</term>
<term>
org.w3c.dom.Document readExternalXMLFile(String fileName)
</term>
<listitem>
<simpara>
    Parses an XML file, and return the Document object of the resulting
    DOM tree.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Object readJSONFile(String fileName)
</term>
<term>
Object readExternalJSONFile(String fileName)
</term>
<listitem>
<simpara>
    Parses a JSON file. The result is a Boolean, Integer, Double, String,
    List or Map, or any data structure composed of them.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
String[][] readCSVFile(String fileName, boolean ignoreFirstLine, boolean ignoreBlankLines, boolean ignoreCommentLines)
</term>
<term>
String[][] readExternalCSVFile(String fileName, boolean ignoreFirstLine, boolean ignoreBlankLines, boolean ignoreCommentLines)
</term>
<listitem>
<simpara>
    Reads a CSV file. The result is an array of lines, where each line is
    a string array. Additional method parameters control whether to discard the
    first line of the file (which is usually a header line), whether to
    ignore blank lines, and whether to ignore comment lines (those starting
    with the # character). Comment lines are not part of the commonly accepted
    CSV format, but they are supported here nevertheless, due to their
    usefulness.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Properties readPropertyFile(String fileName)
</term>
<term>
Properties readExternalPropertyFile(String fileName)
</term>
<listitem>
<simpara>
    Parses a Java property file (<emphasis>key=value</emphasis> lines) in the workspace.
    The result is a Properties object, which is effectively a hash of
    key-value pairs.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
String[][] readSpaceSeparatedTextFile(String fileName, boolean ignoreBlankLines, boolean ignoreCommentLines)
</term>
<term>
String[][] readExternalSpaceSeparatedTextFile(String fileName, boolean ignoreBlankLines, boolean ignoreCommentLines)
</term>
<listitem>
<simpara>
    Reads a text file, and return its contents, split by lines, and each line
    split by whitespace. Additional method parameters control whether to ignore
    blank lines and/or comment lines (those starting with the # character).
    The result is an array of lines, where each line is a string array of the
    items on the line.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
String[] readLineOrientedTextFile(String fileName)
</term>
<term>
String[] readExternalLineOrientedTextFile(String fileName)
</term>
<listitem>
<simpara>
    Reads a text file in the workspace, and returns its lines. Comment lines
    (those starting with a hash mark, #) are discarded. The result is a
    string array.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
String readTextFile(String fileName)
</term>
<term>
String readExternalTextFile(String fileName)
</term>
<listitem>
<simpara>
    Reads a text file, and return its contents unchanged as a single string.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
boolean isValidWorkspacePath(String path)
</term>
<listitem>
<simpara>
    Returns true if the given string is syntactically a valid workspace path.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
boolean isValidWorkspaceFilePath(String path)
</term>
<listitem>
<simpara>
    Returns true if the given string is syntactically a valid workspace file path.
    This function does not check whether the file exists, or whether the given path
    actually already points to a resource of a different type.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
IProject asProject(String path)
</term>
<listitem>
<simpara>
    Returns the handle for the workspace project with the given name.
    Throws exception if the path is not a valid workspace project path.
    This function does not test whether the project exists. To test that,
    call the exists() method on the returned handle.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
IContainer asContainer(String path)
</term>
<listitem>
<simpara>
    Returns the handle for the workspace container (i.e. project or folder) with the given name.
    Throws exception if the path is not a valid workspace container path.
    This function does not test whether the container exists. To test that,
    call the exists() method on the returned handle.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
IFile asFile(String path)
</term>
<listitem>
<simpara>
    Returns the handle for the workspace file with the given name.
    Throws exception if the path is not a valid workspace file path.
    This function does not test whether the file exists. To test that,
    call the exists() method on the returned handle.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_stringutils">
<title>StringUtils</title>
<simpara>Represents the Apache Commons StringUtils class, which contains over a hundred
utility functions for manipulating strings.
See <ulink url="http://commons.apache.org/lang/api/org/apache/commons/lang/StringUtils.html">http://commons.apache.org/lang/api/org/apache/commons/lang/StringUtils.html</ulink></simpara>
<simpara>StringUtils methods</simpara>
<variablelist>
<varlistentry>
<term>
boolean isEmpty(String s)
</term>
<term>
boolean isBlank(String s)
</term>
<term>
String capitalize(String s)
</term>
<term>
String upperCase(String s)
</term>
<term>
String lowerCase(String s)
</term>
<term>
boolean startsWith(String s, String suffix)
</term>
<term>
boolean endsWith(String s, String prefix)
</term>
<term>
String[] split(String s)
</term>
<term>
String join(String[] strings)
</term>
<listitem>
<simpara>
  etc.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_collectionutils">
<title>CollectionUtils</title>
<simpara>Represents the Apache Commons CollectionUtils class, which contains some useful
functions for manipulating collections (like lists). Functions include computing
set union, intersection, and difference.
<ulink url="http://commons.apache.org/collections/apidocs/org/apache/commons/collections/CollectionUtils.html">http://commons.apache.org/collections/apidocs/org/apache/commons/collections/CollectionUtils.html</ulink></simpara>
<simpara>CollectionUtils methods</simpara>
<variablelist>
<varlistentry>
<term>
Collection union(Collection a, Collection b)
</term>
<term>
Collection intersection(Collection a, Collection b)
</term>
<term>
Collection subtract(Collection a, Collection b)
</term>
<listitem>
<simpara>
TODO
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_ideutils">
<title>IDEUtils</title>
<simpara>Provides entry points into various aspects of the IDE. This includes access to
the Eclipse workspace (projects, folders, files), and the NED index. The former
is documented in the Eclipse Platform help; documentation for the latter can
be found in the sources (Javadoc).
See <ulink url="http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/resInt.htm">http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/resInt.htm</ulink>
and <ulink url="http://help.eclipse.org/galileo/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRoot.html">http://help.eclipse.org/galileo/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRoot.html</ulink></simpara>
<simpara>IDEUtils methods</simpara>
<variablelist>
<varlistentry>
<term>
IWorkspaceRoot getWorkspaceRoot()
</term>
<term>
NEDResources getNEDResources()
</term>
<term>
MsgResources getMsgResources()
</term>
<listitem>
<simpara>
TODO
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_langutils">
<title>LangUtils</title>
<simpara>Provides a collection of Java language related utility functions.</simpara>
<simpara>LangUtils methods</simpara>
<variablelist>
<varlistentry>
<term>
boolean hasMethod(Object object, String methodName)
</term>
<listitem>
<simpara>
    Returns true if the object has a method with the given name.
    Method args and return type are not taken into account.
    Search is performed on the object&#8217;s class and all super classes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
boolean hasField(Object object, String fieldName)
</term>
<listitem>
<simpara>
    Returns true if the object has a field with the given name.
    Field type is not taken into account. Search is performed on
    the object&#8217;s class and all super classes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
boolean instanceOf(Object object, String classOrInterfaceName)
</term>
<listitem>
<simpara>
    Returns true if the given object is instance of (subclasses from or
    implements) the given class or interface. To simplify usage, the class
    or interface name is accepted both with and without the package name.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
String toString(Object object)
</term>
<listitem>
<simpara>
    Produces a user-friendly representation of the object. In case of
    collections (lists, maps, etc), the representation is JSON-like.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
List&lt;Object&gt; newList()
</term>
<listitem>
<simpara>
    Creates and returns a new mutable List object (currently ArrayList).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Map&lt;Object, Object&gt; newMap()
</term>
<listitem>
<simpara>
    Creates and returns a new mutable Map object (currently HashMap).
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Set&lt;Object&gt; newSet()
</term>
<listitem>
<simpara>
    Creates and returns a new mutable Set object (currently HashSet).
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="_editing_xswt_files">
<title>EDITING XSWT FILES</title>
<simpara>Double-clicking on an XSWT file will open it in the XSWT editor. The editor
provides basic syntax highlighting (and not much else currently). An extremely
useful feature of the IDE is the XSWT Preview, where you can see preview
the form being edited (it updates when you save the file). The Preview should
open automatically when you open the XSWT file; if it does not (or you close it),
you can access it via the Window|Show View&#8230; menu item.</simpara>
<simpara>Some (custom) widgets may not appear in the Preview; this is because the
Preview does not load jar files from the projects.
XXX This may get fixed.</simpara>
</section>
<section id="_editing_template_files">
<title>EDITING TEMPLATE FILES</title>
<simpara>The Freemarker Editor is opened when you double-click files with the ftl or
fti extension. (The latter stands for Freemarker Template Include, and it is
intended for template fragments that you include into other templates. Otherwise
the wizard ignores fti files, i.e. does not copy them into the new project or
folder.) The Freemarker Editor offers basic syntax highlight, validation
(error markers appear during editing if the template is not syntactically
correct), and basic content assist. Content assist can help you with directives
(&lt;&#8230;&gt; syntax) and builtin operations (like ?number, ?size, ?default, etc).
The content assist popup appears automatically when you type <emphasis>&lt;</emphasis> (actually
a closing <emphasis>&gt;</emphasis> is also needed for the editor to recognize the tag), and
when you hit <emphasis>?</emphasis> within a directive or an interpolation (${&#8230;}).</simpara>
</section>
<section id="_references">
<title>REFERENCES</title>
<simpara>An XSWT tuturial and documentation can be found at:
<ulink url="http://www.coconut-palm-software.com/the_new_visual_editor/doku.php?id=xswt:home">http://www.coconut-palm-software.com/the_new_visual_editor/doku.php?id=xswt:home</ulink></simpara>
<simpara>Documentation for the FreeMarker template language:
<ulink url="http://freemarker.org/docs/index.html">http://freemarker.org/docs/index.html</ulink></simpara>
<simpara>---</simpara>
<simpara>TODO document: supportedWizardTypes = project, simulation, nedfile, network
  and in the concrete template it comes back as wizardType, which can be checked against. together with optionalFiles
  e.g. don&#8217;t generate package.ned if it&#8217;s a simple NED File wizard</simpara>
<simpara>TODO document new FileUtils methods (create/delete file/dir)</simpara>
<simpara>TODO document ProcessUtils</simpara>
<simpara>TODO jar files get loaded from the normal folder, and from the project&#8217;s "plugins" folder. Jar files are not copied over.</simpara>
<simpara>TODO "New NED File" wizard milyen valtozokat definial alapbol!
        "wizardType" (=="nedfile)
        "newFileName" &#8201;&#8212;&#8201;the file name
        "nedPackageName"&#8201;&#8212;&#8201;expected NED package for that folder
        "nedTypeName"&#8201;&#8212;&#8201;derived from the file name
        "bannerComment"&#8201;&#8212;&#8201;with copyright notice, etc</simpara>
<simpara>TODO document: .fti "freemarker template include" files (they open in the FreeMarker editor, but get ignored on template initiation (ie. don&#8217;t get copied over))</simpara>
<simpara>TODO document glob patterns in verbatimFiles etc</simpara>
<simpara>TODO: optionalFiles removed! now all files, if they would be empty, are NOT saved, (existing file, if exists,
 is left there. If you want to generate an empty file, put some comment into it (most files formats allow
 comments), or use FileUtils.writeTextFile() [note: it exists???]. If you want to delete an existing file,
 here&#8217;s how you do it: FileUtils.deleteFile()</simpara>
<simpara>TODO document &lt;@setoutput file=&#8230;/&gt;
   redirects output to the given file. The filename can contain slashes too, i.e.
   one can write files in a different folder. If the folder does not exist, it will
   be created.</simpara>
<literallayout class="monospaced">If filename is empty, the directive restores output to the original file name (the template's name).
This also works if a folder name is given and only the file name is missing
(&lt;@setoutput file="src/"&gt;): then it will write the file with the original name
but into the specified folder.</literallayout>
<literallayout class="monospaced">If there are multiple setoutput's with the same file name within a template,
the content will be concatenated. Concatenation only works within one template;
if you have multiple templates writing into the same file, they will overwrite
each other's content, and it is undefined which one will win.</literallayout>
<literallayout class="monospaced">Empty and blank files (ie. those containing only white space) will not be created,
i.e. processing will skip writing it without any question, warning or error.
This allows you to easily create conditional files. This also means that you
cannot create empty files this way. However, this "limitation" is easy to overcome
as most file formats (ned, c++, ini, xml, etc) have a comment syntax, so you
can just write a file that contains only a comment ("// file intentionally left blank").
Alternatively, you can create an empty file using the FileUtils Java utility class
(&lt;@do FileUtils.createTextFile("empty.txt", "")!/&gt;). Note: although blank files
are not created, the template engine will not delete an existing file that
happens to be already there with the same name.</literallayout>
<literallayout class="monospaced">Typical usage: &lt;@setoutput file=fileName?default("")/&gt;, which means that if
the fileName variable undefined (absent), use "" as file name, i.e. save to
the original file name.</literallayout>
<simpara>TODO document FileChooser and ExternalFileChooser, NedChooser: custom widget: file selector (workspace / external file)
TODO NED type chooser, project chooser</simpara>
<simpara>TODO setoutput path="&#8230;"</simpara>
<simpara>TODO mention <ulink url="http://www.jsonlint.com/">http://www.jsonlint.com/</ulink></simpara>
<simpara>TODO document the &lt;#assign dummy=expr!&gt; trick! alternative: &lt;@do FileUtil.deleteFile(file)!/&gt;</simpara>
<simpara>TODO tutorial: XSWT, FTL, how to edit stuff; how to use Java classes (new widgets in XSWT,
JARs in the templates)</simpara>
<simpara>TODO pelda: "[] make new project dependent on this one" checkbox
TODO Util: hasMethod(), hasField(), instanceof(), newInstance()</simpara>
<simpara>TODO check: BeanWrapper cannot access inherited methods? (e.g. toString())</simpara>
<simpara>TODO: special markup in the template: "&lt;?output="bubu.txt"&gt; &#8230; &lt;/?output&gt;
to support creation of files with runtime-decided names.
TODO pelda: "Name of examples folder", "Name of source" folder</simpara>
<simpara>TODO document page.NN.class = org.foo.SomePageClass;
  class must extend ICustomWizardPage;
  class must have a public constructor with the following signature: (String name, IContentTemplate creatorTemplate, String condition)
  class must be accessible to the class loader (TODO clarify&#8230;)</simpara>
</section>

</chapter>
