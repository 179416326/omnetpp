<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="seq-chart">
  <title>Sequence Charts</title>

  <sect1>
    <title>Introduction</title>
    <para>
      The Sequence Chart and the Eventlog Table tools (often just referred as tools in the
      rest of this chapter) are part of the OMNeT++ IDE. Both of them display an eventlog
      file which can be optionally but automatically recorded by the OMNeT++ 4.0
      simulation kernel.
    </para>
    <para>
      An eventlog file contains various information about a simulation run such as the
      simple and compound modules that were present in the network, the connections
      between them, the messages sent during the simulation (optionally with field level
      detail) and the events where they were processed.
    </para>
    <note>
      Please refer to the OMNeT++ 4.0 Manual for further details on what an eventlog file
      is and what is its exact format.
    </note>
    <para>
      The Sequence Chart displays eventlog files in a graphical notation focusing on the
      causes and consequences of events and message sends. It helps understanding complex
      simulation models and helps correctly implementing the desired component
      behaviors. The Eventlog Table displays an eventlog file in a more detailed and
      direct way focusing on the exact data in tabular format. Both tools can display
      filtered eventlogs created via the Eventlog Tool filter command as described in the
      OMNeT++ 4.0 Manual, by a third party custom filter tool or by the IDE's in memory
      filtering.
    </para>
    <para>
      Using these tools you will be able to easily examine every minute detail of your
      simulation back and forth in terms of simulation time or events focusing on the
      behavior instead of the statistical results of your model.
    </para>
  </sect1>

  <sect1>
    <title>Creating an eventlog file</title>
    <para>
      The Inifile Editor in the OMNeT++ IDE provides a group of widgets in the
      <guilabel>Output Files</guilabel> section to configure automatic eventlog
      recording. To enable it simply put a checkmark next to its checkbox or insert the
      line <screen>record-eventlog = true</screen> into the inifile.
    </para>
    <picture file="pictures/INI-Eventlog.png">Inifile eventlog configuration</picture>
    <para>
      By default the recorded eventlog file will be put in the project's
      <filename>results</filename> directory with the name
      <filename>${configname}-${runnumber}.log</filename>.
    </para>
    <warning>
      If you override the default file name please make sure that the file extension is
      <filename>log</filename> as the example shows above so that the OMNeT++ IDE tools
      will be able to recognize it automatically.
    </warning>
    <para>
      The 'recording intervals' and 'record events' parameters control which events will
      be recorded based on their simulation time and on the module where they occur. The
      'message details' parameter specifies what will be recorded from a message's content
      when it is sent.
    </para>
    <para>
      These parameters also affect the recorded file's size which in turn might change
      performance both during simulation and when viewing the results in the IDE. The
      smaller the file is the better for both writing it to the disk and for loading and
      displaying it from memory. It is always a good idea to provide these parameters with
      reasonable limits.
    </para>
    <note>
      Please refer to the OMNeT++ 4.0 Manual for a complete description of eventlog
      recording parameters.
    </note>
  </sect1>

  <sect1>
    <title>Examples</title>
    <para>
      Before running any of the following examples make sure that eventlog recording is
      enabled by uncommenting the line <screen>record-eventlog = true</screen> in the file
      <filename>omnetpp.ini</filename> under the simulation's directory. To open the
      generated eventlog in the OMNeT++ IDE go to the example's
      <filename>results</filename> directory in the <guilabel>Resource
      Navigator</guilabel> view and double click on the log file.
      <tip>
	You can also open a file in an editor other than its default editor by right
	clicking on it and choosing an item from the <guisubmenu>Open With</guisubmenu>
	submenu. This way you can open an eventlog file in the Eventlog Table editor
	instead of the default Sequence Chart.
      </tip>
    </para>
    <sect2>
      <title>Tic toc</title>
      <para>
	This example is available in the OMNeT++ installation under the directory
	<filename>samples/tictoc</filename>. Tic toc is the most basic example in this
	chapter which provides a quick overview how to use and understand the Sequence
	Chart.
      </para>
      <para>
	Start the simulation and choose the simplest configuration 'Tictoc1' which
	specifies only two nodes called 'tic' and 'toc'. During initializion one of the
	nodes will send a message to the other and at each event from that on the node
	which receives the message will simply send it back. This process continues until
	you stop the simulation. In <xref
	linkend="pictures/SequenceChart-Examples-TicTocTwoNodes.png"/> you can see how
	this is represented on a Sequence Chart. The two horizontal black lines correspond
	to the two nodes and are labelled 'tic' and 'toc'. The red circles represent
	events and the blue arrows represent message sends. It is easy to see that all
	message sends take 100 ms and that the first sender is the node 'tic'.
      </para>
      <picture file="pictures/SequenceChart-Examples-TicTocTwoNodes.png">
	Tic toc with two nodes
      </picture>
      <para>
	In the next tic toc example there are six nodes tossing a message around until it
	reaches its destination. To generate the eventlog file restart the simulation and
	choose the configuration 'Tictoc9'. In <xref
	linkend="pictures/SequenceChart-Examples-TicTocSeveralNodes.png"/> you can see how
	the message goes from one node to another starting from node '0' and returning
	back to it two times until finally the message reaches its end point at node
	'3'. The chart also shows that this example unlike the previous one starts with a
	self message instead of immediately sending a message from initialize to another
	node.
      </para>
      <picture file="pictures/SequenceChart-Examples-TicTocSeveralNodes.png">
	Tic toc with six nodes
      </picture>
      <para>
	This simple example allows to see how filtering works with the Sequence
	Chart. Open the filter dialog with the toolbar button <icon name="filter.png"/>
	and put a checkmark for node '0' and '3' on the panel <guilabel>Module filter|by
	name</guilabel> and apply it. The chart now displays only two axes corresponding
	for the two selected nodes. There are three virtual message sends on the figure,
	the first two show the message returning back to node '0' at
	<eventnumber>9</eventnumber> and <eventnumber>13</eventnumber> while the last
	shows that it reaches the destination at <eventnumber>16</eventnumber> where the
	simulation ends. The details where the message was in between is filtered out.
      </para>
      <picture file="pictures/SequenceChart-Examples-TicTocSeveralNodesFiltered.png">
	Filtering for node '0' and '3'
      </picture>
    </sect2>
    <sect2>
      <title>FIFO</title>
      <para>
	This example is available in the OMNeT++ installation under the directory
	<filename>samples/fifo</filename>. The FIFO is an important example because it
	uses a queue which is an essential part of discrete event simulations and
	introduces the notion of message reuses.
      </para>
      <para>
	When you start the simulation choose the configuration 'low job arrival rate' and
	let it go for a while. In <xref
	linkend="pictures/SequenceChart-Examples-FIFO.png"/> you can see three modules, a
	'source', a 'queue' and a 'sink'. The simulation starts with a self message and then
	the generator sends the first message to the queue at
	<eventnumber>1</eventnumber>. It is immediately obvious that the message stays for
	a while in the queue from <eventnumber>2</eventnumber> to event #3. To measure
	this amount of simulation time show the popup for one of the events while the
	other one is selected. Finally the message is sent to the 'sink' where it is
	destroyed at <eventnumber>4</eventnumber>.
      </para>
      <picture file="pictures/SequenceChart-Examples-FIFO.png">
	First in first out queue
      </picture>
      <para>
	The interesting thing happens at <eventnumber>12</eventnumber> where the incoming
	message suddenly disappears, it seems like the queue does not send that message
	out. Actually what happens is that the queue enqueues the job because it has
	already got one at <eventnumber>10</eventnumber> which is still in the
	queue. Since this queue is a FIFO, it will send out the first message at
	<eventnumber>13</eventnumber>. To see as in <xref
	linkend="pictures/SequenceChart-Examples-FIFOReuse.png"/> how this happens turn on
	<guilabel>Show Reuse Messages</guilabel> from the context menu. It will display a
	couple of green dotted arrows one of which is from <eventnumber>12</eventnumber>
	to <eventnumber>17</eventnumber>. This arrow represents a message reuse that is
	the job got and enqueued at <eventnumber>12</eventnumber> is sent out from the
	queue at <eventnumber>17</eventnumber>. Notice the message that was already in the
	queue when it got this second one will be sent out earlier at
	<eventnumber>13</eventnumber>. Moreover this is the event where the second's
	message processing starts.
      </para>
      <picture file="pictures/SequenceChart-Examples-FIFOReuse.png">
	Showing reuse messages
      </picture>
      <para>
	There are a couple of green dotted arrows with a somewhat different meaning such
	as the one from <eventnumber>3</eventnumber> to
	<eventnumber>6</eventnumber>. These represent the fact that the queue reuses
	(instead of recreating it) the timer message each time it gets a job when it is
	empty. In other words the timer self message is more or less remembered just like
	normal jobs which are enqueued, but in a separate member variable in the queue's
	C++ implementation.
      </para>
      <para>
	The last part of this example is filtering out the queue from the chart. Open the
	filter dialog and put a checkmark for 'sink' and 'source' on the panel
	<guilabel>Module filter|by NED type</guilabel> and apply it. If you look at the
	result in <xref linkend="pictures/SequenceChart-Examples-FIFOFiltered.png"/> then
	you will see zig zag arrows going from the 'source' to the 'sink'. These arrows
	represent the fact that a message is being sent through the queue from 'source' to
	'sink'. The first two arrows do not overlap in simulation time which means the
	queue did not have more than one message in it at that time. On the other hand the
	third and fourth arrows do overlap due to the fact that the forth job reached the
	queue while it was busy with the third one. Scrolling forward you can find other
	places where the queue becomes empty and arrows do not overlap again.
      </para>
      <picture file="pictures/SequenceChart-Examples-FIFOFiltered.png">
	Filtering the queue out
      </picture>
    </sect2>
    <sect2>
      <title>Routing</title>
      <para>
	This example is available in the OMNeT++ installation under the directory
	<filename>samples/routing</filename>. The predefined configuration called Net10
	specifies a network with 10 nodes each node having an application, a few queues
	and a routing module inside. Three preselected nodes namely the node '1', '6' and
	'8' are destinations while all nodes are message sources. The routing module uses
	the shortest path algorithm to find the route to the destination. The goal in this
	example is to create a sequence chart that shows messages which go in
	simultaneously from multiple sources to their destinations.
      </para>
      <picture file="pictures/SequenceChart-Examples-RoutingNetwork.png">
	Network with 10 nodes
      </picture>
      <para>
	Since we don't care about the details what happens within a node, we can just turn
	on filtering for the NED type 'node.Node'. The chart will have 10 axes, each axis
	drawn as two parallel solid black lines close to each other. These are the
	compound modules that represent the nodes in the network. So far events could be
	directly drawn on the simple module's axis where they occured, but now they will
	be drawn on their ancestor compound module's axis.
      </para>
      <picture file="pictures/SequenceChart-Examples-Routing.png">
	Filtering for nodes
      </picture>
      <para>
	To reduce noise the chart will automatically omit events which are internal to the
	compound module. Internal to a compound module means that the event processes a
	message from and sends out messages to only other internal modules.
      </para>
      <para>
	If you look at <xref linkend="pictures/SequenceChart-Examples-Routing.png"/> you
	will see a message going from node '7' at <eventnumber>10</eventnumber> to node
	'1' at <eventnumber>23</eventnumber>. This message stays in node '2' for a while
	from <eventnumber>15</eventnumber> to <eventnumber>17</eventnumber>. Actually the
	routing decision in node '2' takes zero simulation time indicated by the gray
	background area.
      </para>
      <para>
	This example also demonstrates message detail recording configured by
	<screen>eventlog-message-detail-pattern = Packet:declaredOn(Packet)</screen> in
	the inifile. The result in <xref
	linkend="pictures/SequenceChart-Examples-RoutingTooltip.png"/> shows the tooltip
	presented for the second hop of the message described above.
      </para>
      <picture file="pictures/SequenceChart-Examples-RoutingTooltip.png">
	Message detail tooltip
      </picture>
      <para>
	It is very easy to find another message on the chart going through the network
	parallel in simulation time. The one sent from node '3' at
	<eventnumber>13</eventnumber> to node '8' arriving at
	<eventnumber>19</eventnumber> is such a messsage.
      </para>
    </sect2>
    <sect2>
      <title>Wireless</title>
      <para>
	This example is available in the INET Framework under the directory
	<filename>examples/adhoc/ieee80211</filename>. The predefined configuration called
	Config1 specifies two mobile hosts moving around on the playground and
	communicating via the IEEE 802.11 wireless protocol. The network devices are
	configured for ad hoc mode and the transmitter power is set so that hosts can move
	out of range. One of the hosts is continuously pinging the other. The goal is to
	create two sequence charts focusing on the protocol's MAC layer. The first chart
	will show a ping message being successfully sent through the wireless channel
	while the second will show the opposite, ping messages being continuously resent
	due to packet loss.
      </para>
      <para>
	We also would like to record message detail during the simulation so the following
	line should also be uncommented: <screen>eventlog-message-detail-pattern = *:(not
	declaredOn(cMessage) and not declaredOn(cNamedObject) and not
	declaredOn(cObject))</screen>
      </para>
      <para>
	To generate the evenlog file start the simulation environment and choose the
	configuration 'host1 pinging host0'. Run the simulation in fast mode until around
	event number <eventnumber>5000</eventnumber>.
      </para>
      <sect3>
	<title>Preparing the result</title>
	<para>
	  When you open the Sequence Chart it will show a couple of self messages being
	  sent regularly. These are the self messages which control the movement of the
	  two hosts on the playground.
	</para>
	<para>
	  We don't care about those move messages much but would like to focus on the MAC
	  layer instead. To begin with open the filter dialog and check the
	  <guilabel>Module Filter|by NED type</guilabel> option in the tree on the left
	  hand side. It will display on the right hand side a list of NED types present in
	  the eventlog file. Select the inet.linklayer.ieee80211.mac.Ieee80211Mac and the
	  inet.linklayer.radio.Ieee80211Radio types and apply the filter by pressing the
	  <guilabel>Ok</guilabel> button. This will hide all axes from the chart except
	  four simple modules the two MACs and the two radios.
	</para>
	<para>
	  The next step is to attach vector data to the four axes. Open the context menu
	  for each axis by clicking on them one by one and select the submenu
	  <guilabel>Attach Vector to Axis</guilabel>. When pops up always select the file
	  offered and choose the vector mac:State for the MAC modules and mac:RadioState
	  for the radio modules. You should edit the filter in the selection dialog
	  (i.e. delete the last segment) for the radio modules because at the moment the
	  radio state is actually recorded by the MAC module so the default filter will
	  not be right. When this step is completed the chart should display four thick
	  colored bars as module axes.
	</para>
	<para>
	  To make understanding easier you can reorder the axis so that the radio modules
	  are put next to each other. After some zooming and scrolling you should be able to
	  fit the first message exchanges in the window among the two hosts at the MAC layer.
	</para>
      </sect3>
      <sect3>
	<title>Successful ping</title>
	<para>
	  The first message sent by host1 is not a ping request but an ARP request which
	  after some processing in host0 generates the corresponding ARP reply. This is
	  shown by the zig zag arrow between <eventnumber>90</eventnumber> and
	  <eventnumber>91</eventnumber>. The reply goes back to host1 which then sends a
	  wlan acknowledge in return. In this process host1 discovers the MAC address of
	  host0 based on its IP address.
	</para>
	<para>
	  The send procedure for the first ping message starts at
	  <eventnumber>105</eventnumber> in host1 and finishes by receiving the
	  acknowledge at <eventnumber>127</eventnumber>. The ping reply send procedure
	  starts at <eventnumber>125</eventnumber> in host0 and finishes by receiving the
	  acknowledge at <eventnumber>144</eventnumber>. Scrolling a little bit forward
	  you can see as in <xref
	  linkend="pictures/SequenceChart-Examples-WirelessSuccessfulPing.png"/> the
	  second complete successful ping procedure between <eventnumber>170</eventnumber>
	  and <eventnumber>206</eventnumber>. Open the filter dialog and enter these
	  numbers in the range filter.
	</para>
	<picture file="pictures/SequenceChart-Examples-WirelessSuccessfulPing.png">
	  The second ping procedure
	</picture>
	<para>
	  Timing is critical in a protocol implementation so let's take a look at it. The
	  message send from <eventnumber>171</eventnumber> to
	  <eventnumber>172</eventnumber> occurs in zero simulation time (gray background)
	  and represents the moment when the MAC decides to send the ping request down to
	  its radio module. If you look at <eventnumber>172</eventnumber> and
	  <eventnumber>173</eventnumber> you will see how the message propagates from
	  radio1 to radio0 in a finite amount of time with the light of speed. Also
	  looking at the the <eventnumber>172</eventnumber> and
	  <eventnumber>174</eventnumber> you can notice that the transmission time is non
	  zero based on the message's length. Another interesting fact which can be
	  immediately drawn from the figure is that the higher level protocol layers do
	  not add delay to the processing between <eventnumber>176</eventnumber> and
	  <eventnumber>183</eventnumber> while generating the ping reply message in
	  host0. And finally you can get a quick grasp about the timings of IEEE 802.11 in
	  linear timeline mode <icon name="timelinemode.png"/> where the figure changes
	  drammaticaly (scroll and zoom in/out if needed) showing how useful the nonlinear
	  mode is.
	</para>
	<commercial>
	  <para>
	    And finally you can export this sequence chart using the context menu's
	    <guilabel>Export to SVG</guilabel> menu option for documentation purposes.
	  </para>
	</commercial>
      </sect3>
      <sect3>
	<title>Unsuccessful ping</title>
	<para>
	  To see how the chart looks when ping messages get lost in the air first turn off
	  range filtering and then go to <eventnumber>1269</eventnumber> by selecting the
	  <guimenuitem>Goto Event...</guimenuitem> from the Eventlog table view's context
	  menu.  In <xref
	  linkend="pictures/SequenceChart-Examples-WirelessUnsuccessfulPing.png"/> you can
	  see how the receiver radio does not send the incoming message to its MAC layer
	  due to the signal level being too low. This actually happens at
	  <eventnumber>1274</eventnumber> in node '0' while the transmitter MAC layer in
	  node '1' receives a timeout at <eventnumber>1275</eventnumber> and starts the
	  backoff procedure to resend the very same ping message. This goes on with
	  statistically increasing backoff time intervals until
	  <eventnumber>1317</eventnumber> where the maximum number of retries is reached
	  and the message is dropped.
	</para>
	<picture file="pictures/SequenceChart-Examples-WirelessUnsuccessfulPing.png">
	  Ping message get lost
	</picture>
	<para>
	  The chart makes clear that during the unsuccessful ping period there are no
	  events occuring in the MAC layer of node '0' and it is continuously in the state
	  'IDLE'.
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Sequence Chart</title>
    <para>
      The Sequence Chart is devided into three parts the top and bottom gutters and the
      main area. The gutters show the simulation times and the main area displays module
      axes, events and message sends. The chart grows horizontally with simulation time
      and vertically with modules. Module axes can optionally display vector data.
    </para>
    <sect2>
      <title>Legend</title>
      <para>
	A sequence chart is built from various small graphical elements representing
	simple and compound modules, events, message sends, names, etc. listed in the
	following table.
      </para>
      <informaltable>
	<tgroup cols="2">
	  <colspec colwidth="130"/>
	  <colspec/>
	  <tbody>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SimpleModuleAxis.png"/></entry>
	      <entry>simple module axis</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-CompoundModuleAxis.png"/></entry>
	      <entry>compound module axis</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-AxisWithAttachedVector.png"/></entry>
	      <entry>axis with attached vector data</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-ModuleFullPath.png"/></entry>
	      <entry>module full path as axis label</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-InitializationEvent.png"/></entry>
	      <entry>initialization event</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SelfMessageProcessingEvent.png"/></entry>
	      <entry>self message processing event</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageProcessingEvent.png"/></entry>
	      <entry>message processing event</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-EventNumber.png"/></entry>
	      <entry>event number</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SelfMessage.png"/></entry>
	      <entry>self message</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageSend.png"/></entry>
	      <entry>message send</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageReuse.png"/></entry>
	      <entry>message reuse</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SplitArrow.png"/></entry>
	      <entry>message send that goes far away; split arrow</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-ZigZagArrow.png"/></entry>
	      <entry>virtual message send; zig zag arrow</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-MessageName.png"/></entry>
	      <entry>message name</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-ZeroSimulationTimeRegion.png"/></entry>
	      <entry>zero simulation time region</entry>
	    </row>
	    <row valign="middle">
	      <entry><icon file="pictures/SequenceChart-Legend-SimulationTimeHairline.png"/></entry>
	      <entry>simulation time hairline</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>
    </sect2>
    <sect2>
      <title>Timeline</title>
      <para>
	The Sequence Chart's horizontal axis corresponds to the simulation time in four
	different ways. Linear and event number mean that the simulation time and event
	number is proportional to the distance measured in pixels respectively. While non
	linear and step mean that there is a non linear transformation between distance
	measured in pixels and simulation time. The goal of this non linear transformation
	is to get a compact figure even if there are longer and shorter periods of
	simulation time intervals between events. You can switch between
	<guilabel>Timeline Mode</guilabel>s <icon name="timelinemode.png"/> from the
	toolbar or the context menu.
      </para>
      <para>
	The <guilabel>Custom nonlinear</guilabel> timeline mode might be useful in those
	rare cases when the automatic mode does not work well. The best practice is to
	switch to <guilabel>Nonlinear</guilabel> mode first and then to <guilabel>Custom
	nonlinear</guilabel> so that the chart will continuously refresh during changing
	the parameters. At the extreme you can set the parameters so that the nonlinear
	mode becomes equivalent to linear or step.
      </para>
    </sect2>
    <sect2>
      <title>Zero Simulation Time Regions</title>
      <para>
	It is quite common in simulation models that multiple events occur at the very
	same simulation time possibly in different modules. A region with gray background
	color indicates that the simulation time does not change along the horizontal axis
	within the area and all events inside occured at the same moment. Of course the
	order of the events still matters.
      </para>
      <picture file="pictures/SequenceChart-ZeroSimulationTimeRegions.png">Nonlinear simulation time</picture>
    </sect2>
    <sect2>
      <title>Module Axes</title>
      <para>
	The Sequence Chart's vertical axis corresponds to single or compound modules in
	the simulation. By default all single modules are displayed as a single solid line
	and events occurred in that module are shown as filled circles on that
	line. Compound modules are shown as double solid lines along with events occured
	in any of the simple modules not having a separate axis under that compound
	module. These lines called module axes can be reordered with the option
	<guilabel>Axis Ordering Mode</guilabel> <icon name="axisordering.gif"/> manually,
	by module name, by module id or by approximately minimizing the number of crossing
	arrows between them.
      </para>
    </sect2>
    <sect2>
      <title>Gutter</title>
      <para>
	Both the top and the bottom of the Sequence Chart display the simulation times
	corresponding to the currently visible part. The left side of the top simulation
	time gutter displays the common simulation time prefix which should be added to
	each individual simulation time shown at the vertical hairlines. This reduces the
	number of characters on the gutter and allows easier recognition of simulation
	time changes in the significant digits. The right side of the figure displays the
	simulation time range currently visible within the sequence chart window. To see
	what is the simulation time at a specific point on the chart move the mouse to the
	desired place and read the value horizontally aligned with the mouse on the
	gutter.
      </para>
      <picture file="pictures/SequenceChart-Gutter.png">Gutter and range</picture>
    </sect2>
    <sect2>
      <title>Events</title>
      <para>
	Events are displayed as filled circles along the module axes. A green circle
	represents the processing of a self message while a red circle is an event caused
	by receiving a message from another module. The very first event which has the
	event number zero represents the module initialization phase and may spread across
	multiple module axes because the simulation kernel calls each module during
	initialization. To easily distinguish this event from the normal ones it is
	displayed with white background color. Event numbers are just below and to the
	right of their corresponding events and are prefixed with '#'.
      </para>
      <picture file="pictures/SequenceChart-Events.png">Various event kinds</picture>
    </sect2>
    <sect2>
      <title>Messages</title>
      <para>
	The Sequence Chart represents message sends via blue arrows. Vertically the arrow
	starts at the module which is sending the message and ends at the module which
	processed that message. Horizontally the start and end points of the arrow
	correspond to the sender and receiver events. The message name is displayed
	somewhere near middle of the arrow.
      </para>
      <para>
	When a message arrives to a module which neither deletes nor sends but rather
	stores it in some internal state and later on sends the very same message to
	another module then the events where the message arrived and where the message was
	actually sent are in a so called message reuse relationship. This is represented
	by a green dotted arrow between the two events. These arrows are not shown by
	default due to timer self messages usually being reused continuously and adding
	unnecessary noise to the chart. Use the <guilabel>Show Reuse Messages</guilabel>
	<icon name="reusearrows.png"/> option on the toolbar or the context menu to show
	or hide these arrows.
      </para>
      <para>
	Sometimes depending on the zoom factor a message send goes far away on the figure
	in which case the line is split into two smaller parts displayed at the two ends
	pointing towards each other but without actually linked with a continuous
	line. One end of both arrow pieces is a dotted and the other end is a solid
	line. The one which is solid always exactly points to or from the event it is
	really connected to. The other one which is dotted either specifies only the
	module where the arrow really starts or ends or in case of a self message it just
	points towards the other arrow horizontally.
      </para>
      <picture file="pictures/SequenceChart-SplitArrows.png">Split arrows</picture>
    </sect2>
    <sect2>
      <title>Attaching Vectors</title>
      <para>
	It is possible to attach Vector data to individual axes from the context menu by
	right clicking on the desired axis and selecting <guilabel>Attach Vector to
	Axis</guilabel> from the corresponding submenu. In this case the solid line of the
	axis will be turned into a thick bar with coloring based on the values present in
	the vector. If the vector is of type enum and its element names have been
	registered with the C++ macro Register_Enum then the chart will display those
	names inside the bar. Otherwise it will simply display the value as a number. The
	background coloring for the thick bar is automatical either based on the
	enumeration member or alternating for other types.
      </para>
    </sect2>
    <sect2>
      <title>Zooming</title>
      <para>
	To zoom in or out horizontally along the timeline use the <guilabel>Zoom
	In/Out</guilabel> <icon name="zoomplus.png"/> <icon name="zoomminus.png"/>
	commands from the toolbar. To decrease or increase the distance between the axes
	use the <guilabel>Increase/Decrease Spacing</guilabel> <icon
	name="incr_spacing.png"/> <icon name="decr_spacing.png"/> commands.
	<warning>
	  When you zoom out more events and messages become visible on the chart making it
	  slower while zooming in more message lines break making it less informative. Try
	  to keep a reasonable zoom level.
	</warning>
      </para>
    </sect2>
    <sect2>
      <title>Navigation</title>
      <para>
	To scroll the Sequence Chart either use the scroll bars, drag with the mouse left
	button or scroll with the mouse wheel using the <keycap>SHIFT</keycap> modifier
	key for horizontal scroll.
      </para>
      <para>
	There are also navigation options to go to the previous
	(<keycap>SHIFT+LEFT</keycap>) or next (<keycap>SHIFT+RIGHT</keycap>) event in the
	same module.
      </para>
      <para>
	Similarly to the Eventlog Table to go to the cause event press
	<keycap>CTRL+LEFT</keycap> and to go to the arrival of a message send press
	<keycap>CTRL+RIGTH</keycap> while an event is selected.
      </para>
    </sect2>
    <sect2>
      <title>Tooltips</title>
      <para>
	The Sequence Chart displays tooltips for axes, events, message sends and
	resuses. When a tooltip is shown for any of the above the chart will highlight the
	corresponding parts. Sometimes when the chart is zoomed out it might show a
	complex tooltip at once because there are multiple things under the mouse.
      </para>
      <tip>
	To measure the simulation time difference between two events select one of them
	and stay at the other to display the tooltip.
      </tip>
      <picture file="pictures/SequenceChart-Tooltip.png">Event tooltip</picture>
    </sect2>
    <sect2>
      <title>Bookmarks</title>
      <para>
	Just like the Eventlog Table the Sequence Chart also supports bookmarks to make
	navigation easier. Actually bookmarks are saved for the files rather than the
	various editors, therefore they are shared between them. The chart highlights
	bookmarked events with a circle around them similarly to primary selection but
	with a different color.
      </para>
    </sect2>
    <commercial>
      <sect2>
	<title>Exporting</title>
	<para>
	  The Sequence Chart supports exporting continuous parts into SVG format for
	  documentation purposes. This function is available from the context menu <icon
	  name="export_wiz.gif"/>. You can export the whole Sequence Chart, a region
	  between two selected events or the currently visible area.
	</para>
      </sect2>
    </commercial>
    <sect2>
      <title>Filtering</title>
      <para>
	Filtering the Sequence Chart is also possible. This actually means that some of
	the events are not displayed on the chart so that the user can focus on the
	relevant parts. When filtering is turned on (displayed in the status line) some of
	the message arrows might be decorated with a filter sign (a double zigzag crossing
	the arrow line's center). Such a message arrow means that there is a message going
	out from the source module which after some processing in some other filtered out
	modules reaches the target module. The message name of the arrow in this case
	corresponds to the first and the last message in the chain.
      </para>
      <picture file="pictures/SequenceChart-ZigZagArrows.png">Zig zag arrows</picture>
      <para>
	If events occured in a module are completely filtered out then the Sequence Chart
	will not display the superfluous axis belonging to that module. This reduces the
	number of axes and makes it easier to understand the figure. Moreover similarly to
	the Eventlog Table subsequent events may not have subsequent event numbers which
	means that the events in between have been filtered out. At the extreme the chart
	may even become empty meaning that there are no matching events at all.
      </para>
      <para>
	You can filter the Sequence Chart from the filter dialog or from the context menu
	using the shortcuts provided for events and message sends under the mouse.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Eventlog Table</title>
    <para>
      The Evenlog Table has one row per line in the eventlog file. It has three columns
      where the first two called event number and simulation time show the values
      corresponding to the event where the line was recorded. The third column called
      details contains the actual data which varies for each line kind. The different kind
      of lines can be easily recognized by their icon. Some lines such as sending a
      message through a sequence of gates relate with each other and are indented for
      easier recognition.
    </para>
    <para>
      There are various options which control how and what the Eventlog Table
      displays. Some of these are available from the toolbar while some others are
      accessible only from the context menu.
    </para>
    <sect2>
      <title>Display Mode</title>
      <para>
	The eventlog file content may be displayed in two different notations. The
	<guilabel>Raw</guilabel> data notation shows exactly what is present in the file.
      </para>	
      <picture file="pictures/EventlogTable-RawMode.png">
	<guilabel>Raw</guilabel> notation
      </picture>
      <para>
	On the other hand the <guilabel>Descriptive</guilabel> notation displays the log
	file after some preprocessing into a human readable form. It also resolves
	references and types so that less navigation is required to understand what was
	going on. To switch between the two use the <guilabel>Display Mode</guilabel>
	<icon name="displaymode.png"/> option from the toolbar or the context menu.
      </para>
      <picture file="pictures/EventlogTable-DescriptiveMode.png">
	<guilabel>Descriptive</guilabel> notation
      </picture>
    </sect2>
    <sect2>
      <title>Name Mode</title>
      <para>
	There are three different ways to display names in the Eventlog table configurable
	by the <guilabel>Name Mode</guilabel> <icon name="namemode.gif"/> option. Full
	path and full name shows what you would expect while the smart mode uses the
	context where the line is to decide whether a full path or a full name should be
	displayed. For each event line it always uses the full path and for all other
	lines if the name is the same as the enclosing event's module name then it shows
	the full name only.
      </para>
    </sect2>
    <sect2>
      <title>Type Mode</title>
      <para>
	The option called <guilabel>Type Mode</guilabel> can be used to switch between
	displaying the C++ class name or the NED type name in a parenthesis just before
	the name of modules. This is only available from the context menu.
      </para>
    </sect2>
    <sect2>
      <title>Line Filter</title>
      <para>
	The Eventlog Table may be filtered by using the <guilabel>Line Filter</guilabel>
	<icon name="LineFilterMode.png"/> selector available on the toolbar or from the
	context menu. This option allows filtering lines for specific kinds. There are
	some predefined filters but you can also provide custom filter patterns referring
	to fields present in the <guilabel>Raw</guilabel> mode. The following is a custom
	filter example which will show message sends where the message's class is
	AirFrame. <screen>BS and c(AirFrame)</screen> See the OMNeT++ Manual for more
	details on match expressions.
      </para>
      <note>
	Event lines marked with green circles <icon name="event.png"/> are always shown in
	the Eventlog Table independently of the line filter.
      </note>
    </sect2>
    <sect2>
      <title>Navigation</title>
      <para>
	Standard keyboard and mouse navigation and multiple selection within the Eventlog
	Table is done just like in any other table but there are extra navigation options
	in the context menu. 
      </para>
      <para>
	The simplest are the <guilabel>Goto Event</guilabel> and the <guilabel>Goto
	Simulation Time</guilabel> which simply jump to the given location.
      </para>
      <para>
	There are navigation options to go to the previous (<keycap>ALT+UP</keycap>) or
	next (<keycap>ALT+DOWN</keycap>) event in general and to go to the previous
	(<keycap>SHIFT+UP</keycap>) or next (<keycap>SHIFT+DOWN</keycap>)
	event in the same module.
      </para>
      <para>
	Some of the navigation options focus on the causes of events and consequences of
	message sends. To go to the cause event press <keycap>CTRL+UP</keycap>
	and to go to the arrival of a message send press <keycap>CTRL+DOWN</keycap>
	while the selection is on the message being sent.
      </para>
      <picture file="pictures/EventlogTable-NavigationMenu.png">Navigation context menu</picture>
    </sect2>
    <sect2>
      <title>Searching</title>
      <para>
	For performance reasons the search <icon name="Search.gif"/> function works
	directly on the eventlog file and not the text displayed in the Eventlog table. It
	means that some static text present in <guilabel>Descriptive</guilabel> mode
	cannot be found. Usually it is easier to figure out what to search for in
	<guilabel>Raw</guilabel> mode where the eventlog's content file is directly
	displayed. The search can work in both directions starting from the current
	selection and may be case insensitive. To repeat the last search use the
	<guilabel>Find Next</guilabel> <icon name="SearchNext.gif"/> command.
      </para>
    </sect2>
    <sect2>
      <title>Bookmarks</title>
      <para>
	For easier navigation the Eventlog table supports navigation history accessible
	from the standard IDE toolbar and also bookmarks <icon name="bkmrk_nav.gif"/>
	available from the context menu. Bookmarked events are highlighted with a
	different background color.
      </para>
      <picture file="pictures/EventlogTable-Bookmark.png">A bookmark</picture>
      <para>
	Use the standard bookmark view to jump to bookmarks even after restarting the IDE.
      </para>
    </sect2>
    <sect2>
      <title>Tooltips</title>
      <para>
	At the moment only the message send lines have tooltips and only if message detail
	recording was configured for the simulation. In this case the tooltip will show
	the recorded content of the message being sent.
      </para>
      <picture file="pictures/EventlogTable-Tooltip.png">A message send tooltip</picture>
    </sect2>
    <sect2>
      <title>Filtering</title>
      <para>
	If the Eventlog Table displays a filtered eventlog then subsequent events may not
	have subsequent event numbers which means that the events in between have been
	filtered out. At the extreme the table may even become empty meaning that there
	are no matching events at all.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Filter Dialog</title>
    <para>
      The content of an eventlog file may be filtered in memory on the fly by opening the
      filter configuration dialog <icon name="Filter.png"/> and applying it. The result is
      another eventlog resident in memory where some events are filtered out.
      <note>
	Similarly to the command line Eventlog Tool described in the OMNeT++ 4.0 Manual
	the in memory filtering can also only filter out whole events.
      </note>
    </para>
    <para>
      In memory on the fly filtering means that the filter's result is not saved into an
      eventlog file but it is rather lazily computed and stored within memory. This allows
      rapid switching between various views on the same eventlog data within both the
      Sequence Chart and the Eventlog Table.
    </para>
    <para>
      The filter configuration dialog shown in has many options organized into a tree each
      restricting the eventlog's content on its own. The individual components may be
      turned on and off independently of each other.
    </para>
    <para>
      The combination of various filter options is non trivial. To make it less confusing
      the filter dialog automatically displays the current filter in a textual form at the
      bottom.
    </para>
    <picture file="SequenceChart-FilterDialog.png">
      Filter dialog
    </picture>
    <sect2>
      <title>Range filter</title>
      <para>
	This is the simplest one which filters out events from the beginning and from the
	end of the eventlog. It might help to reduce the computation time when defining
	filters which otherwise would be very expensive to compute for the whole eventlog
	file.
      </para>
    </sect2>
    <sect2>
      <title>Module filter</title>
      <para>
	With this filter you can filter out events that did not occur in any of the
	specified modules. The modules which will be included in the result can be
	selected by NED type, full path, module id or by a match expression. The
	expression may refer to data present in the lines marked with 'MC' in the eventlog
	file.
      </para>
    </sect2>
    <sect2>
      <title>Message filter</title>
      <para>
	This filter is the most complicated one. It allows filtering for events which
	either process or send specific messages. The messages can be selected based on
	their C++ class name, message name, various message ids and a match expression.
	The expression may refer to data present in the lines marked with 'BS' in the
	eventlog file.
      </para>
      <para>
	There are four different message ids to filter for each with different
	characteristics. The most basic one is the id which is unique for each constructed
	message independently of how it was created. The tree id is special in that it
	gets copied over when a message is created by copying another. The encapsulation
	id is different in that it gives the id of the innertmost encapsulated
	message. Finally the encapsulation tree id combines the two by providing the
	innermost encapsulated message's tree id.
      </para>
    </sect2>
    <sect2>
      <title>Tracing causes/consequeces</title>
      <para>
	The trace filter allows filtering for causes and consequence of a particular event
	specified by its event number. The cause/consequence relation between two events
	means that there is a message send/resuse path from the cause event to the
	consequence event. If there was a reuse in the path then the whole path is
	considered to be a reuse itself.
      </para>
      <warning>
	Since computing the causes and consequences far away in the log file from the
	traced event might be a time consuming task, there are extra limits around the
	traced event to be set. These limits are separate from the range filter due to
	being linked to the traced event. It is strongly recommended to provide limits
	when tracing events to avoid long running operations.
      </warning>
    </sect2>
    <sect2>
      <title>Collection limits</title>
      <para>
	When an in memory filter is applied to an eventlog it does not only filter out
	whole events but provide automatic discovery for message dependency chains. It
	means that two events far away and not directly related to each other will have a
	virtual message send (or reuse) dependency between them if there is a path of
	message sends (and reuses) connecting the two. The process of collecting these
	virtual dependencies is time consuming and has to be limited. There are two
	options one of which limits the number of virtual message dependencies per event
	and another which limits the depth of cause/consequence chains looked at during
	computing the filter's result.
      </para>
    </sect2>
    <sect2>
      <title>Long Running Operations</title>
      <para>
	Sometimes computing the filter's result takes a lot of time especially when
	tracing causes/consequences without specifying proper range limits in terms of
	event numbers or simulation times. If you canel the long running operation then
	you can go back to the filter dialog to modify the filter parameters or simply
	turn it off and restart drawing. Providing a proper range filter is always a good
	idea to speed up computing the filter's result.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Other features</title>
    <para>
      Both the Sequence Chart and the Eventlog Table tools can be used as an editor and
      also as a view. The difference between being an editor or a view is quite important,
      because there is only at most one instance of a view of the same kind. It means that
      even if multiple eventlog files are open in Sequence Chart editors there are no more
      than one Eventlog Table view shared between them. This singleton view will
      automatically display the eventlog file of the active editor, and remember its
      position and state when switching among editors back and forth. For more details on
      what an editor and a view is and what are the differences please refer to the
      Eclipse documentation.
      <note>
	Despite the name editor which is a concept of the Eclipse platform neither the
	Sequence Chart nor the Eventlog Table can be used to actually change the contents
	of an eventlog file.
      </note>
    </para>
    <para>
      It is possible to open the same eventlog file in multiple editors and to navigate to
      different locations or use different diplay modes or filters in them. Once an
      eventlog is open in an editor, you can use the <guimenuitem>Window|New
      Editor</guimenuitem> to open it again.
      <tip>
	Dragging one of the editors from the tabbed pane to the side of the area allows
	you to interact with the two simultaneously.
      </tip>
    </para>
    <sect2>
      <title>Settings</title>
      <para>
	There are various settings for both tools which affect the display such as display
	modes, content position, filter parameters, etc. These user specified settings are
	automatically saved for each file and reused whenever the file is visited
	again. The per file settings are stored under the OMNeT++ workspace in the
	directory
	<filename>.metadata\.plugins\org.eclipse.core.resources\.projects\&lt;project-name&gt;</filename>.
      </para>
    </sect2>
    <sect2>
      <title>Large File Support</title>
      <para>
	Since an eventlog file might be several Gbytes, both tools are designed in a way
	that allows efficiently displaying such a file without requiring large amounts of
	physical memory to load it at once. As you navigate through the file physical
	memory is filled up with the content lazily. Since it is difficult to reliably
	identify when the system is going low on physical memory, it is up to the user to
	release the allocated memory when needed. This operation although usually not
	required is available from the context menu as <guimenuitem>Release
	Memory</guimenuitem>. It does not affect the user interface in any way.
      </para>
      <para>
	The fact that the eventlog file is being loaded lazily (and optionally filtered)
	also means that the exact number of events and rows it contains cannot be cheaply
	determined. This affects the way scrollbars work in the lazy direction, horizontal
	for the Sequence Chart and vertical for the Eventlog Table. Basically these
	scrollbars act as a non linear approximation in that direction which most of the
	time remains unnoticable for the user unless the file is really small.
      </para>
    </sect2>
    <sect2>
      <title>Viewing a running simulation's results</title>
      <para>
	Despite the simulation kernel keeps the eventlog file open for writing while the
	simulation is running, it may be opened in the OMNeT++ IDE simultaneously. Both
	tools can be instructed by pressing the <keycap>END</keycap> key to follow the
	eventlog's end as new content is appended to it. If you pause the simulation in
	the runtime environment then after a few seconds the tools will refresh their
	contents. This actually makes possible to follow the simulation step-by-step.
      </para>
    </sect2>
    <sect2>
      <title>Caveats</title>
      <para>
	Sometimes drawing the Sequence Chart may take a lot of time. Zooming out too much
	for example might result in slow response times. A dialog might pop up telling
	that a long running eventlog operation is in progress. You can safely cancel these
	operations at any time you like or just wait until they finish. To restart the
	rendering process simply press the refresh button <icon name="refresh.gif"/> on
	the toolbar. Before actually doing that it is a good idea to revert to some
	defaults (e.g. default zoom level) or revert the last changes (e.g. navigate back,
	turn filter off, etc.) and then try refreshing.
      </para>
      <warning>
	An unreasonably long running opreration might be a sign of a problem that should
	be reported for further consideration.
      </warning>
    </sect2>
  </sect1>

</chapter>
