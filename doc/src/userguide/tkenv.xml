<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "custom-docbook.dtd">
<chapter id="tkenv">
  <title>Graphical Runtime Environment</title>
  <sect1>
    <title>Features</title>
    <para> Tkenv is a portable graphical windowing user interface. Tkenv supports interactive execution of
      simulation, tracing and debugging. Tkenv is recommended in the development stage of a simulation or for
      presentation and educational purposes since it allows the user to get a detailed picture of the state of the
      simulation at any point in its execution and to follow what happens inside the network. The most important
      feaures are:</para>
    <itemizedlist>
      <listitem>
        message flow animation
      </listitem>
      <listitem>
        graphical display of statistics (histograms, etc.) and output vectors during simulation execution
      </listitem>
      <listitem>
        separate window for each module's text output
      </listitem>
      <listitem>
        scheduled messages can be watched in a window as simulation progresses
      </listitem>
      <listitem>
        event-by-event, normal and fast execution
      </listitem>
      <listitem>
        labeled breakpoints
      </listitem>
      <listitem>
        inspector windows to examine and alter objects and variables in the model
      </listitem>
      <listitem>
        simulation can be restarted
      </listitem>
      <listitem>
        snapshots (detailed report about the model: objects, variables, etc.)
      </listitem>
    </itemizedlist>
    <para> Tkenv makes it possible to view simulation results (output vectors, etc.) during execution. Results
      can be displayed as histograms and time-series diagrams. This can speed up the process of verifying the
      correct operation of the simulation program and provides a good environment for experimenting with the
      model during execution. When used together with gdb or xxgdb, Tkenv can significantly speed up debugging.</para>
    <para> Tkenv is built with Tcl/Tk. It works on all platforms where Tcl/Tk has been ported to: Unix/X,
      Windows, and Macintosh. You can get more information about Tcl/Tk on the Web pages listed in the Reference section.
    </para>
  </sect1>
  <sect1>
    <title>Starting Tkenv</title>
    <para>A simulation program built with Tkenv accepts the following command line switches:</para>
    <itemizedlist>
      <listitem>
        [[-h]] : The program prints a help message and exits.
      </listitem>
      <listitem>
        [[-f fileName]] : Specifies the name of the configuration file. The default is [[omnetpp.ini]]. Multiple -f
        switches can be given; this allows you to partition your configuration file. For example, one file can
        contain your general settings, another one most of the module parameters, and a third one the module
        parameters you change frequently. The -f switch is optional and can be omitted.
      </listitem>
      <listitem>
        [[-l fileName]] : Loads a shared object (.so file on Unix). Multiple -l switches are accepted. Your .so
        files may contain module code, etc.
      </listitem>
      <listitem>
        [[-n filePath]] : When present, overrides the NEDPATH environment variable and sets the source location for
        simulation NED files.
      </listitem>
      <listitem>
        [[-c configname]] : Selects a configuration for execution.
      </listitem>
      <listitem>
        [[-r run-number]] : It has the same effect as (but takes priority over) the ``tkenv-default-run='' 
        INI file configuration.
      </listitem>
    </itemizedlist>
  </sect1>
  <sect1>
    <title>Configuration options</title>
    <para> Tkenv accepts the following configuration options in the INI file.</para>
    <itemizedlist>
      <listitem>
        [[tkenv-extra-stack]] : Specifies the extra amount of stack (in kilobytes) that is reserved for each
        [[activity()]] simple module when the simulation is run under Tkenv. This value is significantly
        higher than the similar one for Cmdenv (handling GUI events requires a large amount of stack space).
      </listitem>
      <listitem>
        [[tkenv-default-config]] : Specifies which configuration Tkenv should set up automatically after
        startup.
      </listitem>
      <listitem>
        [[tkenv-default-run]] : Specifies which run Tkenv should set up for the selected configuration after
        startup. If there is no default-run = entry or the value is 0, Tkenv will ask which run to set up.
      </listitem>
      <listitem>
        [[tkenv-image-path]] : Specifies which directories should be scanned when Tkenv wants to load an
        image. This is a semicolon-separated list of directories. This setting can be overridden by the
        OMNETPP_IMAGE_PATH environment variable.
      </listitem>
      <listitem>
        [[tkenv-plugin-path]] : Specifies which directories should be scanned when Tkenv wants to load an
        extension plugin. Plugins are small TCL script fragments that contribute additional behavior to
        Tkenv.
      </listitem>
    </itemizedlist>
    <para>The rest of the Tkenv options are saved into the [[.tkenvrc]] file that can be found in the
      current directory or in the user's home directory (in case of global options).</para>
  </sect1>
  <sect1>
    <title>Environment variables</title>
    <para>In case of nonstandard installation, it may be necessary to set the [[OMNETPP_TKENV_DIR]]
      environment variable so that Tkenv can find its parts written in Tcl script.</para>
    <para> The default path from where the icons are loaded can be changed with the [[OMNETPP_IMAGE_PATH]]
      variable, which is a semicolon-separated list of directories that defaults to
      omnetpp-dir/images;./images.</para>
  </sect1>
  <sect1>
    <title>The main window</title>
    <picture file="pictures/Tkenv-main.png" width="300">The main window of the Tcl/Tk runtime environment
    </picture>
    <para>The main window of the simulation environment contains:</para>
    <itemizedlist>
      <listitem>
        ``Toolbar'': You may access the main functions of the runtime environment. The toolbar is displayed
        directly below the main window's menu. It is possible to step, run,
        stop, restart or finish the simulation and configure the visual appearance and logging behavior.
      </listitem>
      <listitem>
        ``Status bar'': Contains information about the current state of the simulation. On the upper line, it
        displays the current run number and network name, the current event number, the simulation time and
        the module name to where the next simulation event will be delivered. The middle line displays the
        number of messages in the FES, the total number of messages created during the simulation and finally
        the number of messages currently present in the whole simulation model. The last line contains
        performance data: How many events are processed in a real and in a simulated second along with the
        relative speed between the simulation-time and real-time.
      </listitem>
      <listitem>
        ``Timeline'': Displays the content of the FES on a logarithmic time scale. Double-clicking on a dot will
        display the message inspector window. You can set what events are displayed on the timeline by setting
        message filters on the main configuration dialog's timeline tab (Tip: right-click on the timeline to
        go directly to the timeline configuration dialog).
      </listitem>
      <listitem>
        ``Object tree'': Displays all inspectable objects currently present in the memory. You may double click on
        nodes to further inspect the given object in a separate window.
      </listitem>
      <listitem>
        ``Log Window'': Contains the output of the simulation. You can filter the content of the window to only include
        messages from specific modules. Open the log window's context menu and select [[Filter window
        contents ]]. Note that the whole content of the log window will be filtered including all previous
        messages.
      </listitem>
    </itemizedlist>
    Both the Object tree and the Timeline can be easily switched off on the toolbar if you need more space for
    your log window.
  </sect1>
  <sect1>
    <title>Inspecting your simulation</title>
    <sect2>
      <title>Networks, Modules</title>
      <picture file="pictures/Tkenv-network.png">Top level network</picture>
      <para>You can start exploring the component hierarchy by browsing the Object tree and double-clicking
        on a node or by clicking the [[Inspect network]] icon on the toolbar. Once you open a node, an
        inspector window will be opened. Networks and compound modules are represented by graphical
        inspectors that display their internal structures. Simple modules are represented by object inspectors
        that display their content as lists. Items in these lists can also be opened and some of them in the
        tree indicated by [...] can be changed during runtime. Double-click on the item and edit it in place.
      </para>
      <para> If you intend to watch some variables in your modules, add the [[WATCH(varName)]] macro to your
        module's [[initialize()]] method. The watched variables will be displayed on the object
        inspector's content page.</para>
      <para>The toolbar on the module inspector window contains several useful commands that can be used
        related to this module. It is possible to directly inspect the parent module, or the type definition
        for this module, show the current module's log output or search for objects inside the module. It
        is also possible to step or run a simulation until the next event occurs in the module.</para>
      <note>
        Tkenv uses reflection information provided by the [[Register_ClassDescriptor(class)]] macro to display
        the object tree. If you want to include your own classes in the tree, you need to register it with the
        above macro.
      </note>
    </sect2>
    <sect2>
      <title>Future Event Set (FES)</title>
      <picture file="pictures/Tkenv-fes.png">The content of the Future Event Set</picture>
      <para> You can peek into the Future Event Set by clicking on ``Inspect | Scheduled events'' . The FES
        contains all messages already scheduled. Double-clicking on any message will show the message object's
        inspector window for further investigation.</para>
      <note>
        The future event set is also displayed on the main window's timeline.
      </note>
    </sect2>
    <sect2>
      <title>Output vectors, histograms, queues</title>
      <picture file="pictures/Tkenv-outvector.png">An output vector displayed in a window</picture>
      <para> You can view graphical representations of output vectors . Double-clicking on an output vector object
        displays the content graphically. You may set the display properties by clicking on the ``Options...''
        button.</para>
      <note>
        To save memory, output vector windows start gathering data only when you open them. No pre-opening data will be displayed.
      </note>
      <picture file="pictures/Tkenv-histogram.png">A real-time histogram window</picture>
      <para> Histogram inspectors provide a real-time display of the registered histograms.</para>
      <note>
        Histograms may not be available right after the simulation starts because the simulation kernel must
        gather some statistics to determine a histogram's properties (number of cells, cell size, etc.) before
        it can actually start collecting the data.
      </note>
      <picture file="pictures/Tkenv-queue.png">Peeking into a queue</picture>
      <para> If your simulation contains queue objects, you can peek into them any time. All messages
        currently waiting in the queue are displayed in the queue inspector window. Double-click on any
        message to further inspect it.</para>
    </sect2>
  </sect1>
  <sect1>
    <title>Browsing your registered components</title>
    <picture file="pictures/Tkenv-registration.png">Display registered functions, classes, etc.</picture>
    <para> Registered components (NED Types, classes, functions, enums) can be displayed with the ``Inspect |
      Available components'' . If an error message reports missing types or classes, it is a good
      practice to check whether everything is loaded and registered correctly.</para>
  </sect1>
  <sect1>
    <title>Running and controlling the simulation</title>
    <para>Tkenv has several modes for running the simulation. These running modes have their
      corresponding buttons on Tkenv's toolbar:</para>
    <sect2>
      <title>Step mode</title>
      <para>In Step mode, you can execute the simulation event-by-event. The next event is always
      shown on the status bar. The module where the next event will be delivered is highlighted
      with a red rectangle on the graphical display.</para>
    </sect2>
    <sect2>
      <title>Run mode</title>
      <para>In Run mode, the simulation runs with all tracing aids on. Message animation is active and
        inspector windows are updated after each event. Output messages are displayed in the main window and
        module output windows. You can stop the simulation with the ``Stop'' button on the toolbar. You can
        fully interact with the user interface while the simulation is running (e.g. you can open inspectors, etc.).
      </para>
      <note>
        If you find this mode too slow or distracting, you may switch off animation features in
        the Tkenv configuration dialog.
      </note>
    </sect2>
    <sect2>
      <title>Fast mode</title>
      <para> In Fast mode, animation is turned off. The inspectors and the message output windows are updated
        every 500 milliseconds (the actual number can be set in ``Options|Simulation options...'' and also in
        the INI file). Fast mode is several times faster than the Run mode; the speed can increase by up to 10 times
        (or up to the configured event count).</para>
    </sect2>
    <sect2>
      <title>Express mode</title>
      <para> In Express mode, the simulation runs at about the same speed as with Cmdenv, all tracing
        disabled. Module output is not recorded in the output windows. You can interact with the
        simulation only once in a while, thus the run-time overhead of the user interface is minimal. You have
        to explicitly push the ``Update inspectors'' button if you want an update.</para>
    </sect2>
    <sect2>
      <title>Run until</title>
      <para>You can run the simulation until a specified simulation time, event number or
        until a specific message has been delivered or canceled. This is
        a valuable tool during debugging sessions (select ``Simulate | Run until...'').
        It is also possible to right-click on an event in the simulation timeline and choose
        the ``Run until this event'' menu item.</para>
    </sect2>
    <sect2>
      <title>Run until next event</title>
      <para> It is also possible to run until an event occurs in a specified module. Browse for the
        module and choose ``Run until next event in this module.'' Simulation will stop once an event occurs
        in this module.</para>
    </sect2>
    <para> Tkenv has a status bar which is regularly updated while the simulation is running. Global
      simulation statistics like simulation speed, event density, current event number and simulation time are
      displayed on the status bar.</para>
    <para> Simulations are created when Tkenv is started and the user has selected a network to simulate (or
      the user clicks the ``New Network'' button to select a new one). First, the simulation kernel loads all
      necessary NED files and registers the loaded modules with the kernel. Object constructors are called at
      this point. The next phase is initialization when all module's [[initialize()]] methods are called.
      Once initialization is complete, Tkenv returns the control to the user and allows stepping or running
      the simulation. If you choose to quit Tkenv before the simulation finishes (or try to restart the
      simulation), Tkenv will ask you whether to call the [[finish()]] method for all modules. This will allow
      the modules to correctly free up resources and save their statistics. Before the simulation program exits,
      the modules are deleted and their destructor is called.</para>
  </sect1>
  <sect1>
    <title>Finding objects</title>
    <picture file="pictures/Tkenv-find.png">Finding a specific object</picture>
    <para>There are times when you do not know the exact location of the object for which you are looking.
      For example, you may want to know the locations for all your messages.
      Invoke the ``Find/inspect objects'' window and search for your object. The window allows you to set the
      start of the search along with the type, class and name of the object. The results will be presented as a
      clickable list.</para>
    <note>
      The checkboxes can be used to select the object category that interests you. If you
      select a category, all objects with that type (and any type derived from it) will be included in the search.
      Alternatively, if you specify object class as a class filter expression, the search
      dialog will try to match the object's class name with the given string. This means that only those types of objects
      will be included in the search (derived types will not be included as they have different
      non-matching classnames).
    </note>
    <para>You can provide a generic filter expression, which matches the object's full path by default.
      Wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range [["a".."e"]] plus [["x"]] and
      [["z"]]. You can match numbers: [["*.job{128..191}"]] will match objects named [["job128"]], [["job129"]], ...,
      "job191". "job{128..}" and "job{..191}" are also understood. You can combine patterns with [[AND]], [[OR]] and
      [[NOT]] and parentheses (lowercase and, or, not are also OK). You can match other object fields such
      as queue length, message kind, etc., with the syntax [["fieldname(pattern)"]]. Put quotation marks around a
      pattern if it contains parentheses (HINT: You will want to start the pattern with [["*."]] in most cases to
      match objects anywhere in the network!).</para>
    <itemizedlist>
      <listitem>
        [[*.destAddr]] : Matches all objects with the name [["destAddr"]] (likely module parameters).
      </listitem>
      [[*.subnet2.*.destAddr]] : Matches objects named [["destAddr"]] inside [["subnet2"]].
      <listitem>
        [[*.node[8..10].*]] : Matches anything inside module [[node[8], node[9] ]]and [[node[10] ]].
      </listitem>
      <listitem>
        [[className(cQueue) and not length(0)]] : Matches non-empty queue objects.
      </listitem>
      <listitem>
        [[className(cQueue) and length({10..})]] : Matches queue objects with length>=10.
      </listitem>
      <listitem>
        [[kind(3) or kind({7..9})]] : Matches messages with message kind equal to 3, 7, 8 or 9 (only messages have
        a [["kind"]] attribute).
      </listitem>
      <listitem>
        [[className(IP*) and *.data-*]] : Matches objects whose class name begins with [["IP"]] and name begins with
        [["data-."]]
      </listitem>
      <listitem>
        [[not className(cMessage) and byteLength({1500..})]] : Matches messages whose class is not cMessage and
        byteLength is at least 1500 (only messages have a [["byteLength"]] attribute).
      </listitem>
      <listitem>
        [["*(*" or "*.msg(ACK)"]] : Quotation marks needed when pattern is a reserved word or contains
        parentheses (note: *.msg(ACK) without parentheses would be interpreted as some object having a "*.msg"
        attribute with the value "ACK"!).
      </listitem>
    </itemizedlist>
    <note>
      Tkenv uses the [[cObject::forEachChild]] method to collect all objects from a tree recursively. If you
      have your own objects derived from [[cObject]], you should redefine the [[cObject::forEachChild]] to
      function correctly with an object search.
    </note>
    <note>
      If you are debugging your simulation with a source level debugger and happen to know the value of the
      pointer to your object, you may use the ``Inspect by pointer'' menu item and insert the pointer value
      there to display an inspector window for the object. Please note that entering an invalid pointer will
      crash your simulation.
    </note>
  </sect1>
  <sect1>
    <title>Logging and module output</title>
    <picture file="pictures/Tkenv-module-out-menu.png">Opening the log of a single module</picture>
    <para> Good log output is your best friend during debugging. The main window displays the output of the
      whole simulation; however, in some cases you may be only interested in how a selected module
      and its submodules are working. Choose ``Module output'' from the module's context menu and select
      your module of interest.</para>
    <picture file="pictures/Tkenv-module-out.png">Module output</picture>
    <para>The module output window only displays messages generated by the selected module and its submodules.
      You can open several module output windows and place them side by side to follow the workings of
      several modules at the same time.</para>
    <para> It is possible to filter the content of the output windows by opening the log window's context menu
      and selecting the ``Filter window contents'' menu item. Individual modules can be selected/deselected.
      General logging behavior can be controlled in the ``Simulation Options'' dialog.</para>
    <picture file="pictures/Tkenv-output-filter.png">Filtering the output of a compound module</picture>
    <note>
      All message lines in the log window are filtered according to the filter settings (older ones, too).
    </note>
  </sect1>
  <sect1>
    <title>Simulation options</title>
    <para> Open ``Options | Simulation options...'' to display the runtime environment's preference dialog.
      You may set global parameters for the simulations here. It is also possible to disable various animation
      primitives to speed up the simulation.</para>
    <sect2>
      <title>General</title>
      <picture file="pictures/Tkenv-sim-opts1.png">General Tkenv options</picture>
      <para>The General options tab can be used to set default layouting and logging behavior. It is
        possible to set how often the user interface will be updated during the simulation run. The user can also configure default font
        size and family here.</para>
    </sect2>
    <sect2>
      <title>Configuring animations</title>
      <picture file="pictures/Tkenv-sim-opts2.png">Animation options</picture>
      <para> Tkenv provides automatic animation when you run your simulation. You can fine-tune your animation
        settings using the ``Animation'' tab on the configuration dialog. If you do not need all the visual
        feedback Tkenv provides, you can selectively turn off some of the features:</para>
      <itemizedlist>
        <listitem>
          Animate messages : Turns on/off the visualization of messages passing between modules.
        </listitem>
        <listitem>
          Broadcast animation : Handles message broadcasts in a special way (messages sent at the same
          simulation time will be animated concurrently).
        </listitem>
        <listitem>
          Show next event maker : Highlights the module which will receive the next event.
        </listitem>
        <listitem>
          Show a flashing arrow when a [[sendDirect()]] method call is executed.
        </listitem>
        <listitem>
          Direct method calls are also animated by default with flashing arrows if you have added the
          [[Enter_Method()]] macro to your method body.
        </listitem>
        <listitem>
          The display of message names and classes can also be turned off, if needed.
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Configuring the timeline</title>
      <para>On the ``timeline'' tab, you can control which messages and events will be displayed on the Timeline View
        in the main window.
        Self/non-self messages can be disabled and filter expressions can be specified based on message class
        or name.</para>
      <para> For object names, wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range
        [["a".."e"]] plus [["x"]] and [["z"]]. You can match numbers: [["job{128..191}"]] will match [["job128"]], [["job129"]], ...,
        "job191". "job{128..}" and "job{..191}" are also understood. You can combine patterns with [[AND]], [[OR]] and
        [[NOT]] and parentheses (lowercase and, or, not are also acceptable). You can match against other object fields
        such as message length, message kind, etc. with the syntax [["fieldname(pattern)"]]. Put quotation marks
        around a pattern if it contains parentheses.</para>
      <itemizedlist>
        <listitem>
          [[m*]] : matches any object whose name begins with "m"
        </listitem>
        <listitem>
          [[m* AND *-{0..250}]] : matches any object whose name begins with "m" and ends with a dash and a
          number between 0 and 250
        </listitem>
        <listitem>
          [[not *timer*]] : matches any object whose name does not contain the substring "timer"
        </listitem>
        <listitem>
          [[not (*timer* or *timeout*)]] : matches any object whose name does not contain either "timer" or
          "timeout"
        </listitem>
        <listitem>
          [[kind(3) or kind({7..9})]] : matches messages with message kind equal to 3, 7, 8 or 9
        </listitem>
        <listitem>
          [[className(IP*) and data-*]] : matches objects whose class name begins with "IP" and name begins
          with "data-"
        </listitem>
        <listitem>
          [[not className(cMessage) and byteLength({1500..}) ]]: matches objects whose class is not cMessage
          and whose byteLength is at least 1500
        </listitem>
        <listitem>
          [["or" or "and" or "not" or "*(*" or "msg(ACK)" ]]: quotation marks needed when pattern is a
          reserved word or contains parentheses (note: msg(ACK) without parentheses would be interpreted as an
          object having an "msg" attribute with the value "ACK"!).
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>.tkenvrc file</title>
      <para> Options in the Tkenv runtime are stored in the [[.tkenvrc]] file. There are two [[.tkenvrc]]
        files. One is stored in the current directory and contains project-specific settings like the open
        inspector's position, size, etc. The other [[.tkenvrc]] can be found in the user's home directory and
        contains global settings like font size and family.</para>
      <note>
        Inspectors are identified by their object name. If you have several components that share the same
        name (this is especially common for messages), you may end up with a lot of inspector windows when you
        start your simulation. In such cases, you may simply delete the [[.tkenvrc]] file.
      </note>
    </sect2>
  </sect1>
</chapter>