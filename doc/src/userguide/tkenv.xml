<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "custom-docbook.dtd">
<chapter id="tkenv">
  <title>Graphical Runtime Environment</title>
  <sect1>
    <title>Features</title>
    <para> Tkenv is a portable graphical windowing user interface. Tkenv supports interactive execution of the
      simulation, tracing and debugging. Tkenv is recommended in the development stage of a simulation or for
      presentation and educational purposes, since it allows one to get a detailed picture of the state of
      simulation at any point of execution and to follow what happens inside the network. The most important
      feaures are:</para>
    <itemizedlist>
      <listitem>
        message flow animation
      </listitem>
      <listitem>
        graphical display of statistics (histograms etc.) and output vectors during simulation execution
      </listitem>
      <listitem>
        separate window for each module's text output
      </listitem>
      <listitem>
        scheduled messages can be watched in a window as simulation progresses
      </listitem>
      <listitem>
        event-by-event, normal and fast execution
      </listitem>
      <listitem>
        labeled breakpoints
      </listitem>
      <listitem>
        inspector windows to examine and alter objects and variables in the model
      </listitem>
      <listitem>
        simulation can be restarted
      </listitem>
      <listitem>
        snapshots (detailed report about the model: objects, variables etc.)
      </listitem>
    </itemizedlist>
    <para> Tkenv makes it possible to view simulation results (output vectors etc.) during execution. Results
      can be displayed as histograms and time-series diagrams. This can speed up the process of verifying the
      correct operation of the simulation program and provides a good environment for experimenting with the
      model during execution. When used together with gdb or xxgdb, Tkenv can speed up debugging a lot.</para>
    <para> Tkenv is built with Tcl/Tk, and it works on all platforms where Tcl/Tk has been ported to: Unix/X,
      Windows, Macintosh. You can get more information about Tcl/Tk on the Web pages listed in the Reference.
    </para>
  </sect1>
  <sect1>
    <title>Starting Tkenv</title>
    <para>A simulation program built with Tkenv accepts the following command line switches:</para>
    <itemizedlist>
      <listitem>
        [[-h]] : The program prints a help message and exits.
      </listitem>
      <listitem>
        [[-f fileName]] : Specify the name of the configuration file. The default is [[omnetpp.ini]]. Multiple -f
        switches can be given; this allows you to partition your configuration file. For example, one file can
        contain your general settings, another one most of the module parameters, another one the module
        parameters you change often. The -f switch is optional and can be omitted.
      </listitem>
      <listitem>
        [[-l fileName]] : Load a shared object (.so file on Unix). Multiple -l switches are accepted. Your .so
        files may contain module code etc.
      </listitem>
      <listitem>
        [[-n filePath]] : When present, overrides the NEDPATH environment variable and sets where the
        simulation NED files are load from.
      </listitem>
      <listitem>
        [[-c configname]] : Select a configuration for execution.
      </listitem>
      <listitem>
        [[-r run-number]] : It has the same effect as (but takes priority over) the tkenv-default-run= ini
        file configuration.
      </listitem>
    </itemizedlist>
  </sect1>
  <sect1>
    <title>Configuration options</title>
    <para> Tkenv accepts the following configuration options in the ini file.</para>
    <itemizedlist>
      <listitem>
        [[tkenv-extra-stack]] : Specifies the extra amount of stack (in kilobytes) that is reserved for each
        [[activity()]] simple module when the simulation is run under Tkenv. This value is significantly
        higher than the similar one for Cmdenv -- handling GUI events requires a large amount of stack space.
      </listitem>
      <listitem>
        [[tkenv-default-config]] : Specifies which configuration Tkenv should set up automatically after
        startup.
      </listitem>
      <listitem>
        [[tkenv-default-run]] : Specifies which run Tkenv should set up for the selected configuration after
        startup. If there's no default-run = entry or the value is 0, Tkenv will ask which run to set up.
      </listitem>
      <listitem>
        [[tkenv-image-path]] : Specifies which directories should be scanned when Tkenv wants to load an
        image. This is a semicolon separated list of directories. This setting can be overridden by the
        OMNETPP_IMAGE_PATH environment variable.
      </listitem>
      <listitem>
        [[tkenv-plugin-path]] : Specifies which directories should be scanned when Tkenv wants to load an
        extension plugin. Plugins are small TCL script fragments that contribute additional behaviour to
        Tkenv.
      </listitem>
    </itemizedlist>
    <para>The rest of the Tkenv options are saved into the [[.tkenvrc]] file that can be found in the
      current directory or in the user's home directory (in case of global options).</para>
  </sect1>
  <sect1>
    <title>Environment variables</title>
    <para>In case of nonstandard installation, it may be necessary to set the [[OMNETPP_TKENV_DIR]]
      environment variable so that Tkenv can find its parts written in Tcl script.</para>
    <para> The default path from where the icons are loaded can be changed with the [[OMNETPP_IMAGE_PATH]]
      variable, which is a semicolon-separated list of directories and defaults to
      omnetpp-dir/images;./images.</para>
  </sect1>
  <sect1>
    <title>The main window</title>
    <picture file="pictures/Tkenv-main.png" width="300">The main window of the Tcl/Tk runtime environment
    </picture>
    <para>The main window of the simulation environment contains:</para>
    <itemizedlist>
      <listitem>
        Toolbar: you may access the main functions of the runtime environment. It is possible to step, run,
        stop, re-start or finish the simulation and configure the visual appearance and logging behaviour.
      </listitem>
      <listitem>
        Status bar: contains information about the current state of the simulation. On the upper line it
        displays the current run number and network name, the current event number, the simulation time and
        the module name where the next simulation event will be delivered to. The middle line displays the
        number of messages in the FES, the total number of messages created during the simulation and finally
        the number of messages currently present in the whole simulation model. The last line contains
        performance data: How many events are processed in a real and in a simulated second along with the
        ratio between the simulation-time and real-time.
      </listitem>
      <listitem>
        Timeline: displays the content of the FES on a logarithmic time scale. Double clicking on a dot will
        display the message inspector window. You can set what events are displayed on the timeline by setting
        message filters on the main configuration dialog's timeline tab (Tip: right click on the timeline to
        go directly to the timeline configuration dialog).
      </listitem>
      <listitem>
        Object tree: displays all inspectable objects currently present in the memory. You may double click on
        nodes to further inspect the given object in a separate window.
      </listitem>
      <listitem>
        Log Window: contains the output of the simulation. You can filter the content of the window to include
        messages only from specific modules. Open the log window's context menu and select [[Filter window
        contents ]]. Note that the whole content of the log window will be filtered including all previous
        messages.
      </listitem>
    </itemizedlist>
    Both the Object tree and the Timeline can be easily switched off on the toolbar if you need more space for
    your log window.
  </sect1>
  <sect1>
    <title>Inspecting your simulation</title>
    <sect2>
      <title>Networks, Modules</title>
      <picture file="pictures/Tkenv-network.png">Top level network</picture>
      <para>You can start exploring the component hierarchy by browsing the Object tree and double clicking
        on a node or by clicking the [[Inspect network]] icon on the toolbar. Once you open a node, an
        inspector window will be opened. Networks and compound modules are represented by a graphical
        inspectors displaying their internal structure. Simple modules are represented by object inspectors
        displaying their content as a list. Items in these lists can also be opened and some of them in the
        tree indicated by [...], can be changed during runtime. Double click on the item and edit it in place.
      </para>
      <para> If you intend to watch some variables in your modules, add the [[WATCH(varName)]] macro to your
        module's [[initialize()]] method. The watched variables will be displayed on the the object
        inspector's content page.</para>
      <para>The toolbar on the module inspector window contains several useful commands that can be used
        related to this module. It is possible to directly inspect the parent module, or the type definition
        for this module, show the current module's log output or search for an objects inside the module. It
        is also possible to step or run a simulation until the next event happening inside this module.</para>
      <note>
        Tkenv uses reflection information provided by the [[Register_ClassDescriptor(class)]] macro to display
        the object tree. If you want to include your own classes in the tree, you need to register it with the
        above macro.
      </note>
    </sect2>
    <sect2>
      <title>Future Event Set (FES)</title>
      <picture file="pictures/Tkenv-fes.png">The content of the Future Event Set</picture>
      <para> You can peek into the Future Event Set by clicking on ``Inspect | Scheduled events'' . The FES
        contains all messages already scheduled. Double clicking on any message will show the message object's
        inspector window for further investigation.</para>
      <note>
        The future event set is also displayed on the main window's timeline.
      </note>
    </sect2>
    <sect2>
      <title>Output vectors, histograms, queues</title>
      <picture file="pictures/Tkenv-outvector.png">An output vector displayed in a window</picture>
      <para> Output vectors have also representation in the model. Double clicking on an output vector object
        displays the content graphically. You may set the display properties by clicking on the ``Options...''
        button.</para>
      <note>
        To save memory, output vector windows start gathering data only when you open them. No data priory to
        the opening will be displayed.
      </note>
      <picture file="pictures/Tkenv-histogram.png">A real-time histogram window</picture>
      <para> Histogram inspectors provide a real-time display for the registered histograms.</para>
      <note>
        Histograms may not be available right after the simulation start, because the simulation kernel must
        gather some statistics to determine the histogram properties (number of cells, cell size etc.) before
        it can actually start collecting the data.
      </note>
      <picture file="pictures/Tkenv-queue.png">Peeking into a queue</picture>
      <para> If your simulation contains queue objects, you can peek into them any time. All messages
        currently waiting in the queue are displayed in the queue inspector window. Double click on any
        message to further inspect it.</para>
    </sect2>
  </sect1>
  <sect1>
    <title>Browsing your registered components</title>
    <picture file="pictures/Tkenv-registration.png">Display registered functions, classes etc.</picture>
    <para> Registered components (NED Types, classes, functions, enums) can be displayed with the ``Inspect |
      Available components'' . If your simulation complains about missing types or classes, it is a good
      practice to check whether everything is loaded and registered correctly.</para>
  </sect1>
  <sect1>
    <title>Running and controlling the simulation</title>
    <para>Tkenv has several modes for running the simulation. These running modes have their
      corresponding buttons on Tkenv's toolbar:</para>
    <sect2>
      <title>Step mode</title>
      <para>In Step mode, you can execute the simulation event-by-event.</para>
    </sect2>
    <sect2>
      <title>Run mode</title>
      <para>In Run mode, the simulation runs with all tracing aids on. Message animation is active and
        inspector windows are updated after each event. Output messages are displayed in the main window and
        module output windows. You can stop the simulation with the ``Stop'' button on the toolbar. You can
        fully interact with the user interface while the simulation is running: you can open inspectors etc.
      </para>
      <note>
        If you find this mode too slow or distracting, you may switch off the unneeded animation features in
        the Tkenv configuration dialog.
      </note>
    </sect2>
    <sect2>
      <title>Fast mode</title>
      <para> In Fast mode, animation is turned off. The inspectors and the message output windows are updated
        after in every 500ms (the actual number can be set in ``Options|Simulation options...'' and also in
        the ini file). Fast mode is several times faster than the Run mode; the speedup can get close to 10
        (or the configured event count).</para>
    </sect2>
    <sect2>
      <title>Express mode</title>
      <para> In Express mode, the simulation runs at about the same speed as with Cmdenv, all tracing
        disabled. Module output is not recorded in the output windows any more. You can interact with the
        simulation only once in a while, thus the run-time overhead of the user interface is minimal. You have
        to explicitly push the ``Update inspectors'' button if you want an update.</para>
    </sect2>
    <sect2>
      <title>Run until</title>
      <para> It is possible to run the simulation until a specified simulation time or event number. This is
        an invaluable tool during debugging sessions. Just select ``Simulate | Run until...''</para>
    </sect2>
    <sect2>
      <title>Run until next event</title>
      <para> It is also possible run until an event is received in a specified module. Just browse for the
        module and choose ``Run until next event in this module.'' Simulation will stop once an event arrives
        to this module.</para>
    </sect2>
    <para> Tkenv has a status bar which is regularly updated while the simulation is running. Global
      simulation statistics like simulation speed, event density, current event number and simulation time is
      displayed on the status bar.</para>
    <para> Simulations are created when Tkenv is started and the user has selected a network to simulate (or
      the user clicked the ``New Network'' button to select a new one). First the simulation kernel loads all
      necessary NED files and registers the loaded modules with the kernel. Object constructors are called at
      this point. The next phase is the initialization when all module's [[initialize()]] method is called.
      Once initialization is completed Tkenv returns the control to the user and allows stepping or running
      the simulation. If you choose to quit Tkenv while the simulation is not finished (or try to restart the
      simulation), Tkenv will ask you whether to call the [[finish()]] method for all modules. This will allow
      the modules to correctly free up resources and save statistics. Before the simulation program exits
      modules are destructed and their destructor is called.</para>
  </sect1>
  <sect1>
    <title>Finding objects</title>
    <picture file="pictures/Tkenv-find.png">Finding a specific object</picture>
    <para>There are times when you don't exactly know the location of the object you are looking for.
      Invoke the ``Find/inspect objects'' window and search for your object. The window allows you to set the
      start of the search and the type, class and name of the object. The results will be presented as a
      clickable list.</para>
    <para>You can provide a generic filter expression which matches the object full path by default.
      Wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range [["a".."e"]], plus [["x"]] and
      [["z"]]. You can match numbers: [["*.job{128..191}"]] will match objects named [["job128"]], [["job129"]], ...,
      "job191". "job{128..}" and "job{..191}" are also understood. You can combine patterns with [[AND]], [[OR]] and
      [[NOT]] and parentheses (lowercase and, or, not are also OK). You can match against other object fields such
      as queue length, message kind, etc., with the syntax [["fieldname(pattern)"]]. Put quotation marks around a
      pattern if it contains parentheses. (HINT: You'll want to start the pattern with [["*."]] in most cases, to
      match objects anywhere in the network!)</para>
    <itemizedlist>
      <listitem>
        [[*.destAddr]] : matches all objects whose name is [["destAddr"]] (likely module parameters)
      </listitem>
      [[*.subnet2.*.destAddr]] : matches objects named [["destAddr"]] inside [["subnet2"]]
      <listitem>
        [[*.node[8..10].*]] : matches anything inside module [[node[8], node[9] ]]and [[node[10] ]]
      </listitem>
      <listitem>
        [[className(cQueue) and not length(0)]] : matches non-empty queue objects
      </listitem>
      <listitem>
        [[className(cQueue) and length({10..})]] : matches queue objects with length>=10
      </listitem>
      <listitem>
        [[kind(3) or kind({7..9})]] : matches messages with message kind equal to 3, 7, 8 or 9 (Only messages have
        a [["kind"]] attribute.)
      </listitem>
      <listitem>
        [[className(IP*) and *.data-*]] : matches objects whose class name begins with [["IP"]] and name begins with
        [["data-"]]
      </listitem>
      <listitem>
        [[not className(cMessage) and byteLength({1500..})]] : matches messages whose class is not cMessage, and
        byteLength is at least 1500. (Only messages have a [["byteLength"]] attribute.)
      </listitem>
      <listitem>
        [["*(*" or "*.msg(ACK)"]] : quotation marks needed when pattern is a reserved word or contains
        parentheses. (Note: *.msg(ACK) without parens would be interpreted as some object having a "*.msg"
        attribute with the value "ACK"!)
      </listitem>
    </itemizedlist>
    <note>
      Tkenv uses the [[cObject::forEachChild]] method to collect all object from a tree recursively. If you
      have your own objects derived from [[cObject]] you should redefine the [[cObject::forEachChild]] to
      participate correctly in the object search.
    </note>
    <note>
      If you are debugging your simulation with a source level debugger and happen to know the value of the
      pointer to your object, you may use the ``Inspect by pointer'' menu item and insert the pointer value
      there to display an inspector window for the object. Please note that entering an invalid pointer will
      crash your simulation.
    </note>
  </sect1>
  <sect1>
    <title>Logging and module output</title>
    <picture file="pictures/Tkenv-module-out-menu.png">Opening the log of a single module</picture>
    <para> Good log output is your best friend during debugging. The main window displays the output of the
      whole simulation, however in some cases you may be interested only how a single module is working.
      Choose ``Module output'' from the module's context menu.</para>
    <picture file="pictures/Tkenv-module-out.png">Module output</picture>
    <para>Module output window displays only messages generated by the selected module. You can open
      several module output window and place them side by side to follow the workings of several module at the
      same time.</para>
    <para> It is possible to filter the content of the output windows by opening the log window's context menu
      and selecting ``Filter window contents'' menu item. Individual modules can be selected/deselected.
      General logging behaviour can be controlled in the ``Simulation Options'' dialog.</para>
    <note>
      All message lines in the log window are filtered according to the filter settings (older ones too).
    </note>
  </sect1>
  <sect1>
    <title>Simulation options</title>
    <para> Open ``Options | Simulation options...'' to display the runtime environment's preference dialog.
      You may set global parameters for the simulations here. It is possible also to disable various animation
      primitives to speed up the simulation.</para>
    <sect2>
      <title>General</title>
      <picture file="pictures/Tkenv-sim-opts1.png">General Tkenv options</picture>
      <para>The General options tab can be used to set default layouting and logging behaviour. It is
        possible to set how often the user interface will be updated during the simulation run. Default font
        size and family can be configured also here.</para>
    </sect2>
    <sect2>
      <title>Configuring animations</title>
      <picture file="pictures/Tkenv-sim-opts2.png">Animation options</picture>
      <para> Tkenv provides automatic animation when you run your simulation. You can fine-tune your animation
        settings using the ``Animation'' tab on the configuration dialog. If you do not need all the visual
        feedback Tkenv provides, you can selectively turn off some of the features:</para>
      <itemizedlist>
        <listitem>
          Animate messages : turn on/off the visualization of message passing between modules.
        </listitem>
        <listitem>
          Broadcast animation : handle message broadcasts specially. (Messages that are sent at the same
          simulation time will be animated concurrently.
        </listitem>
        <listitem>
          Show next event maker : Highlight the module which will receive the next event.
        </listitem>
        <listitem>
          Show a flashing arrow when a sendDirect() method call was executed.
        </listitem>
        <listitem>
          Direct method calls are also animated by default with flashing arrows if you have added the
          Enter_Method() macro to your method body.
        </listitem>
        <listitem>
          The display of message names, classes also can be turned off if needed.
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Timeline</title>
      <para>On this page you can control which messages will be displayed on the timeline view.
        Self/non-self messages can be disabled, and filter expressions can be specified based on message class
        or name.</para>
      <para> For object names wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range
        [["a".."e"]], plus [["x"]] and [["z"]]. You can match numbers: [["job{128..191}"]] will match [["job128"]], [["job129"]], ...,
        "job191". "job{128..}" and "job{..191}" are also understood. You can combine patterns with [[AND]], [[OR]] and
        [[NOT]] and parentheses (lowercase and, or, not are also OK). You can match against other object fields
        such as message length, message kind, etc., with the syntax [["fieldname(pattern)"]]. Put quotation marks
        around a pattern if it contains parentheses.</para>
      <itemizedlist>
        <listitem>
          [[m*]] : matches any object whose name begins with "m"
        </listitem>
        <listitem>
          [[m* AND *-{0..250}]] : matches any object whose name begins with "m" and ends with dash and a
          number between 0 and 250
        </listitem>
        <listitem>
          [[not *timer*]] : matches any object whose name doesn't contain the substring "timer"
        </listitem>
        <listitem>
          [[not (*timer* or *timeout*)]] : matches any object whose name doesn't contain either "timer" or
          "timeout"
        </listitem>
        <listitem>
          [[kind(3) or kind({7..9})]] : matches messages with message kind equal to 3, 7, 8 or 9
        </listitem>
        <listitem>
          [[className(IP*) and data-*]] : matches objects whose class name begins with "IP" and name begins
          with "data-"
        </listitem>
        <listitem>
          [[not className(cMessage) and byteLength({1500..}) ]]: matches objects whose class is not cMessage,
          and byteLength is at least 1500
        </listitem>
        <listitem>
          [["or" or "and" or "not" or "*(*" or "msg(ACK)" ]]: quotation marks needed when pattern is a
          reserved word or contains parentheses. (Note: msg(ACK) without parens would be interpreted as some
          object having a "msg" attribute with the value "ACK"!)
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>.tkenvrc file</title>
      <para> Options in the Tkenv runtime are stored in the [[.tkenvrc]] file. There are two [[.tkenvrc]]
        file. One is stored in the current directory and contains project specific settings like the open
        inspector's position, size etc. The other [[.tkenvrc]] can be found in the user's home directory and
        contains global settings like font size and family.</para>
      <note>
        Inspectors are identified by their object name. If you have several components that share the same
        name (this is especially common for messages), you may end up with a lot of inspector windows when you
        start your simulation.
      </note>
    </sect2>
  </sect1>
</chapter>