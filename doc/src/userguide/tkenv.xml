<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "custom-docbook.dtd">
<chapter id="tkenv">
  <title>The Tkenv Graphical Runtime Environment</title>
  <sect1>
    <title>Features</title>
    <para> Tkenv is a graphical runtime interface for simulations. Tkenv supports interactive simulation execution,
      animation, tracing and debugging. Tkenv is recommended in the development stage of a simulation and for
      presentation and educational purposes, since it allows the user to get a detailed picture of the state of the
      simulation at any point in its execution, and to follow what happens inside the network. The most important
      feaures are:</para>
    <itemizedlist>
      <listitem>
        message flow animation
      </listitem>
      <listitem>
        graphical display of statistics (histograms, etc.) and output vectors during simulation execution
      </listitem>
      <listitem>
        separate window for each module's text output
      </listitem>
      <listitem>
        scheduled messages can be watched in a window as simulation progresses
      </listitem>
      <listitem>
        event-by-event, normal and fast execution
      </listitem>
      <listitem>
        labeled breakpoints
      </listitem>
      <listitem>
        inspector windows to examine and alter objects and variables in the model
      </listitem>
      <listitem>
        simulation can be restarted
      </listitem>
      <listitem>
        snapshots (detailed report about the model: objects, variables, etc.)
      </listitem>
    </itemizedlist>
    <para> Tkenv makes it possible to view simulation results (output vectors, etc.) during execution. Results
      can be displayed as histograms and time-series diagrams. This can speed up the process of verifying the
      correct operation of the simulation program and provides a good environment for experimenting with the
      model during execution. When used together with a C++ source-level debugger, Tkenv can significantly
      speed up development time.</para>
  </sect1>
  <sect1>
    <title>Starting Tkenv</title>
    <para>A simulation program built with Tkenv accepts the following command line switches:</para>
    <itemizedlist>
      <listitem>
        [[-h]] : The program prints a help message and exits.
      </listitem>
      <listitem>
        [[-f fileName]] : Specifies the name of the configuration file. The default is [[omnetpp.ini]]. Multiple [[-f]]
        switches can be given; this allows you to partition your configuration file. For example, one file can
        contain your general settings, another one most of the module parameters, and a third one the module
        parameters you change frequently. The [[-f]] switch is optional and can be omitted.
      </listitem>
      <listitem>
        [[-l fileName]] : Loads a shared library ([[.so]] file on Unix, [[.dll]] on Windows,
        and [[.dylib]] on Mac OS X). Multiple [[-l]] switches are accepted. Shared libraries
        may contain simple modules and other, arbitrary code. File names may be specified without
        the file extension and the [[lib]] name prefix (i.e. [[foo]] instead of [[libfoo.so]]).
      </listitem>
      <listitem>
        [[-n filePath]] : When present, overrides the [[NEDPATH]] environment variable and sets
        the source locations for simulation NED files.
      </listitem>
      <listitem>
        [[-c configname]] : Selects an INI configuration for execution.
      </listitem>
      <listitem>
        [[-r run-number]] : It has the same effect as (but takes priority over) the ``tkenv-default-run=''
        INI file configuration option.
      </listitem>
    </itemizedlist>
  </sect1>
  <sect1>
    <title>Configuration Options</title>
    <para> Tkenv accepts the following configuration options in the INI file.</para>
    <itemizedlist>
      <listitem>
        [[tkenv-extra-stack]] : Specifies the extra amount of stack (in kilobytes) that is reserved for each
        [[activity()]] simple module when the simulation is run under Tkenv. This value is significantly
        higher than the similar one for Cmdenv (handling GUI events requires a large amount of stack space).
      </listitem>
      <listitem>
        [[tkenv-default-config]] : Specifies which INI file configuration Tkenv should set up automatically after
        startup. If there is no such option, Tkenv will ask which configuration to set up.
      </listitem>
      <listitem>
        [[tkenv-default-run]] : Specifies which run of the selected configuration Tkenv should set up
        after startup. If there is no such option, Tkenv will ask.
      </listitem>
      <listitem>
        [[tkenv-image-path]] : Specifies which directories (in addition to [[OMNETPP_IMAGE_PATH]]
        or its built-in default value) Tkenv will load images from. This is a semicolon-separated
        list of directories. The directories will be scanned recursively, and subdirectory names
        become part of the icon name; for example, if an [[images/]] directory is listed,
        [[images/misc/foo.png]] will be registered as icon [[misc/foo]]. PNG and GIF files are accepted.
      </listitem>
      <listitem>
        [[tkenv-plugin-path]] : Specifies which directories (in addition to [[OMNETPP_PLUGIN_PATH]]
        or its built-in default value) will be scanned for Tkenv plugins written in Tcl.
      </listitem>
    </itemizedlist>
    <para>The rest of the Tkenv options are saved into the [[.tkenvrc]] file in the user's home directory.</para>
  </sect1>
  <sect1>
    <title>Environment Variables</title>
    <para>In case of nonstandard installation, it may be necessary to set the [[OMNETPP_TKENV_DIR]]
      environment variable so that Tkenv can find its parts written in Tcl script.</para>
    <para> The default path from where the icons are loaded can be changed with the [[OMNETPP_IMAGE_PATH]]
      variable, which is a semicolon-separated list of directories that defaults to
      [[omnetpp-dir/images;./images]].</para>
    <para> The path from where Tkenv plugins written in Tcl are loaded can be changed
      with the [[OMNETPP_PLUGIN_PATH]] variable, which is a semicolon-separated list of directories
      that defaults to [[./plugins]].</para>
  </sect1>
  <sect1>
    <title>The Main Window</title>
    <picture file="pictures/Tkenv-main.png" width="300">The main window of Tkenv
    </picture>
    <para>The main window of the simulation environment contains:</para>
    <itemizedlist>
      <listitem>
        ``Toolbar'': You may access the main functions of the runtime environment. The toolbar is displayed
        directly below the main window's menu. It is possible to step, run,
        stop, restart or finish the simulation and configure the visual appearance and logging behavior.
      </listitem>
      <listitem>
        ``Status bar'': Contains information about the current state of the simulation. On the upper line, it
        displays the current run number and network name, the current event number, the simulation time and
        the module name to where the next simulation event will be delivered. The middle line displays the
        number of messages in the FES, the total number of messages created during the simulation and finally
        the number of messages currently present in the whole simulation model. The last line contains
        performance data: How many events are processed in a real and in a simulated second along with the
        relative speed between the simulation-time and real-time.
      </listitem>
      <listitem>
        ``Timeline'': Displays the contents of the Future Events Set on a logarithmic time scale.
        Each dot represents an event. Double-clicking on a dot will open an inspector window for the event.
        The contents of the Timeline can be configured on the ``Timeline'' tab of the
        ``Simulation Options'' dialog by specifying message filters. (Tip: the Timeline context menu
        provides a shortcut to that dialog).
      </listitem>
      <listitem>
        ``Object Tree'': Displays all inspectable objects currently present in the memory. You may double-click on
        nodes to further inspect the given object in a separate window.
      </listitem>
      <listitem>
        ``Log Area'': Contains the output of the simulation. You can filter the content of the window to only include
        messages from specific modules. Open the log window's context menu and select ``Filter window
        contents''. Note that the whole content of the log window will be filtered including all previous
        messages.
      </listitem>
    </itemizedlist>
    Both the Object tree and the Timeline can be easily switched off on the toolbar if you need more space for
    the log area.
  </sect1>
  <sect1>
    <title>Inspecting the Simulation</title>
    <sect2>
      <title>Networks, Modules</title>
      <picture file="pictures/Tkenv-network.png">Top level network</picture>
      <para>You can start exploring the component hierarchy by browsing the Object Tree and double-clicking
        on a node or by clicking the ``Inspect network'' icon on the toolbar. Once you open a node, an
        inspector window will be opened. Networks and compound modules are represented by graphical
        inspectors that display their internal structures. Simple modules are represented by object inspectors
        that display their content as lists. Items in these lists can also be opened and some of them in the
        tree indicated by [...] can be changed during runtime. Double-click on the item and edit it in place.
      </para>
      <para> If you intend to watch some variables in your modules, add the [[WATCH(varName)]] macro to your
        module's source code, in the [[initialize()]] method. The watched variables will be displayed on the object
        inspector's content page.</para>
      <para>The toolbar on the module inspector window contains several useful commands that can be used
        related to this module. It is possible to directly inspect the parent module, or the type definition
        for this module, show the current module's log output or search for objects inside the module. It
        is also possible to step or run a simulation until the next event occurs in the module.</para>
      <note>
        Tkenv uses reflection information provided by the [[Register_ClassDescriptor(class)]] macro to display
        the object tree. If you want to include your own classes in the tree, you need to register them with the
        above macro.
      </note>
    </sect2>
    <sect2>
      <title>Future Event Set (FES)</title>
      <picture file="pictures/Tkenv-fes.png">The content of the Future Event Set</picture>
      <para> You can peek into the Future Event Set by clicking on ``Inspect | Scheduled events''. The FES
        contains all messages already scheduled. Double-clicking on any message will show the message object's
        inspector window for further investigation.</para>
      <note>
        The future event set is also displayed on the main window's timeline.
      </note>
    </sect2>
    <sect2>
      <title>Output Vectors, Histograms, Queues</title>
      <picture file="pictures/Tkenv-outvector.png">An output vector displayed in a window</picture>
      <para> You can view graphical representations of output vectors. Double-clicking an output vector object
        displays the content graphically as a line chart. You may set the display properties by clicking
        on the ``Options...'' button.</para>
      <note>
        To conserve memory, output vector windows only start gathering data when you open them.
      </note>
      <picture file="pictures/Tkenv-histogram.png">A real-time histogram window</picture>
      <para> Histogram inspectors provide a real-time display of histogram objects.</para>
      <note>
        Histogram graphics may not be available immediately, because a histogram object must
        precollect some data before it can determine the range of the data and set up the cells.
      </note>
      <picture file="pictures/Tkenv-queue.png">Peeking into a queue</picture>
      <para> If your simulation contains queue objects, you can peek into them. All messages
        currently waiting in the queue are displayed in the queue inspector window.
        Double-click on any message to inspect it further.</para>
    </sect2>
  </sect1>
  <sect1>
    <title>Browsing the Registered Components</title>
    <picture file="pictures/Tkenv-registration.png">Display registered functions, classes, etc.</picture>
    <para> Registered components (NED Types, classes, functions, enums) can be displayed with the ``Inspect |
      Available components''. If an error message reports missing types or classes, you can check here
      whether everything is loaded and registered correctly.</para>
  </sect1>
  <sect1>
    <title>Running and Controlling the Simulation</title>
    <para>Tkenv has several modes for running the simulation. These running modes have their
      corresponding buttons on Tkenv's toolbar:</para>
    <sect2>
      <title>Step Mode</title>
      <para>In Step mode, you can execute the simulation event-by-event. The next event is always
      shown on the status bar. The module where the next event will be delivered is highlighted
      with a red rectangle on the graphical display.</para>
    </sect2>
    <sect2>
      <title>Run Mode</title>
      <para>In Run mode, the simulation runs with all tracing aids on. Message animation is active and
        inspector windows are updated after each event. Output messages are displayed in the main window and
        module output windows. You can stop the simulation with the ``Stop'' button on the toolbar. You can
        fully interact with the user interface while the simulation is running (e.g. you can open inspectors, etc.).
      </para>
      <note>
        If you find this mode too slow or distracting, you may switch off animation features in
        the Tkenv configuration dialog.
      </note>
    </sect2>
    <sect2>
      <title>Fast Mode</title>
      <para> In Fast mode, animation is turned off. The inspectors and the message output windows are updated
        every 500 milliseconds (the actual number can be set in ``Options|Simulation options...'' and also in
        the INI file). Fast mode is several times faster than the Run mode; the speed can increase by up to 10 times
        (or up to the configured event count).</para>
    </sect2>
    <sect2>
      <title>Express Mode</title>
      <para> In Express mode, the simulation runs at about the same speed as with Cmdenv, all tracing
        disabled. Module output is not recorded in the output windows. You can interact with the
        simulation only once in a while, thus the run-time overhead of the user interface is minimal. You have
        to explicitly push the ``Update inspectors'' button if you want an update.</para>
    </sect2>
    <sect2>
      <title>Run Until</title>
      <para>You can run the simulation until a specified simulation time, event number or
        until a specific message has been delivered or canceled. This is
        a valuable tool during debugging sessions (select ``Simulate | Run until...'').
        It is also possible to right-click on an event in the simulation timeline and choose
        the ``Run until this event'' menu item.</para>
    </sect2>
    <sect2>
      <title>Run Until Next Event</title>
      <para> It is also possible to run until an event occurs in a specified module. Browse for the
        module and choose ``Run until next event in this module.'' Simulation will stop once an event occurs
        in the selected module.</para>
    </sect2>
    <para> Tkenv has a status bar which is regularly updated while the simulation is running. Global
      simulation statistics like simulation speed, event density, current event number and simulation time are
      displayed on the status bar.</para>
    <para> Simulations are created when Tkenv is started and the user has selected a network to simulate (or
      the user clicks the ``New Network'' button to select a new one). First, the simulation kernel loads all
      necessary NED files and registers the loaded modules with the kernel. Object constructors are called at
      this point. The next phase is initialization when all module's [[initialize()]] methods are called.
      Once initialization is complete, Tkenv returns the control to the user and allows stepping or running
      the simulation. If you choose to quit Tkenv before the simulation finishes (or try to restart the
      simulation), Tkenv will ask you whether to call the [[finish()]] method for all modules. This will allow
      the modules to correctly free up resources and save their statistics. Before the simulation program exits,
      the modules are deleted and their destructors are called.</para>
  </sect1>
  <sect1>
    <title>Finding Objects</title>
    <picture file="pictures/Tkenv-find.png">Finding a specific object</picture>
    <para>There are times when you do not know the exact location of the object for which you are looking.
      For example, you may want to know the locations for all your messages.
      Invoke the ``Find/inspect objects'' window and search for your object. The window allows you to set the
      start of the search along with the type, class and name of the object. The results will be presented as a
      clickable list.</para>
    <note>
      The checkboxes can be used to select the object category that interests you. If you
      select a category, all objects with that type (and any type derived from it) will be included in the search.
      Alternatively, if you specify object class as a class filter expression, the search
      dialog will try to match the object's class name with the given string. This means that only those types of objects
      will be included in the search (derived types will not be included as they have different
      non-matching classnames).
    </note>
    <para>You can provide a generic filter expression, which matches the object's full path by default.
      Wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range [["a".."e"]] plus [["x"]] and
      [["z"]]. You can match numbers: [["*.job{128..191}"]] will match objects named [["job128"]], [["job129"]], ...,
      "job191". "job{128..}" and "job{..191}" are also understood. You can combine patterns with [[AND]], [[OR]] and
      [[NOT]] and parentheses (lowercase and, or, not are also OK). You can match other object fields such
      as queue length, message kind, etc., with the syntax [["fieldname(pattern)"]]. Put quotation marks around a
      pattern if it contains parentheses (HINT: You will want to start the pattern with [["*."]] in most cases to
      match objects anywhere in the network!).</para>
    <itemizedlist>
      <listitem>
        [[*.destAddr]] : Matches all objects with the name [["destAddr"]] (likely module parameters).
      </listitem>
      [[*.subnet2.*.destAddr]] : Matches objects named [["destAddr"]] inside [["subnet2"]].
      <listitem>
        [[*.node[8..10].*]] : Matches anything inside module [[node[8], node[9] ]]and [[node[10] ]].
      </listitem>
      <listitem>
        [[className(cQueue) and not length(0)]] : Matches non-empty queue objects.
      </listitem>
      <listitem>
        [[className(cQueue) and length({10..})]] : Matches queue objects with length>=10.
      </listitem>
      <listitem>
        [[kind(3) or kind({7..9})]] : Matches messages with message kind equal to 3, 7, 8 or 9 (only messages have
        a [["kind"]] attribute).
      </listitem>
      <listitem>
        [[className(IP*) and *.data-*]] : Matches objects whose class name begins with [["IP"]] and name begins with
        [["data-."]]
      </listitem>
      <listitem>
        [[not className(cMessage) and byteLength({1500..})]] : Matches messages whose class is not cMessage and
        byteLength is at least 1500 (only messages have a [["byteLength"]] attribute).
      </listitem>
      <listitem>
        [["*(*" or "*.msg(ACK)"]] : Quotation marks needed when pattern is a reserved word or contains
        parentheses (note: *.msg(ACK) without parentheses would be interpreted as some object having a "*.msg"
        attribute with the value "ACK"!).
      </listitem>
    </itemizedlist>
    <note>
      Tkenv uses the [[cObject::forEachChild]] method to collect all objects from a tree recursively. If you
      have your own objects derived from [[cObject]], you should redefine the [[cObject::forEachChild]] to
      function correctly with an object search.
    </note>
    <note>
      If you are debugging the simulation with a source level debugger, you may also use
      the ``Inspect by pointer'' menu item. Let the debugger display the address of the object
      to be inspected, and paste it into the dialog. Please note that entering an invalid pointer will
      crash the simulation.
    </note>
  </sect1>
  <sect1>
    <title>Logging and Module Output</title>
    <picture file="pictures/Tkenv-module-out-menu.png">Opening the log of a single module</picture>
    <para>By default, the main window displays the output of the whole simulation.
      It is possible to filter the content of the output windows by opening the log window's context menu
      and selecting the ``Filter window contents'' menu item. Individual modules can be selected
      and deselected.</para>
    <picture file="pictures/Tkenv-output-filter.png">Filtering the output of a compound module</picture>

    <para> General logging behavior can be controlled in the ``Simulation Options'' dialog.</para>
    <para> It is also possible to open separate log windows for individual modules.
      A log window for a compound module displays the log from all of its submodule tree.
      To open a log window, find the module in the module tree or the network display, right-click
      it and choose ``Module output'' from the context menu.</para>
    <picture file="pictures/Tkenv-module-out.png">Module output</picture>
    <para>The module output window only displays messages generated by the selected module and its submodules.
      You can open several module output windows and place them side by side to follow the workings of
      several modules at the same time.</para>
    <note>
      All message lines in the log window are filtered according to the filter settings (older ones, too).
    </note>
  </sect1>
  <sect1>
    <title>Simulation Options</title>
    <para> Select ``Options | Simulation Options...'' from the menu to display the runtime environment's
      preferences dialog. It is possible to adjust various display, network layouting and animation
      options in the dialog. For example, it is possible to disable various animation effects.</para>
    <sect2>
      <title>General</title>
      <picture file="pictures/Tkenv-sim-opts1.png">General Tkenv options</picture>
      <para>The ``General'' tab can be used to set the default display and logging behavior. It is
        possible to set how often the user interface will be updated during the simulation run.
        The user can also configure default font size and family here.
      </para>
    </sect2>
    <sect2>
      <title>Configuring the Layouting Algorithm</title>
      <picture file="pictures/Tkenv-sim-opts2.png">Layouting options</picture>
      <para>Tkenv provides automatic layouting for submodules that do not have their locations
        specified in the NED files. The layouting algorithm can be fine-tuned on the ``Layouting'' page
        of the configuration dialog.</para>
    </sect2>
    <sect2>
      <title>Configuring Animation</title>
      <picture file="pictures/Tkenv-sim-opts3.png">Animation options</picture>
      <para>Tkenv provides automatic animation when you run the simulation. You can fine-tune the animation
        settings using the ``Animation'' tab on the configuration dialog. If you do not need all visual
        feedback Tkenv provides, you can selectively turn off some of the features:</para>
      <itemizedlist>
        <listitem>
          Animate messages : Turns on/off the visualization of messages passing between modules.
        </listitem>
        <listitem>
          Broadcast animation : Handles message broadcasts in a special way (messages sent within the
          same event will be animated concurrently).
        </listitem>
        <listitem>
          Show next event maker : Highlights the module which will receive the next event.
        </listitem>
        <listitem>
          Show a flashing arrow when a [[sendDirect()]] method call is executed.
        </listitem>
        <listitem>
          Show a flashing arrow when a method call occurs from one module to another.
          The call is only animated if the called method contains the [[Enter_Method()]] macro.
        </listitem>
        <listitem>
          The display of message names and classes can also be turned off.
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Configuring the Timeline</title>
      <para>On the ``Timeline'' tab, you can control which messages and events will be displayed on the Timeline View
        in the main window.
        Self/non-self messages can be disabled and filter expressions can be specified based on message class
        or name.</para>
      <para> For object names, wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range
        [["a".."e"]] plus [["x"]] and [["z"]]. You can match numbers: [["job{128..191}"]] will match [["job128"]], [["job129"]], ...,
        "job191". "job{128..}" and "job{..191}" are also understood. You can combine patterns with [[AND]], [[OR]] and
        [[NOT]] and parentheses (lowercase and, or, not are also acceptable). You can match against other object fields
        such as message length, message kind, etc. with the syntax [["fieldname(pattern)"]]. Put quotation marks
        around a pattern if it contains parentheses.</para>
      <itemizedlist>
        <listitem>
          [[m*]] : matches any object whose name begins with "m"
        </listitem>
        <listitem>
          [[m* AND *-{0..250}]] : matches any object whose name begins with "m" and ends with a dash and a
          number between 0 and 250
        </listitem>
        <listitem>
          [[not *timer*]] : matches any object whose name does not contain the substring "timer"
        </listitem>
        <listitem>
          [[not (*timer* or *timeout*)]] : matches any object whose name does not contain either "timer" or
          "timeout"
        </listitem>
        <listitem>
          [[kind(3) or kind({7..9})]] : matches messages with message kind equal to 3, 7, 8 or 9
        </listitem>
        <listitem>
          [[className(IP*) and data-*]] : matches objects whose class name begins with "IP" and name begins
          with "data-"
        </listitem>
        <listitem>
          [[not className(cMessage) and byteLength({1500..}) ]]: matches objects whose class is not cMessage
          and whose byteLength is at least 1500
        </listitem>
        <listitem>
          [["or" or "and" or "not" or "*(*" or "msg(ACK)" ]]: quotation marks needed when pattern is a
          reserved word or contains parentheses (note: msg(ACK) without parentheses would be interpreted as an
          object having an "msg" attribute with the value "ACK"!).
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>The .tkenvrc File</title>
      <para> Options in the Tkenv runtime are stored in [[.tkenvrc]] files. There are two [[.tkenvrc]]
        files. One is stored in the current directory and contains project-specific settings like the open
        inspector's position, size, etc. The other [[.tkenvrc]] can be found in the user's home directory and
        contains global settings like font size and family.</para>
      <note>
        Inspectors are identified by their object names. If you have several components that share the same
        name (this is especially common for messages), you may end up with a lot of inspector windows when you
        start the simulation. In such cases, you may simply delete the [[.tkenvrc]] file.
      </note>
    </sect2>
  </sect1>
</chapter>