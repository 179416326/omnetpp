<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "custom-docbook.dtd">
<chapter id="tkenv">
  <title>The Tkenv Graphical Runtime Environment</title>
  <sect1>
    <title>Features</title>
    <para> Tkenv is a graphical runtime interface for simulations. Tkenv
      supports interactive simulation execution, animation, inspection, tracing
      and debugging. In addition to model development and verification, Tkenv is
      also useful for presentation and educational purposes, since it allows the user
      to get a detailed picture of the state and history of the simulation at any
      point of its execution.
    </para>
    <para> When used together with a C++ source-level debugger, Tkenv can significantly
      speed up model development.
    </para>
    <para>Its most important features are:</para>
    <itemizedlist>
      <listitem>network visualization</listitem>
      <listitem>message flow animation</listitem>
      <listitem>various run modes: event-by-event, normal, fast, express</listitem>
      <listitem>run until (event or simulation time)</listitem>
      <listitem>simulation can be restarted</listitem>
      <listitem>log of message flow</listitem>
      <listitem>display of textual module logs</listitem>
      <listitem>inspectors for viewing contents of objects and variables in the model</listitem>
      <listitem>visualization of statistics (histograms, etc.) during simulation execution</listitem>
      <listitem>eventlog recording for later analysis</listitem>
      <listitem>snapshots (detailed report about the model: objects, variables, etc.)</listitem>
    </itemizedlist>
  </sect1>
  <sect1>
    <title>Overview of the User Interface</title>
    <picture file="pictures/Tkenv-main.png" width="400">The main window of Tkenv</picture>
    <para>The top of the window contains the following elements below the menu bar:</para>
    <itemizedlist>
      <listitem>
        ``Toolbar'': The toolbar lets you access the most frequently used functions,
        such as stepping, running and stopping the simulation.
      </listitem>
      <listitem>
        ``Status bar'': Two rows of various fields and gauges, displaying the current event number,
        simulation time, information about the next simulation event, and other details.
        When the simulation is running, it displays performance data like the number of
        events processed per second. The second row can be turned off to free up vertical space.
      </listitem>
      <listitem>
        ``Timeline'': Displays the contents of the Future Events Set (FES) on a logarithmic time scale.
        The timeline can be turned off to free up vertical space.
      </listitem>
    </itemizedlist>
    <para>The main window is divided into the following areas:</para>
    <itemizedlist>
      <listitem>
        ``Object Navigator'': Displays the hierarchy of objects in the current simulation and in the FES.
      </listitem>
      <listitem>
        ``Object Inspector'': Displays the contents and properties of the selected object.
      </listitem>
      <listitem>
        ``Network Display'': Displays the network or any module graphically. This is also where
        animation takes place.
      </listitem>
      <listitem>
        ``Log Viewer'': Displays the log of packets or messages sent between modules, or log messages
        output by modules during simulation.
      </listitem>
    </itemizedlist>
    <para>Additionally, you can open inspector windows that float on top of the main window.</para>
  </sect1>

  <sect1>
    <title>Using Tkenv</title>
    <sect2>
      <title>Starting Tkenv</title>
      <para>When you launch a simulation from the IDE, by default it will be started with Tkenv.
        When it does not, you can explicitly select Tkenv in the ``Run'' or ``Debug'' dialog.
      </para>
      <para>Tkenv is also the default when you start the simulation from the command line.
        When necessary, you can force Tkenv by adding the [[-u Tkenv]] switch to the command line.
      </para>
      <para>The complete list of command-line options, related environment variables
        and configuration options can be found at the end of this chapter.
      </para>
    </sect2>
    <sect2>
      <title>Setting Up and Running the Simulation</title>
      <para>On startup, Tkenv reads the ini file(s) specified on the command line (or [[omnetpp.ini]]
        if none is specified), and automatically sets up the simulation described in them.
        If they contain several simulation configurations, Tkenv will ask you which one you
        want to set up.
      </para>
      <picture file="pictures/Tkenv-setup-dialog.png">Setting Up a New Simulation</picture>
      <para>Once a simulation has been set up (modules have been created and initialized),
        you can run it in various modes and examine its state. At any time you can restart
        the simulation, or set up another simulation. If you choose to quit Tkenv before the
        simulation finishes (or try to restart the simulation), Tkenv will ask you whether
        to finalize the simulation, which usually translates to saving summary statistics.
      </para>
      <para>Functions related to setting up a simulation are in the ``File'' menu.
        Some of these functions are:
      </para>
      <picture file="pictures/Tkenv-file-menu.png">The File menu</picture>
      <sect3>
        <title>Set up a Configuration</title>
        <para>This function lets you choose a configuration and run number from the ini file.
        </para>
      </sect3>
      <sect3>
        <title>Open Primary Ini File</title>
        <para>Opens the first ini file in an text window for viewing.
        </para>
      </sect3>

      <para>Simulation-related functions are in the ``Simulate'' menu, and are accessible via
        toolbar icons and keyboard shortcuts as well.
      </para>
      <picture file="pictures/Tkenv-simulate-menu.png">The Simulate menu</picture>
      <sect3>
        <title>Step</title>
        <para>``Step'' lets you execute one simulation event, that at the front of the FES.
          The next event is always shown on the status bar. The module where the next event
          will be delivered is highlighted with a red rectangle on the graphical display.
        </para>
      </sect3>
      <sect3>
        <title>Run (or Normal Run)</title>
        <para>In ``Run'' mode, the simulation runs with all tracing aids on. Message animation is active and
          inspector windows are updated after each event. Output messages are displayed in the main window and
          module output windows. You can stop the simulation with the ``Stop'' button on the toolbar. You can
          fully interact with the user interface while the simulation is running (e.g. you can open inspectors, etc.).
        </para>
        <note>
          If you find this mode too slow or distracting, you may switch off animation features in
          the ``Preferences'' dialog.
        </note>
      </sect3>
      <sect3>
        <title>Fast Run</title>
        <para> In ``Fast'' mode, animation is turned off. The inspectors and the message output windows
          are updated every 500 milliseconds (the actual number can be set in ``File|Preferences...'').
          Fast mode is several times faster than the Run mode; the speed can increase by up to 10 times
          (or up to the configured event count).
        </para>
      </sect3>
      <sect3>
        <title>Express Run</title>
        <para> In ``Express mode'', the simulation runs at about the same speed as with Cmdenv, all tracing
          disabled. Module log is not recorded. You can interact with the simulation only once in a while,
          thus the run-time overhead of the user interface is minimal. You have to explicitly click
          the ``Update inspectors'' button if you want a display update.
        </para>
      </sect3>
      <sect3>
        <title>Run Until</title>
        <para>You can run the simulation until a specified simulation time, event number or
          until a specific message has been delivered or canceled. This is
          a valuable tool during debugging sessions (select ``Simulate | Run until...'').
          It is also possible to right-click on an event in the simulation timeline and choose
          the ``Run until this event'' menu item.
        </para>
        <picture file="pictures/Tkenv-rununtil.png">The Run Until dialog</picture>
      </sect3>
      <sect3>
        <title>Run Until Next Event</title>
        <para> It is also possible to run until an event occurs in a specified module. Browse for the
          module and choose ``Run until next event in this module.'' Simulation will stop once an event occurs
          in the selected module.</para>
      </sect3>
      <sect3>
        <title>Debug Next Event</title>
        <para> This function is useful when you are running the simulation under a C++ source-level
          debugger. ``Debug Next Event'' will perform one simulation event just like ``Step'', but
          executes a software debugger breakpoint ([[int3]] or [[SIGTRAP]]) just before entering
          the module's event handling code ([[handleMessage()]] or [[activity()]]). This will
          cause the debugger to stop the program there, letting you examine state variables,
          single-step, etc. When you resume execution, Tkenv will get back control and become
          responsive again.
        </para>
      </sect3>
      <sect3>
        <title>Recording an Event Log</title>
        <para>The &Omnetpp; simulation kernel allows you to record event related information into a file
          which later can be used to analyze the simulation run using the ``Sequence Chart'' tool in
          the IDE. Eventlog recording can be turned on with the [[record-eventlog=true]] ini file option,
          but also interactively, via the respective item in the ``Simulate'' menu, or using a toobar button.
        </para>
        <para>Note that the starting Tkenv with [[record-eventlog=true]] and turning on recording later
          does not result in exactly the same eventlog file. In the former case, all steps of setting up
          the network, such as module creations, are recorded as they happen; while for the latter,
          Tkenv has to "fake" a chain of steps that would result in the current state of the simulation.
        </para>
      </sect3>
      <sect3>
        <title>Conclude Simulation</title>
        <para> This function finalizes the simulation by invoking the user-supplied [[finish()]]
          member functions on all module and channel objects in the simulation. The customary
          implementation of [[finish()]] is to record summary statistics. The simulation cannot
          be continued afterwards.
        </para>
      </sect3>
      <sect3>
        <title>Rebuild Network</title>
        <para> Rebuilds the simulation by deleting the current network and setting it up again.
          Improperly written simulations often crash when ``Rebuild Network'' is invoked; this is
          usually due to incorrectly written destructors in module classes.
        </para>
      </sect3>
    </sect2>
    <sect2>
      <title>Inspecting Simulation Objects</title>
      <sect3>
        <title>Inspectors</title>
        <para> The ``Network Display'', the ``Log Viewer'' and the ``Object Inspector''
          in the main window share some common properties: they display various aspects
          (graphical view / log messages / fields or contents) of a given object.
          Such UI parts are called ``inspectors'' in Tkenv.
        </para>
        <para> The three inspectors mentioned above are built into the main window, but
          you can open add additional ones at any time. The new inspectors will open in
          floating windows above the main window, and you can have any number of them open.
        </para>
        <picture file="pictures/Tkenv-floating-inspector.png">A floating inspector window</picture>
        <para> Inspectors come in many flavours. They can be graphical like the network view
          or a histogram inspector, textual like a log viewer, tree-based like an object
          inspector, or something entirely different.
        </para>
      </sect3>
      <sect3>
        <title>Opening Inspectors</title>
        <para>Inspectors can be opened in various ways: by double-clicking an item in the
          ``Object Navigator'' or in other inspectors; by choosing one of the ``Open...''
          menu items from the context menu of an object displayed on the UI;
          via the ``Find/Inspect Objects'' dialog (see later); or even by directly entering
          the C++ pointer of an object as a hex value. Inspector-related menu items are
          in the ``Inspect'' menu.</para>
        <picture file="pictures/Tkenv-inspect-menu.png">The Inspect menu</picture>
      </sect3>
      <sect3>
        <title>History</title>
        <para> Inspectors always show some aspect of one simulation object, but
          they can change objects. For example, in the ``Network View'', when you double-click
          a submodule which is itself a compound module, the view will switch to
          showing the internals of that module; or, the ``Object Inspector'' will always
          show information about the object last clicked in the UI.
          Inspectors maintain a navigable history: the ``Back''/``Forward'' functions
          go to the object inspected before/after the currently displayed object.
          Objects that are deleted during simulation also disappear from the history.
        </para>
      </sect3>
      <sect3>
        <title>Restoring Inspectors</title>
        <para> When you exit and then restart a simulation program, Tkenv tries to restore
          the open inspector windows. However, as object identity is not preserved
          across different runs of the same program, Tkenv uses the object full path,
          class name and object ID (where exists) to find and identify the object
          to be inspected.
        </para>
        <para> Preferences such as zoom level or open/closed state of a tree node are usually
          maintained per object type (i.e. tied to the C++ class of the inspected object).
        </para>
      </sect3>
      <sect3>
        <title>Extending Tkenv</title>
        <para> It is possible for the user to contribute new inspector types without
          modifying Tkenv code. For this, the inspector C++ code needs to include
          Tkenv header files and link with the Tkenv library. One caveat is that the
          Tkenv headers are not public API and thus subject to change in a new version
          of &Omnetpp;.
        </para>
      </sect3>
    </sect2>
  </sect1>

  <sect1>
    <title>Using Tkenv with a Debugger</title>
    <para>You  can use Tkenv together with a C++ debugger, which is mainly useful when
      developing new models. When you do that, there are a few things you need to know.
    </para>
    <para>Tkenv is a library that runs as part of the simulation program. This has
      a lot of implications, the most apparent being that when the simulation crashes
      (due to a bug in the model's C++ code), it will bring down the whole OS process,
      including the Tkenv GUI.
    </para>
    <para>The second consequence is that suspending the simulation program in a debugger
      will also freeze the GUI until it is resumed. Also, Tkenv is also single-theaded
      and runs in the same thread as the simulation program, so even if you only suspend
      the simulation's thread in the debugger, the UI will freeze.
    </para>
    <para>The Tkenv UI deals with [[cObject]]s (the C++ methods that the GUI relies
      on are defined on [[cObject]]). All other data such as primitive variables,
      non-cObject classes and structs, STL containers etc, are hidden from Tkenv.
      You may wrap objects into cObjects to make them visible for Tkenv, that's what
      e.g. the WATCH macros do as well.
    </para>
    <para>The following sections go into detail about various parts and functions of the Tkenv UI.</para>
  </sect1>

  <sect1>
    <title>Parts of the Tkenv UI</title>
    <sect2>
      <title>The Status Bar</title>
      <para> The status bar shows the simulation's progress. It contains two rows, the second of
        which can be hidden using the ``View|Status Details'' menu item.
      </para>
      <picture file="pictures/Tkenv-statusbar.png" width="400">The status bar</picture>
      <para> The first row contains the following items:</para>
      <orderedlist>
        <listitem>Ini config name, run number, and the name of the network</listitem>
        <listitem>The event number of the next simulation event</listitem>
        <listitem>The simulation time of the next (expected) simulation event.</listitem>
        <listitem>Message statistics: the number of messages currently scheduled (i.e. in the FES);
          the number of message objects that currently exists in the simulation; and the
          number of message objects that have been created this far, including the
          already deleted ones. Out of the three, probably the middle one is the most useful:
          if it is steadily growing without apparent reason, the simulation model is probably
          missing some [[delete msg]] statements, and needs to be debugged.
        </listitem>
      </orderedlist>
      <para> When the simulation is paused or runs with animation, the second row displays
       the next expected simulation event. Note the word ``expected'': certain schedulers may
       insert new events before the displayed event in the last moment. Some schedulers
       that tend to do that are those that accept input from outside sources:
       real-time scheduler, hybrid or hardware-in-the-loop schedulers, parallel
       simulation schedulers, etc. Contents of the second row:
      </para>
      <orderedlist>
        <listitem>Name, C++ class and ID of the next message (event) object</listitem>
        <listitem>The module where the next event will occur (i.e. the module where
          the message will be delivered)
        </listitem>
        <listitem>Time of the next event since the last executed event.</listitem>
      </orderedlist>
      <para> When the simulation is running, displaying the next event becomes meaningless,
        and second row is replaced by the following performance gauges:
      </para>
      <picture file="pictures/Tkenv-statusbar-running.png" width="400">The status bar during Fast or Express run</picture>
      <orderedlist>
        <listitem>Simulation speed: number of events processed per real second</listitem>
        <listitem>Relative speed of the simulation (compared to real-time)</listitem>
        <listitem>Event density:  the number of events per simulated seconds</listitem>
      </orderedlist>
    </sect2>
    <sect2>
      <title>The Timeline</title>
      <picture file="pictures/Tkenv-timeline.png" width="400">The timeline</picture>
      <para> The timeline displays the contents of the Future Events Set on a logarithmic time scale.
        Each dot represents a message (event).
      </para>
      <para>Clicking an event will focus it in the ``Object Inspector'', and double-clicking
        will open a floating inspector window. Right-clicking will bring up a context menu
        with further actions.
      </para>
      <para>
        The timeline is often crowded, limiting its usefulness. To overcome this, you can hide
        uninteresting events from the timeline: right-click the event, and choose
        ``Exclude Messages Like 'x' from the Animation'' from the context menu. This will
        hide events with same name and C++ class name from the timeline, and also skip
        the animation when such messages are sent from one module to another.
        You can view and edit the list of excluded messages on the ``Filtering'' page of the
        ``Preferences'' dialog. (Tip: the timeline context menu provides a shortcut to that dialog).
      </para>
      <para> The timeline can be hidden (and revealed again) using the ``View|Timeline'' menu item.
      </para>
    </sect2>
    <sect2>
      <title>The Object Navigator</title>
      <picture file="pictures/Tkenv-objtree.png">The object tree</picture>
      <para> The ``Object Navigator'' displays inspectable objects reachable from two
        root objects (the network module and the FES) in a tree form.
      </para>
      <para>Clicking an object will focus it in the ``Object Inspector'', and double-clicking
        will open a floating inspector window. Right-clicking will bring up a context menu
        with further actions.
      </para>
    </sect2>
    <sect2>
      <title>The Object Inspector</title>
      <para> The ``Object Inspector'' is located below the ``Object Navigator'', and lets
        you examine the contents of objects in detail. The ``Object Inspector'' always
        focuses on the object last clicked (or otherwise selected) on the Tkenv UI.
        It can be directly navigated as well, via the ``Back'', ``Forward'', and ``Go to Parent''
        buttons, and also by double-clicking objects shown inside the inspector's area.
      </para>
      <picture file="pictures/Tkenv-inspector-fields.png">The object inspector</picture>
      <para> The inspector features a tabbed interface with two pages: ``Fields'' and ``Contents''.
        The ``Fields'' page shows the fields (or data members) of the object, organized in
        categories. It uses meta-information generated by the message compiler to obtain
        the list of fields and their values. (This is true even for the built-in classes --
        the simulation kernel contains their description of msg format.)
      </para>
      <picture file="pictures/Tkenv-inspector-contents.png">The object inspector</picture>

      <para> The ``Contents'' page lists the child objects of the currently inspected object.
        The child list is obtained via the [[forEach()]] method of the object.
      </para>
    </sect2>
    <sect2>
      <title>The Network Display</title>
      <para> The network view provides a graphical view of the network and in general, modules.
        Graphical representation is based on display strings ([[@display]] properties in the
        NED file). You can go into any compound module by double-clicking its icon.
      </para>
      <para> Message sending, method calls and certain other events are animated in the graphical view.
        You can customize animation in the ``Animation'' page of the ``Preferences'' dialog.
      </para>
      <picture file="pictures/Tkenv-network.png">The network display</picture>
      <para> The context menu of submodules makes further actions available (see below).
      </para>
      <picture file="pictures/Tkenv-submod-contextmenu.png">Submodule context menu</picture>
      <picture file="pictures/Tkenv-submod-utilities.png">The Utilities submenu</picture>
      <sect3>
        <title>Zooming and Panning</title>
        <para>
          There are several ways for zooming the canvas, both using the mouse and the keyboard:
        </para>
        <itemizedlist>
          <listitem>
            <para>Use <keycap>Ctrl+M</keycap> to zoom in, <keycap>Ctrl+N</keycap> to zoom out;
            the same functionality is also available in the canvas toolbar</para>
          </listitem>
          <listitem>
            <para>To zoom in around a point, double-click the canvas; use <keycap>Shift</keycap> +
            double-click to zoom out</para>
          </listitem>
          <listitem>
            <para>For marquee zoom, drag out a rectangle with the left mouse button while
            holding down <keycap>Ctrl</keycap>; you can cancel the operation with the right
            mouse button.</para>
          </listitem>
          <listitem>
            <para>Panning: moving the mouse while holding down the left mouse button will
            move the canvas; this is often a more comfortable way to navigate the canvas
            than using the scroll bars.</para>
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>
    <sect2>
      <title>The Log Viewer</title>
      <para> When you run the simulation, Tkenv will remember the output from logging statements
        ([[EV &lt;&lt; "Hello World\n";]]) and the messages sent between modules, and can present
        it to you in a meaningful manner. Only the output from the last N events is preserved
        (N being configurable in the ``Preferences'' dialog), and only in Step, Run and Fast Run
        modes. (Express mode can be so fast because such overhead is turned off while it's active.)
      </para>
      <para> The ``Log Viewer'' shows log related to one compound module and its subtree. It has two
        modes: ``Messages'' and ``Log'' mode, the default being ``Messages''. You can switch between
        the two modes with tool icons on the inspector's local toolbar.
      </para>
      <para> In ``Messages'' mode, the window displays messages sent between the (immediate) submodules
        of the inspected compound module, and messages sent out of, or into the compound module.
      </para>
      <note> In ``Messages'' mode, the ``Info'' column can be customized by writing and registering
       a custom [[cMessagePrinter]] class.
      </note>
      <picture file="pictures/Tkenv-log-msgs.png">The log viewer showing message traffic</picture>
      <para> In ``Log'' mode, the window displays log lines that belong to submodules
        under the inspected compound module (i.e. the whole module subtree.)
      </para>
      <picture file="pictures/Tkenv-log-textual.png">The log viewer showing module log</picture>
      <para> You can filter the content of the window to only include messages from specific
        modules. Open the log window's context menu and select ``Filter Window Contents''.
      </para>
      <picture file="pictures/Tkenv-log-filter.png">The log filter dialog</picture>
      <para> General logging behavior can be controlled in the ``Preferences'' dialog.</para>
      <para> It is also possible to open separate log windows for individual modules.
        A log window for a compound module displays the log from all of its submodule tree.
        To open a log window, find the module in the module tree or the network display,
        right-click it and choose ``Open Component Log'' from the context menu.
      </para>
    </sect2>
  </sect1>

  <sect1>
    <title>Inspecting Objects</title>
    <sect2>
      <title>Object Inspectors</title>
      <para>In addition to the inspectors embedded in the main window, Tkenv also lets you
       open floating inspector windows for objects. The screenshow below shows Tkenv
       with several inspectors open.
      </para>
      <picture file="pictures/Tkenv-with-inspectors.png" width="400">Tkenv with several floating inspectors open</picture>
      <para>The following screenshots show various inspectors available in Tkenv.</para>
      <picture file="pictures/Tkenv-outvector.png">Graphical inspector for cOutVector object</picture>
      <picture file="pictures/Tkenv-histogram.png">Graphical for a histogram object</picture>
    </sect2>
    <sect2>
      <title>Browsing the Registered Components</title>
      <picture file="pictures/Tkenv-inspect-menu-full.png">The Inspect menu</picture>
      <para> Registered components (NED Types, classes, functions, enums) can be displayed with the
        ``Inspect | Available components'' menu item. If an error message reports missing types or classes,
        you can check here whether the missing item is in fact available, i.e. registered correctly.
      </para>
    </sect2>
    <sect2>
      <title>Querying Objects</title>
      <para>The ``Find/Inspect Objects'' dialog lets you search the simulation for
        objects that meet certain criteria. The criteria may be the object name, class name,
        the value of a field of the object, or the combination of those.
        The results are presented in a table which you can sort by columns,
        and double-click items in it to inspect them.
      </para>

      <para>Some possible use cases:</para>
      <itemizedlist>
        <listitem>Identifying bottlenecks in the network by looking at the list of
          all queues, and ordering them by length (i.e. have the result table sorted
          by the ``Info'' column)
        </listitem>
        <listitem>Finding nodes with the highest packet drop count. If the drop counts are
          watched variables (see [[WATCH()]] macro), you can get a list of them.
        </listitem>
        <listitem>Finding modules that leak messages. If the live message count on
          the status bar keeps climbing up, you can issue a search for all message
          objects, and see where the leaked messages hide.
        </listitem>
        <listitem>Easy access for some data structures or objects, for example routing tables.
          You can search by name or class name, and use the result list as a collection of hotlinks,
          sparing you manual navigation in the simulation's object tree.
        </listitem>
      </itemizedlist>
      <picture file="pictures/Tkenv-find.png">Using the Find/Inspect Objects dialog for finding long queues</picture>
      <para>The dialog lets you specify the search root, and the name and class name of the objects
        to find. The latter two accept wildcard patterns.
      </para>
      <para>The checkboxes in the dialog can be used to select the object category that interests you.
        If you select a category, all objects with that type (and any type derived from it)
        will be included in the search. Alternatively, if you specify object class as a class filter
        expression, the search dialog will try to match the object's class name with the given string,
        meaning that objects of derived types will not be included.
      </para>
      <para>You can also provide a generic filter expression, which matches the object's full path by default.
        Wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range [["a".."e"]] plus [["x"]] and
        [["z"]]. You can match numbers: [["*.job{128..191}"]] will match objects named [["job128"]], [["job129"]], ...,
        [["job191"]]. [["job{128..}"]] and [["job{..191}"]] are also understood.
        You can combine patterns with [[AND]], [[OR]] and [[NOT]] and parentheses
        (lowercase [[and]], [[or]], [[not]] are also accepted). You can match other object fields such
        as queue length, message kind, etc., with the syntax [["fieldname(pattern)"]]. If the pattern
        contains parentheses or space, you need to enclose in in quotes.
        (HINT: You will want to start the pattern with [["*."]] in most cases to
        match objects anywhere in the network!).
      </para>
      <para>Examples:</para>
      <itemizedlist>
        <listitem>
          [[*.destAddr]] : Matches all objects with the name [["destAddr"]] (likely module parameters).
        </listitem>
        [[*.subnet2.*.destAddr]] : Matches objects named [["destAddr"]] inside [["subnet2"]].
        <listitem>
          [[*.node[8..10].*]] : Matches anything inside module [[node[8], node[9] ]]and [[node[10] ]].
        </listitem>
        <listitem>
          [[className(cQueue) and not length(0)]] : Matches non-empty queue objects.
        </listitem>
        <listitem>
          [[className(cQueue) and length({10..})]] : Matches queue objects with length>=10.
        </listitem>
        <listitem>
          [[kind(3) or kind({7..9})]] : Matches messages with message kind equal to 3, 7, 8 or 9 (only messages have
          a [["kind"]] attribute).
        </listitem>
        <listitem>
          [[className(IP*) and *.data-*]] : Matches objects whose class name begins with [["IP"]] and name begins with
          [["data-."]]
        </listitem>
        <listitem>
          [[not className(cMessage) and byteLength({1500..})]] : Matches messages whose class is not cMessage and
          byteLength is at least 1500 (only messages have a [["byteLength"]] attribute).
        </listitem>
        <listitem>
          [["*(*" or "*.msg(ACK)"]] : Quotation marks needed when pattern is a reserved word or contains
          parentheses (note: *.msg(ACK) without parentheses would be interpreted as some object having a "*.msg"
          attribute with the value "ACK"!).
        </listitem>
      </itemizedlist>
      <note>
        Tkenv uses the [[cObject::forEachChild]] method to collect all objects from a tree recursively. If you
        have your own objects derived from [[cObject]], you should redefine the [[cObject::forEachChild]] to
        function correctly with an object search.
      </note>
      <note>
        If you are debugging the simulation with a source level debugger, you may also use
        the ``Inspect by pointer'' menu item. Let the debugger display the address of the object
        to be inspected, and paste it into the dialog. Please note that entering an invalid pointer will
        crash the simulation.
      </note>
    </sect2>
  </sect1>
  <sect1>
    <title>The Preferences Dialog</title>
    <para> Select ``File | Preferences...'' from the menu to display the runtime environment's
      configuration dialog. The dialog lets you adjust various display, network layouting and animation
      options.</para>
    <sect2>
      <title>General</title>
      <picture file="pictures/Tkenv-pref-general.png">General settings</picture>
      <para>The ``General'' tab can be used to set the default display and logging behavior. It is
        possible to set how often the user interface will be updated during the simulation run.
      </para>
    </sect2>
    <sect2>
      <title>Configuring the Layouting Algorithm</title>
      <picture file="pictures/Tkenv-pref-layouting.png">Layouting settings</picture>
      <para>Tkenv provides automatic layouting for submodules that do not have their locations
        specified in the NED files. The layouting algorithm can be fine-tuned on the ``Layouting'' page
        of this dialog.</para>
    </sect2>
    <sect2>
      <title>Configuring Animation</title>
      <picture file="pictures/Tkenv-pref-animation.png">Animation settings</picture>
      <para>Tkenv provides automatic animation when you run the simulation. You can fine-tune the animation
        settings using the ``Animation'' page of the settings dialog. If you do not need all visual
        feedback Tkenv provides, you can selectively turn off some of the features:
      </para>
      <itemizedlist>
        <listitem>
          Animate messages: Turns on/off the visualization of messages passing between modules.
        </listitem>
        <listitem>
          Broadcast animation: Handles message broadcasts in a special way (messages sent within the
          same event will be animated concurrently).
        </listitem>
        <listitem>
          Show next event marker: Highlights the module which will receive the next event.
        </listitem>
        <listitem>
          Show a dotted arrow when a [[sendDirect()]] method call is executed.
        </listitem>
        <listitem>
          Show a flashing arrow when a method call occurs from one module to another.
          The call is only animated if the called method contains the [[Enter_Method()]] macro.
        </listitem>
        <listitem>
          The display of message names and classes can also be turned off.
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Timeline and Animation Filtering</title>
      <picture file="pictures/Tkenv-pref-filtering.png">Filtering</picture>
      <para>The ``Filtering'' page of the dialog serves two purposes. First, it lets you
        filter the contents of the ``Timeline''. You can hide all self-messages (timers),
        or all non-self messages, and you can further reduce the number of messages shown
        on the timeline by also hiding the non-animated messages, explained below.
      </para>
      <para>Second, you can suppress the animation of certain messages. For example,
        when your focus is routing protocol messages, you can suppress the animation
        of data traffic.
      </para>
      <para> The text box lets you specify several filters, one per line. You can filter
       messages by name, class name, or by any other property that appears in the
       ``Fields'' page of the ``Object Inspector'' when you focus it on the given
       message object.
      </para>
      <note>When you select ``Exclude from Animation'' from the context menu
        of a message object somewhere in the UI, it will add a new filter on this
        dialog page.
      </note>

      <para> For object names, wildcards ([["?"]], [["*"]]) are allowed. [["{a-exz}"]] matches any character in the range
        [["a".."e"]] plus [["x"]] and [["z"]]. You can match numbers: [["job{128..191}"]] will match [["job128"]], [["job129"]], ...,
        [["job191"]]. [["job{128..}"]] and [["job{..191}"]] are also understood. You can combine patterns with [[AND]], [[OR]] and
        [[NOT]] and parentheses (lowercase and, or, not are also acceptable). You can match against other object fields
        such as message length, message kind, etc. with the syntax [["fieldname(pattern)"]]. Put quotation marks
        around a pattern if it contains parentheses.
      </para>
      <para> Some examples:</para>
      <itemizedlist>
        <listitem>
          [[m*]] : matches any object whose name begins with "m"
        </listitem>
        <listitem>
          [[m* AND *-{0..250}]] : matches any object whose name begins with "m" and ends with a dash and a
          number between 0 and 250
        </listitem>
        <listitem>
          [[not *timer*]] : matches any object whose name does not contain the substring "timer"
        </listitem>
        <listitem>
          [[not (*timer* or *timeout*)]] : matches any object whose name contains neither "timer" nor
          "timeout"
        </listitem>
        <listitem>
          [[kind(3) or kind({7..9})]] : matches messages with message kind equal to 3, 7, 8 or 9
        </listitem>
        <listitem>
          [[className(IP*) and data-*]] : matches objects whose class name begins with "IP" and name begins
          with "data-"
        </listitem>
        <listitem>
          [[not className(cMessage) and byteLength({1500..}) ]]: matches objects whose class is not cMessage
          and whose byteLength is at least 1500
        </listitem>
        <listitem>
          [["or" or "and" or "not" or "*(*" or "msg(ACK)" ]]: quotation marks needed when pattern is a
          reserved word or contains parentheses (note: msg(ACK) without parentheses would be interpreted as an
          object having an "msg" attribute with the value "ACK"!).
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Configuring Fonts</title>
      <picture file="pictures/Tkenv-pref-fonts.png">Font selection</picture>
      <para>The ``Fonts'' page of the settings dialog lets you select the typeface and font size for
        various user interface elements.</para>
    </sect2>
    <sect2>
      <title>The .tkenvrc File</title>
      <para>Settings are stored in [[.tkenvrc]] files. There are two [[.tkenvrc]] files: one is stored
        in the current directory and contains project-specific settings like the list of open
        inspectors; the other is saved into the user's home directory and contains global settings.</para>
      <note>
        Inspectors are identified by their object names. If you have several components that share the same
        name (this is especially common for messages), you may end up with a lot of inspector windows when you
        start the simulation. In such cases, you may simply delete the [[.tkenvrc]] file.
      </note>
      <note>
          Error messages generated by the Tkenv runtime environment are logged to the [[.tkenvlog]] file.
      </note>
    </sect2>
  </sect1>

<!-- TODO
  <sect1>
    <title>Typical Errors and Dealing with them in Tkenv</title>
    <para>``Module class not found''</para>
    <para>Xmodule class not found</para>
    <para>leaking messages</para>
    <para>runtime error</para>
    <para>crash on rebuild</para>
    <para>debug next event</para>
  </sect1>
-->
  <sect1>
    <title>Tkenv and C++</title>
    <para>This section describes which C++ API functions various parts of Tkenv employ
      to display data and otherwse perform their functions. Most functions are member
      functions of the [[cObject]] class.
    </para>
    <sect2>
      <title>Inspectors</title>
      <para>Inspectors display the hierarchical name (i.e. full path) and class name
        of the inspected object in the title using the [[getFullPath()]] and [[getClassName()]]
        [[cObject]] member functions. The ``Go to parent'' feature in inspectors uses the
        [[getOwner()]] method of [[cObject]].
      </para>
      <para>The ``Object Navigator'' displays the full name and class name of each object
        ([[getFullName()]] and [[getClassName()]]), and also the ID for classes that have one
        ([[getId()]] on [[cMessage]] and [[cModule]]). When you hover with the mouse, the tooltip
        displays the info string ([[info()]] method). The roots of the tree are the network module
        ([[simulation.getSystemModule()]]) and the FES ([[simulation.getMessageQueue()]].
        Child objects are enumerated with the help of the [[forEachChild()]] method.
      </para>
      <para>In the ``Object Inspector'', the ``Contents'' page displays the full name,
        class name and info string ([[getFullName()]], [[getClassName()]], [[info()]])
        of child objects enumerated using [[forEachChild()]]. [[forEachChild()]] can only
        enumerate objects that are subclassed from [[cObject]]. If you want your
        non-[[cObject]] variables (e.g. primitive types or STL containers) to appear
        in the ``Contents'' list, you need to wrap them into [[cObject]]. The [[WATCH()]]
        macro does exactly that: it creates an object wrapper that displays the
        variable's value via the wrapper's [[info()]] method. There are watch macros
        for STL contains as well, they present the wrapped object to Tkenv in a more
        structured way, via custom class descriptors (cClassDescriptor, see below).
      </para>
      <para> One might ask how the [[forEachChild()]] method of modules can enumerate
        messages, queues, and other objects that are owned by the module. The answer is
        that the module class maintains a list of owned objects, and [[cObject]]
        automatically joins that list.
      </para>
      <para> The ``Object Inspector'''s ``Fields'' page display an object's fields by
        making use of the class descriptor ([[cClassDescriptor]]) for that class.
        Class descriptors are automatically generated for new classes by the message compiler.
        Class descriptors for the &Omnetpp; library classes are also generated by the
        message compiler, see [[src/sim/sim_std.msg]] in the source tree.
      </para>
      <para> The ``Network Display'' uses [[cSubmoduleIterator]] to enumerate submodules,
        and its ``Go to parent module'' function uses [[getParentModule()]]. Background and
        submodule rendering is based on display strings ([[getDisplayString()]] method of
        [[cComponent]]).
      </para>
      <para> The module log page of ``Log Viewer'' displays the output to [[EV]] streams
        from modules and channels.
      </para>
      <para> The message/packet traffic page of ``Log Viewer'' shows information based
        on stored copies of sent messages (the copy is created using [[dup()]]), and stored
        sendhop information. The ``Name'' column displays the message name ([[getFullName()]]).
        However, the ``Info'' column does not display the string returned from [[info()]],
        but rather, strings produced by a [[cMessagePrinter]] object. Message printers
        can be dynamically registered.
      </para>
    </sect2>
    <sect2>
      <title>During Simulation</title>
      <para> Tkenv sets up a network by calling [[simulation.setupNetwork()]], then
        immediately proceeds to invoke [[callInitialize()]] on the root module.
        During simulation, [[simulation.selectNextModule()]] and [[simulation.doOneEvent()]]
        are called iteratively. When the simulation ends, Tkenv invokes [[callFinish()]]
        on the root module; the same happens when you select the ``Conclude Simulation''
        menu item. The purpose of [[callFinish()]] is to record summary statistics
        at the end of a successful simulation run, so it will be skipped if an error occurs
        during simulation. On exit, and before a new network is set up,
        [[simulation.deleteNetwork()]] is called.
      </para>
      <para> The ``Debug Next Event'' menu item issues the [[int3]] x86 assembly instruction
        on Windows, and raises a [[SIGTRAP]] signal on other systems.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Reference</title>
    <sect2>
      <title>Command-Line Options</title>
      <para>A simulation program built with Tkenv accepts the following command line switches:</para>
      <itemizedlist>
        <listitem>
          [[-h]]: The program prints a help message and exits.
        </listitem>
        <listitem>
          [[-u Tkenv]]: Causes the program to start with Tkenv. (This is the default, unless the program
          hasn't been linked with Tkenv, or has another, custom environment library with a higher priority
          than Tkenv.)
        </listitem>
        <listitem>
          [[-f fileName]]: Specifies the name of the configuration file. The default is [[omnetpp.ini]]. Multiple [[-f]]
          switches can be given; this allows you to partition your configuration file. For example, one file can
          contain your general settings, another one most of the module parameters, and a third one the module
          parameters you change frequently. The [[-f]] switch is optional and can be omitted.
        </listitem>
        <listitem>
          [[-l fileName]]: Loads a shared library ([[.so]] file on Unix, [[.dll]] on Windows,
          and [[.dylib]] on Mac OS X). Multiple [[-l]] switches are accepted. Shared libraries
          may contain simple modules and other, arbitrary code. File names may be specified without
          the file extension and the [[lib]] name prefix (i.e. [[foo]] instead of [[libfoo.so]]).
        </listitem>
        <listitem>
          [[-n filePath]]: When present, overrides the [[NEDPATH]] environment variable and sets
          the source locations for simulation NED files.
        </listitem>
        <listitem>
          [[-c configname]]: Selects an INI configuration for execution.
        </listitem>
        <listitem>
          [[-r run-number]]: It has the same effect as (but takes priority over) the ``tkenv-default-run=''
          INI file configuration option.
        </listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Environment Variables</title>
      <itemizedlist>
        <listitem>[[OMNETPP_TKENV_DIR]]: In case of nonstandard installation, it may be necessary to
          set this environment variable to point to [[&lt;omnetpp&gt;/src/tkenv]]
          so that Tkenv can find its parts written in Tcl.</listitem>
        <listitem>[[OMNETPP_IMAGE_PATH]]: It controls where Tkenv will load images for network
          graphics (modules, background, etc.) from. The value should be a semicolon-separated
          list of directories, but on non-Windows systems, the colon is also accepted as separator.
          The default is [[&lt;omnetpp&gt;/images;./images]], that is, by default Tkenv looks
          into the [[images]] folder of your installation, and [[images]] folder
          in the working directory of the simulation. The directories will be scanned recursively,
          and subdirectory names become part of the icon name; for example, if an [[images/]] directory
          is listed, the file [[images/misc/foo.png]] will be registered as icon [[misc/foo]].
          PNG an GIF files are accepted.</listitem>
        <listitem>[[OMNETPP_PLUGIN_PATH]]: Certain aspects of Tkenv can be extended with plugins written in Tcl.
          The path where such plugins are looked for is taken from this environment variable.
          It is expected to contain a semicolon-separated list of directories, and defaults to [[./plugins]].
          (Again, colon is also accepted as separator on non-Windows systems.)</listitem>
      </itemizedlist>
    </sect2>
    <sect2>
      <title>Configuration Options</title>
      <para> Tkenv accepts the following configuration options in the INI file.</para>
      <itemizedlist>
        <listitem>
          [[tkenv-extra-stack]]: Specifies the extra amount of stack (in kilobytes) that is reserved for each
          [[activity()]] simple module when the simulation is run under Tkenv. This value is significantly
          higher than the similar one for Cmdenv (handling GUI events requires a large amount of stack space).
        </listitem>
        <listitem>
          [[tkenv-default-config]]: Specifies which INI file configuration Tkenv should set up automatically after
          startup. If there is no such option, Tkenv will ask which configuration to set up.
        </listitem>
        <listitem>
          [[tkenv-default-run]]: Specifies which run of the selected configuration Tkenv should set up
          after startup. If there is no such option, Tkenv will ask.
        </listitem>
        <listitem>
          [[tkenv-image-path]]: Tkenv will append this value to the value of the [[OMNETPP_IMAGE_PATH]]
          environment variable to determine the list of directories to load images from.
        </listitem>
        <listitem>
          [[tkenv-plugin-path]]: Tkenv will append this value to the value of the [[OMNETPP_PLUGIN_PATH]]
          or its built-in default value to get the list of directories to be scanned for plugins written in Tcl.
        </listitem>
      </itemizedlist>
      <para>All other Tkenv settings can be changed via the GUI, and are saved into the [[.tkenvrc]] file
      in the user's home directory or in the current directory.
      </para>
    </sect2>
  </sect1>
</chapter>