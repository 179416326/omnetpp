<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>IDE Customization Guide</title>
</articleinfo>
<section id="_writing_wizards">
<title>Writing Wizards</title>
<section id="_motivation">
<title>Motivation</title>
<simpara>The IDE offers several wizards via the <emphasis>File|New</emphasis> menu: <emphasis>New OMNeT++ Project</emphasis>,
<emphasis>New Simple Module</emphasis>, <emphasis>New Compound Module</emphasis>, <emphasis>New Network</emphasis>, <emphasis>New Simulation</emphasis>,
<emphasis>New Msg File</emphasis>, and <emphasis>New Ini File</emphasis>. This chapter describes how one can add
content to these dialogs to create wizards that are specific to simulation models:
for example a <emphasis>New INET Ad-Hoc Network</emphasis> wizard, a <emphasis>New MiXiM Simulation</emphasis> wizard,
an <emphasis>Import INET Network From CSV File</emphasis> wizard, a <emphasis>New MiXiM Radio Model</emphasis> wizard,
and others.</simpara>
<simpara>For someone who is writing a model framework which will be available for the
general public, wizards are a great way to educate future users about the
simulation model. While documentation and example simulations are somewhat
passive ways of showing off model features to users, wizards encourage users
to experiment with the model and explore its capabilities. The right set of
capable wizards can give a jump start to users, and emphasizes learning by doing.</simpara>
<simpara>These wizards can be prepared with low effort and without any Java or C++
programming, and can be distributed with the corresponding model framework
(i.e. INET or MiXiM). When end users import the model framework project
into the IDE, the wizards get automatically contributed to the corresponding
wizard dialogs; the end user does not need to install them or otherwise do
anything to deploy the wizards.</simpara>
<simpara>To facilitate creating wizards, we have also added a <emphasis>New Wizard</emphasis> wizard to
the <emphasis>File|New</emphasis> menu.</simpara>
</section>
<section id="_overview">
<title>Overview</title>
<simpara>Custom wizards are read from the <literal>templates/</literal> folder of OMNeT++ projects.
Wizards are implemented by mixing a templating engine (for generating
the output files) and a GUI description language (for custom wizard pages to
gather user input for the file generation). Because of the use of a
templating engine, we&#8217;ll also refer to custom wizards as "content templates".</simpara>
<simpara>The IDE offers several OMNeT++ related wizard dialogs: <emphasis>New OMNeT++ Project</emphasis>,
<emphasis>New NED File</emphasis>, <emphasis>New Simple Module</emphasis>, and so on. Every content template can
contribute to one or more of those wizard dialogs.</simpara>
<simpara>In the <literal>templates/</literal> folder, every subfolder that contains a <literal>template.properties</literal>
file is treated as a content template. (Other folders are ignored.) Every
content template folder may contain several types of files:</simpara>
<itemizedlist>
<listitem>
<simpara>
The <literal>template.properties</literal> file contains general information about the wizard.
  Defines the initial value for the template variables, and specifies the
  custom wizard pages to be shown when the wizard is run.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>*.ftl</literal> files are template files that will be copied (without the <literal>.ftl</literal> extension)
  into the target folder after template variable substitution.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>*.xswt</literal> files describe custom wizard pages to gather user input.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>*.fti</literal> (template include) files are included by <literal>*.ftl</literal>
  files. This can be used to factor out common parts from the template files.
  The wizard ignores <literal>.fti</literal> files, i.e. does not copy them into the new
  project or folder.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>*.jar</literal> files can be used to extend the wizard&#8217;s functionality
  with dynamically loaded Java code.
</simpara>
</listitem>
<listitem>
<simpara>
All other files are regarded as files that have to be copied into the
  target folder verbatim when the wizard runs. The wizard folder may contain
  subdirectories which may also contain files of the above type (except
  <literal>template.properties</literal> of course).
</simpara>
</listitem>
</itemizedlist>
<section id="_template_processing">
<title>Template Processing</title>
<simpara>Template processing uses the FreeMarker library (<emphasis>http://freemarker.org</emphasis>), and
all template syntax supported by FreeMarker can be used. Especially, variable
references of the syntax <literal>${varName}</literal> will be replaced with the variable value.</simpara>
<simpara>The FreeMarker language also offers constructs that make it a full programming
language: variable assignments, conditionals, loops, switch statement,
functions, macros, expression evaluation, built-in operators, etc, as well
as access to fields and methods of classes defined in Java. This means that
any algorithm can be expressed in the FreeMarker language, and if that would
not be enough, one can directly access Java classes using FreeMarker&#8217;s Bean Wrapper.</simpara>
<tip><simpara>Documentation for the FreeMarker template language can be found at:
     <emphasis>http://freemarker.org/docs/index.html</emphasis></simpara></tip>
<simpara>Templates can use several sources for input. They can:</simpara>
<itemizedlist>
<listitem>
<simpara>
gather information from the user, using custom wizard pages
</simpara>
</listitem>
<listitem>
<simpara>
call any Java code to execute any arbitrarily complex algorithm
</simpara>
</listitem>
<listitem>
<simpara>
call external programs
</simpara>
</listitem>
<listitem>
<simpara>
read and write from/to any file on the filesystem
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_defining_the_gui">
<title>Defining the GUI</title>
<simpara>Custom wizard pages are defined in XSWT (<emphasis>http://xswt.sourceforge.net</emphasis>).
XSWT is an XML based language that allows the definition of SWT (the widget set
used by Eclipse) widget hierarchies, without the need to write any code in Java. XSWT also maps
widget properties to XML attributes so the visual appearance of the wizard pages
can be easily tweaked. It is also possible to invoke methods on the generated widgets
and use the SWT layout containers, allowing further customizations. Each <literal>.xswt</literal> file
in the template directory defines a separate wizard page which can be shown
either conditionally or unconditionally.</simpara>
<tip><simpara>An XSWT tutorial and documentation can be found at:
      <emphasis>http://www.coconut-palm-software.com/the_new_visual_editor/doku.php?id=xswt:home</emphasis></simpara></tip>
<note><simpara>Currently we use XSWT 1.1.2. Newer XSWT integration builds from
      <emphasis>http://www.coconut-palm-software.com/~xswt/integration/plugins/</emphasis>
      did not work out well.</simpara></note>
</section>
</section>
<section id="_using_the_ide">
<title>Using the IDE</title>
<simpara>The IDE offers support for editing both <literal>.ftl</literal> and <literal>.xswt</literal> files to help
the creation of wizard pages and templates.</simpara>
<section id="_editing_xswt_files">
<title>Editing XSWT Files</title>
<simpara>Double-clicking on an XSWT file will open it in the XSWT editor. The editor
provides basic syntax highlighting. An extremely
useful feature of the IDE is the XSWT Preview, where you can preview
the form being edited (it updates when you save the file). The Preview should
open automatically when you open the XSWT file; if it does not (or you close it),
you can access it via the <emphasis>Window|Show View&#8230;</emphasis> menu item.</simpara>
<simpara>Some (custom) widgets may not appear in the Preview; this is because the
Preview does not load jar files from the projects.</simpara>
</section>
<section id="_editing_template_files">
<title>Editing Template Files</title>
<simpara>The Freemarker Editor is opened when you double-click files with the <literal>*.ftl</literal> or
<literal>*.fti</literal> extension.  The Freemarker Editor offers basic syntax highlight, validation
(error markers appear during editing if the template is not syntactically
correct), and basic content assist. Content assist can help you with directives
(<literal>&lt;#...&gt;</literal> syntax) and builtin operations (like <literal>?number, ?size, ?default</literal>, etc).
The content assist popup appears automatically when you type <literal>&lt;#</literal> (actually
a closing <literal>&gt;</literal> is also needed for the editor to recognize the tag), and
when you hit <literal>?</literal> within a directive or an interpolation (<literal>${...}</literal>).</simpara>
</section>
</section>
<section id="_writing_an_example_wizard">
<title>Writing an Example Wizard</title>
<simpara>In the following sections, we will create a simple wizard as an example, which
will support either creating a simulation (complete with NED and INI files),
or just a single NED file with a network defined in it. The user will be able to
specify the type and the number of the submodules the network contains.</simpara>
<section id="_configuring_the_wizard">
<title>Configuring the Wizard</title>
<simpara>The first step when creating a wizard is to create a new folder
under the <literal>templates</literal> directory of the project. A file named <literal>template.properties</literal>
must be present in the newly created directory. This file is used to configure
the wizard. Create a folder a folder named <literal>templates/examplewizard</literal> under the
project, then create <literal>template.properties</literal> and add the following lines to it:</simpara>
<literallayout class="monospaced">templateName = New Test Wizard
templateDescription = Generate an example
templateCategory = Test Wizards
supportedWizardTypes = simulation, network</literallayout>
<simpara>These lines specify the name, type and category for the wizard. Category is used to
specify how the wizards will be grouped in the template selection page&#8217;s tree control.
Wizard type specifies in which <emphasis>New &#8230; Wizard</emphasis>  your wizard will appear.
You can specify one or more of <literal>project</literal>, <literal>simulation</literal>, <literal>network</literal>, etc.; the list
of all possible wizard types will be covered later in this document. In our case,
the wizard will appear in the <emphasis>New Simulation</emphasis> and <emphasis>New Network</emphasis> wizard dialogs.</simpara>
<simpara>We can now decide what data we would like to ask from the user.
Template variables and their values can be defined as key-value pairs:</simpara>
<literallayout class="monospaced">nodeType = Dummy
networkSize = 6</literallayout>
<simpara>The <literal>nodeType</literal> variable will be used as the submodule type in our network, while
the <literal>networkSize</literal> defines how many submodules we want in the network.</simpara>
<simpara>We define a custom wizard page where the user can specify the values
of the above variables (i.e. override their default value, specified above).</simpara>
<literallayout class="monospaced">page.1.file = parameters.xswt
page.1.title = Network parameters</literallayout>
<simpara>We will use the file <literal>parameters.xswt</literal> to define the layout and the content of the new wizard page.</simpara>
<note><simpara>There are numerous other configuration keys that can be used in <literal>template.properties</literal>. See the
"Configuration Keys" section for an exhaustive list of options.</simpara></note>
</section>
<section id="_creating_a_new_wizard_page">
<title>Creating a New Wizard Page</title>
<simpara>Files with <literal>.xswt</literal> extension (Wizard Page definitions) are used to define the UI and
add new wizard pages to gather user input for the template generation. In the previous
section we have specified that the file called <literal>parameters.xswt</literal> will contain the new
wizard page definition. We will add a <emphasis>spinner</emphasis> control to specify the size of our network
and a <emphasis>text</emphasis> control to specify the node type. Create a new file called <literal>parameters.xswt</literal>
with the following content:</simpara>
<literallayout class="monospaced">&lt;xswt xmlns:x="http://sweet_swt.sf.net/xswt"&gt;
  &lt;x:import&gt;
    &lt;!-- Import all widgets and utility classes  --&gt;
    &lt;package name="java.lang"/&gt;
    &lt;package name="org.eclipse.swt.widgets" /&gt;
    &lt;package name="org.eclipse.swt.graphics" /&gt;
    &lt;package name="org.eclipse.swt.layout" /&gt;
    &lt;package name="org.eclipse.swt.custom" /&gt;
    &lt;package name="org.omnetpp.common.wizard.support" /&gt;
    &lt;package name="org.omnetpp.ned.editor.wizards.support" /&gt;
    &lt;package name="org.omnetpp.cdt.wizard.support" /&gt;
  &lt;/x:import&gt;
  &lt;!-- Create a two-column layout  --&gt;
  &lt;layout x:class="GridLayout" numColumns="2"/&gt;
  &lt;x:children&gt;
    &lt;!-- First row --&gt;
    &lt;label text="Number of nodes in the network:"/&gt;
    &lt;spinner x:id="networkSize" minimum="2" x:style="BORDER"/&gt;
    &lt;!-- Second row --&gt;
    &lt;label text="Type of nodes:"/&gt;
    &lt;text x:id="nodeType" x:style="BORDER"/&gt;
  &lt;/x:children&gt;
&lt;/xswt&gt;</literallayout>
<simpara>The above defined wizard page will have two columns. The first column contains labels,
and the second contains editable widgets.
The <literal>x:id="varName"</literal> attributes in the spinner and text control definitions are used
to bind a template variable to the control. When a page is displayed, the content of
the bound variables are copied into the controls. When the user navigates away from
the page or press the <emphasis>Finish</emphasis> button, the content of the controls are copied back
to the bound variables. These variables can be used in the template files we are
about to define in the following section.</simpara>
<note><simpara>To see the list of all available widgets, check the Appendix.</simpara></note>
</section>
<section id="_creating_templated_files">
<title>Creating Templated Files</title>
<simpara>When the template is used, the contents of the template folder (and its subfolders)
will be copied over into the new project, preserving the directory structure,
with the exception of <literal>template.properties</literal>. (It is also possible to specify
other files and folders to be ignored by specifying a file list for the
<literal>ignoreResources</literal> configuration key.)</simpara>
<simpara>When the wizard is being used, a pool of variables is kept by the wizard dialog.
These variables are initialized from the <literal>key = value</literal> lines in the
<literal>template.properties</literal> files; they can get displayed and/or edited
on custom wizard pages; and eventually they get substituted into <literal>*.ftl</literal> files
(using the <literal>${varname}</literal> syntax).</simpara>
<simpara>Some variables have special meaning and are interpreted by the wizard dialog
(e.g. the <literal>nedSrcFolders</literal> variable determines which folders get denoted as
NED Source Folders by the <emphasis>New OMNeT++ Project</emphasis> wizard). Variables can be used
to generate output file names, can be used as input file names, and can serve
as input and working variables for arbitrarily complex algorithms programmed
in the template (<literal>*.ftl</literal>) files.</simpara>
<simpara>Let us have a one-minute look at the FreeMarker template language.
Variables can be inserted into the output using the <literal>${varname}</literal> syntax. One can
also write expressions inside <literal>${..}</literal>. For example, <literal>${numServers?number + 1}</literal>
uses the <literal>number</literal> builtin operator to convert the <literal>numServers</literal> variable to a number,
and adds one to it and inserts the result into the template output. FreeMarker
exposes many other functions (conversion to string, upper-case version of a string,
size of an array, etc.) as builtin operators.</simpara>
<simpara>Programming facilities can be accessed via directives that have the <literal>&lt;#...&gt;</literal> syntax.
Use <literal>&lt;#if&gt;</literal> (<literal>&lt;#if&gt; cond&gt;..&lt;#elseif cond&gt;..&lt;#else&gt;..&lt;/#if&gt;</literal>) for conditionals;
<literal>&lt;#list&gt;</literal> for iterations and loops (e.g. <literal>&lt;#list words as w&gt;..&lt;/#list&gt;</literal>;
<literal>&lt;#list 0..9 as i&gt;..&lt;/#list&gt;</literal>; <literal>&lt;#list 9..0 as i&gt;..&lt;/#list&gt;</literal>);
<literal>&lt;#assign&gt;</literal> for assigning variables (<literal>&lt;#assign x=5&gt;</literal>; <literal>&lt;#assign x&gt;the number ${i}&lt;/#assign&gt;</literal>).
One can define functions (<literal>&lt;#function&gt;</literal>) and macros (<literal>&lt;#macros&gt;</literal>), and include
other templates (<literal>&lt;#include&gt;</literal>). Here we only covered a small fraction of FreeMarker&#8217;s
possibilities; we recommend that you read the FreeMarker manual for more information.</simpara>
<simpara>Let us create a file with a filename with <literal>.ftl</literal> extension (e.g.<literal>untitled.ned.ftl</literal>).
Because of the extension, this file will be processed by the templating engine.
The actual name of the file does not matter, because the
<literal>&lt;@setoutput .../&gt;</literal> directive instructs the templating engine to output
everything from the current file into the file that is specified by the
<literal>targetFileName</literal> variable. The <literal>targetFileName</literal>, <literal>targetTypeName</literal>, <literal>bannerComment</literal>
and <literal>nedPackageName</literal> variables are automatically filled out by the wizard, based
on the filename and folder the user selected on the first wizard page.</simpara>
<literallayout class="monospaced">&lt;@setoutput path=targetFileName /&gt;
${bannerComment}</literallayout>
<literallayout class="monospaced">&lt;#if nedPackageName!=""&gt;package ${nedPackageName};&lt;/#if&gt;</literallayout>
<literallayout class="monospaced">network ${targetTypeName}
{
    node[${networkSize}] : ${nodeType}
}</literallayout>
<simpara>The template variables will be substituted into the template automatically.</simpara>
<simpara>Specific wizard dialog types will also define extra variables for use in the
templates, e.g. the wizard type that creates a complete simulation (with all required files),
will put the <literal>simulationName</literal> variable into the context. To see all defined variables,
check the Appendix.</simpara>
<tip><simpara>The <emphasis>New Wizard</emphasis> wizard in the IDE provides you with more than a handful of
     working examples, useful utilities for writing wizards, sample code for
     accessing various features, and so on. The aim of these wizards is to get you
     productive in the shortest time possible.</simpara></tip>
<simpara>As a last step in our example, we create also an INI file template:</simpara>
<simpara>Create a file called <literal>omnetpp.ini.ftl</literal>, and fill with:</simpara>
<literallayout class="monospaced">&lt;#if wizardType=="simulation"&gt;
network = ${targetTypeName}
&lt;/#if&gt;</literallayout>
<simpara>We need the INI file only if we are creating a simulation. If the
current type is not <literal>simulation</literal>, the content will be empty, and the
file will not be written to disk.</simpara>
</section>
</section>
<section id="_wizard_types">
<title>Wizard Types</title>
<simpara>The wizard will set the <literal>wizardType</literal> template variable when it executes,
so template code can check under which wizard type it runs (using <literal>&lt;#if&gt;..&lt;/#if&gt;</literal>), and
act accordingly. This feature allows one to create templates that
can be used for multiple wizard types.</simpara>
<simpara>There are several types of wizards you can create. Each one has a different
goal:</simpara>
<section id="_new_project_wizards">
<title>New Project Wizards</title>
<literallayout class="monospaced">wizardType = project</literallayout>
<simpara>Project wizards create new projects, and let the user create files in them.
It is possible to adjust project properties to customize the new project.
You can add C++ support to the project, set source and NED folders, etc.</simpara>
<simpara>The first two pages of the wizard are standard: they prompt the user for
the name of the new project, and let the user choose a content template.
These pages are followed by pages provided by the selected content template.
If the user selected C++ support on the first page, custom pages are
followed by the standard CDT New Project pages.</simpara>
<simpara>When the user clicks <emphasis>Finish</emphasis>, the wizard creates the project, and configures
it according to the selected options (C++ support, source folders, etc). After that,
template files are copied into the new project, performing template processing
as necessary. Templated pages are responsible for creating the <literal>package.ned</literal>
file according to the <literal>nedPackageName</literal> and <literal>namespaceName</literal> options, as well
as creating source files in the NED, and C++ source folders.</simpara>
<note><simpara>NED and C++ files are not automatically placed into the
      NED and C++ source folders. Templated pages have to be written
      (for example using <literal>setoutput</literal>) so that they explicitly create the files
      at the proper places.</simpara></note>
<simpara>There are a few useful variables that template files can make use of. The
<literal>rawProjectName</literal> variable contains the project name. This variable cannot be
directly used as C++ or NED package names, type names, etc, because it may
contain spaces or other characters not allowed in identifiers. For convenience,
the wizard provides sanitized versions of the project name that can be used
as identifiers, they are in the variables <literal>projectName</literal>, <literal>PROJECTNAME</literal> and
<literal>projectname</literal>, and differ in capitalization. The <literal>targetFolder</literal> variable
is set to <literal>/</literal><emphasis>&lt;project name&gt;</emphasis>. These variables cannot be edited in custom wizard
pages.</simpara>
<simpara>The variables <literal>addProjectReference</literal>, <literal>makemakeOptions</literal>, <literal>sourceFolders</literal> and
<literal>nedSourceFolders</literal> affect the creation of the project before template files
get processed. It is allowed to provide an initialization value for these
variables in <literal>template.properties</literal>, and to let the user change them in
custom pages.</simpara>
<simpara>For conformance with other wizards, the project wizard initializes
the following variables with different case versions of the project name:
<literal>targetTypeName</literal>, <literal>nedPackageName</literal>, <literal>namespaceName</literal>. The <literal>targetMainFile</literal>
variable is initialized to <emphasis>projectName</emphasis>+<literal>.ned</literal>, but there is no requirement
that the template actually creates this file. It is allowed to provide a
different initialization value for these variables in <literal>template.properties</literal>,
and to let the user change them in custom pages.</simpara>
<note><simpara>The <literal>targetFileName</literal> variable is not set, because the project wizard
is not required to create a file.</simpara></note>
<simpara>See the appendix for the variable names that are supported in project wizard
templates.</simpara>
</section>
<section id="_new_simulation_wizards">
<title>New Simulation Wizards</title>
<literallayout class="monospaced">wizardType = simulation</literallayout>
<simpara>A new simulation is basically a new folder containing all files required to run a
simulation. The simulation folder usually contains NED files and an INI file,
and possibly also CC, H and MSG files.</simpara>
<simpara>The first two pages of the wizard are standard: they prompt the user for
the parent and name of the new folder, and let the user choose a content template.
These pages are followed by pages provided by the selected content template.
Simulations can only be created in new folders under existing projects or folders.</simpara>
<simpara>When the user clicks <emphasis>Finish</emphasis>, the wizard creates the folder. After that,
template files are copied into the new folder, performing template processing
as necessary.</simpara>
<simpara>There are a few useful variables that template files can make use of. The
<literal>simulationFolderName</literal> contains the name of the new folder (without path).
This variable cannot be directly used as a C++ or NED identifier, because it may
contain spaces or other characters not allowed in identifiers. For convenience,
the wizard provides the <literal>simulationName</literal> variable which is a sanitized version
of the folder name. The <literal>targetFolder</literal> variable is set to the workspace path of the new
folder. These variables cannot be edited in custom wizard pages.</simpara>
<simpara>For conformance with other wizards, the simulation wizard initializes
the <literal>targetTypeName</literal> variable with the simulation name. The <literal>targetMainFile</literal>
variable is initialized to <emphasis>simulationName</emphasis>+<literal>.ned</literal>, but there is no requirement
that the template actually creates this file. It is allowed to provide a
different initialization value for these variables in <literal>template.properties</literal>,
and to let the user change them in custom pages.</simpara>
<note><simpara>The <literal>targetFileName</literal> variable is not set, because the simulation wizard
is not required to create a file.</simpara></note>
<simpara>The <literal>nedPackageName</literal> and <literal>namespaceName</literal> variables are set by the wizard to the
NED package name and C++ namespace expected for the given folder. These values
are derived from the folder path, the toplevel <literal>package.ned</literal> file and the
<literal>@namespace</literal> property in it, and cannot be overridden.</simpara>
<simpara>See the appendix for the variable names that are supported in simulation wizard
templates.</simpara>
</section>
<section id="_new_ini_msg_or_ned_file_wizards">
<title>New INI, MSG or NED File Wizards</title>
<literallayout class="monospaced">wizardType = compoundmodule, network, nedfile, inifile, msgfile</literallayout>
<simpara>These wizard types generate a single file. The first two pages of the wizard
are standard: they prompt the user for the parent folder and name of the new file,
and let the user choose a content template. These pages are followed by pages
provided by the selected content template.</simpara>
<note><simpara>Currently the wizard does not ensure that the created file will be under
      a NED/C++ source folder. This may change in the future.</simpara></note>
<simpara>When the user clicks <emphasis>Finish</emphasis>, template files are copied into the selected parent
folder, performing template processing as necessary. The template files
are expected to create a file with the name chosen by the user.</simpara>
<simpara>The wizard passes the file name to the template files in the <literal>targetFileName</literal>
variable.</simpara>
<note><simpara>The wizard does not prevent the templates from creating other files than
      <literal>targetFileName</literal>. It is the responsibility of the template author to
      ensure that only a single file is created.</simpara></note>
<simpara>There are a few useful variables that template files can make use of. The
<literal>targetFolder</literal> variable is set to the workspace path of the parent
folder. This variable cannot be edited in custom wizard pages.</simpara>
<simpara>For conformance with other wizards, the new wizard initializes the
<literal>targetTypeName</literal> variable to a sanitized version of the file name (minus
extension). This variable can be used as a NED or message type name
in the generated file. The <literal>targetMainFile</literal> variable is the same as
<literal>targetFileName</literal>.</simpara>
<simpara>One can provide a different initialization value for the <literal>targetTypeName</literal>
variable in <literal>template.properties</literal>, and let the user change it in custom pages.</simpara>
<simpara>The <literal>nedPackageName</literal> and <literal>namespaceName</literal> variables are set by the wizard to the
NED package name and C++ namespace expected for the given folder. These values
are derived from the file path, the toplevel <literal>package.ned</literal> file and the
<literal>@namespace</literal> property in it, and cannot be overridden.</simpara>
<simpara>See the appendix for the variable names that are supported in new file wizard
templates.</simpara>
</section>
<section id="_new_simple_module_wizard">
<title>New Simple Module Wizard</title>
<literallayout class="monospaced">wizardType = simplemodule</literallayout>
<simpara>The simple module wizard creates a simple module, usually consisting of a
NED file and C++ implementation files. This wizard works in a similar way
as the <emphasis>New NED File</emphasis> or <emphasis>New Compound Module</emphasis> wizard, but it is allowed to
create other files (C++ sources) in addition to the NED file.</simpara>
</section>
<section id="_import_wizards">
<title>Import Wizards</title>
<literallayout class="monospaced">wizardType = import</literallayout>
<simpara>Import wizard is not a standalone type, but rather a flag on other wizard types.
It makes the wizard appear in the <emphasis>File|Import&#8230;</emphasis> dialog in addition to the <emphasis>File|New &#8230;</emphasis>
dialogs.</simpara>
<simpara>To access the import wizards, choose <emphasis>OMNeT++</emphasis>, <emphasis>Networks, simulations and other items</emphasis>
as import source on the first page of the <emphasis>Import</emphasis> dialog. The next page will be the
the content template selection page. After choosing a template, the next page
will be the file, folder or project name selection page of the <emphasis>New&#8230;</emphasis> wizard,
followed by the custom wizard pages.</simpara>
<note><simpara>If an import wizard supports more than one wizard types (e.g. <literal>project</literal>, <literal>simulation</literal>, <literal>nedfile</literal>, etc.),
the <emphasis>File|Import&#8230;</emphasis> dialog will use only one of those types. The type is chosen in the following order
of preference: <literal>network</literal>, <literal>nedfile</literal>, <literal>compoundmodule</literal>, <literal>simplemodule</literal>, <literal>msgfile</literal>,
<literal>inifile</literal>, <literal>simulation</literal>, <literal>project</literal>. This may be changed in the future to explicit
wizard type selection.</simpara></note>
</section>
<section id="_export_wizards">
<title>Export Wizards</title>
<literallayout class="monospaced">wizardType = export</literallayout>
<simpara>Export wizards can be accessed via the <emphasis>File|Export&#8230;</emphasis> dialog, and export data
into one or more files in the workspace or in the file system.</simpara>
<simpara>To access the export wizards, choose <emphasis>OMNeT++</emphasis>, <emphasis>Networks, simulations and other items</emphasis>
as export destination on the first page of the <emphasis>Export</emphasis> dialog. The next page will be the
the content template selection page, followed by the custom wizard pages.</simpara>
<simpara>Export wizards do not have a standard file/folder selection page, the target
file name(s) must be obtained from the user on custom wizard pages.</simpara>
<tip><simpara>You can use the <literal>SaveAsChooser</literal> and <literal>ExternalSaveAsChooser</literal> custom controls
     to prompt for a file name in the workspace and in the file system, respectively.</simpara></tip>
<simpara>The export wizard does not set <literal>targetFileName</literal>, <literal>targetMainFile</literal>, or any similar
variables. It is entirely up to the template author to define a variable to store the
output file name, let the user edit it, and save the content in that file.</simpara>
<simpara>Template files are not allowed to produce any output: they are supposed to create
the target files programmatically.</simpara>
<tip><simpara>Templates can use static methods of the <literal>FileUtils</literal> class, e.g.
   <literal>createFile(workspacepath, content)</literal> and <literal>createExternalFile(filesystempath, content)</literal>,
   to create the files. Here, <literal>content</literal> is a string that holds the text to be written
   out into the file, in the platform&#8217;s default encoding.</simpara></tip>
<tip><simpara>The content text may be assembled using plain string concatenation
  (<literal>&lt;#assign content = content + "\nsome text"&gt;</literal>), or templated content
  (<literal>&lt;#assign content&gt;some text, ${foo} and ${bar}...&lt;/#assign&gt;</literal>).</simpara></tip>
</section>
<section id="_new_wizard_wizard">
<title>New Wizard Wizard</title>
<literallayout class="monospaced">wizardType = wizard</literallayout>
<simpara>TODO Like &#8230;</simpara>
</section>
</section>
<section id="_configuration_keys">
<title>Configuration Keys</title>
<simpara>The <literal>template.properties</literal> file is a standard Java property file (<literal>key = value</literal> syntax).
That file can be used to supply a template name, a template description,
and various other options.</simpara>
<simpara>Recognized property file keys:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>templateName</literal> 
</term>
<listitem>
<simpara>
                The template&#8217;s display name. This is the name that appears in
                the tree in the template selection page. This property defaults
                to the name of the folder that holds the wizard files.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateDescription</literal> 
</term>
<listitem>
<simpara>
                Description of the template. This may appear as a tooltip
                or in a description page in the wizard.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateCategory</literal> 
</term>
<listitem>
<simpara>
                Template category is used for organizing the templates into a
                tree in the wizard&#8217;s template selection page. Defaults to the
                name of the project that provides the template.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateImage</literal> 
</term>
<listitem>
<simpara>
                Name of the icon that appears with the name in the wizard&#8217;s
                template selection page.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>supportedWizardTypes</literal> 
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of wizard types (e.g.
                <literal>nedfile</literal>, <literal>simplemodule</literal>, <literal>project</literal>, <literal>inifile</literal>) that
                this template supports. If not specified, the wizard will support
                all known wizard types.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>ignoreResources</literal> 
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of non-template files or
                folders; those files won&#8217;t get copied over to the new project.
                The <literal>template.properties</literal> file and custom wizard page files
                automatically count as nontemplates, so they don&#8217;t have to be listed.
                Wildcards (<literal>*</literal>, <literal>**</literal>, <literal>?</literal>) are accepted. Note that <literal>*.foo</literal>
                is interpreted as <literal>./*.foo</literal>; write <literal>**/*.foo</literal> to mean foo files
                anywhere.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>verbatimFiles</literal> 
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of files that need to be
                copied over into the target project verbatim, even if they have
                the <literal>.ftl</literal> extension. Wildcards (<literal>*</literal>, <literal>**</literal>, <literal>?</literal>) are accepted.
                Note that <literal>*.foo</literal> is interpreted as <literal>./*.foo</literal>; write <literal>**/*.foo</literal>
                to mean foo files anywhere.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The <emphasis>New OMNeT++ Project</emphasis> wizard also recognizes the following options. These
options can be overridden from custom wizard pages.</simpara>
<variablelist>
<varlistentry>
<term>
<literal>addProjectReference</literal> 
</term>
<listitem>
<simpara>
                True or false; defaults to true. If true, the template&#8217;s project
                will be added to the referenced projects list of the new project.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>sourceFolders</literal> 
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of C++ source folders
                to be created and configured. By default, none.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>nedSourceFolders</literal> 
</term>
<listitem>
<simpara>
                Comma-separated or JSON-syntax list of NED source folders
                to be created and configured. By default, none.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>makemakeOptions</literal> 
</term>
<listitem>
<simpara>
                Comma-separated list of items in the syntax "folder:options",
                or a JSON-syntax map of strings; it sets opp_makemake options
                for the given folders. There is no default.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>There are additional options for adding custom pages into the wizard, as described
in the next section.</simpara>
</section>
<section id="_templates">
<title>Templates</title>
<simpara>For wizards several variables are predefined, such as <literal>templateName, targetFolder, date,
author</literal>; others like <literal>targetFileName, targetTypeName, simulationFolderName,
nedPackageName</literal>, etc. are defined only for certain wizard dialogs.
A full list of variables is provided in the Appendix.</simpara>
<section id="_generating_multiple_files">
<title>Generating multiple files</title>
<simpara>By default templates are processed and copied with the same name (chopping the <literal>.ftl</literal>
extension), but it is possible to redirect the output of the template to a different
file using the <literal>&lt;@setoutput path=.../&gt;</literal> macro. The filename can contain slashes too, i.e.
one can write files in a different folder. If the folder does not exist, it will
be created. An example:</simpara>
<literallayout class="monospaced">&lt;@setoutput path=targetFileName/&gt;</literallayout>
<simpara>If filename is empty, the directive restores output to the original file name (the template&#8217;s name).
This also works if a folder name is given and only the file name is missing
(<literal>&lt;@setoutput path="src/"&gt;</literal>): then it will write the file with the original name
but into the specified folder.</simpara>
<note><simpara>If there are multiple setoutput&#8217;s with the same file name within a template,
the content will be concatenated. Concatenation only works within one template;
if you have multiple templates writing into the same file, they will overwrite
each other&#8217;s content, and it is undefined which one will win.</simpara></note>
</section>
<section id="_conditional_file_creation">
<title>Conditional file creation</title>
<simpara>Empty and blank files (ie. those containing only white space) will not be created,
i.e. processing will skip writing it without any question, warning or error.
This allows you to easily create conditional files. This also means that you
cannot create empty files this way. However, this "limitation" is easy to overcome
as most file formats (NED, C++, INI, XML, etc) have a comment syntax, so you
can just write a file that contains only a comment ( <literal>// file intentionally left blank</literal> ).
Alternatively, you can create an empty file using the <literal>FileUtils</literal> Java utility class
(<literal>&lt;@do FileUtils.createFile("empty.txt", "")!/&gt;</literal>).</simpara>
<note><simpara>Although blank files are not created, the template engine will not delete an
      existing file that happens to be already there with the same name.</simpara></note>
</section>
</section>
<section id="_custom_wizard_pages">
<title>Custom Wizard Pages</title>
<simpara>The following properties can be used to define custom pages in the wizard. <literal>&lt;i&gt;</literal> is
an integer page ID (starting with 1); their ordering defines the order of wizard
pages.</simpara>
<variablelist>
<varlistentry>
<term>
<literal>page.&lt;i&gt;.file</literal> 
</term>
<listitem>
<simpara>
                The name of the XSWT file that describes the wizard page layout.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>page.&lt;i&gt;.class</literal> 
</term>
<listitem>
<simpara>
                In addition to XSWT files, custom Java pages may also be defined
                in Java code. This can be useful when the wizard page would be
                too complex to describe with XSWT, would need to have significant
                active behavior, or simply the wizard page code already exists
                in Java form. See below for further discussion about custom pages.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>page.&lt;i&gt;.title</literal> 
</term>
<listitem>
<simpara>
                Title of the wizard page, displayed in the page&#8217;s title area.
                Defaults to the template name.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>page.&lt;i&gt;.description</literal> 
</term>
<listitem>
<simpara>
                Description of the wizard page, shown in the dialog&#8217;s title area
                below the title. Defaults to text in the format "Page 1 of 3".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>page.&lt;i&gt;.condition</literal> 
</term>
<listitem>
<simpara>
                A condition for showing the page. If it evaluates to false, the
                page will be skipped when it would normally come in the page
                sequence of the wizard. This makes it possible not only to skip
                pages, but also to show different pages based on some choice
                or choices the user made earlier in the wizard (decision tree).
                The condition will be evaluated by the template engine, so any
                valid FreeMarker expression that can produce true or "true" as
                a result will do. The expression must be supplied without the
                <literal>${</literal> and <literal>}</literal> marks: the string you enter will be substituted into
                the "<literal>${( &lt;condition&gt; )?string}</literal>" string (will replace "<literal>&lt;condition&gt;</literal>"),
                and evaluate as such. An example will be provided later.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>All property file entries are available as template variables, too. Also, most
property values may refer to other property values or template variables, using
the <literal>${name}</literal> syntax.</simpara>
<section id="_xswt_forms">
<title>XSWT Forms</title>
<simpara>An XSWT form is defined in an XML file with the root element <literal>&lt;xswt&gt;</literal>.
Some XSWT specific elements and attributes (<literal>import</literal> and <literal>package</literal>
declarations, <literal>id</literal> and <literal>class</literal> attributes to name a few) are
defined in the <literal>http://sweet_swt.sf.net/xswt</literal> XML namespace
(we use the <literal>x</literal> namespace prefix here).</simpara>
<simpara>Controls that can be used in XSWT are instantiated by an element
with same name as the control (but starting with lowercase).</simpara>
<simpara>Controls and classes used in an XSWT file must be imported before they can be used.</simpara>
<literallayout class="monospaced">&lt;xswt xmlns:x="http://sweet_swt.sf.net/xswt"&gt;
  &lt;x:import&gt;
    &lt;package name="java.lang"/&gt;
    &lt;package name="org.eclipse.swt.widgets" /&gt;
    &lt;package name="org.eclipse.swt.custom" /&gt;
    &lt;package name="org.eclipse.swt.graphics" /&gt;
    &lt;package name="org.eclipse.swt.layout" /&gt;
    &lt;package name="org.omnetpp.common.wizard.support" /&gt;
    &lt;package name="org.omnetpp.ned.editor.wizards.support" /&gt;
    &lt;package name="org.omnetpp.cdt.wizard.support" /&gt;
  &lt;/x:import&gt;
  &lt;label text="Hello"/&gt;
&lt;/xswt&gt;</literallayout>
<simpara>Entities and attributes in an XSWT file are directly mapped to the corresponding
SWT controls and their properties. For example, a <literal>&lt;styledText&gt;</literal> tag creates
an <literal>org.eclipse.swt.custom.StyledText</literal> control. Similarly, a <literal>text</literal> attribute
causes the <literal>setText()</literal> method of the control to be called.</simpara>
<literallayout class="monospaced">&lt;styledText text="Hello world!" /&gt;</literallayout>
<simpara>Alternatively, it is possible to call a public method on the control
by embedding a "call" as a child tag and supplying the parameters as <literal>p0</literal>, <literal>p1</literal>, etc.:</simpara>
<literallayout class="monospaced">&lt;styledText&gt;
  &lt;setText x:p0="Hello World"/&gt;
&lt;/styledText&gt;</literallayout>
<note><simpara>Because of a limitation in XSWT, only methods accepting <literal>String</literal> parameters can be
      accessed this way.</simpara></note>
<simpara>Integer constants in controls (<literal>public static final int</literal> fields) can be used in an
XSWT file by appending the Java class name before them:</simpara>
<literallayout class="monospaced">&lt;gateChooser gateFilter="GateChooser.INOUT|GateChooser.VECTOR"/&gt;</literallayout>
<simpara>Constants in the SWT class do not need the <literal>SWT.</literal> prefix. You can write:</simpara>
<literallayout class="monospaced">&lt;button x:style="RADIO"/&gt;</literallayout>
<simpara>Children can be added to a compound control inside the <literal>&lt;x:children&gt;&lt;/x:children&gt;</literal> tags.</simpara>
<literallayout class="monospaced">&lt;group text="Hello"&gt;
  &lt;x:children&gt;
    &lt;label text="Label 1" /&gt;
    &lt;label text="Label 2" /&gt;
  &lt;/x:children&gt;
&lt;/group&gt;</literallayout>
<simpara>Layout and layout data can also be added as a new tag inside a control element:</simpara>
<literallayout class="monospaced">&lt;text x:id="numServers" x:style="BORDER"&gt;
  &lt;layoutData x:class="GridData" horizontalAlignment="FILL"
              grabExcessHorizontalSpace="true"/&gt;
&lt;/text&gt;</literallayout>
<note><simpara>Layout is always needed, otherwise the control will not appear on the page.</simpara></note>
<tip><simpara>SWT is documented on the Eclipse website. See:
     <emphasis>http://www.eclipse.org/swt/docs.php</emphasis> for documentation, examples and tutorials.</simpara></tip>
</section>
<section id="_binding_of_template_variables_to_widgets">
<title>Binding of Template Variables to Widgets</title>
<simpara>XSWT allows one to tag widgets with ID attributes. Widget IDs will become the
names of template variables, with the values being the content of widgets.
For example, text widgets (org.eclipse.swt.widgets.Text) provide a string value
(Java type "String"), while checkboxes and radio buttons provide a boolean
(Java type "Boolean").</simpara>
<simpara>XSWT also allows filling up the widgets with default values
(e.g. <literal>&lt;styledText text="some text"/&gt;</literal> ), but this feature
should be used with care, because the defaults set in XSWT may not make it
to the file templates. This is so because if the user clicks <emphasis>Finish</emphasis> early,
the rest of the wizard pages (and their widgets) may not be created at all,
so values set in the XSWT will take no effect.</simpara>
<simpara>For this reason, defaults should always be set in the property file. To do so,
simply use a key with the ID of the widget; those values will be written
into the wizard page when the page is created. For example, if you have a
text widget with <literal>x:id="numNodes"</literal> and a checkbox with <literal>x:id="generateTraffic"</literal>, then
the following lines</simpara>
<literallayout class="monospaced">numNodes = 100
generateTraffic = true</literallayout>
<simpara>will fill in the text widget with "100", and select the checkbox. Widgets that
do not have such lines in the property file will be left alone.
The property file takes precedence over values specified in the XSWT file.</simpara>
<simpara>Compound data structures (arrays, maps, and any combination of them) can be
specified in the JSON syntax (<emphasis>http://json.org</emphasis>). They can be iterated over
in the templates, and can be used as input/output for custom compound widgets.
Examples:</simpara>
<literallayout class="monospaced">apps = ["ftp", "smtp", "news"]
layers = {"datalink":"ieee80211", "network":"ip", "transport":["tcp","udp"]}</literallayout>
<tip><simpara>If you get an error complaining about syntax errors in a JSON entry, the
<emphasis>http://jsonlint.com</emphasis> website can help you locate the problem.</simpara></tip>
</section>
<section id="_conditional_pages">
<title>Conditional Pages</title>
<simpara>Now that basic XSWT usage was covered, we can revisit how one can use page
conditions. Consider the following practical example of creating a wizard
for wireless networks.</simpara>
<simpara>On the first page of the wizard you could have a <emphasis>[] Configure routing</emphasis> checkbox,
with the ID <literal>wantRouting</literal>. If this checkbox gets selected, you want to display
a second page where the user can select a routing protocol, then further
configuration pages depending on the chosen routing protocol.</simpara>
<simpara>To achieve this, you would add the following lines to <literal>template.properties</literal>:</simpara>
<literallayout class="monospaced"># page with the "wantRouting" checkbox
page.1.title = General
# page with the "protocol" combobox
page.2.title = Choose Routing Protocol
page.3.title = AODV Options
page.4.title = DSDV Options</literallayout>
<literallayout class="monospaced">page.2.condition = wantRouting
page.3.condition = wantRouting &amp;&amp; protocol=="AODV"
page.4.condition = wantRouting &amp;&amp; protocol=="DSDV"</literallayout>
<simpara>The <literal>.condition</literal> keys will make the wizard include only the pages where
the condition evaluates to true. Conditions can be arbitrary FreeMarker
expressions that evaluate to <literal>true</literal> (as boolean) or <literal>"true"</literal> (as string).
Conditions are re-evaluated after every page, so you can depend on variables
edited on earlier pages.</simpara>
</section>
<section id="_conditional_widgets">
<title>Conditional Widgets</title>
<simpara>It is also possible to create controls conditionally.
To overcome the limitation that XSWT page descriptions are completely static,
XSWT files undergo FreeMarker template processing before giving them to the
XSWT engine for instantiation. This template processing occurs right before
the page gets displayed, so data entered on previous pages can also be
used as input for generating XSWT source. This feature can be useful to make
conditional widgets (i.e. using <literal>&lt;#if&gt;</literal> to make part of the page appear only
when a certain option has been activated on earlier pages); to create a
previously unknown number of widgets (using a <literal>&lt;#list&gt;..&lt;/#list&gt;</literal> loop);
to populate combo boxes, listboxes or other widgets with options; and more.</simpara>
<literallayout class="monospaced">&lt;!-- Show only if the wizard is run from the New Simulation wizard--&gt;
&lt;#if wizardType=="simulation"&gt;
&lt;label text="Description how the wizard works for new simulations."/&gt;
&lt;/#if&gt;</literallayout>
<simpara>If the user navigates in the wizard back and forth several times (using the
Next and Back buttons), the contents of wizard pages are always re-created
with using the current values of template variables just before getting
displayed, so they will always be up to date.</simpara>
</section>
</section>
<section id="_extending_the_wizards_in_java">
<title>Extending the Wizards in Java</title>
<simpara>It is possible to create new Wizard pages, custom widgets or add new template
variables by extending the wizards in Java.</simpara>
<section id="_creating_wizard_pages">
<title>Creating Wizard Pages</title>
<simpara>Defining a wizard page in Java requires that you install the Eclipse PDE
(Plug-in Development Environment), and that you have some Eclipse development skills.</simpara>
<simpara>The <literal>template.properties</literal> key for denoting a Java-based wizard page is <literal>page.&lt;NN&gt;.class</literal>,
and the value should be the fully qualified name of the Java class that implements
the wizard page. The requirements for the class are:</simpara>
<itemizedlist>
<listitem>
<simpara>
the class must be accessible to the class loader
</simpara>
</listitem>
<listitem>
<simpara>
the class must extend <literal>org.omnetpp.common.wizard.ICustomWizardPage;</literal>
</simpara>
</listitem>
<listitem>
<simpara>
the class must have a public constructor with the following argument list:
  <literal>(String name, IContentTemplate creatorTemplate, String condition)</literal>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_creating_custom_widgets">
<title>Creating Custom Widgets</title>
<simpara>Since XSWT works via Java reflection, your own custom widgets can be used
the forms very much like normal SWT widgets. No glue or registration code
is needed, just add their package to the <literal>&lt;import&gt;</literal> tags at the top of the XSWT
file.</simpara>
<simpara>However, some Java code is needed so that the wizard knows how to write
template variables into your widgets and how to extract them after editing.
This functionality can be added via the <literal>org.omnetpp.common.wizard.IWidgetAdapter</literal>
interface. This interface must be implemented either by the widget class
itself, or by a class named <literal>&lt;widgetclass&gt;Adapter</literal> in the same package.
The interface has methods to tell whether the adapter supports a given widget,
to read the value out of the widget, and to write a value into the widget.</simpara>
<simpara>In addition to basic data types (<literal>Boolean, Integer, Double, String, etc</literal>),
it is possible to use compound data types as well, i.e. those composed of
the List and Map interfaces of the Java Collections API. The default values
can be given in the <literal>template.properties</literal> file in the JSON notation, and the
result can be used in the templates (iteration via <literal>&lt;#list&gt;</literal>, etc).</simpara>
</section>
<section id="_extending_your_template_with_custom_classes_and_widgets">
<title>Extending your Template with Custom Classes and Widgets</title>
<simpara>Jar files placed into the <literal>plugins/</literal> subdirectory of an OMNeT++ project will be
loaded automatically, and will be available to all templates. Jar files in
that directory may be plain Java jars and Eclipse plug-in jars. (The latter
makes it also possible to contribute new functionality into the IDE via
various extension points, but this is outside the scope of this discussion
about wizards.)</simpara>
<simpara>Jar files placed in the folder of the template will
be loaded automatically when the template is used, and the classes in it will
be available for that template. Custom SWT widget classes can be imported and
used in XSWT forms, and other code can be used in the template files via the
FreeMarker Bean Wrapper (e.g. <literal>${classes["org.example.SomeClass"].someStaticMethod(...)}</literal>,
see the example wizards.) Like <literal>.xswt</literal> files and <literal>template.properties</literal>, jar files
are not copied over into the destination folder when the wizard executes.</simpara>
</section>
<section id="_extending_the_template_processing">
<title>Extending the Template Processing</title>
<simpara>If you are skilled in writing Eclipse plug-ins, there are ways you can extend
content templates. One is to contribute to the <literal>org.omnetpp.common.wizard.templatecontributor</literal>
extension point, which lets you supply <literal>IContentTemplateContributor</literal> objects
that can extend the content template implementation in various ways. You can
contribute new variables, functions or macros to the template context.</simpara>
</section>
</section>
<section id="_common_pitfalls">
<title>Common Pitfalls</title>
<itemizedlist>
<listitem>
<simpara>
Variables need to be defined. Referring to an undefined variable is an
   error in FreeMarker, i.e. it does not return empty string as in bash or
   in makefiles.
</simpara>
</listitem>
<listitem>
<simpara>
Default values should be specified in <literal>template.properties</literal>, not in the XSWT forms.
   You should resist the temptation to define them in the XSWT page by pre-filling the corresponding
   widget (e.g. <literal>&lt;text x:id="n" text="100"&gt;</literal>). If you specify the value in a page,
   the assignment will not take effect if the user skips that page (i.e. clicks
   <emphasis>Finish</emphasis> earlier). That causes variable to remain undefined, resulting in a
   runtime error during template processing.
</simpara>
</listitem>
<listitem>
<simpara>
Type mismatch. Variables have types in FreeMarker, and one can get type conversion
   errors if the templates are not programmed carefully; for example, comparing a number
   and a string is a runtime error. Worse, widgets in wizard pages may implicitly
   perform type conversion. For example, a <literal>numHosts=100</literal> line in <literal>template.properties</literal>
   defines a number, but if you have a <literal>&lt;text x:id="numHosts"/&gt;</literal> widget in the form,
   the variable will come back from it as a string. Even worse, whether the
   number&#8594;string conversion takes place will depend on whether the page gets
   displayed in the wizard session or not. Therefore, it is recommended that
   you explicitly convert numeric variables to numbers at the top of templates,
   for example like this: <literal>&lt;#assign numHosts = numHosts?number&gt;</literal>
</simpara>
</listitem>
<listitem>
<simpara>
For some reason, FreeMarker refuses to print boolean variables, i.e. <literal>${isFoo}</literal>
   results in a runtime error. The common workaround is to write
   <literal>&lt;#if isFoo&gt;true&lt;#else&gt;false&lt;/#if&gt;</literal>; this can be shortened with our <emphasis>iif()</emphasis> function:
   <literal>${iff(isFoo, "true", "false")}</literal>.
</simpara>
</listitem>
<listitem>
<simpara>
Many string operations are available both as builtin FreeMarker operators
   (<literal>varname?trim</literal>) and as Java methods via  FreeMarker&#8217;s BeanWrapper (<literal>varname.trim()</literal>).
   If you are mixing the two, it is possible that you&#8217;ll start getting
   spurious errors for the Java method calls. In that case, simply change
   Java method calls to FreeMarker builtins, and all will be well.
</simpara>
</listitem>
<listitem>
<simpara>
Some Java functionality (the instanceof operator, <literal>Class.newInstance()</literal>, etc)
   cannot be accessed via BeanWrapper. If you hit such a limitation, check
   our <literal>LangUtils</literal> class that provides FreeMarker-callable static methods
   to plug these holes.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_xswt_tips_and_tricks">
<title>XSWT Tips and Tricks</title>
<simpara><emphasis role="strong">How can I make a checkbox or radio button? <literal>&lt;checkbox&gt;</literal> and <literal>&lt;radio&gt;</literal> are not recognized in my XSWT files!</emphasis></simpara>
<simpara>They are called <literal>&lt;button x:style="CHECK"&gt;</literal> and <literal>&lt;button x:style="RADIO"&gt;</literal> in SWT.</simpara>
<simpara><emphasis role="strong">My text fields, combo boxes, etc. look strange, what do I do wrong?</emphasis></simpara>
<simpara>You usually want to add the <literal>BORDER</literal> option, like this: <literal>&lt;text x:style="BORDER"&gt;</literal></simpara>
<simpara><emphasis role="strong">How can I make a long label wrap nicely?</emphasis></simpara>
<simpara>Specifying x:style="WRAP" is necessary, but not enough. It is
also needed that the label widget expands and fills the space horizontally:</simpara>
<literallayout class="monospaced">&lt;label text="Some long text...." x:style="WRAP"&gt;
    &lt;layoutData x:class="GridData" horizontalAlignment="FILL"
       grabExcessHorizontalSpace="true"/&gt;
&lt;/label&gt;</literallayout>
<simpara><emphasis role="strong">How can I set the initial focus?</emphasis></simpara>
<simpara>Add <literal>&lt;setFocus/&gt;</literal> to the XML body of the desired widget.</simpara>
<simpara><emphasis role="strong">How can I make the presence of some widget conditional to some previous input?</emphasis></simpara>
<simpara>You can use <literal>&lt;#if&gt;</literal> and other FreeMarker directives in XSWT files. These
files undergo template processing each time the corresponding page
appears.</simpara>
<simpara><emphasis role="strong">How can I carry forward data from a previous page to the next?</emphasis></simpara>
<simpara>Use FreeMarker variables (<literal>${varName}</literal>) in the page.</simpara>
<simpara><emphasis role="strong">How can I fill a combo box with values that I&#8217;ll only know at runtime?</emphasis></simpara>
<simpara>You can generate the <literal>&lt;option&gt;</literal> children of the combo using FreeMarker
directives, e.g. <literal>&lt;#list&gt;...&lt;/#list&gt;</literal></simpara>
<simpara><emphasis role="strong">How can I have some more sophisticated user input than simple textedit fields, checkboxes and the like?</emphasis></simpara>
<simpara>You can implement custom SWT controls in Java, and use them in the
wizard pages. The custom controls may even be packaged into jar files
in the template&#8217;s directory, i.e. you do not need to write a separate
Eclipse plug-in or something. Have a look at the source files of the
existing custom controls (<literal>FileChooser</literal>, <literal>NedTypeChooser</literal>, <literal>InfoLink</literal>, etc).</simpara>
<simpara><emphasis role="strong">How can I dynamically enable/disable controls on a page, depending on
 other controls (i.e. the state of a checkbox or a radio button)?</emphasis></simpara>
<simpara>Currently you cannot. If you are desperate, you have the following options:
(1) put the dependent controls onto a separate page, which you can make
conditional; (2) write a custom <literal>CheckboxComposite</literal> control in Java
that features a checkbox, and enables/disables child controls
when the checkbox selection changes; (3) write the full custom wizard
page entirely in Java, and register it in <literal>template.properties</literal> with
<literal>page.xx.class=</literal> instead of <literal>page.xx.file=</literal>; (4) implement scripting support
for XSWT 1.x and contribute the patch to us.</simpara>
<simpara><emphasis role="strong">In the Project wizard, how does it get decided which templates get
offered when the <emphasis>With C++ Support</emphasis> checkbox is selected and when
it is not selected on the first page?</emphasis></simpara>
<simpara>If the C++ support checkbox is cleared, templates that require
C++ support will not appear; when it is checked, there is no
such filtering. A template is regarded as one that requires C++ support
if the <literal>template.properties</literal> file contains any of the following:
<literal>sourceFolders=</literal>, <literal>makemakeOptions=</literal>, or <literal>requiresCPlusPlus=true</literal>.</simpara>
</section>
<section id="_appendix_a_widgets_in_xswt">
<title>Appendix A - Widgets in XSWT</title>
<section id="_standard_swt_widgets">
<title>Standard SWT widgets</title>
<tip><simpara>The SWT controls are documented on the Eclipse web site. See:
<emphasis>http://help.eclipse.org/galileo/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/swt/widgets/package-summary.html</emphasis></simpara></tip>
<simpara>It is possible to bind template variables to a specific control by using the <literal>x:id</literal>
attribute.</simpara>
<literallayout class="monospaced">&lt;text x:id="templateVariableName" /&gt;</literallayout>
<simpara>This is the way how template variables are bound to the controls (R=read, W=write):</simpara>
<variablelist>
<varlistentry>
<term>
Button
</term>
<listitem>
<simpara>
This SWT class represents buttons, checkboxes and radio
                buttons, depending on its style attribute (<literal>SWT.PUSH,
                SWT.CHECK, SWT.RADIO</literal>).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: the string "true" selects the checkbox/radiobutton,
                   everything else clears it.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns a Boolean.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Combo, CCombo
</term>
<listitem>
<simpara>
Represent a combo box and a custom combo box. It can be
                made read-only (with the <literal>SWT.READ_ONLY</literal> style); a read-only
                combo allows list selection but no manual editing.
                The list items can be specified from XSWT. Variables only
                work with the textedit part (cannot add/remove list items).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: the string value gets written into the combo. If the combo
                   is read-only and contains no such item, nothing happens.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the currently selected item as string.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
DateTime
</term>
<listitem>
<simpara>
A widget for editing date/time.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string in the following format: "yyyy-mm-dd hh:mm:ss".
                   If the string is not in the right format, an error occurs.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns a string in the same format, "yyyy-mm-dd hh:mm:ss".
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Label
</term>
<listitem>
<simpara>
Label widget (not interactive).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: sets the label to the string
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the label
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
List
</term>
<listitem>
<simpara>
A listbox widget that allows selection of one or more items,
                depending on the style attribute (<literal>SWT.SINGLE</literal> or <literal>SWT.MULTI</literal>).
                List items can be specified from XSWT. Template variables only
                work with the selection (cannot add/remove list items).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with comma-separated items, and selects the
                   corresponding item(s) in the listbox. Items that are not
                   among the listbox items are ignored.
</simpara>
</listitem>
<listitem>
<simpara>
R: Returns a string array object (String[]) that can be
                   iterated over in the template.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Scale
</term>
<listitem>
<simpara>
A graphical widget for selecting a numeric value.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts strings with an integer value. Non-numeric strings
                   will cause an error (a message dialog will be displayed).
</simpara>
</listitem>
<listitem>
<simpara>
R: returns an Integer which can be used in arithmetic
                   expressions in the template.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
Slider
</term>
<listitem>
<simpara>
A scrollbar-like widget for selecting a positive numeric value.
                Handled in a similar way as Scale.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Spinner
</term>
<listitem>
<simpara>
Similar to a textedit, but contains little up and down arrows,
                and can be used to input an integer number.
                Handled in a similar way as Scale.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
StyledText
</term>
<listitem>
<simpara>
A textedit widget which allows displaying and editing of
                styled text. Handled similarly to Text.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Text
</term>
<listitem>
<simpara>
A textedit widget. It can be single-line or multi-line,
                depending on the style attribute (<literal>SWT.SINGLE, SWT.MULTI</literal>).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a (potentially multi-line) string.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the edited text as a string.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_custom_widgets">
<title>Custom widgets</title>
<variablelist>
<varlistentry>
<term>
HttpLink
</term>
<listitem>
<simpara>
A control containing a text and a hyperlink between <literal>&lt;a&gt;&lt;/a&gt;</literal> tags. An URL can
                be specified to be opened in an external browser.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with the target URL.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the target URL as string.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
text : the textual content of the control <literal>&lt;a&gt;&lt;/a&gt;</literal> denotes the link inside.
</simpara>
</listitem>
<listitem>
<simpara>
URL : the target URL where the control points to
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
InfoLink
</term>
<listitem>
<simpara>
A control for which displays a text with embedded link(s), and clicking
                on a link will display a hover text in a window. The hover text can be given
                the with setHoverText method (i.e. the hoverText XSWT attribute), or bound
                to a template variable (using the x:id XSWT attribute).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with the hover text for the control.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the hover text as string.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
text : the content of the control
</simpara>
</listitem>
<listitem>
<simpara>
hoverText : the html formatted text displayed in the hover control
</simpara>
</listitem>
<listitem>
<simpara>
hoverMinimumWidth : the minimal width for the hover control
</simpara>
</listitem>
<listitem>
<simpara>
hoverMinimumHeight : the minimal height for the hover control
</simpara>
</listitem>
<listitem>
<simpara>
hoverPreferredWidth : the preferred width for the hover control
</simpara>
</listitem>
<listitem>
<simpara>
hoverPreferredHeight : the preferred height for the hover control
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
FileLink
</term>
<listitem>
<simpara>
A control for displaying the name of a resource as a link. When clicked, it shows
                the resource (opens Project Explorer and focuses it to the resource).
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with the workspace path of the resource to be shown.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the full workspace path of the resource.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
resourcePath : the full workspace path of the file
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
FileChooser
</term>
<listitem>
<simpara>
A control for selecting a file from the workspace. Implemented as a Composite with
                a single-line Text and a Browse button.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with the workspace file name.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the name of the selected file as a string from the workspace.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
fileName : the full workspace path of the selected file.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
ExternalFileChooser
</term>
<listitem>
<simpara>
                A control for selecting a file from the filesystem. Implemented as a Composite with
                a single-line Text and a Browse button.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with the full file name.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the name of the selected file as a string from the filesystem.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
fileName : the full filesystem path of the selected file.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
SaveAsChooser
</term>
<listitem>
<simpara>
A control for selecting a name for a new file from the workspace.
                Implemented as a Composite with a single-line Text and a Browse button.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with the workspace file name.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the name of the selected file as a string from the workspace.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
fileName : the full workspace path for the new file.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
ExternalSaveAsChooser
</term>
<listitem>
<simpara>
                A control for selecting a name for a new file in the filesystem.
                Implemented as a Composite with a single-line Text and a Browse button.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts a string with the full file name.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the name (with full filesystem path) of the new file as a string.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
fileName : the full filesystem path for the new file.
</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
GateChooser
</term>
<listitem>
<simpara>
A control for selecting a gate of a NED module type. If the module
                exists, it lets the user select one of its gates from a combo;
                if it doesn&#8217;t, it lets the user enter a gate name.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts strings with a gate name.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the name of the selected gate as a string.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
gateName : the name of the selected gate
</simpara>
</listitem>
<listitem>
<simpara>
nedTypeName : the NED type whose gates should be enumerated.
</simpara>
</listitem>
<listitem>
<simpara>
gateFilter : type filter for the enumerated gates. Expects a
                  binary OR (|) of the following values: <literal>GateChooser.INPUT,
                  GateChooser.OUTPUT, GateChooser.INOUT, GateChooser.VECTOR,
                  GateChooser.SCALAR</literal>.
</simpara>
<literallayout class="monospaced">&lt;gateChooser x:id="gateName"
  nedTypeName="${nodeType}"
  gateFilter="GateChooser.INOUT|GateChooser.VECTOR"/&gt;</literallayout>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
<varlistentry>
<term>
NedTypeChooser
</term>
<listitem>
<simpara>
                A control for selecting a NED module type. An existing type name can be selected
                or a new one can be entered.
</simpara>
<itemizedlist>
<listitem>
<simpara>
W: accepts strings with a ned type name.
</simpara>
</listitem>
<listitem>
<simpara>
R: returns the name of the selected ned type as a string.
</simpara>
</listitem>
<listitem>
<simpara>
Other attributes:
</simpara>
<itemizedlist spacing="compact">
<listitem>
<simpara>
nedName : the NED module type as a string
</simpara>
</listitem>
<listitem>
<simpara>
acceptedTypes : filter for the enumeration of types. Expects a
                  binary OR (|) of the following values: <literal>NedTypeChooser.MODULE,
                NedTypeChooser.SIMPLE_MODULE, NedTypeChooser.COMPOUND_MODULE,
                NedTypeChooser.MODULEINTERFACE, NedTypeChooser.CHANNEL,
                NedTypeChooser.CHANNELINTERFACE, NedTypeChooser.NETWORK</literal>.
</simpara>
<literallayout class="monospaced">&lt;nedTypeChooser x:id="channelType"
     acceptedTypes="NedTypeChooser.CHANNEL"/&gt;</literallayout>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</varlistentry>
</variablelist>
<note><simpara>Table and tree widgets are currently not supported in a useful way, the main
reason being that SWT Tables and Trees are not editable by default.</simpara></note>
<simpara>Some non-interactive widgets which cannot be connected to template variables
but are useful in forms as structuring elements:</simpara>
<variablelist>
<varlistentry>
<term>
Composite
</term>
<listitem>
<simpara>
Used to group two or more controls into a single one.
</simpara>
<literallayout class="monospaced">&lt;composite&gt;
  &lt;layoutData x:class="GridData" horizontalSpan="2"/&gt;
  &lt;layout x:class="GridLayout"/&gt;
  &lt;x:children&gt;
    &lt;button x:id="dynamic" text="Dynamic" x:style="RADIO"/&gt;
    &lt;button x:id="static" text="Static" x:style="RADIO"/&gt;
  &lt;/x:children&gt;
&lt;/composite&gt;</literallayout>
</listitem>
</varlistentry>
<varlistentry>
<term>
Group
</term>
<listitem>
<simpara>
Used to group the controls with a visual heading.
</simpara>
<literallayout class="monospaced">&lt;group text="Heading text"&gt;
  &lt;x:children&gt;
     &lt;label text="Control 1"/&gt;
     &lt;label text="Control 2"/&gt;
  &lt;/x:children&gt;
&lt;/group&gt;</literallayout>
</listitem>
</varlistentry>
<varlistentry>
<term>
TabFolder/TabItem
</term>
<listitem>
<simpara>
Can be used to group the controls into separate pages.
</simpara>
<literallayout class="monospaced">&lt;tabFolder&gt;
  &lt;x:children&gt;
    &lt;composite x:id="page1"&gt;&lt;/composite&gt;
    &lt;composite x:id="page2"&gt;&lt;/composite&gt;
    &lt;tabItem text="Tab 1" control="page1"/&gt;
    &lt;tabItem text="Tab 2" control="page2"/&gt;
  &lt;/x:children&gt;
&lt;/tabFolder&gt;</literallayout>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="_appendix_b_predefined_template_variables">
<title>Appendix B - Predefined Template Variables</title>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="8">
<colspec colname="col_1" colwidth="30*"/>
<colspec colname="col_2" colwidth="10*"/>
<colspec colname="col_3" colwidth="10*"/>
<colspec colname="col_4" colwidth="10*"/>
<colspec colname="col_5" colwidth="10*"/>
<colspec colname="col_6" colwidth="10*"/>
<colspec colname="col_7" colwidth="10*"/>
<colspec colname="col_8" colwidth="10*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>variable name</simpara></entry>
<entry align="center" valign="top"><simpara>project</simpara></entry>
<entry align="center" valign="top"><simpara>simul.</simpara></entry>
<entry align="center" valign="top"><simpara>msgfile</simpara></entry>
<entry align="center" valign="top"><simpara>inifile</simpara></entry>
<entry align="center" valign="top"><simpara>nedfile</simpara></entry>
<entry align="center" valign="top"><simpara>wizard</simpara></entry>
<entry align="center" valign="top"><simpara>export</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>addProjectReference</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>author</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>date</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>licenseCode</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>licenseText</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>makemakeOptions</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>namespaceName</literal></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>nedPackageName</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>nedSourceFolders</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>newWizardName</literal></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>newWizardProject</literal></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>projectName</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>PROJECTNAME</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>projectname</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>rawProjectName</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>requiresCPlusPlus</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>simulationFolderName</literal></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>simulationName</literal></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>sourceFolders</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>targetFileName</literal></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>targetFolder</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>targetMainFile</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>targetTypeName</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>templateCategory</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>templateDescription</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>templateFolderName</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>templateFolderPath</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>templateName</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>templateProject</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>templateURL</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>withCplusplusSupport</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
<entry align="center" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>wizardType</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>year</literal></simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
<entry align="center" valign="top"><simpara>X</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section id="_general">
<title>General</title>
<simpara>In the following sections we describe the individual wizard types and their supported
template variables. Variables will be marked with one or more letter to show in
which wizard types they are supported as shown on in the previous table</simpara>
<itemizedlist>
<listitem>
<simpara>
A: supported in all wizards
</simpara>
</listitem>
<listitem>
<simpara>
P: project
</simpara>
</listitem>
<listitem>
<simpara>
S: simulation
</simpara>
</listitem>
<listitem>
<simpara>
M: messagefile
</simpara>
</listitem>
<listitem>
<simpara>
I: inifile
</simpara>
</listitem>
<listitem>
<simpara>
N: nedfile, simplemodule, compoundmodule, network
</simpara>
</listitem>
<listitem>
<simpara>
W: wizard
</simpara>
</listitem>
</itemizedlist>
<simpara>Variables marked as (*) are set by the wizard automatically and
generally it does not make sense to change their values.</simpara>
<variablelist>
<varlistentry>
<term>
<literal>date</literal> (A)
</term>
<listitem>
<simpara>
current date in yyyy-mm-dd format
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>year</literal> (A)
</term>
<listitem>
<simpara>
year in yyyy format
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>author</literal> (A)
</term>
<listitem>
<simpara>
user name ("user.name" Java system property)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>licenseCode</literal> (A)
</term>
<listitem>
<simpara>
license identifier for the @license NED property
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>licenseText</literal> (A)
</term>
<listitem>
<simpara>
copyright notice for the given license
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>bannerComment</literal> (A)
</term>
<listitem>
<simpara>
banner comment for source files; includes license text
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_template_information">
<title>Template information</title>
<variablelist>
<varlistentry>
<term>
<literal>wizardType</literal> (A,*)
</term>
<listitem>
<simpara>
the wizard type the template is invoked as. One of the
                following: <literal>project</literal>, <literal>simulation</literal>, <literal>nedfile</literal>, <literal>inifile</literal>, <literal>msgfile</literal>,
                <literal>simplemodule</literal>, <literal>compoundmodule</literal>, <literal>network</literal>, <literal>wizard</literal>, <literal>export</literal>
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateName</literal> (A,*)
</term>
<listitem>
<simpara>
name of the template
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateDescription</literal> (A,*)
</term>
<listitem>
<simpara>
template description
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateCategory</literal> (A,*)
</term>
<listitem>
<simpara>
template category, used to visually group the
                       templates in the wizards
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateURL</literal> (A,*)
</term>
<listitem>
<simpara>
the URL, the template was loaded from (only for built-in and
                  other URL-based wizards)
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>The following variables are only defined if the template was loaded from the workspace
(i.e. a project&#8217;s <literal>templates/</literal> subdirectory):</simpara>
<variablelist>
<varlistentry>
<term>
<literal>templateFolderName</literal> (A,*)
</term>
<listitem>
<simpara>
name of the folder (without path) in which the template files are
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateFolderPath</literal> (A,*)
</term>
<listitem>
<simpara>
full workspace path of the folder in which the template files are
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>templateProject</literal> (A,*)
</term>
<listitem>
<simpara>
name of the project that defines the template
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_file_name_related_variables">
<title>File name related variables</title>
<variablelist>
<varlistentry>
<term>
<literal>targetFolder</literal> (A,*)
</term>
<listitem>
<simpara>
the project or folder path in which the project will generate files.
   For project wizards, this holds the name of the project being created; for
   file wizards, it holds the name of the folder in which the file will be created;
   for simulation wizard, it holds the name of the folder where files will be created.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>targetFileName</literal> (N,I,M,*)
</term>
<listitem>
<simpara>
the name of the new file to be created. The file can be specified on the
                               first wizard page.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>targetTypeName</literal> (P,S,N,I,M)
</term>
<listitem>
<simpara>
a typename that can be used as the main <emphasis>type</emphasis> for the resulting code.
                         (for projects it&#8217;s the <literal>${projectName}</literal>, for simulations it&#8217;s the specified <literal>${simulationName}</literal>, for the rest of wizards it is calculated from the <literal>${targetFileName}</literal>)
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>targetMainFile</literal> (P,S,N,I,M)
</term>
<listitem>
<simpara>
a file name that can be used as the <emphasis>main</emphasis> output file for the template
                         (for projects and simulations it&#8217;s <literal>${targetTypeName}.ned</literal>, for ned,msg and ini files it is <literal>${targetFileName}</literal>)
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_project_name_related_variables">
<title>Project name related variables</title>
<variablelist>
<varlistentry>
<term>
<literal>rawProjectName</literal> (A)
</term>
<listitem>
<simpara>
the project name, "as is"
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>projectName</literal> (A)
</term>
<listitem>
<simpara>
sanitized project name with first letter capitalized
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>projectname</literal> (A)
</term>
<listitem>
<simpara>
sanitized project name in all lowercase
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>PROJECTNAME</literal> (A)
</term>
<listitem>
<simpara>
sanitized project name in all uppercase
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Sanitization means making the name suitable as a NED or C/C++ identifier
(spaces, punctuation and other unfit chars replaced with underscore, etc.)</simpara>
</section>
<section id="_c_project_control">
<title>C++ project control</title>
<variablelist>
<varlistentry>
<term>
<literal>addProjectReference</literal> (P)
</term>
<listitem>
<simpara>
If true, the wizard will make the result project as
                          dependent on the project containing the wizard itself.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>withCplusplusSupport</literal> (P,*)
</term>
<listitem>
<simpara>
Whether the project supports C++ code compilation.
                                 This is the state of the "C++ support" checkbox on the first
                                 page of the project wizard. Setting this variable does
                                 not have any effect on the created project.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>sourceFolders</literal> (P)
</term>
<listitem>
<simpara>
Source folders to be created and configured automatically
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>makemakeOptions</literal> (P)
</term>
<listitem>
<simpara>
makemake options, as "folder1:options1, folder2:options2,&#8230;".
                      The wizard will automatically configure the C++ project with the
                      given options.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>requiresCPlusPlus</literal> (P)
</term>
<listitem>
<simpara>
If true, the wizard requires the "support C++ option" during the project creation.
                        If any of the <literal>sourceFolders, makemakeOptions</literal> are present or <literal>withCplusplusSupport=true</literal>,
                        the template will be displayed only if the "support C++ option" option was set on the
                        first page of the project wizard.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>namespaceName</literal> (S,N,M)
</term>
<listitem>
<simpara>
The namespace where C++ classes should be placed.
                        This is determined automatically by looking up the value of the
                        <literal>@namespace</literal> property in NED files in the NED source folder.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_ned_files_and_message_files">
<title>NED files and message files</title>
<variablelist>
<varlistentry>
<term>
<literal>nedSourceFolders</literal> (P)
</term>
<listitem>
<simpara>
NED source folders to be created and configured automatically.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>nedPackageName</literal> (P,S,N,I)
</term>
<listitem>
<simpara>
The NED package name. For projects it is <literal>${projectname}</literal>,
                           for simulations, NED and INI files, it is automatically
                           calculated from the folder hierarchy where the file
                           is generated.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_variables_specific_to_new_simulation_wizards">
<title>Variables specific to New Simulation wizards</title>
<variablelist>
<varlistentry>
<term>
<literal>simulationFolderName</literal> (S,*)
</term>
<listitem>
<simpara>
the folder where the simulation will be created
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>simulationName</literal> (S,*)
</term>
<listitem>
<simpara>
The name of the simulation. It is the capitalized and
                           sanitized name derived from the <literal>simulationFolderName</literal> .
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_variables_for_new_wizard_generation">
<title>Variables for New Wizard generation</title>
<variablelist>
<varlistentry>
<term>
<literal>newWizardName</literal> (W,*)
</term>
<listitem>
<simpara>
The name of the new wizard to be created. It is the name
                          of the folder under the <literal>templates</literal> directory where
                          all the template files will be stored.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>newWizardProject</literal> (W)
</term>
<listitem>
<simpara>
The project where the new wizard will be created.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_miscellaneus">
<title>Miscellaneus</title>
<simpara>The variables below are just for advanced use only. They can be used to access
directly all known NED and message types, static classes for utility functions and
the whole context used during template processing.</simpara>
<variablelist>
<varlistentry>
<term>
<literal>creationContext</literal> (A)
</term>
<listitem>
<simpara>
The template evaluation context. Provided for low level access.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>classes</literal> (A)
</term>
<listitem>
<simpara>
Access to class static models. It is possible to access
                      class static methods via this variable. See <emphasis>http://freemarker.org/docs/pgui_misc_beanwrapper.html#autoid_54</emphasis>
                      for further details.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>nedResources</literal> (A)
</term>
<listitem>
<simpara>
Provides direct access to the in memory model of the parsed NED files. It is possible to query,
                   check and iterate over the available NED types.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>msgResources</literal> (A)
</term>
<listitem>
<simpara>
Provides access to the in memory model of the parsed NED files.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<note><simpara>In addition to the above variables, all keys found in the template.properties file
are added automatically to the context as a template variable.</simpara></note>
</section>
</section>
<section id="_appendix_c_functions_classes_and_macros_available_from_templates">
<title>Appendix C - Functions, Classes and Macros available from Templates</title>
<simpara>In addition to the standard FreeMarker template constructs, there are
several java utility classes, template macros and functions
that can be used in your wizard templates to ease the development of
custom wizards. The following sections briefly describe these calsses and
methods.</simpara>
<section id="_custom_macros_and_functions">
<title>Custom Macros and Functions</title>
<literallayout class="monospaced">iif(condition, valueIfTrue, valueIfFalse)</literallayout>
<simpara>Inline if. The FreeMarker language does not have a conditional operator
(like ?: of C/C++ ), but the <literal>iif()</literal> function can save you from the verbosity
of having to spell out <literal>&lt;#if&gt;..&lt;#else&gt;..&lt;/#if&gt;</literal>, where such thing is needed.
Note that unlike in C/C++ the evaluation is not lazy, i.e. both the "then" and
the "else" expressions are always evaluated.</simpara>
<literallayout class="monospaced">&lt;@do expression !/&gt;</literallayout>
<simpara>FreeMarker does not have a construct for calling a function and then discarding
the result. One could use <literal>&lt;#assign dummy = expression&gt;</literal>, but this, apart from
being ugly, will fail if the called (Java) function is void or returns null.
We recommend our small <literal>&lt;@do ..!/&gt;</literal> macro which takes one argument and does nothing,
and the exclamation mark (the FreeMarker default value operator) cures the
void/null problem.</simpara>
<simpara>The following Java classes are available during template processing:</simpara>
<variablelist>
<varlistentry>
<term>
Math
</term>
<listitem>
<simpara>
java.lang.Math
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
StringUtils
</term>
<listitem>
<simpara>
org.apache.commons.lang.StringUtils
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
CollectionUtils
</term>
<listitem>
<simpara>
org.apache.commons.lang.CollectionUtils
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
WordUtils
</term>
<listitem>
<simpara>
org.apache.commons.lang.CollectionUtils
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
FileUtils
</term>
<listitem>
<simpara>
see below for documentation
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
NedUtils
</term>
<listitem>
<simpara>
see below for documentation
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
IDEUtils
</term>
<listitem>
<simpara>
see below for documentation
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
ProcessUtils
</term>
<listitem>
<simpara>
see below for documentation
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
LangUtils
</term>
<listitem>
<simpara>
see below for documentation
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_math">
<title>Math</title>
<simpara>Represents the Java Math class, which contains mathematical functions.
See <emphasis>http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Math.html</emphasis> .</simpara>
<simpara>Math has the following methods:</simpara>
<literallayout class="monospaced">double cos(double x)</literallayout>
<literallayout class="monospaced">double sin(double x)</literallayout>
<literallayout class="monospaced">double pow(double x, double y)</literallayout>
<simpara>etc.</simpara>
</section>
<section id="_stringutils">
<title>StringUtils</title>
<simpara>Represents the Apache Commons StringUtils class, which contains over a hundred
utility functions for manipulating strings.
See: <emphasis>http://commons.apache.org/lang/api/org/apache/commons/lang/StringUtils.html</emphasis> .</simpara>
<simpara>StringUtils has the following methods:</simpara>
<literallayout class="monospaced">boolean isEmpty(String s)</literallayout>
<literallayout class="monospaced">boolean isBlank(String s)</literallayout>
<literallayout class="monospaced">String capitalize(String s)</literallayout>
<literallayout class="monospaced">String upperCase(String s)</literallayout>
<literallayout class="monospaced">String lowerCase(String s)</literallayout>
<literallayout class="monospaced">boolean startsWith(String s, String suffix)</literallayout>
<literallayout class="monospaced">boolean endsWith(String s, String prefix)</literallayout>
<literallayout class="monospaced">String[] split(String s)</literallayout>
<literallayout class="monospaced">String join(String[] strings)</literallayout>
<simpara>etc.</simpara>
</section>
<section id="_wordutils">
<title>WordUtils</title>
<simpara>Represents the Apache Commons WordUtils class, which contains utility functions
for manipulating strings as word sequences.
See <emphasis>http://commons.apache.org/lang/api/org/apache/commons/lang/WordUtils.html</emphasis> .</simpara>
<simpara>WordUtils has the following methods:</simpara>
<literallayout class="monospaced">String wrap(String str, int wrapLength)</literallayout>
<literallayout class="monospaced">String capitalize(String str)</literallayout>
<literallayout class="monospaced">String swapCase(String str)</literallayout>
<simpara>etc.</simpara>
</section>
<section id="_collectionutils">
<title>CollectionUtils</title>
<simpara>Represents the Apache Commons CollectionUtils class, which contains some useful
functions for manipulating collections (like lists). Functions include computing
set union, intersection, and difference.
See <emphasis>http://commons.apache.org/collections/apidocs/org/apache/commons/collections/CollectionUtils.html</emphasis></simpara>
<simpara>CollectionUtils has the following methods:</simpara>
<literallayout class="monospaced">Collection union(Collection a, Collection b)</literallayout>
<literallayout class="monospaced">Collection intersection(Collection a, Collection b)</literallayout>
<literallayout class="monospaced">Collection subtract(Collection a, Collection b)</literallayout>
<simpara>etc.</simpara>
</section>
<section id="_fileutils">
<title>FileUtils</title>
<simpara>Contains utility functions for reading files in the following formats: XML,
JSON, CSV, property file, and functions to read and return a text file
as a single string, as an array of lines, and as a an array of string arrays
(where string arrays were created by splitting each by whitespace).</simpara>
<simpara>There are two sets of functions, one works on files in the Eclipse workspace,
and the other files on "external" files, i.e. files in the file system.
Files are interpreted in the Java platform&#8217;s default encoding (unless XML files,
which specify their own encoding.)</simpara>
<simpara>FileUtils has the following methods:</simpara>
<literallayout class="monospaced">org.w3c.dom.Document readXMLFile(String fileName)
org.w3c.dom.Document readExternalXMLFile(String fileName)</literallayout>
<simpara>Parses an XML file, and return the Document object of the resulting
DOM tree.</simpara>
<literallayout class="monospaced">Object readJSONFile(String fileName)
Object readExternalJSONFile(String fileName)</literallayout>
<simpara>Parses a JSON file. The result is a Boolean, Integer, Double, String,
List or Map, or any data structure composed of them. The JSON syntax is
documented at <emphasis>http://json.org</emphasis> ; if you want to check whether a particular
text file corresponds to the JSON syntax, use <emphasis>http://jsonlint.com</emphasis> .</simpara>
<literallayout class="monospaced">String[][] readCSVFile(String fileName, boolean ignoreFirstLine,
                       boolean ignoreBlankLines,
                       boolean ignoreCommentLines)
String[][] readExternalCSVFile(String fileName, boolean ignoreFirstLine,
                       boolean ignoreBlankLines,
                       boolean ignoreCommentLines)</literallayout>
<simpara>Reads a CSV file. The result is an array of lines, where each line is
a string array. Additional method parameters control whether to discard the
first line of the file (which is usually a header line), whether to
ignore blank lines, and whether to ignore comment lines (those starting
with the # character). Comment lines are not part of the commonly accepted
CSV format, but they are supported here nevertheless, due to their
usefulness.</simpara>
<literallayout class="monospaced">Properties readPropertyFile(String fileName)
Properties readExternalPropertyFile(String fileName)</literallayout>
<simpara>Parses a Java property file (<emphasis>key=value</emphasis> lines) in the workspace.
The result is a Properties object, which is effectively a hash of
key-value pairs.</simpara>
<literallayout class="monospaced">String[][] readSpaceSeparatedTextFile(String fileName,
                         boolean ignoreBlankLines,
                         boolean ignoreCommentLines)
String[][] readExternalSpaceSeparatedTextFile(String fileName,
                         boolean ignoreBlankLines,
                         boolean ignoreCommentLines)</literallayout>
<simpara>Reads a text file, and return its contents, split by lines, and each line
split by whitespace. Additional method parameters control whether to ignore
blank lines and/or comment lines (those starting with the # character).
The result is an array of lines, where each line is a string array of the
items on the line.</simpara>
<literallayout class="monospaced">String[] readLineOrientedTextFile(String fileName)
String[] readExternalLineOrientedTextFile(String fileName)</literallayout>
<simpara>Reads a text file in the workspace, and returns its lines. Comment lines
(those starting with a hash mark, #) are discarded. The result is a
string array.</simpara>
<literallayout class="monospaced">String readTextFile(String fileName)
String readExternalTextFile(String fileName)</literallayout>
<simpara>Reads a text file, and return its contents unchanged as a single string.</simpara>
<literallayout class="monospaced">boolean isValidWorkspacePath(String path)</literallayout>
<simpara>Returns true if the given string is syntactically a valid workspace path.</simpara>
<literallayout class="monospaced">boolean isValidWorkspaceFilePath(String path)</literallayout>
<simpara>Returns true if the given string is syntactically a valid workspace file path.
This function does not check whether the file exists, or whether the given path
actually already points to a resource of a different type.</simpara>
<literallayout class="monospaced">IWorkspaceRoot getWorkspaceRoot()</literallayout>
<simpara>Returns the workspace root object. The workspace contains the user&#8217;s
projects.</simpara>
<literallayout class="monospaced">IProject asProject(String path)</literallayout>
<simpara>Returns the handle for the workspace project with the given name.
Throws exception if the path is not a valid workspace project path.
This function does not test whether the project exists. To test that,
call the exists() method on the returned handle.</simpara>
<literallayout class="monospaced">IContainer asContainer(String path)</literallayout>
<simpara>Returns the handle for the workspace container (i.e. project or folder) with the given name.
Throws exception if the path is not a valid workspace container path.
This function does not test whether the container exists. To test that,
call the exists() method on the returned handle.</simpara>
<literallayout class="monospaced">IFile asFile(String path)</literallayout>
<simpara>Returns the handle for the workspace file with the given name.
Throws exception if the path is not a valid workspace file path.
This function does not test whether the file exists. To test that,
call the exists() method on the returned handle.</simpara>
<literallayout class="monospaced">IResource asResource(String pathName)</literallayout>
<simpara>Returns the handle for the workspace project, folder or file with
the given name. If the resource does not exist and the path contains
more than one segment (i.e. it cannot be a project), it is returned as
a file handle if it has a file extension, and as a folder if it
does not.</simpara>
<literallayout class="monospaced">File asExternalFile(String path)</literallayout>
<simpara>Returns a java.io.File object for the given path. The object can be used to
access operations provided by the File API, such as exists(), length(), etc.</simpara>
<literallayout class="monospaced">void copy(String path, String destPath, IProgressMonitor monitor)</literallayout>
<simpara>Copies a workspace resource (file, folder or project) given with its path
to the destination path. For projects and folders, it copies recursively
(i.e. copies the whole folder tree). From the project root directory it
leaves out dot files, hidden files, and team private files.</simpara>
<literallayout class="monospaced">void copyURL(String url, String destFilePath,
                      IProgressMonitor monitor)</literallayout>
<simpara>Copies the file at the given URL to the given destination workspace file.</simpara>
<literallayout class="monospaced">String createTempFile(String content)</literallayout>
<simpara>Writes the given string to a temporary file, and returns the path of the
temporary file in the file system. The file will be automatically deleted
when the IDE exits, but it can be also deleted earlier via deleteExternalFile().</simpara>
<literallayout class="monospaced">void createFile(String fileName, String content)</literallayout>
<simpara>Creates a workspaces text file with the given contents, in the platform&#8217;s default encoding.</simpara>
<literallayout class="monospaced">void createExternalFile(String fileName, String content)</literallayout>
<simpara>Creates a text file in the file system with the given contents, in the platform&#8217;s default encoding.</simpara>
<literallayout class="monospaced">void deleteFile(String fileName)</literallayout>
<simpara>Deletes the given workspace file. It is OK to invoke it on a nonexistent file.</simpara>
<literallayout class="monospaced">void deleteExternalFile(String fileName)</literallayout>
<simpara>Deletes the given file from the file system. It is OK to invoke it on a nonexistent file.</simpara>
<literallayout class="monospaced">void createDirectory(String fileName)</literallayout>
<simpara>Creates a workspace folder. The parent must exist.</simpara>
<literallayout class="monospaced">void createExternalDirectory(String fileName)</literallayout>
<simpara>Creates a directory in the file system. The parent must exist.</simpara>
<literallayout class="monospaced">void removeDirectory(String fileName)</literallayout>
<simpara>Deletes a workspace folder. The folder must be empty. It is OK to invoke
it on a nonexistent folder.</simpara>
<literallayout class="monospaced">void removeExternalDirectory(String fileName)</literallayout>
<simpara>Deletes a directory in the file system. The directory must be empty.
It is OK to invoke it on a nonexistent directory.</simpara>
</section>
<section id="_nedutils">
<title>NedUtils</title>
<simpara>Provides utility methods to work with NED types and check their existence.</simpara>
<simpara>NedUtils has the following methods:</simpara>
<literallayout class="monospaced">boolean isVisibleType(String typeName, String inFolder)</literallayout>
<simpara>Returns whether the given NED type is visible in the given folder.
If the type is a fully qualified name, it is recognized if it is
defined in the same project as the given folder, or in one of its
referenced projects; if the type is a simple name (without package),
it is recognized if it&#8217;s in the NED package of the given folder.</simpara>
<literallayout class="monospaced">INEDTypeInfo getNedType(String typeName, String inFolder)</literallayout>
<simpara>Like isVisibleNedType(), but actually returns the given NED type
if it was found; otherwise it returns null. Useful if you implement
a complex wizard page in Java.</simpara>
</section>
<section id="_ideutils">
<title>IDEUtils</title>
<simpara>Provides entry points into various aspects of the IDE. This includes access to
the Eclipse workspace (projects, folders, files), and the NED index. The former
is documented in the Eclipse Platform help; documentation for the latter can
be found in the sources (Javadoc).
See <emphasis>http://help.eclipse.org/galileo/index.jsp?topic=/org.eclipse.platform.doc.isv/guide/resInt.htm</emphasis>
and <emphasis>http://help.eclipse.org/galileo/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRoot.html</emphasis></simpara>
<simpara>IDEUtils has the following methods:</simpara>
<literallayout class="monospaced">boolean openConfirm(String title, String message,
                            String detailsMessage)
boolean openQuestion(String title, String message,
                             String detailsMessage)
boolean openError(String title, String message,
                          String detailsMessage)
boolean openWarning(String title, String message,
                            String detailsMessage)
boolean openInformation(String title, String message,
                            String detailsMessage)</literallayout>
<simpara>Opens a standard message dialog, with an closable details message.</simpara>
</section>
<section id="_langutils">
<title>LangUtils</title>
<simpara>Provides a collection of Java language related utility functions.</simpara>
<simpara>LangUtils shas the following methods:</simpara>
<literallayout class="monospaced">boolean hasMethod(Object object, String methodName)</literallayout>
<simpara>Returns true if the object has a method with the given name.
Method args and return type are not taken into account.
Search is performed on the object&#8217;s class and all super classes.</simpara>
<literallayout class="monospaced">boolean hasField(Object object, String fieldName)</literallayout>
<simpara>Returns true if the object has a field with the given name.
Field type is not taken into account. Search is performed on
the object&#8217;s class and all super classes.</simpara>
<literallayout class="monospaced">boolean instanceOf(Object object, String classOrInterfaceName)</literallayout>
<simpara>Returns true if the given object is instance of (subclasses from or
implements) the given class or interface. To simplify usage, the class
or interface name is accepted both with and without the package name.</simpara>
<literallayout class="monospaced">String toString(Object object)</literallayout>
<simpara>Produces a user-friendly representation of the object. In case of
collections (lists, maps, etc), the representation is JSON-like.</simpara>
<literallayout class="monospaced">List&lt;Object&gt; newList()</literallayout>
<simpara>Creates and returns a new mutable List object (currently ArrayList).</simpara>
<literallayout class="monospaced">Map&lt;Object, Object&gt; newMap()</literallayout>
<simpara>Creates and returns a new mutable Map object (currently HashMap).</simpara>
<literallayout class="monospaced">Set&lt;Object&gt; newSet()</literallayout>
<simpara>Creates and returns a new mutable Set object (currently HashSet).</simpara>
<literallayout class="monospaced">Class&lt;?&gt; getClass(Object object)</literallayout>
<simpara>Returns the class of the given object. Provided because BeanWrapper
seems to have a problem with the getClass() method.</simpara>
</section>
<section id="_processutils">
<title>ProcessUtils</title>
<simpara>Provides functionality to start external applications from the wizard,</simpara>
<simpara>ProcessUtis has the following methods:</simpara>
<literallayout class="monospaced">ProcessResult exec(String command, String[] arguments,
                           String workingDirectory,
                           String standardInput, double timeout)</literallayout>
<simpara>Executes the given command with the arguments as a separate process.
The standard input is fed into the spawn process and the output is read
until the process finishes or timeout occurs. The timeout value 0 means wait
infinitely long to finish the process. Arguments at the end of the argument
list are optional.</simpara>
<literallayout class="monospaced">String lookupExecutable(String name)</literallayout>
<simpara>Finds the given executable in the path, and returns it with full path.
If not found, it returns the original string.</simpara>
</section>
</section>
</section>
</article>
