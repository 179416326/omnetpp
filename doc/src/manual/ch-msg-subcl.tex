\chapter{Message Definitions}
\label{cha:message-definitions}

\section{Motivation}

In former releases of {\opp}, \fname{cPar} objects were the only way
to add data to message objects. This technique had significant drawbacks:
\fname{cPar}'s were fairly complex objects themselves,
and they added both execution and memory overhead. They were
also error-prone because \fname{cPar} objects had to be
added dynamically and individually to each message object.

A better approach is to leave out \fname{cPar} objects and rely on
the C++ language instead. Since the simulation library is written in C++,
it is very easy to subclass \fname{cMessage}, and add the necessary
parameters as instance variables.

For defining a new message class, one could write the following:

\begin{verbatim}
class RadioMsg : public cMessage {
  public:
    int freq;
    double power;
    ...
};
\end{verbatim}


Now it is possible to write code like this:

\begin{verbatim}
RadioMsg *msg = new RadioMsg();
msg->freq = 1;
msg->power = 10.0;
...
\end{verbatim}

This code is more efficient than using \fname{cPar}s, and
also benefits from static type checking: if you mistype the name
of a parameter, already the compiler can detect the mistake.

Note that the above code is only for illustration.
In real code, one should avoid public data members:
\fname{freq} and \fname{power} should be private members,
and getter/setter methods should exist to access them.
Also, the above class definition misses several member functions
(constructor, assignment operator, etc.) that should be written.

In one test (slotted Aloha simulation with 10 nodes), the simulation was
8 times faster when using this technique. Of course, if your simulation
doesn't create and destroy many messages (compared to other activities),
you may not benefit this much.

However, you'll notice one drawback of this solution when you try to use
Tkenv for debugging. While \fname{cPar}-based message parameters can be viewed in
message inspector windows, parameters added by subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because the C++ language
does not support ``reflection'' (extracting class information at runtime)
like for example Java does.

There is a solution however: one can supply Tkenv with missing ``reflection''
information about the new class. Reflection info might take the form of
a separate C++ class whose methods return information about the
\fname{RadioMsg} fields. This descriptor class might look like this:

\begin{verbatim}
class RadioMsgDescriptor : public Descriptor
{
  public:
    virtual int getFieldCount() {return 2;}

    virtual const char *getFieldName(int k) {
        const char *fieldname[] = {"freq", "power";}
        if (k<0 || k>=2) return NULL;
        return fieldname[k];
    }

    virtual double getFieldAsDouble(RadioMsg *msg, int k) {
        if (k==0) return msg->freq;
        if (k==1) return msg->power;
        return 0.0; // not found
    }
    //...
};
\end{verbatim}

Then you have to inform Tkenv that a \fname{RadioMsgDescriptor} exists and that it
should be used whenever Tkenv finds messages of type \fname{RadioMsg} (as it is
currently implemented, whenever the object's \fname{className()} method returns
\ttt{"RadioMsg"}). So when you inspect a \fname{RadioMsg} in your simulation, Tkenv
can use \fname{RadioMsgDescriptor} to extract and display the values of
the \fname{freq} and \fname{power} variables.

The actual implementation is somewhat more complicated than this, but not
much.

To relieve the simulation programmer from having to write this extra code,
messages are described in a higher-level syntax, and a compiler is used to
generate the necessary C++ code with subclasses of \fname{cMessage} and \fname{cPacket}.
The message compiler can add the necessary data members and methods.
It also generates the necessary reflection code which makes it
possible to inspect message contents in Tkenv.

\opp currently contains an experimental implementation of the message
subclassing feature described above. ``Experimental'' means that:

\begin{itemize}
  \item The message description syntax and features may change in the future,
    based on feedback from the community;
  \item The compiler that translates message descriptions into C++ is
    a perl script \fprog{opp\_msgc}. This is a temporary solution until
    the C++-based \fprog{nedtool} is finished.
\end{itemize}

The subclassing approach for adding message parameters was originally
suggested by Nimrod Mesika.


\section{The first message class}

Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a \ttt{mypacket.msg} file with the following contents:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} MyPacket
\{
    \tbf{fields}:
       \tbf{int} srcAddress;
       \tbf{int} destAddress;
       \tbf{int} hops = 0;
\};
\end{Verbatim}

The task of the ``message subclassing compiler'' is to generate C++ classes
you can use from your models as well as ``reflection'' classes that allow
Tkenv to inspect these data stuctures.

If you process \ttt{mypacket.msg} with ``message subclassing compiler'', it will
create the following files for you: \ttt{mypacket\_m.h} and \ttt{mypacket\_m.cc}.
\ttt{mypacket\_m.h} contains the declaration of the \fname{MyPacket} C++ class, and
it should be included into your C++ sources where you need to handle
\fname{MyPacket} objects.

The \fname{MyPacket} class declaration in \ttt{mypacket\_m.h} will look like this:

\begin{verbatim}
class MyPacket : public cMessage {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
\end{verbatim}

So in your C++ file, you could use it like this:

\begin{verbatim}
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt->setSrcAddress( localAddr );
...
\end{verbatim}

The \ttt{mypacket\_m.cc} file contains implementation of the generated \fname{MyPacket}
class, as well as ``reflection'' code that allows you to inspect these data
stuctures in the Tkenv GUI. The \ttt{mypacket\_m.cc} file should be compiled and
linked into your simulation. (If you use the \fname{opp\_makemake} tool
to generate your makefiles, the latter will be automatically taken care of.)


\section{Features}

The following sections describe the message syntax and features in detail.


\subsection{Declaring enums}

An \fname{enum \{..\}} generates a normal C++ enum, plus creates an object
which stores text representations of the constants. The latter makes it possible
to display symbolic names in Tkenv.
An example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{enum} ProtocolTypes
\{
   IP = 1;
   TCP = 2;
\};
\end{Verbatim}

% It is possible to ``extend'' an enum with new values.
%
% begin{Verbatim}[commandchars=\\\{\}]
% // add new values to ProtocolTypes
% \tbf{enum} MoreProtocolTypes \tbf{extends} ProtocolTypes
% \{
%   CLNP = 3;
%   TP4 = 4;
% \};
% end{Verbatim}

\subsection{Message declarations}

\textbf{Basic use}

You can describe messages with the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
    \tbf{fields}:
        \tbf{int} sourceAddress;
        \tbf{int} destAddress;
        \tbf{bool} hasPayload;
\};
\end{Verbatim}

Processing this description with the message compiler will produce
a C++ header file with a generated class, \fname{FooPacket}.
\fname{FooPacket} will be a subclass of \fname{cMessage}.

For each field in the above description, the generated class will have
a protected data member, a getter and a setter method. The names of the
methods will begin with \fname{get} and \fname{set},
followed by the field name with its first letter converted to uppercase.
Thus, \fname{FooPacket} will contain the following methods:

\begin{verbatim}
virtual int getSourceAddress() const;
virtual void setSourceAddress(int sourceAddress);

virtual int getDestAddress() const;
virtual void setDestAddress(int destAddress);

virtual bool getHasPayload() const;
virtual void setHasPayload(bool hasPayload);
\end{verbatim}

Note that the methods are all declared \fname{virtual} to give you the possibility
of overriding them in subclasses.

Two constructors will be generated: one that optionally accepts an object name,
and a copy constructor:

\begin{verbatim}
FooPacket(const char *name=NULL);
FooPacket(const FooPacket& other);
\end{verbatim}

Appropriate assignment operator (\fname{operator=()}) and \fname{dup()} methods will
also be generated.

Data types for fields are not limited to \fname{int} and \fname{bool}. You can use the
following primitive types (i.e. primitive types as defined in the C++ language):

\begin{itemize}
   \item \fname{bool}
   \item \fname{char}, \fname{unsigned char}
   \item \fname{short}, \fname{unsigned short}
   \item \fname{int}, \fname{unsigned int}
   \item \fname{long}, \fname{unsigned long}
   \item \fname{double}
\end{itemize}

Field values are initialized to zero.


\textbf{Initial values}

You can initialize field values with the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
   \tbf{fields}:
        \tbf{int} sourceAddress = 0;
        \tbf{int} destAddress = 0;
        \tbf{bool} hasPayload = false;
\};
\end{Verbatim}

Initialization code will be placed in the constructor of the generated class.


\textbf{Enum declarations}

You can declare that an \fname{int} (or other integral type) field
takes values from an enum. The message compiler can than generate code
that allows Tkenv display the symbolic value of the field.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
  \tbf{fields}:
      \tbf{int} payloadType \tbf{enum}(PayloadTypes);
\};
\end{Verbatim}

The enum has to be declared separately in the message file.


\textbf{Fixed-size arrays}

You can specify fixed size arrays:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
    \tbf{fields}:
        \tbf{long} route[4];
\};
\end{Verbatim}

The generated getter and setter methods will have an extra \fname{k} argument,
the array index:

\begin{verbatim}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
\end{verbatim}

If you call the methods with an index that is out of bounds, an exception
will be thrown.


\textbf{Dynamic arrays}

If the array size is not known in advance, you can declare the field
to be a dynamic array:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
   \tbf{fields}:
       \tbf{long} route[];
\};
\end{Verbatim}

In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

\begin{verbatim}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
\end{verbatim}

The \fname{set...ArraySize()} method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

The default array size is zero. This means that you need to call the
\fname{set...ArraySize()} before you can start filling array elements.


\textbf{String members}

You can declare string-valued fields with the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
   \tbf{fields}:
       \tbf{string} hostName;
\};
\end{Verbatim}

The generated getter and setter methods will return and accept \fname{const char*}
pointers:

\begin{verbatim}
virtual const char *getHostName() const;
virtual void setHostName(const char *hostName);
\end{verbatim}

The generated object will have its own copy of the string.

NOTE: a string member is different from a character array,
which is treated as an array of any other type. For example,

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
   \tbf{fields}:
       \tbf{char} chars[10];
\};
\end{Verbatim}

will generate the following methods:

\begin{verbatim}
virtual char getChars(unsigned k);
virtual void setChars(unsigned k, char a);
\end{verbatim}


\subsection{Inheritance, composition}

So far we have discussed how to add fields of primitive types
(\fname{int}, \fname{double}, \fname{char}, ...) to \fname{cMessage}.
This might be sufficient for simple models, but if you have
more complex models, you'll probably need to:

\begin{itemize}
  \item set up a hierarchy of message (packet) classes, that is,
    not only subclass from \fname{cMessage} but also from your
    own message classes;
  \item use not only primitive types as fields, but also structs,
    classes or typedefs. Sometimes you'll want to use a C++ type
    present in an already existing header file, another time you'll
    want a struct or class to be generated by the message
    compiler so that you can benefit from Tkenv inspectors.
\end{itemize}

The following section describes how to do these tasks.


\textbf{Inheritance among message classes}

By default, messages are subclassed from \fname{cMessage}. However, you can
explicitly specify the base class using the \fname{extends} keyword:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket \tbf{extends} FooBase
\{
    \tbf{fields}:
        ...
\};
\end{Verbatim}

For the above example, the generated C++ code will look like:

\begin{verbatim}
class FooPacket : public FooBase { ... };
\end{verbatim}

Inheritance also works for structs and classes (see next sections
for details).



\textbf{Defining classes}

Until now we have used the \fname{message} keyword to define classes, which
implies that the base class is \fname{cMessage}, either directly or indirectly.

But as part of complex messages, you'll need structs and other classes
(rooted or not rooted in \fname{cObject}) as building blocks.
Classes can be created with the \fname{class} class keyword;
structs we'll cover in the next section.

The syntax for defining classes is almost the same as defining messages,
only the \fname{class} keyword is used instead of \fname{message}.

Slightly different code is generated for classes that are rooted in
\fname{cObject} than for those which are not.
If there is no \ttt{extends}, the generated class will not be
derived from \fname{cObject}, thus it will not have \fname{name()},
\fname{className()}, \fname{setOwner()}, etc. methods.
To create a class with those methods, you have to explicitly write
\ttt{extends cObject}.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{class} MyClass \tbf{extends} cObject
\{
    \tbf{fields}:
        ...
\};
\end{Verbatim}



\textbf{Defining plain C structs}

You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods''.
(Actually, in the C++ language a struct can have methods,
and in general it can do anything a class can.)

The syntax is similar to that of defining messages:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{struct} MyStruct
\{
    \tbf{fields}:
        \tbf{char} array[10];
        \tbf{short} version;
\};
\end{Verbatim}

However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. For the above definition, the
following code is generated:

\begin{verbatim}
// generated C++
struct MyStruct
{
    char array[10];
    short version;
};
\end{verbatim}

A struct can have primitive types or other structs are fields. It cannot
have string or class as field.

Inheritance is supported for structs:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{struct} Base
\{
    ...
\};

\tbf{struct} MyStruct extends Base
\{
    ...
\};
\end{Verbatim}

But because a struct has no member functions, there are limitations:

\begin{itemize}
   \item field initialization is not supported (it would need constructor)
   \item struct fields are not initialized to zero (it would need constructor)
   \item dynamic arrays are not supported (no place for the array allocation code)
   \item ``generation gap'' or abstract fields (see later) cannot be used,
      because they would build upon virtual functions.
\end{itemize}


\textbf{Using structs and classes as fields}

In addition to primitive types, you can also use other structs or objects
as a field. For example, if you have a struct named \fname{IPAddress},
you can write the following:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
   \tbf{fields}:
       IPAddress src;
\};
\end{Verbatim}

The \fname{IPAddress} structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via \ttt{cplusplus \{\{...\}\}} and its type announced
(see Announcing C++ types).

The generated class will contain an \fname{IPAddress} data member
(that is, \textbf{not} a pointer to an \fname{IPAddress}).
The following getter and setter methods will be generated:

\begin{verbatim}
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
\end{verbatim}


\textbf{Pointers}

Not supported yet.



\subsection{Using existing C++ types}


\textbf{Announcing C++ types}

If you want to use one of your own types (a class, struct or typedef,
declared in a C++ header) in a message definition, you have to
announce those types to the message compiler. You also have to make sure
that your header file gets included into the generated \ttt{\_m.h} file
so that the C++ compiler can compile it.

Suppose you have an \fname{IPAddress} structure, defined in an \ttt{ipaddress.h}
file:

\begin{verbatim}
// ipaddress.h
struct IPAddress {
    int byte0, byte1, byte2, byte3;
};
\end{verbatim}

To be able to use \fname{IPAddress} in a message definition, the message
file (say \ttt{foopacket.msg}) should contain the following lines:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{cplusplus} \{\{
#include "ipaddress.h"
\}\};

\tbf{struct} IPAddress;
\end{Verbatim}

The effect of the first three lines is simply that the \fname{\#include}
statement will be copied into the generated \ttt{foopacket\_m.h}
file to let the C++ compiler know about the \fname{IPAddress} class.
The message compiler itself will not try to make sense of the
text in the body of the \ttt{cplusplus \{\{ ... \}\}} directive.

The next line, \ttt{struct IPAddress}, tells the message compiler that
\fname{IPAddress} is a C++ struct. This information will (among others)
affect the generated code.

Classes can be announced using the \fname{class} keyword:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{class} cSubQueue;
\end{Verbatim}

The above syntax assumes that the class is derived from \fname{cObject}
either directly or indirectly. If it is not, the \fname{noncobject}
keyword should be used:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{class} \tbf{noncobject} IPAddress;
\end{Verbatim}

The distinction between classes derived and not derived from \fname{cObject}
is important because the generated code differs at places.
The generated code is set up so that if you incidentally
forget the \fname{noncobject} keyword (and so you mislead the
message compiler into thinking that your class is rooted in
\fname{cObject} when in fact it is not), you'll get a C++ compiler
error in the generated header file.


\subsection{Customizing the generated class}


\textbf{The Generation Gap pattern}

Sometimes you need the generated code to something
more or do something differently than the version generated
by the message compiler.
For example, when setting a integer field named \fname{payloadLength},
you might also need to adjust the packet length. That is,
the following default (generated) version of the
\fname{setPayloadLength()} method is not suitable:

\begin{verbatim}
void FooPacket::setPayloadLength(int payloadLength)
{
    this->payloadLength = payloadLength;
}
\end{verbatim}

Instead, it should look something like this:

\begin{verbatim}
void FooPacket::setPayloadLength(int payloadLength)
{
    int diff = payloadLength - this->payloadLength;
    this->payloadLength = payloadLength;
    setLength( length() + diff );
}
\end{verbatim}

According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the \textit{Generation Gap} design pattern.
It is enabled with the following syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
   \tbf{properties}:
       customize = true;
   \tbf{fields}:
       \tbf{int} payloadLength;
\};
\end{Verbatim}

The \fname{properties} section within the message declaration contains
meta-info that affects how generated code will look like.
The customize property enables the use of the Generation Gap
pattern.

If you process the above code with the message compiler,
the generated code will contain a \fname{FooPacket\_Base} class
instead of \fname{FooPacket}. The idea is that you have
to subclass from \fname{FooPacket\_Base} to produce
\fname{FooPacket}, while doing your customizations
by redefining the necessary methods.

\begin{verbatim}
class FooPacket_Base : public cMessage
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
\end{verbatim}

There is a minimum amount of code you have to write
for \fname{FooPacket}, because not everything can be
pre-generated as part of \fname{FooPacket\_Base}, e.g.
constructors cannot be inherited. This minimum
code is the following (you'll find it the generated C++ header
too, as a comment):

\begin{verbatim}
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual cObject *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
\end{verbatim}

So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

\begin{verbatim}
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy contructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
\end{verbatim}



\textbf{Abstract fields}

The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

For example, this is the situation when you want to store a bitfield
in a single \fname{int} or \fname{short}, and still you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

You can declare any field to be abstract with the following syntax:

%
% FIXME TBD: is customize=true really needed?
%
\begin{Verbatim}[commandchars=\\\{\}]
\tbf{message} FooPacket
\{
   \tbf{properties}:
       customize = true;
   \tbf{fields}:
       \tbf{abstract} \tbf{bool} urgentBit;
\};
\end{Verbatim}

For an \fname{abstract} field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

\begin{verbatim}
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
\end{verbatim}


Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.


\section{Summary}

This section attempts to summarize the possibilities.

You can generate:

\begin{itemize}
  \item  classes rooted in \cclass{cObject}
  \item  messages (default base class is \cclass{cMessage})
  \item  classes not rooted in \cclass{cObject}
  \item  plain C structs
\end{itemize}

The following data types are supported for fields:

\begin{itemize}
  \item  primitive types: \ttt{bool}, \ttt{char}, \ttt{short},
    \ttt{int}, \ttt{long}, \ttt{unsigned short}, \ttt{unsigned int},
    \ttt{unsigned long}, \ttt{double}
  \item  \ttt{string}, a dynamically allocated string, presented as \ttt{const char *}
  \item  fixed-size arrays of the above types
  \item  structs, classes (both rooted and not rooted in \cclass{cObject}),
    declared with the message syntax or externally in C++ code
  \item  variable-sized arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
\end{itemize}

Further features:

\begin{itemize}
  \item  fields initialize to zero (except struct members)
  \item  fields initializers can be specified (except struct members)
  \item  assigning \ttt{enum}s to variables of integral types.
  \item  inheritance
  \item  customizing the generated class via subclassing (\textit{Generation Gap} pattern)
  \item  abstract fields (for nonstandard storage and calculated fields)
\end{itemize}

Generated code (all generated methods are \ttt{virtual}, although
this is not written out in the following table):

\begin{longtable}{|p{4cm}|p{10cm}|}
\hline
\tabheadcol

\tbf{Field declaration}
    &
\tbf{Generated code}
\\\hline

primitive types
\begin{verbatim}
double field;
\end{verbatim}
     &
\begin{verbatim}
double getField();
void setField(double d);
\end{verbatim}
\\\hline

string type
\begin{verbatim}
string field;
\end{verbatim}
     &
\begin{verbatim}
const char *getField();
void setField(const char *);
\end{verbatim}
\\\hline

fixed-size arrays
\begin{verbatim}
double field[4];
\end{verbatim}
     &
\begin{verbatim}
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
\end{verbatim}

\\\hline

dynamic arrays
\begin{verbatim}
double field[];
\end{verbatim}
     &
\begin{verbatim}
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
\end{verbatim}
\\\hline

customized class
\begin{verbatim}
class Foo {
  properties:
    customize=true;
\end{verbatim}
     &
\begin{verbatim}
class Foo_Base { ... };
\end{verbatim}
and you have to write:
\begin{verbatim}
class Foo : public Foo_Base {
   ...
};
\end{verbatim}
\\\hline

abstract fields
\begin{verbatim}
abstract double field;
\end{verbatim}
     &
\begin{verbatim}
double getField() = 0;
void setField(double d) = 0;
\end{verbatim}
\\\hline

\end{longtable}


\section{Example}

Several of the example simulations (Token Ring, Dyna2, Hypercube)
use message definitions. For example, in Dyna2 you'll find this:

\begin{itemize}
 \item \ttt{dynapacket.msg} defines \fname{DynaPacket} and \fname{DynaDataPacket};
 \item \ttt{dynapacket\_m.h} and \ttt{dynapacket\_m.cc} are produced
   by the message subclassing compiler from it, and they contain
   the generated \fname{DynaPacket} and \fname{DynaDataPacke}t
   C++ classes (plus code for Tkenv inspectors);
 \item other model files (\ttt{client.cc}, \ttt{server.cc}, ...)
   use the generated message classes
\end{itemize}


