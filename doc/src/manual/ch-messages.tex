\chapter{Messages}
\label{cha:messages}

\section{Messages and Packets}

\subsection{The cMessage and cPacket Classes}

Messages are a central concept in {\opp}. In the model, message objects
represent events, packets, commands, jobs, customers or other kinds of
entities, depending on the model domain.

Messages are represented with the \cclass{cMessage} class and its subclass
\cclass{cPacket}. \cclass{cPacket} is used for network packets (frames,
datagrams, transport packets, etc.) in a communication network, and
\cclass{cMessage} is used for everything else. Users are free to subclass
both \cclass{cMessage} and \cclass{cPacket} to create new types and to
add data.

\cclass{cMessage} has the following fields. Some are used by
the simulation kernel, others are provided for the convenience
of the simulation programmer:

\begin{itemize}
  \item The \textit{name} field is a string (\ttt{const char *}),
    which can be freely used by the simulation programmer. The message
    name gets displayed at many places in the graphical runtime interface,
    so it is generally useful to choose a descriptive name. Message name
    is inherited from \cclass{cOwnedObject} (see section
    \ref{sec:ch-sim-lib:cobject}).
  \item \textit{Message kind} is an integer field.
    Some negative values are reserved by the simulation library, but zero
    and positive values can be freely used in the model for any purpose.
    Message kind is typically used to carry a value that conveys the
    role, type, category or identity of the message.
  \item The \textit{scheduling priority} field is used by the simulation
    kernel to determine the delivery order of messages that have the same
    arrival time values. This field is rarely used in practice.
  \item The \textit{send time}, \textit{arrival time}, \textit{source module},
    \textit{source gate}, \textit{destination module}, \textit{destination gate}
    fields store information about the message's last sending or scheduling,
    and should not be modified from the model. These fields are primarily
    used internally by the simulation kernel while the message is in the
    future events set (FES)\index{FES}, but the information is still in
    the message object when the message gets delivered to a module.
  \item \textit{Time stamp} (not to be confused with \textit{arrival time})
    is a utility field, which the programmer can freely use for any purpose.
    The time stamp is not examined or changed by the simulation kernel at all.
  \item The \textit{parameter list}, \textit{control info} and
    \textit{context pointer} fields make some simulation tasks easier
    to program, and they will be discussed later.
\end{itemize}

The \cclass{cPacket} class extends \cclass{cMessage} with fields that are
useful for representing network packets:

\begin{itemize}
  \item The \textit{packet length} field represents the length of the packet
    in bits. It is used by the simulation kernel to compute the transmission
    duration when a packet travels through a connection that has an assigned
    data rate, and also for error modeling on channels with a nonzero
    bit error rate.
  \item The \textit{encapsulated packet} field helps modeling protocol layers
    by supporting the concept of encapsulation and decapsulation.
  \item The \textit{bit error flag} field carries the result of error
    modelling after the packet is sent through a channel that has a nonzero
    packet error rate (PER) or bit error rate (BER). It is up to the receiver
    to examine this flag after having received the packet, and to act upon it.
  \item The \textit{duration} field carries the transmission duration after
    the packet was sent through a channel with a data rate.
  \item The \textit{is-reception-start} flag tells whether this packet
    represents the start or the end of the reception after the packet travelled
    through a channel with a data rate. This flag is controlled by the
    \textit{deliver-on-reception-start} flag of the receiving gate.
\end{itemize}


\subsubsection{Basic Usage}


The \cclass{cMessage} constructor accepts several arguments.
Most commonly, you would create a message using an \textit{object name}
(a \ttt{const char *} string) and a \textit{message kind} (\ttt{int}):

\begin{cpp}
cMessage *msg = new cMessage("timer", kind);
\end{cpp}

Both arguments are optional and initialize to the null string (\ttt{""})
and 0, so the following statements are also valid:

\begin{cpp}
cMessage *msg = new cMessage();
cMessage *msg = new cMessage("timer");
\end{cpp}

Descriptive message names can be very useful when tracing, debugging or
demonstrating the simulation, so it is recommended to use them.

Message kind is usually initialized with a symbolic constant
(e.g. an \textit{enum} value) which signals what the message object
represents. Only positive values and zero can be used --
negative values are reserved for use by the simulation kernel.

The \cclass{cPacket} constructor accepts a further \textit{bit length} argument.

\index{message!data members}

Once a message has been created, its data members can be changed by the following functions:

\begin{cpp}
msg->setKind( kind );
msg->setBitLength( length );
msg->setByteLength( lengthInBytes );
msg->setSchedulingPriority( priority );
msg->setBitError( err );
msg->setTimestamp();
msg->setTimestamp( simtime );
\end{cpp}

With these functions the user can set the message
kind\index{message!kind}, the message length\index{message@length},
the priority\index{message!priority}, the error
flag\index{message!error flag} and the time stamp\index{message!time
  stamp}. The \ffunc{setTimeStamp()} function without any argument
sets the time stamp to the current simulation time.
\ffunc{setByteLength()} sets the same field as \ffunc{setBitLength()},
only the parameters gets internally multiplied by 8.

The values can be obtained by the following functions:

\begin{cpp}
int k       = msg->getKind();
int p       = msg->getSchedulingPriority();
int l       = msg->getBitLength();
int lb      = msg->getByteLength();
bool b      = msg->hasBitError();
simtime_t t = msg->getTimestamp();
\end{cpp}

\ffunc{getBitLength()} and \ffunc{getByteLength()} both read the same
field, but the latter divides by 8 and rounds up the result.


\subsubsection{Duplicating Messages}
\index{message!duplication}

It is often necessary to duplicate a message or a packet, for example,
to send one and keep a copy. Duplication can be done in the same way as
for any other {\opp} object:

\begin{cpp}
cMessage *copy = msg->dup();
\end{cpp}

The resulting message (or packet) will be an exact copy of the original,
including message parameters and encapsulated messages.
  \footnote{Note, however, that the simulation library may delay the
  duplication of the encapsulated message until it is really needed;
  see section \ref{ch:messages:reference-counting}.}


\subsection{Self-Messages}

\subsubsection{Using a Message as Self-Message}

Messages are often used to represent events internal to a module,
such as a periodically firing timer on expiry of a timeout.
A message is termed \textit{self-message} when it is used
in such a scenario -- otherwise self-messages are normal messages,
of class \cclass{cMessage} or a class derived from it.

When a message is delivered to a module by the simulation kernel,
you can call the \ffunc{isSelfMessage()} method to determine if it is
a self-message; it other words, if it was scheduled with
\ffunc{scheduleAt()} or was sent with one of the
\ffunc{send...()} methods. The \ffunc{isScheduled()} method
returns true if the message is currently scheduled. A scheduled
message can also be cancelled (\ffunc{cancelEvent()}).

\begin{cpp}
bool isSelfMessage();
bool isScheduled();
\end{cpp}

The following methods return the time of creating and scheduling the message
as well as its arrival time. While the message is scheduled, arrival
time is the time it will be delivered to the module.

\begin{cpp}
simtime_t getCreationTime();
simtime_t getSendingTime();
simtime_t getArrivalTime();
\end{cpp}

\subsubsection{Context Pointer}

\cclass{cMessage} contains a \ttt{void*} pointer which is
set/returned by the \ffunc{setContextPointer()} and
\ffunc{getContextPointer()} functions:

\begin{cpp}
void *context =...;
msg->setContextPointer(context);
void *context2 = msg->getContextPointer();
\end{cpp}


It can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

Intended purpose: a module which schedules several self-messages
(timers) will need to identify a self-message when it arrives back to
the module, ie. the module will have to determine which timer went off
and what to do then. The context pointer\index{context pointer} can be
made to point at a data structure kept by the module which can carry
enough ``context'' information about the event.



\subsection{Modelling Packets}

\subsubsection{Arrival Gate and Time}

The following methods can tell where the message came from and
where it arrived (or will arrive if it is currently scheduled or under way.)

\begin{cpp}
int getSenderModuleId();
int getSenderGateId();
int getArrivalModuleId();
int getArrivalGateId();
\end{cpp}

The following methods are just convenience functions which build
on the ones above.

\begin{cpp}
cModule *getSenderModule();
cGate *getSenderGate();
cGate *getArrivalGate();
\end{cpp}

And there are further convenience functions to tell whether
the message arrived on a specific gate given with id or
name+index.

\begin{cpp}
bool arrivedOn(int id);
bool arrivedOn(const char *gname, int gindex=0);
\end{cpp}

The following methods return message creation time and the last sending
and arrival times.

\begin{cpp}
simtime_t getCreationTime();
simtime_t getSendingTime();
simtime_t getArrivalTime();
\end{cpp}

\subsubsection{Control Info}

One of the main application areas of {\opp} is the simulation of
telecommunication networks. Here, protocol layers are usually
implemented as modules which exchange packets. Packets themselves
are represented by messages subclassed from \cclass{cMessage}.

However, communication between protocol layers requires sending
additional information to be attached to packets. For example,
a TCP implementation sending down a TCP packet to IP will want
to specify the destination IP address and possibly
other parameters. When IP passes up a packet to TCP after
decapsulation from the IP header, it'll want to let TCP know
at least the source IP address.

This additional information is represented by \textit{control info}
objects in {\opp}. Control info objects have to be subclassed from
\cclass{cObject} (a small footprint base class with
no data members), and attached to the messages representing
packets. \cclass{cMessage} has the following methods for this
purpose:

\begin{cpp}
void setControlInfo(cObject *controlInfo);
cObject *getControlInfo();
cObject *removeControlInfo();
\end{cpp}

When a "command" is associated with the message sending (such as
TCP OPEN, SEND, CLOSE, etc), the message kind field (\ttt{getKind()},
\ttt{setKind()} methods of \ttt{cMessage}) should carry the command code.
When the command doesn't involve a data packet (e.g.
TCP CLOSE command), a dummy packet (empty \ttt{cMessage}) can be sent.



\subsubsection{Identifying the Protocol}

In {\opp} protocol models, the protocol type is usually represented
in the message subclass. For example, instances of class
\ttt{IPv6Datagram} represent IPv6 datagrams and \ttt{EthernetFrame}
represents Ethernet frames) and/or in the message kind value.
The PDU type is usually represented as a field inside the message class.

The C++ \ttt{dynamic\_cast} operator can be used to determine
if a message object is of a specific protocol.

\begin{cpp}
cMessage *msg = receive();
if (dynamic_cast<IPv6Datagram *>(msg) != NULL)
{
    IPv6Datagram *datagram = (IPv6Datagram *)msg;
    ...
}
\end{cpp}


\subsection{Encapsulation}

\subsubsection{Encapsulating Packets}

It is often necessary to encapsulate a packet\index{packet!encapsulation}
into another when you are modeling layered protocols of computer networks.

The \ffunc{encapsulate()} function encapsulates a packet
into another one. The length of the packet will grow by the length of
the encapsulated packet. An exception: when the encapsulating (outer)
packet has zero length, {\opp} assumes it is not a real packet but
some out-of-band signal, so its length is left at zero.

\begin{cpp}
cPacket *data = new cPacket("data");
data->setByteLength(1024);

TCPSegment *tcpseg = new TCPSegment("tcp"); // subclassed from cPacket
tcpseg->setByteLength(24);

tcpseg->encapsulate(data);
ev << tcpseg->getByteLength() << endl; // --> 1024+24 = 1028
\end{cpp}

A packet can only hold one encapsulated packet at a time, the
second \ffunc{encapsulate()} call will result in an error. It is also
an error if the packet to be encapsulated is not owned by the
module.

You can get back the encapsulated packet by calling \ffunc{decapsulate()}:

\begin{cpp}
cPacket *userdata = tcpseg->decapsulate();
\end{cpp}

\ffunc{decapsulate()} will decrease the length of the packet accordingly,
except if it was zero. If the length would become negative, an
error occurs.

The \ffunc{getEncapsulatedMsg()} function returns a pointer to the encapsulated
packet, or \ttt{NULL} if no packet is encapsulated.


\subsubsection{Reference Counting}
\label{ch:messages:reference-counting}

Since the 3.2 release, {\opp} implements reference counting of
encapsulated packets, meaning that if you \ffunc{dup()} a packet
that contains an encapsulated packet, then the encapsulated packet will
not be duplicated, only a reference count incremented. Duplication of
the encapsulated packet is deferred until \ffunc{decapsulate()}
actually gets called. If the outer packet gets deleted without its
\ffunc{decapsulate()} method ever being called, then the reference
count of the encapsulated packet simply gets decremented. The
encapsulated packet is deleted when its reference count reaches
zero.

Reference counting can significantly improve performance, especially
in LAN and wireless scenarios. For example, in the simulation of a
broadcast LAN or WLAN, the IP, TCP and higher layer packets won't
get duplicated (and then discarded without being used) if the
MAC address doesn't match in the first place.

The reference counting mechanism works transparently. However, there
is one implication: \tbf{one must not change anything in a packet
that is encapsulated into another!} That is,
\ffunc{getEncapsulatedMsg()} should be viewed as if it returned a
pointer to a read-only object (it returns a \ttt{const} pointer
indeed), for quite obvious reasons: the encapsulated packet may be
shared between several packets, and any change would affect those
other packets as well.


\subsubsection{Encapsulating Several Packets}

The \cclass{cPacket} class does not directly support encapsulating more
than one packet, but you can subclass \cclass{cPacket} or \cclass{cMessage}
to add the necessary functionality. (It is recommended that you
use the message definition syntax \ref{ch:messages:message-definitions}
and customized messages \ref{sec:ch-messages:customizing-generated-class}
to be described later on in this chapter -- it can spare you some work.)

You can store the messages in a fixed-size or a dynamically allocated
array, or you can use STL classes like \ttt{std::vector} or \ttt{std::list}.
There is one additional ``trick'' that you might not expect: your message
class has to \textbf{take ownership} of the inserted messages, and
\textbf{release} them when they are removed from the message. These are
done via the \ffunc{take()} and \ffunc{drop()} methods. Let us see
an example which assumes you have added to the class an \ttt{std::list} member
called \ttt{messages} that stores message pointers:

\begin{cpp}
void MessageBundleMessage::insertMessage(cMessage *msg)
{
    take(msg);  // take ownership
    messages.push_back(msg);  // store pointer
}

void MessageBundleMessage::removeMessage(cMessage *msg)
{
    messages.remove(msg);  // remove pointer
    drop(msg);  // release ownership
}
\end{cpp}

You will also have to provide an \ffunc{operator=()} method to
make sure your message objects can be copied and duplicated
properly -- this is something often needed in simulations
(think of broadcasts and retransmissions!). Section
\ref{sec:ch-sim-lib:deriving-new-classes} contains more info
about the things you need to take care of when deriving new classes.



\subsection{Attaching Parameters and Objects}

If you want to add parameters or objects to a message, the preferred
way to do that is via message definitions, described in chapter
\ref{ch:messages:message-definitions}.


\subsubsection{Attaching Objects}

The \cclass{cMessage} class has an internal \cclass{cArray} object which can
carry objects\index{message!attaching objects}. Only objects
that are derived from \cclass{cOwnedObject} (most {\opp} classes are so) can be attached.
The \ffunc{addObject()}, \ffunc{getObject()}, \ffunc{hasObject()},
\ffunc{removeObject()} methods use the object name
as the key to the array. An example:

\begin{cpp}
cLongHistogram *pklenDistr = new cLongHistogram("pklenDistr");
msg->addObject(pklenDistr);
...
if (msg->hasObject("pklenDistr"))
{
   cLongHistogram *pklenDistr =
       (cLongHistogram *) msg->getObject("pklenDistr");
   ...
}
\end{cpp}

You should take care that names of the attached objects don't
clash with each other or with \cclass{cMsgPar} parameter names
(see next section).
If you do not attach anything to the message and do not call the
\ffunc{getParList()} function, the internal \cclass{cArray} object
will not be created. This saves both storage and execution time.

You can attach non-object types (or non-\cclass{cOwnedObject} objects) to
the message\index{message!attaching non-object types} by using
\cclass{cMsgPar}'s \ttt{void*} pointer 'P') type (see later in the description
of \cclass{cMsgPar}). An example:

\begin{cpp}
struct conn_t *conn = new conn_t; // conn_t is a C struct
msg->addPar("conn") = (void *) conn;
msg->par("conn").configPointer(NULL,NULL,sizeof(struct conn_t));
\end{cpp}




\subsubsection{Attaching Parameters}

The preferred way of extending messages with new data fields is to use
message definitions (see section \ref{ch:messages:message-definitions}).

The old, deprecated way of adding new fields to messages is via
attaching \cclass{cMsgPar} objects.
There are several downsides of this approach, the worst being
large memory and execution time overhead. \cclass{cMsgPar}'s are
heavy-weight and fairly complex objects themselves.
It has been reported that using \cclass{cMsgPar} message parameters
might account for a large part of execution time, sometimes as much as 80\%.
Using \cclass{cMsgPar}s is also error-prone because \cclass{cMsgPar} objects
have to be added dynamically and individually to each message object.
In contrast, subclassing benefits from static type checking:
if you mistype the name of a field in the C++ code, already the compiler
can detect the mistake.

If you still need \cclass{cMsgPar}s for some reason, here is a short summary.
At the sender side you can add a new named parameter to the message
with the \ffunc{addPar()} member function, then set its value with
one of the methods \ffunc{setBoolValue()}, \ffunc{setLongValue()},
\ffunc{setStringValue()}, \ffunc{setDoubleValue()}, \ffunc{setPointerValue()},
\ffunc{setObjectValue()}, and \ffunc{setXMLValue()}. There are also overloaded
assignment operators for the corresponding C/C++ types.

At the receiver side, you can look up the parameter object on the message
by name and obtain a reference to it with the \ffunc{par()} member function.
\ffunc{hasPar()} can be used to check first whether the message object has a parameter
object with the given name. Then the value can be read with the methods
\ffunc{boolValue()}, \ffunc{longValue()}, \ffunc{stringValue()},
\ffunc{doubleValue()}, \ffunc{pointerValue()}, \ffunc{objectValue()},
\ffunc{xmlValue()}, or by using the provided overloaded type cast operators.

Example usage:

\begin{cpp}
msg->addPar("destAddr");
msg->par("destAddr").setLongValue(168);
...
long destAddr = msg->par("destAddr").longValue();
\end{cpp}

Or, using overloaded operators:

\begin{cpp}
msg->addPar("destAddr");
msg->par("destAddr") = 168;
...
long destAddr = msg->par("destAddr");
\end{cpp}


\section{Message Definitions}
\label{ch:messages:message-definitions}

\subsection{Introduction}

In practice, you will need to add various fields to \cclass{cMessage} to
make it useful. For example, if you are modelling packets in communication
networks, you need to have a way to store protocol header fields in message
objects. Since the simulation library is written in C++, the natural way
of extending \cclass{cMessage} is via subclassing it.
However, because for each field you need to write at least
three things (a private data member, a getter and a setter method),
and the resulting class has to integrate with the simulation framework,
writing the necessary C++ code can be a tedious and time-consuming task.

{\opp} offers a more convenient way called \textit{message definitions}.
Message definitions provide a very compact syntax to describe
message contents. C++ code is automatically generated from message
definitions, saving you a lot of typing.

A common source of complaint about code generators in general is
lost flexibility: if you have a different idea how the generated
code should look like, there is little you can do about it.
In {\opp}, however, there is nothing to worry about: you can
customize the generated class to any extent you like.
Even if you decide to heavily customize the generated class,
message definitions still save you a great deal of manual work.

The subclassing approach for adding message parameters was originally
suggested by Nimrod Mesika.


\subsubsection{The First Message Class}

Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a \ttt{mypacket.msg} file with the following contents:

%% FIXME TODO show the "packet" keyword too!

\begin{msg}
message MyPacket
{
     int srcAddress;
     int destAddress;
     int hops = 32;
};
\end{msg}

The task of the \textit{message subclassing compiler} is to generate C++ classes
you can use from your models as well as ``reflection'' classes that allow
Tkenv to inspect these data structures.

If you process \ttt{mypacket.msg} with the message subclassing compiler, it will
create the following files for you: \ttt{mypacket\_m.h} and \ttt{mypacket\_m.cc}.
\ttt{mypacket\_m.h} contains the declaration of the \ttt{MyPacket} C++ class, and
it should be included into your C++ sources where you need to handle
\ttt{MyPacket} objects.

The generated \ttt{mypacket\_m.h} will contain the following class declaration:

\begin{cpp}
class MyPacket : public cMessage {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
\end{cpp}

So in your C++ file, you could use the \ttt{MyPacket} class like this:

\begin{cpp}
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt->setSrcAddress( localAddr );
...
\end{cpp}

The \ttt{mypacket\_m.cc} file contains implementation of the generated \ttt{MyPacket}
class, as well as ``reflection'' code that allows you to inspect these data
structures in the Tkenv GUI. The \ttt{mypacket\_m.cc} file should be compiled and
linked into your simulation. (If you use the \fprog{opp\_makemake} tool
to generate your makefiles, the latter will be automatically taken care of.)


\subsubsection{What Is Message Subclassing \textit{Not?}}

There can be some confusion about the purpose and
concept of message definitions, so it might be a good idea
to deal with them right here.

It is \textit{\textbf{not:}}

\begin{itemize}
  \item{\textit{... an attempt to reproduce the functionality of C++ with another
     syntax.} Do not look for complex C++ types, templates, conditional compilation, etc.
     Also, it defines \textit{data} only (or rather: an interface to access
     data) -- not any kind of active behaviour.}
  \item{\textit{... a generic class generator.} This is meant for defining message
     contents, and data structure you put in messages.
     Defining methods is not supported on purpose.
     Also, while you can probably (ab)use the syntax to
     generate classes and structs used internally in simple modules,
     this is probably not a good idea.}
\end{itemize}

The goal is to define the \textit{interface} (getter/setter methods) of messages
rather than their implementations in C++. A simple and straightforward
implementation of fields is provided -- if you'd like a different internal
representation for some field, you can have it by customizing the class.

There are questions you might ask:

\begin{itemize}
  \item{\textit{Why doesn't it support \ttt{std::vector} and other STL classes?}
     Well, it does. Message definitions focus on the interface
     (getter/setter methods) of the classes, optionally leaving the implementation
     to you -- so you can implement fields (dynamic array fields)
     using \ttt{std::vector}.
     (This aligns with the idea behind STL -- it was designed to be
     \textit{nuts and bolts} for C++ programs).}
  \item{\textit{Why does it support C++ data types and not octets,
     bytes, bits, etc..?}
     That would restrict the scope of message definitions to networking,
     and {\opp} wants to support other application areas as well.
     Furthermore, the set of necessary concepts to be supported is
     probably not bounded, there would always be new data types to
     be adopted.}
  \item{\textit{Why no embedded classes?} Good question. As it does not
     conflict with the above principles, it might be added someday.}
\end{itemize}



The following sections describe the message syntax and features in detail.


\subsection{Declaring Enums}

An enum (declared with the \fkeyword{enum} keyword) generates a normal C++
enum, plus creates an object which stores text representations of the
constants. The latter makes it possible to display symbolic names in Tkenv.
An example:

\begin{msg}
enum ProtocolTypes
{
   IP = 1;
   TCP = 2;
};
\end{msg}

Enum values need to be unique.


% It is possible to ``extend'' an enum with new values.
%
% begin{msg}
% // add new values to ProtocolTypes
% enum MoreProtocolTypes extends ProtocolTypes
% {
%   CLNP = 3;
%   TP4 = 4;
% };
% end{msg}

\subsection{Message Declarations}

\subsubsection{Basic Use}

You can describe messages with the following syntax:

\begin{msg}
message FooPacket
{
    int sourceAddress;
    int destAddress;
    bool hasPayload;
};
\end{msg}

Processing this description with the message compiler will produce
a C++ header file with a generated class, \ttt{FooPacket}.
\ttt{FooPacket} will be a subclass of \cclass{cMessage}.

For each field in the above description, the generated class will have
a protected data member, a getter and a setter method. The names of the
methods will begin with \ttt{get} and \ttt{set}, followed by the field name
with its first letter converted to uppercase.\footnote{
  To generate getter methods without the \ttt{get} verb, add the
  \ttt{@omitGetVerb(true)} property to the message. It is not recommended
  to use \ttt{@omitGetVerb(true)} though, because it goes against the
  accepted naming convention in {\opp} and models.}
Thus, \ttt{FooPacket} will contain the following methods:

\begin{cpp}
virtual int getSourceAddress() const;
virtual void setSourceAddress(int sourceAddress);

virtual int getDestAddress() const;
virtual void setDestAddress(int destAddress);

virtual bool getHasPayload() const;
virtual void setHasPayload(bool hasPayload);
\end{cpp}

Note that the methods are all declared \fkeyword{virtual} to give you the possibility
of overriding them in subclasses.

Two constructors will be generated: one that optionally accepts object name and
(for \cclass{cMessage} subclasses) message kind, and a copy constructor:

\begin{cpp}
FooPacket(const char *name=NULL, int kind=0);
FooPacket(const FooPacket& other);
\end{cpp}

Appropriate assignment operator (\ffunc{operator=()}) and \ffunc{dup()} methods will
also be generated.

Data types for fields are not limited to \fkeyword{int} and
\fkeyword{bool}. You can use the following primitive types (i.e. primitive
types as defined in the C++ language):

\begin{itemize}
   \item \fkeyword{bool}
   \item \fkeyword{char}, \fkeyword{unsigned char}
   \item \fkeyword{short}, \fkeyword{unsigned short}
   \item \fkeyword{int}, \fkeyword{unsigned int}
   \item \fkeyword{long}, \fkeyword{unsigned long}
   \item \fkeyword{double}
\end{itemize}

Field values are initialized to zero.


\subsubsection{Initial Values}

You can initialize field values with the following syntax:

\begin{msg}
message FooPacket
{
    int sourceAddress = 0;
    int destAddress = 0;
    bool hasPayload = false;
};
\end{msg}

Initialization code will be placed in the constructor of the generated class.


\subsubsection{Enum Declarations}

You can declare that an \fkeyword{int} (or other integral type) field
takes values from an enum. The message compiler can than generate code
that allows Tkenv display the symbolic value of the field.

Example:

\begin{msg}
message FooPacket
{
    int payloadType enum(PayloadTypes);
};
\end{msg}

The enum has to be declared separately in the message file.


\subsubsection{Fixed-Size Arrays}

You can specify fixed size arrays:

\begin{msg}
message FooPacket
{
    long route[4];
};
\end{msg}

The generated getter and setter methods will have an extra \ttt{k} argument,
the array index:

\begin{cpp}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
\end{cpp}

If you call the methods with an index that is out of bounds, an exception
will be thrown.


\subsubsection{Dynamic Arrays}

If the array size is not known in advance, you can declare the field
to be a dynamic array:

\begin{msg}
message FooPacket
{
    long route[];
};
\end{msg}

In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

\begin{cpp}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
\end{cpp}

The \ffunc{set...ArraySize()} method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

The default array size is zero. This means that you need to call the
\ffunc{set...ArraySize()} before you can start filling array elements.


\subsubsection{String Members}

You can declare string-valued fields with the following syntax:

\begin{msg}
message FooPacket
{
    string hostName;
};
\end{msg}

The generated getter and setter methods will return and accept \ttt{const char*}
pointers:

\begin{cpp}
virtual const char *getHostName() const;
virtual void setHostName(const char *hostName);
\end{cpp}

The generated object will have its own copy of the string.

Note that a string member is different from a character array,
which is treated as an array of any other type. For example,

\begin{msg}
message FooPacket
{
    char chars[10];
};
\end{msg}

will generate the following methods:

\begin{cpp}
virtual char getChars(unsigned k);
virtual void setChars(unsigned k, char a);
\end{cpp}


\subsection{Inheritance, Composition}

So far we have discussed how to add fields of primitive types
(\fkeyword{int}, \fkeyword{double}, \fkeyword{char}, ...) to
\cclass{cMessage}. This might be sufficient for simple models, but if you
have more complex models, you will probably need to:

\begin{itemize}
  \item set up a hierarchy of message (packet) classes, that is,
    not only subclass from \cclass{cMessage} but also from your
    own message classes;
  \item use not only primitive types as fields, but also structs,
    classes or typedefs. Sometimes you'll want to use a C++ type
    present in an already existing header file, another time you will
    want a struct or class to be generated by the message
    compiler so that you can benefit from Tkenv inspectors.
\end{itemize}

The following section describes how to do this.


\subsubsection{Inheritance Among Message Classes}

By default, messages are subclassed from \cclass{cMessage}. However, you can
explicitly specify the base class using the \fkeyword{extends} keyword:

\begin{msg}
message FooPacket extends FooBase
{
    ...
};
\end{msg}

For the example above, the generated C++ code will look like:

\begin{cpp}
class FooPacket : public FooBase { ... };
\end{cpp}

Inheritance also works for structs and classes (see next sections
for details).



\subsubsection{Defining Classes}

Until now we have used the \fkeyword{message} keyword to define classes, which
implies that the base class is \cclass{cMessage}, either directly or indirectly.

But as part of complex messages, you will need structs and other classes
(rooted or not rooted in \cclass{cOwnedObject}) as building blocks.
Classes can be created with the \fkeyword{class} class keyword;
structs we'll cover in the next section.

The syntax for defining classes is almost the same as defining messages,
only the \fkeyword{class} keyword is used instead of \fkeyword{message}.

Slightly different code is generated for classes that are rooted in
\cclass{cOwnedObject} than for those which are not.
If there is no \ttt{extends}, the generated class will not be
derived from \cclass{cOwnedObject}, thus it will not have \ffunc{getName()},
\ffunc{getClassName()}, etc. methods.
To create a class with those methods, you have to explicitly write
\ttt{extends cOwnedObject}.

\begin{msg}
class MyClass extends cOwnedObject
{
    ...
};
\end{msg}



\subsubsection{Defining Plain C Structs}

You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods''.
(Actually, in the C++ a struct can have methods,
and in general it can do anything a class can.)

The syntax is similar to that of defining messages:

\begin{msg}
struct MyStruct
{
    char array[10];
    short version;
};
\end{msg}

However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. For the definition above, the
following code is generated:

\begin{cpp}
// generated C++
struct MyStruct
{
    char array[10];
    short version;
};
\end{cpp}

A struct can have primitive types or other structs as fields. It cannot
have string or class as field.

Inheritance is supported for structs:

\begin{msg}
struct Base
{
    ...
};

struct MyStruct extends Base
{
    ...
};
\end{msg}

But because a struct has no member functions, there are limitations:

\begin{itemize}
   \item dynamic arrays are not supported (no place for the array allocation code)
   \item ``generation gap'' or abstract fields (see later) cannot be used,
      because they would build upon virtual functions.
\end{itemize}


\subsubsection{Using Structs and Classes as Fields}

In addition to primitive types, you can also use other structs or objects
as a field. For example, if you have a struct named \ttt{IPAddress},
you can write the following:

\begin{msg}
message FooPacket
{
    IPAddress src;
};
\end{msg}

The \ttt{IPAddress} structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via \ttt{cplusplus \{\{...\}\}} and its type announced
(see Announcing C++ types).

The generated class will contain an \ttt{IPAddress} data member
(that is, \textbf{not} a pointer to an \ttt{IPAddress}).
The following getter and setter methods will be generated:

\begin{cpp}
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
\end{cpp}


\subsubsection{Pointers}

Not supported yet.



\subsection{Using Existing C++ Types}


\subsubsection{Announcing C++ Types}

If you want to use one of your own types (a class, struct or typedef,
declared in a C++ header) in a message definition, you have to
announce those types to the message compiler. You also have to make sure
that your header file gets included into the generated \ttt{\_m.h} file
so that the C++ compiler can compile it.

Suppose you have an \ttt{IPAddress} structure, defined in an \ttt{ipaddress.h}
file:

\begin{cpp}
// ipaddress.h
struct IPAddress {
    int byte0, byte1, byte2, byte3;
};
\end{cpp}

To be able to use \ttt{IPAddress} in a message definition, the message
file (say \ttt{foopacket.msg}) should contain the following lines:

\begin{msg}
cplusplus {{
#include "ipaddress.h"
}};

struct IPAddress;
\end{msg}

The effect of the first three lines is simply that the \ttt{\#include}
statement will be copied into the generated \ttt{foopacket\_m.h}
file to let the C++ compiler know about the \ttt{IPAddress} class.
The message compiler itself will not try to make sense of the
text in the body of the \ttt{cplusplus \{\{ ... \}\}} directive.

The next line, \ttt{struct IPAddress}, tells the message compiler that
\ttt{IPAddress} is a C++ struct. This information will (among others)
affect the generated code.

Classes can be announced using the \fkeyword{class} keyword:

\begin{msg}
class cSubQueue;
\end{msg}

The above syntax assumes that the class is derived from \cclass{cOwnedObject}
either directly or indirectly. If it is not, the \fkeyword{noncobject}
keyword should be used:

\begin{msg}
class noncobject IPAddress;
\end{msg}

The distinction between classes derived and not derived from \cclass{cOwnedObject}
is important because the generated code differs at places.
The generated code is set up so that if you incidentally
forget the \fkeyword{noncobject} keyword (and thereby mislead the
message compiler into thinking that your class is rooted in
\cclass{cOwnedObject} when in fact it is not), you will get a C++ compiler
error in the generated header file.


\subsection{Customizing the Generated Class}
\label{sec:ch-messages:customizing-generated-class}


\subsubsection{The Generation Gap Pattern}

Sometimes you need the generated code to do something
more or do something differently than the version generated
by the message compiler.
For example, when setting a integer field named \ttt{payloadLength},
you might also need to adjust the packet length. That is,
the following default (generated) version of the
\ttt{setPayloadLength()} method is not suitable:

\begin{cpp}
void FooPacket::setPayloadLength(int payloadLength)
{
    this->payloadLength = payloadLength;
}
\end{cpp}

Instead, it should look something like this:

\begin{cpp}
void FooPacket::setPayloadLength(int payloadLength)
{
    int diff = payloadLength - this->payloadLength;
    this->payloadLength = payloadLength;
    setBitLength(length() + diff);
}
\end{cpp}

According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the \textit{Generation Gap} design pattern.
It is enabled with the \fprop{@customize} property set on the
message:

\begin{msg}
message FooPacket
{
   @customize(true);
   int payloadLength;
};
\end{msg}

If you process the above code with the message compiler,
the generated code will contain a \ttt{FooPacket\_Base} class
instead of \ttt{FooPacket}. Then you would subclass
\ttt{FooPacket\_Base} to produce \ttt{FooPacket},
while doing your customizations by redefining the necessary methods.

\begin{cpp}
class FooPacket_Base : public cMessage
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
\end{cpp}

There is a minimum amount of code you have to write
for \ttt{FooPacket}, because not everything can be
pre-generated as part of \ttt{FooPacket\_Base}, e.g.
constructors cannot be inherited. This minimum
code is the following (you will find it the generated C++ header
too, as a comment):

\begin{cpp}
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual FooPacket *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
\end{cpp}

Note that it is important that you redefine \ffunc{dup()} and
provide an assignment operator (\ffunc{operator=()}).

So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

\begin{cpp}
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy constructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setBitLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
\end{cpp}



\subsubsection{Abstract Fields}

The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

For example, this is the situation when you want to store a bitfield
in a single \fkeyword{int} or \fkeyword{short}, and still you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

You can declare any field to be abstract with the following syntax:

\begin{msg}
message FooPacket
{
   @customize(true);
   abstract bool urgentBit;
};
\end{msg}

For an \fkeyword{abstract} field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

\begin{cpp}
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
\end{cpp}


Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.



\subsection{Using STL in Message Classes}


%%FIXME ADD THIS SOLUTION:
%%cplusplus {{
%%#include <vector>
%%typedef std::vector<int> IntVector;
%%}}
%%
%%class noncobject IntVector;
%%
%%message X {
%%  fields:
%%    IntVector v;
%%};


You may want to use STL \ttt{vector} or \ttt{stack} classes in your message classes.
This is possible using abstract fields. After all, \ttt{vector} and \ttt{stack}
are representations of a \textit{sequence} -- same abstraction as dynamic-size vectors.
That is, you can declare the field as \ttt{abstract T fld[]}, and provide
an underlying implementation using \ttt{vector<T>}. You can also add methods
to the message class that invoke \ttt{push\_back()}, \ttt{push()}, \ttt{pop()}, etc.
on the underlying STL object.

See the following message declaration:

\begin{msg}
struct Item
{
    int a;
    double b;
}

message STLMessage
{
   @customize(true);
   abstract Item foo[]; // will use vector<Item>
   abstract Item bar[]; // will use stack<Item>
}
\end{msg}

If you compile the above, in the generated code you will only find a couple of
abstract methods for \ttt{foo} and \ttt{bar}, no data members or anything concrete.
You can implement everything as you like. You can write the following C++ file
then to implement \ttt{foo} and \ttt{bar} with \ttt{std::vector} and \ttt{std::stack}:

\begin{cpp}
#include <vector>
#include <stack>
#include "stlmessage_m.h"


class STLMessage : public STLMessage_Base
{
  protected:
    std::vector<Item> foo;
    std::stack<Item> bar;

  public:
    STLMessage(const char *name=NULL, int kind=0) : STLMessage_Base(name,kind) {}
    STLMessage(const STLMessage& other) : STLMessage_Base(other.getName()) {operator=(other);}
    STLMessage& operator=(const STLMessage& other) {
        if (&other==this) return *this;
        STLMessage_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual STLMessage *dup() {return new STLMessage(*this);}

    // foo methods
    virtual void setFooArraySize(unsigned int size) {}
    virtual unsigned int getFooArraySize() const {return foo.size();}
    virtual Item& getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, const Item& afoo) {foo[k]=afoo;}
    virtual void addToFoo(const Item& afoo) {foo.push_back(afoo);}

    // bar methods
    virtual void setBarArraySize(unsigned int size) {}
    virtual unsigned int getBarArraySize() const {return bar.size();}
    virtual Item& getBar(unsigned int k) {throw cRuntimeException("sorry");}
    virtual void setBar(unsigned int k, const Item& bar) {throw cRuntimeException("sorry");}
    virtual void barPush(const Item& abar) {bar.push(abar);}
    virtual void barPop() {bar.pop();}
    virtual Item& barTop() {return bar.top();}
};

Register_Class(STLMessage);
\end{cpp}

Some additional notes:

\begin{enumerate}
  \item{\ttt{setFooArraySize()}, \ttt{setBarArraySize()} are redundant.}
  \item{\ttt{getBar(int k)} cannot be implemented in a straightforward way
     (\ttt{std::stack} does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.}
  \item{\ttt{setBar(int k, const Item\&)} could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.}
\end{enumerate}

You may regret that the STL \ttt{vector}/\ttt{stack} are not directly exposed.
Well you could expose them (by adding a \ttt{vector<Item>\& getFoo() \{return foo;\}}
method to the class) but this is probably not a good idea.
STL itself was purposefully designed with a low-level approach, to provide
``nuts and bolts'' for C++ programming, and STL is better used in other classes
for internal representation of data.



\subsection{Summary}

This section attempts to summarize the possibilities.

You can generate:

\begin{itemize}
  \item  classes rooted in \cclass{cOwnedObject}
  \item  messages (default base class is \cclass{cMessage})
  \item  classes not rooted in \cclass{cOwnedObject}
  \item  plain C structs
\end{itemize}

The following data types are supported for fields:

\begin{itemize}
  \item  primitive types: \ttt{bool}, \ttt{char}, \ttt{short},
    \ttt{int}, \ttt{long}, \ttt{unsigned short}, \ttt{unsigned int},
    \ttt{unsigned long}, \ttt{double}
  \item  \ttt{string}, a dynamically allocated string, presented as \ttt{const char *}
  \item  fixed-size arrays of the above types
  \item  structs, classes (both rooted and not rooted in \cclass{cOwnedObject}),
    declared with the message syntax or externally in C++ code
  \item  variable-sized arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
\end{itemize}

Further features:

\begin{itemize}
  \item  fields initialize to zero (except struct members)
  \item  fields initializers can be specified (except struct members)
  \item  assigning \ttt{enum}s to variables of integral types.
  \item  inheritance
  \item  customizing the generated class via subclassing (\textit{Generation Gap} pattern)
  \item  abstract fields (for nonstandard storage and calculated fields)
\end{itemize}

Generated code (all generated methods are \ttt{virtual}, although
this is not written out in the following table):

\begin{longtable}{|p{4cm}|p{10cm}|}
\hline
\tabheadcol

\tbf{Field declaration}
    &
\tbf{Generated code}
\\\hline

primitive types
\begin{verbatim}
double field;
\end{verbatim}
     &
\begin{verbatim}
double getField();
void setField(double d);
\end{verbatim}
\\\hline

string type
\begin{verbatim}
string field;
\end{verbatim}
     &
\begin{verbatim}
const char *getField();
void setField(const char *);
\end{verbatim}
\\\hline

fixed-size arrays
\begin{verbatim}
double field[4];
\end{verbatim}
     &
\begin{verbatim}
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
\end{verbatim}

\\\hline

dynamic arrays
\begin{verbatim}
double field[];
\end{verbatim}
     &
\begin{verbatim}
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
\end{verbatim}
\\\hline

customized class
\begin{verbatim}
class Foo {
  @customize(true);
\end{verbatim}
     &
\begin{verbatim}
class Foo_Base { ... };
\end{verbatim}
and you have to write:
\begin{verbatim}
class Foo : public Foo_Base {
   ...
};
\end{verbatim}
\\\hline

abstract fields
\begin{verbatim}
abstract double field;
\end{verbatim}
     &
\begin{verbatim}
double getField() = 0;
void setField(double d) = 0;
\end{verbatim}
\\\hline

\end{longtable}


\subsubsection{Example Simulations}

Several of the example simulations contain message definitions, for example
Tictoc, Dyna, Routing and Hypercube. For example, in Dyna you will find this:

\begin{itemize}
 \item \ttt{dynapacket.msg} defines \ttt{DynaPacket} and \ttt{DynaDataPacket};
 \item \ttt{dynapacket\_m.h} and \ttt{dynapacket\_m.cc} are produced
   by the message subclassing compiler from it, and they contain
   the generated \ttt{DynaPacket} and \ttt{DynaDataPacket}
   C++ classes (plus code for Tkenv inspectors);
 \item other model files (\ttt{client.cc}, \ttt{server.cc}, ...)
   use the generated message classes
\end{itemize}



\subsection{What Else Is There in the Generated Code?}

In addition to the message class and its implementation,
the message compiler also generates reflection code which makes it
possible to inspect message contents in Tkenv.
To illustrate why this is necessary, suppose you manually subclass
\cclass{cMessage} to get a new message class. You could write the following:
  \footnote{Note that the code is only for illustration.
  In real code, \ttt{freq} and \ttt{power} should be private members,
  and getter/setter methods should exist to access them.
  Also, the above class definition misses several member functions
  (constructor, assignment operator, etc.) that should be written.}

\begin{cpp}
class RadioMsg : public cMessage
{
  public:
    int freq;
    double power;
    ...
};
\end{cpp}

Now it is possible to use \ttt{RadioMsg} in your simple modules:

\begin{cpp}
RadioMsg *msg = new RadioMsg();
msg->freq = 1;
msg->power = 10.0;
...
\end{cpp}

%% FIXME remove this section?

You will notice one drawback of this solution when you try to use
Tkenv for debugging. While \cclass{cMsgPar}-based message parameters can be viewed in
message inspector windows, fields added via subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because C++ does not
support ``reflection'' (extracting class information at runtime)
like for example Java does.

There is a solution however: one can supply Tkenv with missing ``reflection''
information about the new class. Reflection info might take the form of
a separate C++ class whose methods return information about the
\ttt{RadioMsg} fields. This descriptor class might look like this:

\begin{cpp}
class RadioMsgDescriptor : public Descriptor
{
  public:
    virtual int getFieldCount() {return 2;}

    virtual const char *getFieldName(int k) {
        const char *fieldname[] = {"freq", "power";}
        if (k<0 || k>=2) return NULL;
        return fieldname[k];
    }

    virtual double getFieldAsDouble(RadioMsg *msg, int k) {
        if (k==0) return msg->freq;
        if (k==1) return msg->power;
        return 0.0; // not found
    }
    //...
};
\end{cpp}

Then you have to inform Tkenv that a \ttt{RadioMsgDescriptor} exists and that it
should be used whenever Tkenv finds messages of type \ttt{RadioMsg} (as it is
currently implemented, whenever the object's \ffunc{getClassName()} method returns
\ttt{"RadioMsg"}). So when you inspect a \ttt{RadioMsg} in your simulation, Tkenv
can use \ttt{RadioMsgDescriptor} to extract and display the values of
the \ttt{freq} and \ttt{power} variables.

The actual implementation is somewhat more complicated than this, but not
much.

