\chapter{Messages and Packets}
\label{cha:messages}

\section{The cMessage and cPacket Classes}

Messages are a central concept in {\opp}. In the model, message objects
represent events, packets, commands, jobs, customers or other kinds of
entities, depending on the model domain.

Messages are represented with the \cclass{cMessage} class and its subclass
\cclass{cPacket}. \cclass{cPacket} is used for network packets (frames,
datagrams, transport packets, etc.) in a communication network, and
\cclass{cMessage} is used for everything else. Users are free to subclass
both \cclass{cMessage} and \cclass{cPacket} to create new types and to
add data.

\cclass{cMessage} has the following fields; some are used by
the simulation kernel, and others are provided for the convenience
of the simulation programmer:

\begin{itemize}
  \item The \textit{name} field is a string (\ttt{const char *}),
    which can be freely used by the simulation programmer. The message
    name is displayed at many places in the graphical runtime interface,
    so it is generally useful to choose a descriptive name. Message name
    is inherited from \cclass{cObject} (see section
    \ref{sec:ch-sim-lib:cobject}).
  \item \textit{Message kind} is an integer field.
    Some negative values are reserved by the simulation library, but zero
    and positive values can be freely used in the model for any purpose.
    Message kind is typically used to carry a value that conveys the
    role, type, category or identity of the message.
  \item The \textit{scheduling priority} field is used by the simulation
    kernel to determine the delivery order of messages that have the same
    arrival time values. This field is rarely used in practice.
  \item The \textit{send time}, \textit{arrival time}, \textit{source module},
    \textit{source gate}, \textit{destination module}, \textit{destination gate}
    fields store information about the message's last sending or scheduling,
    and should not be modified from the model. These fields are primarily
    used internally by the simulation kernel while the message is in the
    future events set (FES)\index{FES}, but the information is still in
    the message object when the message is delivered to a module.
  \item \textit{Time stamp} (not to be confused with \textit{arrival time})
    is a utility field, which the programmer can freely use for any purpose.
    The time stamp is not examined or changed by the simulation kernel at all.
  \item The \textit{parameter list}, \textit{control info} and
    \textit{context pointer} fields make some simulation tasks easier
    to program, and they will be discussed later.
\end{itemize}

The \cclass{cPacket} class extends \cclass{cMessage} with fields that are
useful for representing network packets:

\begin{itemize}
  \item The \textit{packet length} field represents the length of the packet
    in bits. It is used by the simulation kernel to compute the transmission
    duration when a packet travels through a connection that has an assigned
    data rate, and also for error modeling on channels with a nonzero
    bit error rate.
  \item The \textit{encapsulated packet} field helps modeling protocol layers
    by supporting the concept of encapsulation and decapsulation.
  \item The \textit{bit error flag} field carries the result of error
    modelling after the packet is sent through a channel that has a nonzero
    packet error rate (PER) or bit error rate (BER). It is up to the receiver
    to examine this flag after having received the packet, and to act upon it.
  \item The \textit{duration} field carries the transmission duration after
    the packet was sent through a channel with a data rate.
  \item The \textit{is-reception-start} flag tells whether this packet
    represents the start or the end of the reception after the packet travelled
    through a channel with a data rate. This flag is controlled by the
    \textit{deliver-on-reception-start} flag of the receiving gate.
\end{itemize}


\subsection{Basic Usage}


The \cclass{cMessage} constructor accepts several arguments.
Most commonly, you would create a message using an \textit{object name}
(a \ttt{const char *} string) and a \textit{message kind} (\ttt{int}):

\begin{cpp}
cMessage *msg = new cMessage("timer", kind);
\end{cpp}

Both arguments are optional and initialize to the null string (\ttt{""})
and 0, so the following statements are also valid:

\begin{cpp}
cMessage *msg = new cMessage();
cMessage *msg = new cMessage("timer");
\end{cpp}

Descriptive message names can be very useful when tracing, debugging or
demonstrating the simulation, so it is recommended to use them.

Message kind is usually initialized with a symbolic constant
(e.g. an \textit{enum} value) which signals what the message object
represents. Only positive values and zero can be used --
negative values are reserved for use by the simulation kernel.

The \cclass{cPacket} constructor accepts a further \textit{bit length} argument.

\index{message!data members}

Once a message has been created, its data members can be changed by the following functions:

\begin{cpp}
msg->setKind( kind );
msg->setBitLength( length );
msg->setByteLength( lengthInBytes );
msg->setSchedulingPriority( priority );
msg->setBitError( err );
msg->setTimestamp();
msg->setTimestamp( simtime );
\end{cpp}

With these functions the user can set the message
kind\index{message!kind}, the message length\index{message@length},
the priority\index{message!priority}, the error
flag\index{message!error flag} and the time stamp\index{message!time
  stamp}. The \ffunc{setTimeStamp()} function without any argument
sets the time stamp to the current simulation time.
\ffunc{setByteLength()} sets the same field as \ffunc{setBitLength()},
except that the parameter is internally multiplied by 8.

The values can be obtained by the following functions:

\begin{cpp}
int k       = msg->getKind();
int p       = msg->getSchedulingPriority();
int l       = msg->getBitLength();
int lb      = msg->getByteLength();
bool b      = msg->hasBitError();
simtime_t t = msg->getTimestamp();
\end{cpp}

\ffunc{getBitLength()} and \ffunc{getByteLength()} both read the same
field, but the latter divides by 8 and rounds up the result.


\subsection{Duplicating Messages}
\index{message!duplication}

It is often necessary to duplicate a message or a packet, for example,
to send one and keep a copy. Duplication can be done in the same way as
for any other {\opp} object:

\begin{cpp}
cMessage *copy = msg->dup();
\end{cpp}

The resulting message (or packet) will be an exact copy of the original,
including message parameters and encapsulated messages.
  \footnote{Note, however, that the simulation library may delay the
  duplication of the encapsulated message until it is really needed;
  see section \ref{sec:messages:reference-counting}.}


\section{Self-Messages}

\subsection{Using a Message as Self-Message}

Messages are often used to represent events internal to a module,
such as a periodically firing timer to represent expiry of a timeout.
A message is termed \textit{self-message} when it is used
in such a scenario -- otherwise self-messages are normal messages
of class \cclass{cMessage} or a class derived from it.

When a message is delivered to a module by the simulation kernel,
you can call the \ffunc{isSelfMessage()} method to determine if it is
a self-message; it other words, if it was scheduled with
\ffunc{scheduleAt()} or was sent with one of the
\ffunc{send...()} methods. The \ffunc{isScheduled()} method
returns true if the message is currently scheduled. A scheduled
message can also be cancelled (\ffunc{cancelEvent()}).

\begin{cpp}
bool isSelfMessage();
bool isScheduled();
\end{cpp}

The following methods return the time of creating and scheduling the message
as well as its arrival time. While the message is scheduled, arrival
time is the time it will be delivered to the module.

\begin{cpp}
simtime_t getCreationTime();
simtime_t getSendingTime();
simtime_t getArrivalTime();
\end{cpp}

\subsection{Context Pointer}

\cclass{cMessage} contains a \ttt{void*} pointer which is
set/returned by the \ffunc{setContextPointer()} and
\ffunc{getContextPointer()} functions:

\begin{cpp}
void *context =...;
msg->setContextPointer(context);
void *context2 = msg->getContextPointer();
\end{cpp}


It can be used for any purpose by the simulation programmer.
It is not used by the simulation kernel, and it is treated as
a mere pointer (no memory management is done on it).

Intended purpose: a module which schedules several self-messages
(timers) will need to identify a self-message when it arrives back to
the module, ie. the module will have to determine which timer went off
and what to do then. The context pointer\index{context pointer} can be
made to point at a data structure kept by the module which can carry
enough ``context'' information about the event.



\section{Modelling Packets}

\subsection{Arrival Gate and Time}

The following methods can tell where the message came from and
where it arrived (or will arrive if it is currently scheduled or under way.)

\begin{cpp}
int getSenderModuleId();
int getSenderGateId();
int getArrivalModuleId();
int getArrivalGateId();
\end{cpp}

The following methods are just convenience functions which build
on the ones above.

\begin{cpp}
cModule *getSenderModule();
cGate *getSenderGate();
cGate *getArrivalGate();
\end{cpp}

And there are further convenience functions to tell whether
the message arrived on a specific gate given with id or
name+index.

\begin{cpp}
bool arrivedOn(int id);
bool arrivedOn(const char *gname, int gindex=0);
\end{cpp}

The following methods return message creation time and the last sending
and arrival times.

\begin{cpp}
simtime_t getCreationTime();
simtime_t getSendingTime();
simtime_t getArrivalTime();
\end{cpp}

\subsection{Control Info}

One of the main application areas of {\opp} is the simulation of
telecommunication networks. Here, protocol layers are usually
implemented as modules which exchange packets. Packets themselves
are represented by messages subclassed from \cclass{cMessage}.

However, communication between protocol layers requires sending
additional information to be attached to packets. For example,
a TCP implementation sending down a TCP packet to IP will want
to specify the destination IP address and possibly
other parameters. When IP passes up a packet to TCP after
decapsulation from the IP header, it will want to let TCP know
at least the source IP address.

This additional information is represented by \textit{control info}
objects in {\opp}. Control info objects have to be subclassed from
\cclass{cObject} (a small footprint base class with
no data members), and attached to the messages representing
packets. \cclass{cMessage} has the following methods for this
purpose:

\begin{cpp}
void setControlInfo(cObject *controlInfo);
cObject *getControlInfo();
cObject *removeControlInfo();
\end{cpp}

When a "command" is associated with the message sending (such as
TCP OPEN, SEND, CLOSE, etc), the message kind field (\ttt{getKind()},
\ttt{setKind()} methods of \ttt{cMessage}) should carry the command code.
When the command doesn't involve a data packet (e.g.
TCP CLOSE command), a dummy packet (empty \ttt{cMessage}) can be sent.



\subsection{Identifying the Protocol}

In {\opp} protocol models, the protocol type is usually represented
in the message subclass. For example, instances of class
\ttt{IPv6Datagram} represent IPv6 datagrams and \ttt{EthernetFrame}
represents Ethernet frames) and/or in the message kind value.
The PDU type is usually represented as a field inside the message class.

The C++ \ttt{dynamic\_cast} operator can be used to determine
if a message object is of a specific protocol.

\begin{cpp}
cMessage *msg = receive();
if (dynamic_cast<IPv6Datagram *>(msg) != NULL)
{
    IPv6Datagram *datagram = (IPv6Datagram *)msg;
    ...
}
\end{cpp}


\section{Encapsulation}

\subsection{Encapsulating Packets}

It is often necessary to encapsulate a packet\index{packet!encapsulation}
into another when you are modeling layered protocols of computer networks.

The \ffunc{encapsulate()} function encapsulates a packet
into another one. The length of the packet will grow by the length of
the encapsulated packet. An exception: when the encapsulating (outer)
packet has zero length, {\opp} assumes it is not a real packet but
some out-of-band signal, so its length is left at zero.

\begin{cpp}
cPacket *data = new cPacket("data");
data->setByteLength(1024);

TCPSegment *tcpseg = new TCPSegment("tcp"); // subclassed from cPacket
tcpseg->setByteLength(24);

tcpseg->encapsulate(data);
ev << tcpseg->getByteLength() << endl; // --> 1024+24 = 1048
\end{cpp}

A packet can only hold one encapsulated packet at a time; the
second \ffunc{encapsulate()} call will result in an error. It is also
an error if the packet to be encapsulated is not owned by the
module.

You can get back the encapsulated packet by calling \ffunc{decapsulate()}:

\begin{cpp}
cPacket *userdata = tcpseg->decapsulate();
\end{cpp}

\ffunc{decapsulate()} will decrease the length of the packet accordingly,
except if it was zero. If the length would become negative, an
error occurs.

The \ffunc{getEncapsulatedPacket()} function returns a pointer to the encapsulated
packet, or \ttt{NULL} if no packet is encapsulated.


\subsection{Reference Counting}
\label{sec:messages:reference-counting}

Since the 3.2 release, {\opp} implements reference counting of
encapsulated packets, meaning that if you \ffunc{dup()} a packet
that contains an encapsulated packet, then the encapsulated packet will
not be duplicated, only a reference count incremented. Duplication of
the encapsulated packet is deferred until \ffunc{decapsulate()}
actually gets called. If the outer packet is deleted without its
\ffunc{decapsulate()} method ever being called, then the reference
count of the encapsulated packet is simply decremented. The
encapsulated packet is deleted when its reference count reaches
zero.

Reference counting can significantly improve performance, especially
in LAN and wireless scenarios. For example, in the simulation of a
broadcast LAN or WLAN, the IP, TCP and higher layer packets won't
be duplicated (and then discarded without being used) if the
MAC address doesn't match in the first place.

The reference counting mechanism works transparently. However, there
is one implication: \tbf{one must not change anything in a packet
that is encapsulated into another!} That is,
\ffunc{getEncapsulatedPacket()} should be viewed as if it returned a
pointer to a read-only object (it returns a \ttt{const} pointer
indeed), for quite obvious reasons: the encapsulated packet may be
shared between several packets, and any change would affect those
other packets as well.


\subsection{Encapsulating Several Packets}

The \cclass{cPacket} class does not directly support encapsulating more
than one packet, but you can subclass \cclass{cPacket} or \cclass{cMessage}
to add the necessary functionality. (It is recommended that you
use the message definition syntax \ref{cha:message-definitions}
and customized messages \ref{sec:ch-messages:customizing-generated-class}
to be described later on in this chapter -- it can spare you some work.)

You can store the messages in a fixed-size or a dynamically allocated
array, or you can use STL classes like \ttt{std::vector} or \ttt{std::list}.
There is one additional ``trick'' that you might not expect: your message
class has to \textbf{take ownership} of the inserted messages, and
\textbf{release} them when they are removed from the message. These are
done via the \ffunc{take()} and \ffunc{drop()} methods. Let us see
an example which assumes you have added to the class an \ttt{std::list} member
called \ttt{messages} that stores message pointers:

\begin{cpp}
void MessageBundleMessage::insertMessage(cMessage *msg)
{
    take(msg);  // take ownership
    messages.push_back(msg);  // store pointer
}

void MessageBundleMessage::removeMessage(cMessage *msg)
{
    messages.remove(msg);  // remove pointer
    drop(msg);  // release ownership
}
\end{cpp}

You will also have to provide an \ffunc{operator=()} method to
make sure your message objects can be copied and duplicated
properly -- this is something often needed in simulations
(think of broadcasts and retransmissions!). Section
\ref{sec:ch-sim-lib:deriving-new-classes} contains more
about the things you need to take care of when deriving new classes.



\section{Attaching Parameters and Objects}

If you want to add parameters or objects to a message, the preferred
way to do that is via message definitions, described in chapter
\ref{ch:messages:message-definitions}.


\subsection{Attaching Objects}

The \cclass{cMessage} class has an internal \cclass{cArray} object which can
carry objects\index{message!attaching objects}. Only objects
that are derived from \cclass{cObject} (most {\opp} classes are so) can be attached.
The \ffunc{addObject()}, \ffunc{getObject()}, \ffunc{hasObject()},
\ffunc{removeObject()} methods use the object name
as the key to the array. An example:

\begin{cpp}
cLongHistogram *pklenDistr = new cLongHistogram("pklenDistr");
msg->addObject(pklenDistr);
...
if (msg->hasObject("pklenDistr"))
{
   cLongHistogram *pklenDistr =
       (cLongHistogram *) msg->getObject("pklenDistr");
   ...
}
\end{cpp}

You should take care that names of the attached objects don't
conflict with each other or with \cclass{cMsgPar} parameter names
(see next section).
If you do not attach anything to the message and do not call the
\ffunc{getParList()} function, the internal \cclass{cArray} object
will not be created. This saves both storage and execution time.

You can attach non-object types (or non-\cclass{cObject} objects) to
the message\index{message!attaching non-object types} by using
\cclass{cMsgPar}'s \ttt{void*} pointer 'P') type (see later in the description
of \cclass{cMsgPar}). An example:

\begin{cpp}
struct conn_t *conn = new conn_t; // conn_t is a C struct
msg->addPar("conn") = (void *) conn;
msg->par("conn").configPointer(NULL,NULL,sizeof(struct conn_t));
\end{cpp}




\subsection{Attaching Parameters}

The preferred way of extending messages with new data fields is to use
message definitions (see section \ref{ch:messages:message-definitions}).

The old, deprecated way of adding new fields to messages is via
attaching \cclass{cMsgPar} objects.
There are several downsides of this approach, the worst being
large memory and execution time overhead. \cclass{cMsgPar}'s are
heavy-weight and fairly complex objects themselves.
It has been reported that using \cclass{cMsgPar} message parameters
might account for a large part of execution time, sometimes as much as 80\%.
Using \cclass{cMsgPar} is also error-prone because \cclass{cMsgPar} objects
have to be added dynamically and individually to each message object.
In contrast, subclassing benefits from static type checking:
if you mistype the name of a field in the C++ code, the compiler
can detect the mistake.

If you still need \cclass{cMsgPar}s for some reason, here is a short summary.
At the sender side you can add a new named parameter to the message
with the \ffunc{addPar()} member function, then set its value with
one of the methods \ffunc{setBoolValue()}, \ffunc{setLongValue()},
\ffunc{setStringValue()}, \ffunc{setDoubleValue()}, \ffunc{setPointerValue()},
\ffunc{setObjectValue()}, and \ffunc{setXMLValue()}. There are also overloaded
assignment operators for the corresponding C/C++ types.

At the receiver side, you can look up the parameter object on the message
by name and obtain a reference to it with the \ffunc{par()} member function.
\ffunc{hasPar()} can be used to check first whether the message object has a parameter
object with the given name. Then the value can be read with the methods
\ffunc{boolValue()}, \ffunc{longValue()}, \ffunc{stringValue()},
\ffunc{doubleValue()}, \ffunc{pointerValue()}, \ffunc{objectValue()},
\ffunc{xmlValue()}, or by using the provided overloaded type cast operators.

Example usage:

\begin{cpp}
msg->addPar("destAddr");
msg->par("destAddr").setLongValue(168);
...
long destAddr = msg->par("destAddr").longValue();
\end{cpp}

Or, using overloaded operators:

\begin{cpp}
msg->addPar("destAddr");
msg->par("destAddr") = 168;
...
long destAddr = msg->par("destAddr");
\end{cpp}


