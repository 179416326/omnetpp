\chapter{The NED Language}
\label{cha:the-ned-language}


\section{NED overview}

The user describes the structure of a simulation model in the NED language. NED
stands for Network Description. NED lets the user declare simple modules, and
connect and assemble them into compound modules. The user can label some compound
modules as \textit{networks}, self-contained simulation models. Channels are
another component type, whose instances can also be used in compound modules.

The NED language has several features which let it scale well to large projects:

\begin{description}

\item[Hierarchical] The traditional way to deal with complexity is via
introducing hierarchies. In {\opp}, any module which would be too complex as
a single entity can be broken down into smaller modules, and used as a
compound module.

\item[Component-Based] Simple modules and compound modules are inherently
reusable, which not only reduces code copying, but more importantly, allows
component libraries (like the INET Framework, MiXiM, Castalia, etc.) to
exist.

\item[Interfaces] Module and channel interfaces can be used as a
placeholder where normally a module or channel type would be used, and the
concrete module or channel type is determined at network setup time by a
parameter. Concrete module types have to ``implement'' the interface they
can substitute. For example, given a compound module type named
\ttt{MobileHost} contains a \ttt{mobility} submodule of the type
\ttt{IMobility} (where \ttt{IMobility} is a module interface), the actual
type of \ttt{mobility} may be chosen from the module types that implemented
\ttt{IMobility} (\ttt{RandomWalkMobility}, \ttt{TurtleMobility}, etc.)

\item[Inheritance] Modules and channels can be subclassed. Derived modules
and channels may add new parameters, gates, and (in the case of compound
modules) new submodules and connections. They may set existing parameters
to a specific value, and also set the gate size of a gate vector. This
makes it possible, for example, to take a \ttt{GenericTCPClientApp} module
and derive an \ttt{FTPClientApp} from it by setting certain parameters to a fixed
value; or to derive a \ttt{WebClientHost} compound module from a
\ttt{BaseHost} compound module by adding a \ttt{WebClientApp} submodule and
connecting it to the inherited \ttt{TCP} submodule.

\item[Packages] The NED language features a Java-like package structure,
to reduce the risk of name clashes between different models. \ttt{NEDPATH}
(similar to Java's \ttt{CLASSPATH}) was also introduced to make it easier
to specify dependencies among simulation models.

\item[Inner types] Channel types and module types used locally by a
compound module can be defined within the compound module, in order to
reduce namespace pollution.

\item[Metadata annotations] It is possible to annotate module or channel
types, parameters, gates and submodules by adding properties. Metadata are
not used by the simulation kernel directly, but they can carry extra
information for various tools, the runtime environment, or even for other
modules in the model. For example, a module's graphical representation
(icon, etc)  or the prompt string and measurement unit (milliwatt, etc) of a
parameter are already specified as metadata annotations.

\end{description}

\begin{note}
    The NED language has changed significantly in the 4.0 version.
    Inheritance, interfaces, packages, inner types, metadata annotations, inout
    gates were all added in the 4.0 release, together with many other features.
    Since the basic syntax has changed as well, old NED files need to be
    converted to the new syntax. There are automated tools for this purpose, so
    manual editing is only needed to take advantage of new NED features.
\end{note}

The NED language has an equivalent tree representation which can be
serialized to XML; that is, NED files can be converted to XML and back
without loss of data, including comments. This lowers the barrier for
programmatic manipulation of NED files, for example extracting information,
refactoring and transforming NED, generating NED from information stored in
other system like SQL databases, and so on.

\begin{note}
    This chapter is going to explain the NED language gradually, via examples.
    If you are looking for a more formal and concise treatment, see
    Appendix \ref{cha:ned-language-grammar}.
\end{note}


\section{Warmup}

In this section we introduce the NED language via a complete and
reasonably real-life example: a communication network.

Our hypothetical network consists of nodes. One each node there's an
application running which generates packets at random intervals.
The nodes are routers themselves as well. We assume that the application
uses datagram-based communication, so that we can leave out the
transport layer from the model.

%% XXX keep the example simple!

\subsection{The network}

First we'll define the network, then in the next sections we'll continue
to define the network nodes.

Let the network topology be as in Figure \ref{fig:ned-net6-topology}.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[scale=0.6]{figures/ned-net6-topology}
    \caption{The network}
    \label{fig:ned-net6-topology}
  \end{center}
\end{figure}

The corresponding NED description would look like this:

\begin{Verbatim}
//
// A six-node network
//
network Net6
{
    submodules:
        node1: Node;
        node2: Node;
        node3: Node;
        node4: Node;
        node5: Node;
        node6: Node;
    connections:
        node1.port++ <--> {datarate=100Mbps;} <--> node2.port++;
        node2.port++ <--> {datarate=100Mbps;} <--> node4.port++;
        node4.port++ <--> {datarate=100Mbps;} <--> node6.port++;
        ...
        node3.port++ <--> {datarate=100Mbps;} <--> node4.port++;
}
\end{Verbatim}

The above code defines a network type named \ttt{Net6}. Note that the NED
language uses the familiar curly brace syntax, and ``\ttt{//}'' to denote
comments.

\begin{note}
    Comments in NED not only make the source code more readable, but in the
    {\opp} IDE they also get displayed at various places (tooltips, content
    assist, etc), and become part of the documentation extracted from the NED
    files. The NED documentation system, not unlike \textit{JavaDoc} or
    \textit{Doxygen}, will be described in Chapter \ref{cha:neddoc}.
\end{note}

The network contains six nodes, named \ttt{node1}...\ttt{node6},
from the NED module type \ttt{Node}. (We'll define \ttt{Node} in the next
sections.)

The second half of the declaration defines how the nodes are to be
connected. The double arrow means bidirectional connection. The connection
points of modules are called gates, and the \ttt{port++} notation adds a
new gate to the \ttt{port[]} gate vector. Gates and connections will be
covered in more detail in sections XXX and XXX. Nodes are connected
with a channel that has a data rate of 100Mbps.

\begin{note}
    In many other systems, the equivalent of {\opp} gates are called
    \textit{ports}. We have retained the term \textit{gate} to reduce
    collisions with other uses of the otherwise overloaded word
    \textit{port}: router port, TCP port, I/O port, etc.
\end{note}

The above code would be placed into a file named \ttt{Net6.ned}. It is
a convention to put every NED definition into its own file and to name the
file accordingly, but it is not mandatory to do so.

One can define any number of networks in the NED files, and for every
simulation the user has to specify which network he wants to set up.
The usual way of specifying the network is to put the \fconfig{network}
option into the configuration (by default the \ttt{omnetpp.ini} file):

\begin{Verbatim}
[General]
network = Net6
\end{Verbatim}


\subsection{Introducing a channel}

It is cumbersome to have to repeat the data rate for every connection.
Luckily, NED provides a convenient solution: one can create a new channel
type that encapsulates the data rate setting, and this channel type can
be defined inside the network so that it does not litter the global
namespace.

The improved network will look like this:

\begin{Verbatim}
//
// A six-node network
//
network Net6
{
    types:
        channel C extends ned.DatarateChannel {
            datarate = 100Mbps;
        }
    submodules:
        node1: Node;
        node2: Node;
        node3: Node;
        node4: Node;
        node5: Node;
        node6: Node;
    connections:
        node1.port++ <--> C <--> node2.port++;
        node2.port++ <--> C <--> node4.port++;
        node4.port++ <--> C <--> node6.port++;
        ...
        node3.port++ <--> C <--> node4.port++;
}
\end{Verbatim}

Later sections will cover the concepts used (inner types, channels, the
\ttt{DatarateChannel} built-in type, inheritance) in details.


\subsection{The App, Routing and Queue simple modules}

Simple modules are the basic building blocks for other (compound) modules.
All active behavior in the model is encapsulated in simple modules.
Behavior is defined with a C++ class; NED files only declare the externally
visible interface of the module (gates, parameters).

In our example, we could define \ttt{Node} as a simple module. However,
its functionality is quite complex (traffic generation, routing, etc),
so it is better to implement it with several smaller simple module types
which we are going to assemble into a compound module. We'll have
one simple module for traffic generation (\ttt{App}), one for routing
(\ttt{Routing}), and one for queueing up packets to be sent out (\ttt{Queue}).
For brevity, we omit the bodies of the latter two in the code below.

\begin{Verbatim}[commandchars=\\\{\}]
simple App
\{
    parameters:
        int destAddress;
        ...
        @display("i=block/browser");
    gates:
        input in;
        output out;
\}

simple Routing
\{
    ...
\}

simple Queue
\{
    ...
\}
\end{Verbatim}

By convention, the above simple module declarations go into the
\ttt{App.ned}, \ttt{Routing.ned} and \ttt{Queue.ned} files.

\begin{note}
    Note that module type names (\ttt{App}, \ttt{Routing}, \ttt{Queue})
    begin with a capital letter, and parameter and gate names begin with
    lowercase -- this is the recommended naming convention. Capitalization
    matters because the language is case sensitive.
\end{note}

Let us see the first simple module type declaration. \ttt{App} has a
parameter called \ttt{destAddress} (others have been omitted for now),
and two gates named \ttt{out} and \ttt{in} for sending and receiving
application packets.

The argument of \ttt{@display()} is called a \textit{display string},
and it defines the default rendering of the module in graphical environments;
\ttt{"i=..."} defines the default icon.

Generally, \ttt{@}-words like \ttt{@display} are called \textit{properties}
in NED, and they are used to annotate various objects
with metadata. Properties can be attached to files, modules, parameters, gates,
connections, and other objects, and parameter values have a very flexible
syntax.


\subsection{The Node compound module}

Now we can assemble \ttt{App}, \ttt{Routing} and {Queue} into the
compound module \ttt{Node}. A compound module can be thought of as
a ``cardboard box'' that groups other modules into a larger unit,
which can further be used as a building block for other modules;
networks are also a kind of compound module.

\begin{Verbatim}[commandchars=\\\{\}]
module Node
\{
    parameters:
        @display("i=misc/node_vs,gold");
    gates:
        inout port[];
    submodules:
        app: App;
        routing: Routing;
        queue[sizeof(port)]: Queue;
    connections:
        routing.localOut --> app.in;
        routing.localIn <-- app.out;
        for i=0..sizeof(port)-1 \{
            routing.out[i] --> queue[i].in;
            routing.in[i] <-- queue[i].out;
            queue[i].line <--> port[i];
        \}
\}
\end{Verbatim}

Compound modules, like simple modules, may have parameters and gates.
Our \ttt{Node} module contains an \ttt{address} parameter, plus a
\textit{gate vector} of unspecified size, named \ttt{port}.
The actual gate vector size will be determined implicitly by the number
of neighbours when we create a network from nodes of this type.
The type of \ttt{port[]} is \ttt{inout}, which allows bidirectional
connections.

The modules that make up the compound module are listed under \ttt{submodules}.
Our \ttt{Node} compound module type has an \ttt{app} and a \ttt{routing}
\textit{submodule}, plus a \ttt{queue[]} \textit{submodule vector} that
contains one \ttt{Queue} module for each port, as specified by
\ttt{[sizeof(port)]}.

XXX explain "for" loop

\subsection{Putting it together}

XXX Explain how the network is set up! top-down etc

\bigskip
\begin{center}* * *\end{center}
\bigskip

In the following sections we'll go through the elements of the NED
language and look at them in more details.



\section{Simple modules}

Simple modules are the active components in the model.
Simple modules are defined with the \fkeyword{simple} keyword.

An example simple module:

\begin{Verbatim}[commandchars=\\\{\}]
simple Queue
\{
    parameters:
        int capacity;
        @display("i=block/queue");
    gates:
        input in;
        output out;
\}
\end{Verbatim}

Both the \fkeyword{parameters} and \fkeyword{gates} sections are optional, that is,
they can be left out if there's no parameter or gate. In addition, the
\fkeyword{parameters} keyword itself is optional too, it can be left out
even if there are parameters or properties.

Note that the NED definition doesn't contain any code to define the
operation of the module: that part is expressed in C++. By default, {\opp}
looks for C++ classes of the same name as the NED type (so here, \ttt{Queue}).

One can explicitly specify the C++ class with the \ttt{@class} property.
Classes with namespace qualifiers are also accepted, as shown in the following
example that uses the \ttt{mylib::Queue} class:

\begin{Verbatim}[commandchars=\\\{\}]
simple Queue
\{
    parameters:
        int capacity;
        @class(mylib::Queue);
        @display("i=block/queue");
    gates:
        input in;
        output out;
\}
\end{Verbatim}

If you have several modules that are all in a common namespace, then a
better alternative to \ttt{@class} is the \ttt{@namespace} property. The
C++ namespace given with \ttt{@namespace} will be prepended to the normal
class name. In the following example, the C++ classes will be
\ttt{mylib::App}, \ttt{mylib::Router} and \ttt{mylib::Queue}:

\begin{Verbatim}
@namespace(mylib);

simple App {
   ...
}

simple Router {
   ...
}

simple Queue {
   ...
}
\end{Verbatim}

As you've seen, \ttt{@namespace} can be specified on file level. Moreover,
when placed in a file called \ttt{package.ned}, the namespace will apply to
all files in the same directory and all directories below.

The implementation C++ classes need to be subclassed from the
\cclass{cSimpleModule} library class; chapter XXX of this manual describes
in detail how to write them.

Simple modules can be extended (or specialized) via subclassing.
The motivation for subclassing can be to set some open parameters
or gate sizes to a fixed value (see XXX), or to replace the C++
class with a different one. Now, by default the derived NED module type
will \textit{inherit} the C++ class from its base, so it is important
to remember that you need to write out \ttt{@class} if you want it
to use the new class.

The following example shows how to specialize a module by setting a parameter
to a fixed value (and leaving the C++ class unchanged):

\begin{Verbatim}
simple Queue
{
   int capacity;
   ...
}

simple BoundedQueue extends Queue
{
   capacity = 10;
}
\end{Verbatim}

In the next example, the author wrote a \ttt{PriorityQueue} C++ class, and
wants to have a corresponding NED type, derived from \ttt{Queue}. However,
it does not work as expected:

\begin{Verbatim}
simple PriorityQueue extends Queue // wrong! still uses the Queue C++ class
{
}
\end{Verbatim}

The correct solution is to add a \ttt{@class} property to override the
inherited C++ class:

\begin{Verbatim}
simple PriorityQueue extends Queue
{
   @class(PriorityQueue);
}
\end{Verbatim}

Inheritance in general will be discussed in section \ref{sec:ch-ned-lang:inheritance}.



\section{Compound modules}

A compound module groups other modules into a larger unit. A compound
module may have gates and parameters like a simple module, but
no active behavior (no C++ code) is associated with it.

\begin{note}
    When there is a temptation to add code to a compound module,
    then encapsulate the code into a simple module, and add it as
    a submodule.
\end{note}

A compound module declaration may contain several sections,
all of them optional:

\begin{Verbatim}
module Host
{
   types:
       ...
   parameters:
       ...
   gates:
       ...
   submodules:
       ...
   connections:
       ...
}
\end{Verbatim}

Modules contained in a compound module are called submodules,
and they are listed in the \ttt{submodules} section. One can create
arrays of submodules (i.e. submodule vectors), and the submodule type
may come from a parameter.

Connections are listed under the \ttt{connections} section of the
declaration. One can create connections using simple programming
constructs (loop, conditional). Connection behaviour can be defined
by associating a channel with the connection; the channel type may
also come from a parameter.

Module and channel types only used locally can be defined in the
\ttt{types} section, so that they don't pollute the namespace.

inheritance may add new submodules, new connections etc; one may refer to
inherited submodules, inherited types etc.

inheritance example: hostbase -> host+apps, etc



\section{Channels}
\label{sec:ch-ned-lang:channels}

Channels are like simple modules, in the sense that there are C++ classes
behind them. The rules for finding the C++ class for a NED channel type is
the same as with simple modules: the default class name is the NED type
name unless there is a \ttt{@class} property (\ttt{@namespace} is also
observed), and the C++ class is inherited when the channel is subclassed.

Thus, the following channel type would expect a \ttt{CustomChannel} C++ class
to be present:

\begin{Verbatim}
channel CustomChannel  // needs a CustomChannel C++ class
{
}
\end{Verbatim}

The practical difference to modules is that you rarely need to write you own
channel C++ class, because there are predefined channel types that you can
subclass from, inheriting their C++ code. The predefined types are:
\ttt{ned.IdealChannel}, \ttt{ned.Delay\-Channel} and \ttt{ned.Datarate\-Channel}.
(``\ttt{ned}'' is the package name; you can get rid of it if you import the types
with the \ttt{import ned.*} or similar directive. Packages and imports
are described in section XXX.)

\ttt{IdealChannel} has no parameters, and lets through all messages without
delay or any side effect. A connection without a channel object
and a connection with an \ttt{IdealChannel} behave in the same way.
Still, \ttt{IdealChannel} has its uses, for example when a channel object
is required so that it can carry a new property or parameter that is
going to be read by other parts of the simulation model.

\ttt{DelayChannel} has two parameters:

\begin{itemize}
    \item \ttt{delay} is a \ttt{double} parameter which represents the
          propagation delay of the message. Values need to be specified
          together with a time unit (\ttt{s}, \ttt{ms}, \ttt{us}, etc.)
    \item \ttt{disabled} is a boolean parameter that defaults to \ttt{false};
          when set to \ttt{true}, the channel object will drop all messages.
\end{itemize}

\ttt{DatarateChannel} has a few additional parameters compared to \ttt{DelayChannel}:

\begin{itemize}
    \item \ttt{datarate} is a \ttt{double} parameter that represents the
          bandwidth of the channel, and it is used for calculating the
          transmission duration of packets. Values need to be specified
          with bits per second or its multiples as unit (\ttt{bps},
          \ttt{Kbps}, \ttt{Mbps}, \ttt{Gbps}, etc.) Zero is treated
          specially and results in zero transmission duration, i.e.
          it stands for infinite bandwidth. Zero is also the default.
    \item \ttt{ber} and \ttt{per} stand for Bit Error Rate and Packet Error Rate,
          and allow basic error modelling. They expect a \ttt{double}
          in the $[0,1]$ range. When the channel decides (based on random
          numbers) that an error occurred during transmission a packet,
          it sets an error flag in the packet object. The receiver
          module is expected to check the flag, and discard the packet
          as corrupted if it is set. The default \ttt{ber} and \ttt{per}
          are zero.
\end{itemize}

\begin{note}
    XXX "deliver on first bit": this can be specified in C++
\end{note}

XXX example DatarateChannel

\begin{Verbatim}[commandchars=\\\{\}]
channel C extends ned.DatarateChannel
\{
    datarate = 100Mbps;
    delay = 100us;
    ber = 1e-10;
\}
\end{Verbatim}

XXX connections: one of the latter 2 built-in types are chosen for connections.

XXX Channels may have parameters; you can also add parameters and properties
via subclassing. Even if you don't modify the underlying C++ class,
they may be read and used by other parts of the model. For example,
adding a \ttt{cost} parameter (or \ttt{@cost} property) may be observed
by the routing algorithm and used for routing decisions.


\section{Parameters}

Parameters are variables that belong to a module. Parameters can be
used in building the topology (number of nodes, etc), and to supply
input to C++ code that implements simple modules and channels.

Parameters can be of type \fkeyword{double}, \fkeyword{int},
\fkeyword{bool}, \fkeyword{string} and \fkeyword{xml}; they can also
be declared \fkeyword{volatile}. For the numeric types, a unit of
measurement can also be specified (\ttt{@unit} property), to increase
type safety.

Parameters can get their value from NED files or from the configuration
(\ttt{omnetpp.ini}). A default value can also be given (\ttt{default(}...\ttt{)}),
which gets used if the parameter is not assigned otherwise.

Let use see an example before we go into details:

\begin{Verbatim}[commandchars=\\\{\}]
simple App
\{
    parameters:
        int address;  // local node address
        string destAddresses;  // destination addresses
        volatile double sendIaTime @unit(s) = default(exponential(1s));
                               // time between generating packets
        volatile int packetLength @unit(byte);  // length of one packet
    ...
\}
\end{Verbatim}

\subsubsection{Values}

may be assigned in submodules

via inheritance  (examples!!!)

in the configuration

C-like expression etc

\subsubsection{volatile}

The \fkeyword{volatile} modifier causes the parameter's value expression to
be evaluated every time the parameter is read. This has significance if the
expression is not constant, for example it involves numbers drawn from a
random number generator. In contrast, non-volatile parameters are evaluated
only once. (This practically means that they are evaluated and replaced
with the resulting constant at the start of the simulation.)

To better understand \fkeyword{volatile}, let's suppose we have an
\ttt{ActiveQueue} simple module that has a \ttt{volatile double} parameter
named \ttt{serviceTime}.

XXX ??? random serviceTime altalaban hulyeseg, maradjunk az iatime-nel

The queue module's C++ implementation would re-read the \ttt{serviceTime}
parameter at runtime for every job serviced; so if \ttt{serviceTime} is
assigned an expression like \ttt{uniform(0.5s, 1.5s)}, every job would have
a different, random service time.

In practice, a volatile parameter usually means that the underlying C++
code will re-read the parameter every time a value is needed at runtime, so
the parameter can be used a source of random numbers.

\begin{note}
    This does not mean that a non-volatile parameter cannot be assigned a value
    like \ttt{uniform(0.5s, 1.5s)}. It can, but that has a totally different
    effect. Had we omitted the \ttt{volatile} keyword from the
    \ttt{serviceTime} parameter, for example, the effect would be that every
    job had the \textit{same} constant service time, say \ttt{1.2975367s},
    chosen randomly at the beginning of the simulation.
\end{note}

\subsubsection{Units}

One can declare a parameter to have an associated unit of measurement,
by adding the \ttt{@unit} property.

The \ttt{serviceTime} parameter is decorated with \ttt{@unit(s)}. This means
that the value must be specified in either seconds, or in a measurement unit {\opp}
can convert to seconds, like milliseconds or hours; dimensionless numbers
will not be accepted. The {\opp} runtime does a full and rigorous unit check on
parameters to ensure ``unit safety'' of models.

XXX see \_\_SCRATCH for more....


\subsubsection{XML parameters}

Sometimes modules need more complex input than simple module parameters
can describe. Then you'd put these parameters into an external config file,
and let the modules read and process the file. You'd pass the file name
to the modules in a string parameter.

These days, XML is increasingly becoming a standard format for configuration
files as well, so you might as well describe your configuration in XML.
From the 3.0 version, {\opp} contains built-in support for XML config files.

{\opp} wraps the XML parser (LibXML, Expat, etc.), reads and DTD-validates
the file (if the XML document contains a DOCTYPE), caches the file
(so that if you refer to it from several modules, it'll still be loaded
only once), lets you pick parts of the document via an XPath-subset notation,
and presents the contents to you in a DOM-like object tree.

This machinery can be accessed via the NED parameter type \ttt{xml}, and the
\ttt{xmldoc()} operator. You can point \ttt{xml}-type module parameters
to a specific XML file (or to an element inside an XML file) via the
\ttt{xmldoc()} operator. You can assign \ttt{xml} parameters both from NED
and from \ttt{omnetpp.ini}.

XXX add a complete example!


\section{Gates}

Gates are the connection points of modules.  {\opp} has three types of
gates: \textit{input}, \textit{output} and \textit{inout}, the latter being
essentially an input and an output gate glued together.

A gate, whether input or output, cannot be connected to two or more other
gates. (For compound module gates, this means one connection "outside" and
one "inside".)  It is possible, though generally not recommended, to
connect the input and output sides of an inout gate separately.

One can create single gates and gate vectors. The size of a gate vector
can be given inside square brackets in the declaration, but it also possible
to leave it open by just writing a pair of empty brackets ("\ttt{[]}").

When the gate vector size is left open, one can still specify it later,
when subclassing the module, or when using the module for a submodule in a
compound module. However, it does not need to be specified, because
one can create connections with the \ttt{$gate$++} operator that
automatically expands the gate vector.

The gate size can be queried from various NED expressions with the
\ttt{sizeof()} operator.

NED normally requires that all gates be connected. To relax this
requirement, you can annotate selected gates with the \ttt{@loose}
property, which turns off connectivity check for that gate. Also, input
gates that solely exist so that the module can receive messages via
\fname{sendDirect()} (see XXX) should be annotated with \ttt{@directIn}.
(\ttt{@directIn} gates must remain unconnected.) It is also possible
to turn off connectivity check for all gates within a compound module, by
specifying the \fkeyword{allowunconnected} keyword in the module's
connections section.

Let us see some examples.

In the following example, the \ttt{Classifier} module has one input for
receiving jobs, which it will send to one of the outputs. The number of
outputs is determined by a module parameter:

\begin{verbatim}
simple Classifier {
    parameters:
        int numCategories;
    gates:
        input in;
        output out[numCategories];
}
\end{verbatim}

The following \ttt{Sink} module also has its \ttt{in[]} gate defined
as vector, so that it can be connected to several modules:

\begin{verbatim}
simple Sink {
    gates:
        input in[];
}
\end{verbatim}

A node for building a square grid. Gates around the edges of the grid are
expected to remain unconnected, hence the \ttt{@loose} annotation:

\begin{verbatim}
simple GridNode {
    gates:
        inout neighbour[4] @loose;
}
\end{verbatim}

\ttt{WirelessNode} below is expected to receive messages (radio transmissions)
via direct sending, so its \ttt{radioIn} gate is marked with \ttt{@directIn}.

\begin{verbatim}
simple WirelessNode {
    gates:
        input radioIn @directIn;
}
\end{verbatim}

fsdfsdfsdfsdf

\begin{verbatim}
simple TreeNode {
    gates:
        inout parent;
        inout children[];
}

simple BinaryTreeNode extends TreeNode {
    gates:
        children[2];
}
\end{verbatim}

XXX submodule example

example: creating the same number of submodules as parent module gate vector size



\section{Submodules}

scalar submodule, vector submodule (vector size cannot be left open as with gates)

type is another NED module type, simple or compound. it is also possible
to specify the type with a string expression, more about it later...

Syntactically, a submodule may have a curly brace block as body, where
it is possible to assign its parameters (see \ttt{address} in the example),
set the size of gate vectors, or to add properties like the display string
(\ttt{@display}). Display strings specified here will be merged with the
display string from the type to get the effective display string.
The \ttt{"p="} tag used here means position on the canvas.

example...

inheritance can add new submodules....

---

Submodules\index{module!submodule} are defined in the
\fkeyword{submodules} section of a compound
module declaration. Submodules are identified by names.
By convention, submodule names begin with lower-case letters.

Any module type (simple or compound module) can be
used as a submodule.

Submodules are instances of a module type, either simple
or compound -- there is no distinction.

It is possible to define vectors of submodules, and the
size of the vector may come from a parameter value.

When defining submodules, you can assign values to their
parameters, and if the corresponding module type has gate vectors,
you have to specify their sizes.


\subsubsection{Submodule vectors}

It is possible to create an array\index{module!array} of
submodules\index{submodule|see{module}} (a module
vector\index{module!vector}).  This is done with an expression between
brackets right behind the module type name. The expression can refer
to module parameters. A zero value as module count is also allowed.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
    node[2*size+1]: Node;
\end{Verbatim}

there are submodule vectors;
submodule body may assign parameters, specify gate sizes

submodule type may be parameter, but see this later

we can replace node1, node2 etc with node[]:

\begin{Verbatim}
network Net6
{
    submodules:
        node[5]: Node {
            address = index;
        }
    connections:
        node[1].port++ <--> node[2].port++;
        node[2].port++ <--> node[4].port++;
        node[4].port++ <--> node[6].port++;
        node[1].port++ <--> node[3].port++;
        node[3].port++ <--> node[5].port++;
        node[5].port++ <--> node[6].port++;
        node[2].port++ <--> node[5].port++;
        node[3].port++ <--> node[4].port++;
}
\end{Verbatim}


\section{Connections, channels}

input and output gates are connected with a normal arrow, and inout gates
with a double-headed arrow ``\ttt{<-->}''. Submodule vectors and gate
vectors can be connected with the familiar \ttt{for} syntax. Nesting and
conditional connections (\ttt{if}), although not shown here, are also
possible.

\begin{Verbatim}
<--> {delay=10ms; datarate=1e-8;} <-->
\end{Verbatim}

we can use the channel type C.

channel types

Channels types resemble simple modules in the sense that they need an underlying
C++ class to function, the NED declaration itself is not enough. Our
\ttt{Backbone} channel inherits this C++ class from \ttt{ned.DatarateChannel}.

FIXME @class, @namespace

A channel definition specifies a connection type of some given characteristics.
Let us see an example channel:

\begin{Verbatim}[commandchars=\\\{\}]
channel Backbone extends ned.DatarateChannel
\{
    parameters:
        delay = 2ms;
        datarate = 10Gbps;
\}
\end{Verbatim}

\begin{note}
    The \ttt{parameters:} keyword is optional (everywhere, not only in
    channels), so it can be left out.
\end{note}

Our \ttt{Backbone} channel type extends (subclasses, builds upon) the
\ttt{ned.DatarateChannel} channel type. (In the latter name, \ttt{ned} is the
package name, and \ttt{DatarateChannel} is the actual type name.)
\ttt{ned.DatarateChannel} is a built-in NED type, and it declares the
following parameters: \ttt{delay} (propagation delay), \ttt{ber} (bit error rate),
\ttt{per} (packet error rate), \ttt{datarate} (channel bandwidth, used for
calculating transmission time of a packet), and \ttt{disabled} (a boolean parameter).

\ttt{ned.DatarateChannel} initializes these parameters to provide an ideal channel
(zero delay and bit error rate, infinite data rate). In the above
declaration, we override \ttt{delay} and \ttt{datarate} to get our custom
channel.

TODO other channel types; implicit selection based on parameters

Another channel type, \ttt{ned.DelayChannel} only defines the \ttt{delay}
and \ttt{disabled} parameters, and may be used in, say, queueing
network simulations.

The simplest built-in channel type is \ttt{ned.IdealChannel}.
It defines no parameters, and its C++ implementation
does nothing but let the message though without any change or delay.
It is used... XXX




\section{Multiple Connections}

Simple programming constructs (loop, conditional) allow creating
multiple connections easily.

Example...

Let use see more connection examples.

\subsubsection{Chain}

One can create a chain\index{chain} of modules like this:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} Chain
    \tbf{parameters}:
        int count;
    \tbf{submodules}:
        node[count] : Node \{
            \tbf{gates}:
                port[2];
        \}
    \tbf{connections allowunconnected}:
        \tbf{for} i = 0..count-2 \{
            node[i].port[1] <--> node[i+1].port[0];
        \}
\}
\end{Verbatim}


\subsubsection{Binary Tree}

One can use conditional connections to build a binary tree\index{binary tree}.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{simple} BinaryTreeNode \{
    \tbf{gates}:
        \tbf{inout} left;
        \tbf{inout} right;
        \tbf{inout} parent;
\}

\tbf{module} BinaryTree \{
    \tbf{parameters}:
        int height;
    \tbf{submodules}:
        node[2^height-1]: BinaryTreeNode;
    \tbf{connections} \tbf{allowunconnected}:
        \tbf{for} i=0..2^(height-1)-2 \{
            node[i].left <--> node[2*i+1].parent;
            node[i].right <--> node[2*i+2].parent;
        \}
\}
\end{Verbatim}

Note that not every gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the \fkeyword{allowunconnected} modifier.
Consequently, it is the simple modules' responsibility not to send
on a gate which is not leading anywhere.



\subsubsection{Random graph}

Conditional connections can also be used to generate random
topologies\index{topology!random}.  The following code generates a
random subgraph of a full graph:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} RandomGraph \{
    \tbf{parameters}:
        int count;
        double connectedness; // 0.0<x<1.0
    \tbf{submodules}:
        node[count]: Node \{
            \tbf{gates}:
                \tbf{in}[count];
                \tbf{out}[count];
        \}
    \tbf{connections} \tbf{allowunconnected}:
        \tbf{for} i=0..count-1, j=0..count-1 \{
            node[i].out[j] --> node[j].in[i]
                \tbf{if} i!=j && uniform(0,1)<connectedness;
        \}
\}
\end{Verbatim}

Note the use of the \fkeyword{allowunconnected} modifier
here too, to turn off error messages given by the network setup code
for unconnected gates.


\subsection{Design patterns for compound modules}

\index{module!compound!patterns}
\index{topology!patterns}

Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are
described below.


\subsubsection{`Subgraph of a Full Graph'}


This pattern takes a subset of the connections of a full graph.  A
condition is used to ``carve out'' the necessary interconnection from
the full graph:

\begin{Verbatim}[commandchars=\\\{\}]
for i=0..N-1, j=0..N-1 \{
    node[i].out[...] --> node[j].in[...] if condition(i,j);
\}
\end{Verbatim}

The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate $condition(i,j)$ can be formulated. For example,
when generating a tree\index{topology!tree} structure, the condition
would return whether node $j$ is a child of node $i$ or
vica versa.

Though this pattern is very general, its usage can be prohibitive if
the $N$ number of nodes is high and the graph is sparse (it has
much fewer connections that $N^2$). The following
two patterns do not suffer from this drawback.


\subsubsection{`Connections of Each Node'}

The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

\begin{Verbatim}[commandchars=\\\{\}]
for i=0..Nnodes, j=0..Nconns(i)-1 \{
    node[i].out[j] --> node[rightNodeIndex(i,j)].in[j];
\}
\end{Verbatim}

The Hypercube\index{topology!hypercube} compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

The applicability of this pattern depends on how easily the $rightNodeIndex(i,j)$
function can be formulated.


\subsubsection{``Enumerate All Connections''}


A third pattern is to list all connections within a loop:

\begin{Verbatim}[commandchars=\\\{\}]
for i=0..Nconnections-1 \{
    node[leftNodeIndex(i)].out[...] --> node[rightNodeIndex(i)].in[...];
\}
\end{Verbatim}

The pattern can be used if $leftNodeIndex(i)$ and $rightNodeIndex(i)$
mapping functions can be sufficiently formulated.

The \ttt{Chain} module is an example of this approach where the mapping
functions are extremely simple: $leftNodeIndex(i)=i$ and $rightNodeIndex(i) = i+1$.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

In the case of irregular structures where none of the above patterns
can be employed, you can resort to specifying constant submodule/gate
vector sizes and explicitly listing all connections, like you
would do it in most existing simulators.



\section{Submodule type as parameter}

\begin{Verbatim}
network Net6
{
    parameters:
        string nodeType;
    submodules:
        node[5]: <nodeType> like INode {
            address = index;
        }
    connections:
        ...
}
\end{Verbatim}

\begin{Verbatim}
moduleinterface INode
{
    parameters:
        int address;
    gates:
        inout port[];
}
\end{Verbatim}

\begin{Verbatim}
module SomeNode like INode
{
    parameters:
        int address;
        ...
    gates:
        inout port[];
        ...
}
\end{Verbatim}



\section{Properties (metadata annotations)}

@display, @unit, @prompt, @namespace, @class etc are properties

metadata annotations: using properties, one can attach extra information
to NED elements. some properties are interpreted by NED or the simkernel,
others you may choose to interpret in the model, or model editing tools
can use it etc.

properties are attached to the type, so you cannot have per-instance different
properties

properties have names; if you want to add more than one property with the
same name, use an index.  example...

properties can have a rich data model. keys, value lists, etc...
special case: how boolean properties are interpreted...

how properties are inherited. type, parameter and gate properties as well



\section{Inheritance}
\label{sec:ch-ned-lang:inheritance}

just a summary, because inheritance details have already been explained
at parameters, gates etc section

Single inheritance is supported between modules.

summarize the rules (copy from ned ref?)



\section{Packages}

Small simulation projects are fine to have all NED files in a single
directory. When a project grows, however, it sooner or later becomes
inevitable to introduce a directory structure, and sort the NED files into
them. NED natively supports directory trees with NED files, and calls
directories \textit{packages}. Packages are also useful for reducing
name clashes, because names can be qualified with the package name.

\begin{note}
    NED packages are based on the Java package concept, with minor
    enhancements. If you are familiar with Java, you'll find little
    surprise in this section.
\end{note}

\subsubsection{Overview}

When a simulation is run, you must tell the simulation kernel the
directory which is the root of your package tree; let's call it
\textit{NED source folder}. The simulation kernel will traverse
the whole directory tree, and load all NED files from every directory.
You can have several NED directory trees, and their roots (the NED source
folders) should be given to the simulation kernel in the NEDPATH
variable. NEDPATH can be specified in several ways: as an environment
variable (\ttt{NEDPATH}), as a configuration option (\fconfig{ned-path}),
or as a command-line option to the simulation runtime. NEDPATH is
described in details in XXX.

Directories in a NED source tree correspond to packages. If you have
NED files in a \ttt{<root>/a/b/c} directory (where \ttt{<root>}
gets listed in NEDPATH), then the package name is \ttt{a.b.c}.
The package name has to be explicitly declared at the top of the NED
files as well, like this:

\begin{Verbatim}
package a.b.c;
\end{Verbatim}

The package name that follows from the directory name and the declared
package must match; it is an error if they don't. (The only exception
is the root \ttt{package.ned} file, as described below.)

By convention, package names are all lowercase, and begin with either
the project name (\ttt{myproject}), or the reversed domain name plus the
project name (\ttt{org.example.myproject}). The latter convention
would cause the directory tree to begin with a few levels of empty
directories, but this can be eliminated with a toplevel \ttt{package.ned}.

NED files called \fname{package.ned} have a special role, as they are meant
to represent the whole package. For example, comments in
\fname{package.ned} are treated as documentation of the package. Also, a
\ttt{@namespace} property in a \fname{package.ned} file affects all NED
files in that directory and all directories below.

The toplevel \fname{package.ned} file can be used to designate the root
package, which is useful for eliminating a few levels of empty directories
resulting from the package naming convention. That is, if you have a
\fname{package.ned} file in your \ttt{<root>} directory whose package
declaration says \ttt{org.example.myproject}, then the \ttt{<root>/a/b/c}
directory will be package \ttt{org.example.myproject.a.b.c} -- and NED
files in them must contain that as package declaration. Only the root
\fname{package.ned} has this property, other \fname{package.ned}'s cannot
change the package.

Let's look at the INET Framework as example, which contains hundreds of NED
files in several dozen packages. The directory structure looks like this:

\begin{Verbatim}
INET/
    src/
        base/
        transport/
            tcp/
            udp/
            ...
        networklayer/
        linklayer/
        ...
    examples/
        adhoc/
        ethernet/
        ...
\end{Verbatim}

The \ttt{src} and \ttt{examples} subdirectories are denoted as NED source
folders, so NEDPATH is the following (provided INET was unpacked in
\ttt{/home/joe}):

\begin{Verbatim}
/home/joe/INET/src;/home/joe/INET/examples
\end{Verbatim}

Both \ttt{src} and \ttt{examples} contain \fname{package.ned} files to
define the root package:

\begin{Verbatim}
// INET/src/package.ned:
package inet;
\end{Verbatim}

\begin{Verbatim}
// INET/examples/package.ned:
package inet.examples;
\end{Verbatim}

And other NED files follow the package defined in \fname{package.ned}:

\begin{Verbatim}
// INET/src/transport/tcp/TCP.ned:
package inet.transport.tcp;
\end{Verbatim}


\subsubsection{Name resolution, imports}

We already mentioned that packages can be used to distinguish
similarly named NED types. The name that includes the package name
(\ttt{a.b.c.Queue} for a \ttt{Queue} module in the \ttt{a.b.c}
package) is called \textit{fully qualified name}; without the package
name (\ttt{Queue}) it is called \textit{simple name}.

Simple names alone are not enough to unambiguously identify a type.
Here is how you can refer to an existing type:

\begin{enumerate}
  \item By fully qualified name. This is often cumbersome though,
        as names tend to be too long;
  \item Import the type, then the simple name will be enough;
  \item If the type is in the same package, then it doesn't need to be
        imported; it can be referred to by simple name
\end{enumerate}

TODO import rules

TODO import examples


\subsubsection{Name resolution with "like"}

The situation is a little different for submodule and connection channel
specifications using the \fkeyword{like} keyword, when the type name comes
from a string-valued expression (see section XXX about submodule and
channel types as parameters). Imports are not much use here: at the time of
writing the NED file it is not yet known what NED types will be suitable
for being "plugged in" there, so they cannot be imported in advance.

There is no problem with fully qualified names, but simple names need
to be resolved differently. What NED does is this: it determines which
interface the module or channel type must implement (i.e. \ttt{... like INode}),
and then collects the types that have the given simple name AND implement
the given interface. There must be exactly one such type, which is then used.
If there's none or there's more than one, it will be reported as an error.

Let us see the following example:

\begin{Verbatim}
module MobileHost
{
    parameters:
        string mobilityType;
    submodules:
        mobility: <mobilityType> like IMobility;
        ...
}
\end{Verbatim}

and suppose that the following modules implement the \ttt{IMobility} module
interface: \ttt{inet.mo\-bility.Random\-Walk}, \ttt{inet.adhoc.RandomWalk},
\ttt{inet.mobility.MassMobility}; and suppose that there's also a type
called \ttt{inet.examples.adhoc.MassMobility} but it does not implement the
interface.

So if \ttt{mobilityType="MassMobility"}, then
\ttt{inet.mobility.MassMobility} will be selected; the other
\ttt{MassMobility} doesn't interfere. However, if
\ttt{mobilityType="RandomWalk"}, then it's an error because there're two
matching \ttt{RandomWalk} types. Both \ttt{RandomWalk}'s can still be used,
but one must explicitly choose one of them by providing a package name:
\ttt{mobility\-Type="inet.ad\-hoc.Random\-Walk"}.


\subsubsection{The default package}

It is not mandatory to make use of packages: if all NED files are in a
single directory listed on the NEDPATH, then package declarations (and
imports) can be omitted. Those files are said to be in the \textit{default
package}.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:



