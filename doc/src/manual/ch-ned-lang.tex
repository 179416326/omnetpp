\chapter{The NED Language}
\label{cha:the-ned-language}


\section{NED overview}

The user describes the structure of a simulation model in the NED language.
NED stands for Network Description. NED lets the user declare simple modules,
and connect and assemble them into compound modules. The user can label
some compound modules as \textit{networks}, self-contained simulation
models. Channels are another component type, whose instances can also be used
in compound modules.

The NED languge has several features which let it scale well to large projects:

\begin{description}

\item[Hierarchical] The traditional way to deal with complexity is via
introducing hierarchies. In \opp, any module which would be too complex as
a single entity can be broken down into smaller modules, and used as a
compound module.

\item[Component-Based] Simple modules and compound modules are inherently
reusable, which not only reduces code copying, but more importantly, allows
component libraries (like the INET Framework, MiXiM, Castalia, etc.) to
exist.

\item[Interfaces] Module and channel interfaces can be used as a
placeholder where normally a module or channel type would be used, and the
concrete module or channel type is determined at network setup time by a
parameter. Concrete module types have to ``implement'' the interface they
can substitute. For example, given a compound module type named
\ttt{MobileHost} contains a \ttt{mobility} submodule of the type
\ttt{IMobility} (where \ttt{IMobility} is a module interface), the actual
type of \ttt{mobility} may be chosen from the module types that implemented
\ttt{IMobility} (\ttt{RandomWalkMobility}, \ttt{TurtleMobility}, etc.)

\item[Inheritance] Modules and channels can be subclassed. Derived modules
and channels may add new parameters, gates, and (in the case of compound
modules) new submodules and connections. They may set existing parameters
to a specific value, and also set the gate size of a gate vector. This
makes it possible, for example, to take a \ttt{GenericTCPClientApp} module
and derive an \ttt{FTPApp} from it by setting certain parameters to a fixed
value; or derive a \ttt{WebClientHost} compound module from a
\ttt{BaseHost} compound module by adding a \ttt{WebClientApp} submodule and
connecting it to the inherited \ttt{TCP} submodule.

\item[Packages] To address name clashes between different models and to
simplify specifying which NED files are needed by a specific simulation
model, the NED language features a Java-like package structure.

\item[Inner types] Channel types and module types used locally by a
compound module can be defined within the compound module, in order to
reduce namespace pollution.

\item[Metadata annotations] It is possible to annotate module or channel
types, parameters, gates and submodules by adding properties. Metadata are
not used by the simulation kernel directly, but they can carry extra
information for various tools, the runtime environment, or even for other
modules in the model. For example, a module's graphical representation
(icon, etc)  or the prompt string and physical unit (milliwatt, etc) of a
parameter are already specified as metadata annotations.

\end{description}

\begin{note}
    The NED language has changed significantly in the 4.0 version.
    Inheritance, interfaces, packages, inner types, metadata annotations, inout
    gates were all added in the 4.0 release, together with many other features.
    Since the basic syntax has changed as well, old NED files need to be
    converted to the new syntax. There are automated tools for this purpose, so
    manual editing is only needed to take advantage of new NED features.
\end{note}

The NED language has an equivalent tree representation which can be
serialized to XML; that is, NED files can be converted to XML and back
without loss of data, including comments. This lowers the barrier for
programmatic manipulation of NED files, for example extracting information,
refactoring and transforming NED, generating NED from information stored in
other system like SQL databases, and so on.

\begin{note}
    This chapter is going to explain the NED language gradually, via examples.
    Users looking for a more formal treatment might want to read to the
    language grammar in Appendix \ref{cha:ned-language-grammar} in addition to
    the more reference-style sections in this chapter.
\end{note}


\section{Elements of the language}

\subsection{NED files}

NED files have the \texttt{.ned} file name suffix. This is mandatory, and
cannot be changed.


\subsection{Reserved words}
\index{ned!keywords}

Authors have to take care that no reserved words are used for names.
The reserved words of the NED language are:

\ttt{allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inout input int like
module moduleinterface network output package parameters property simple
sizeof string submodules this true types volatile xml xmldoc}


\subsection{Identifiers}
\index{ned!identifiers}

Identifiers are the names of modules, channels, networks,
submodules, parameters, gates, channel attributes and functions.

Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and the underscore ``\_''.
Identifiers may only begin with a letter or the underscore.

If you have identifiers that are composed of several words, the convention
is to capitalize the beginning of every word (``camel case''). Also, it is
recommended that you begin the names of types (modules, channels, networks,
etc.) with a capital letter, and the names of parameters, gates and submodules
with a lower-case letter.


\subsection{Case sensitivity}
\index{ned!case sensitivity}

The network description and all identifiers in it are case sensitive.
For example, \ttt{TCP} and \ttt{Tcp} are two different names.


\subsection{Comments}
\index{ned!comments}

Comments can be placed anywhere in the NED file, with the usual C++
syntax: comments begin with a double slash `//', and last until
the end of the line.


\section{Simple modules}

Simple modules are the basic building blocks for other (compound)
modules. By convention, module names begin with upper-case letters.

An example simple module declaration:

%% FIXME TODO syntax highlight here and everywhere

\begin{Verbatim}[commandchars=\\\{\}]
//
// A queue with a built-in server
//
simple Queue
\{
    parameters:
        @display("i=block/queue;q=queue");
        int capacity = default(-1);  // use -1 for unlimited
        volatile double serviceTime @unit(s);
    gates:
        input in[];
        output out;
\}
\end{Verbatim}

This declares a simple module named \ttt{Queue}, which has two parameters
\ttt{capacity} and \ttt{serviceTime}, and two gates \ttt{in} and \ttt{out}.

Notice that this declaration doesn't contain any code to define the operation
of the queue itself: that part is expressed in C++. By default, \opp looks for a
C++ class of the same name (so here, \ttt{Queue}), although this gets slightly
more complicated if C++ namespaces or NED packages are present, and the user
can also explicitly specify which C++ class to use.

The \ttt{capacity} parameter is created with the type \ttt{int}, and
\ttt{serviceTime} with \ttt{double}. Other NED parameter types include
\ttt{bool}, \ttt{string} and \ttt{xml}. Parameters can be read from C++ code,
and they can get values from NED code, from the configuration (ini files, see
FIXME), or interactively from the user. It is also possible to give them a default value (see
\ttt{default(-1)} in the example), which gets assigned to the parameter if a
matching \ttt{apply-default=true} line is found in the configuration.

%% FIXME maybe not here but in with compound modules?
\begin{note}
    How do you decide whether to assign a parameter from NED or from and ini
    file? The point of ini files is a cleaner separation of the \textit{model}
    and \textit{experiments}. NED files (together with C++ code) are considered
    to be part of the model, and to be more or less constant. Ini files, on
    the other hand, are for experimenting with the model, by running it
    several times with different parameters. Thus, parameters that are expected
    to change (or make sense to be changed) during experimentation should be
    put into ini files.
\end{note}

The \ttt{serviceTime} parameter is decorated with \ttt{@unit(s)}. This means
that the value must be specified in either seconds, or in a physical unit \opp
can convert to seconds, like milliseconds or hours; dimensionless numbers
will not be accepted. The \opp runtime does a full and rigorous unit check on
parameters to ensure ``unit safety'' of models.

\ttt{serviceTime} is also declared \ttt{volatile}: this indicates that the
underlying C++ code is going to re-read the parameter at runtime for every
use of it; for example, this queue would re-read the parameter for every job
serviced. Thus, it makes sense to assign \ttt{serviceTime} a random value like
\ttt{uniform(0.5s, 1.5s)}, which would result in every job to have a different,
random service time. Non-volatile parameters, however, are evaluated and
replaced with a constant at the start of the simulation.

\begin{note}
    This does not mean that a non-volatile parameter cannot be assigned a value
    like \ttt{uniform(0.5s, 1.5s)}. It can, but that has a totally different
    effect. Had we omitted the \ttt{volatile} keyword from the
    \ttt{serviceTime} parameter, for example, the effect would be that every
    job had the \textit{same} constant service time, say \ttt{1.2975367s},
    chosen randomly at the beginning of the simulation.
\end{note}

So far we have neglected the \ttt{@display} line in the above code. It is called
\textit{display string}, and specifies how the module appears in the animation.
This particular display string specifies a default icon
(\ttt{block/queue}), and requests that the length of an internal C++ queue
object named \ttt{queue} be displayed next to the module icon. Other display
strings may specify position, color, arrangement, etc. of modules. The
syntactical similarity of \ttt{@display} to \ttt{@unit} is not accidental; they
are both metadata annotations (\textit{properties} in \opp), recognized and
treated specially by the runtime.

Gates are the connection points of modules. \opp has three types of gates:
\textit{input}, \textit{output} and \textit{inout}, the latter being essentially
an input and an output gate glued together. The C++ code that implements the
simple module may send and receive messages via gates. Gates allow one-to-one
connections, but in this example the \ttt{in} gate is declared as a \textit{gate
vector} (or \textit{vector gate}) in order to allow several sources to send jobs
into the queue. The size of the gate vector (the number of gates in it) is left
undefined here, letting actual users (compound modules or networks that
instantiate this module type) create as many gates as they want.

\begin{note}
    In many other systems, the equivalent of \opp gates are called
    \textit{ports}. We have retained the term \textit{gate} to reduce
    collisions with other uses of the otherwise overloaded word
    \textit{port}: router port, TCP port, I/O port, etc.
\end{note}

Parameters and gates will be discussed in detail in section FIXME.

Comments in the NED source also serve a purpose in addition to making the
NED source more readable: in the \opp IDE they get displayed at various places (tooltips,
content assist, etc), and become part of the documentation extracted from the
NED files. The NED documentation system, not completely unlike \textit{JavaDoc}
or \textit{Doxygen}, will be described in Chapter \ref{cha:neddoc}.


\section{Channels}
\index{channel}
\index{channel!definition}
\index{channel!delay}
\index{channel!error}
\index{channel!datarate}

A channel definition specifies a connection type of given characteristics.
The channel name can be used later in the NED description to
create connections with these parameters.

The syntax:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{channel} ChannelName
    //...
\tbf{endchannel}
\end{Verbatim}

Three attributes can be assigned values in the body of the channel declaration,
all of them are optional: \ttt{delay}, \ttt{error} and \ttt{datarate}.
\ttt{delay} is the propagation delay in (simulated) seconds;
\ttt{error} is the bit error rate that speficifies the probability
that a bit is incorrectly transmitted; and \ttt{datarate}
is the channel bandwidth in bits/second, used for calculating
transmission time of a packet. The attributes can appear
in any order.

The values should be constants.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{channel} LeasedLine
    \tbf{delay} 0.0018  // sec
    \tbf{error} 1e-8
    \tbf{datarate} 128000  // bit/sec
\tbf{endchannel}
\end{Verbatim}




\section{Compound modules}

Compound modules are modules composed of one or more submodules.
Any module type (simple or compound module) can be used as a submodule.
Like simple modules, compound modules can also have gates and parameters,
and they can be used wherever simple modules can be used.

It is useful to think about compound modules as ``cardboard boxes''
that help you organize your simulation model and bring structure into
it. No active behaviour is associated with compound modules -- they
are simply for grouping modules into larger components that can
can be used either as a model (see section \ref{sec:ch-ned-lang:network})
or as a building block for other compound modules.

By convention, module type names (and so compound module type names, too)
begin with upper-case letters.

Submodules may use parameters of the compound module.
They may be connected with each other and/or with
the compound module itself.

A compound module definition\index{module!compound!definition} looks
similar to a simple\index{module!simple} module definition:
it has \texttt{gates} and \texttt{parameters} sections.
There are two additional sections, \texttt{submodules} and
\texttt{connections}.

The syntax for compound modules is the following:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} CompoundModule
    \tbf{parameters}:
        //...
    \tbf{gates}:
        //...
    \tbf{submodules}:
        //...
    \tbf{connections}:
        //...
\tbf{endmodule}
\end{Verbatim}

All sections (\texttt{parameters}, \texttt{gates}, \texttt{submodules},
\texttt{connections}) are optional.



\subsection{Compound module parameters and gates}

Parameters\index{module!compound!parameters} and gates \index{gate}
for compound modules are declared and work in the same way
as with simple modules, described in sections
\ref{sec:ch-ned-lang:simple-module-param}
and \ref{sec:ch-ned-lang:simple-module-gates}.

Typically, compound module parameters are passed to submodules and
used for initializing their parameters.

Parameters can also be used in defining the internal structure of
the compound module: the number of submodules and sizes of gate vectors
can be defined with the help of parameters, and parameters can
also be used in defining the connections inside the compound module.
As a practical example, you can create a \ttt{Router} compound module
with a variable number of ports, specified in a \ttt{numOfPorts} parameter.

Parameters affecting the internal structure should always be declared
\ttt{const}, so that accessing them always yields the same value.
Otherwise, if the parameter was assigned a random value, one could
get a different value each time the parameter is accessed during building
the internals of the compound module, which is surely not what was meant.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} Router
    \tbf{parameters}:
        packetsPerSecond : \tbf{numeric},
        bufferSize : \tbf{numeric},
        numOfPorts : \tbf{const};
    \tbf{gates}:
        \tbf{in}: inputPort[];
        \tbf{out}: outputPort[];
    \tbf{submodules}: //...
    \tbf{connections}: //...
\tbf{endmodule}
\end{Verbatim}


\subsection{Submodules}

Submodules\index{module!submodule} are defined in the
\fpar[ned!keywords!submodules]{submodules:} section of a compound
module declaration. Submodules are identified by names.
By convention, submodule names begin with lower-case letters.

Submodules are instances of a module type, either simple
or compound -- there is no distinction. The module type
must be known to the NED compiler, that is, it must have appeared
earlier in the same NED file or have been imported from another
NED file.

It is possible to define vectors of submodules, and the
size of the vector may come from a parameter value.

When defining submodules, you can assign values to their
parameters, and if the corresponding module type has gate vectors,
you have to specify their sizes.


Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} CompoundModule
    //...
    \tbf{submodules}:
        submodule1: ModuleType1
            \tbf{parameters}:
                //...
            \tbf{gatesizes}:
                //...
        submodule2: ModuleType2
            \tbf{parameters}:
                //...
            \tbf{gatesizes}:
                //...
\tbf{endmodule}
\end{Verbatim}


\subsubsection{Submodule vectors}


It is possible to create an array\index{module!array} of
submodules\index{submodule|see{module}} (a module
vector\index{module!vector}).  This is done with an expression between
brackets right behind the module type name. The expression can refer
to module parameters. A zero value as module count is also allowed.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} CompoundModule
    \tbf{parameters}:
        size: \tbf{const};
    \tbf{submodules}:
        submod1: Node[3]
            //...
        submod2: Node[size]
            //...
        submod3: Node[2*size+1]
            //...
\tbf{endmodule}
\end{Verbatim}



\subsection{Submodule type as parameter}
\label{sec:ch-ned-lang:like}
\index{module!as parameter}

Sometimes it is convenient to make the name of a submodule type a parameter,
so that one can easily `plug in' any module there.

For example, assume the purpose of your simulation study is
to compare different routing algorithms. Suppose you programmed
the needed routing algorithms as simple modules: \texttt{DistVecRoutingNode},
\texttt{AntNetRouting1Node}, \texttt{AntNetRouting2Node}, etc.
You have also created the network topology as a compound module
called \ttt{RoutingTestNetwork}, which will serve as a testbed for your routing
algorithms. Currently, \ttt{RoutingTestNetwork} has \texttt{DistVecRoutingNode}
hardcoded (all submodules are of this type), but you want
to be able to switch to other routing algorithms easily.

NED gives you the possibility to add a string-valued parameter,
say \ttt{routingNodeType} to the \ttt{RoutingTestNetwork} compound module.
Then you can tell NED that types of the submodules inside \ttt{RoutingTestNetwork}
are not of any fixed module type, but contained in the \ttt{routingNodeType}
parameter. That is all -- now you are free to assign any of
the \texttt{"DistVecRoutingNode"}, \texttt{"AntNetRouting1Node"} or
\texttt{"AntNetRouting2Node"} string constants to this parameter
(you can do that in NED, in the config file (\ttt{omnetpp.ini}),
or even enter it interactively),
and your network will use the routing algorithm you chose.

If you specify a wrong value, say \texttt{"FooBarRoutingNode"}
when you have no \ttt{FooBarRoutingNode} module implemented,
you'll get a runtime error at the beginning of the simulation:
\textit{module type definition not found}.

Inside the \ttt{RoutingTestNetwork} module you assign parameter values
and connect the gates of the routing modules. To provide some degree
of type safety, NED wants to make sure you didn't misspell
parameter or gate names and you used them correctly.
To be able to do such checks, NED requires some help from you:
you have to name an existing module type (say \ttt{RoutingNode})
and promise NED that all modules you're going you specify
in the \ttt{routingNodeType} parameter will have (at least) the same
parameters and gates as the \ttt{RoutingNode} module.
  \footnote{If you like, the above solution somewhat similar to polymorphism
  in object-oriented languages -- \ttt{RoutingNode} is like a
  ``base class'', \texttt{DistVecRoutingNode} and \texttt{AntNetRouting1Node}
  are like ``derived classes'', and the \ttt{routingNodeType} parameter
  is like a ``pointer to a base class'' which may be downcast to specific
  types.}

All the above is achieved via the \fpar[ned!keywords!like]{like} keyword.
The syntax is the following:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} RoutingTestNetwork
    \tbf{parameters}:
        routingNodeType: \tbf{string}; // should hold the name
                                  // of an existing module type
    \tbf{gates}: //...
    \tbf{submodules}:
        node1: routingNodeType \tbf{like} RoutingNode;
        node2: routingNodeType \tbf{like} RoutingNode;
        //...
    \tbf{connections nocheck}:
        node1.out0 --> node2.in0;
        //...
\tbf{endmodule}
\end{Verbatim}

The \texttt{RoutingNode} module type does not need to be implemented in
C++, because no instance of it is created; it is merely used
to check the correctness of the NED file.

On the other hand, the actual module types that will be substituted
(e.g. \texttt{DistVecRoutingNode}, \texttt{AntNetRouting1Node},etc.)
do not need to be declared in the NED files.

The \fpar[ned!keywords!like]{like} phrase lets you create families
of modules that serve similar purposes and implement the same interface
(they have the same gates and parameters)
and to use them interchangeably in NED files.




\subsection{Assigning values to submodule parameters}

\index{module!submodule!parameters}

If the module type used as submodule has parameters, you can assign
values to them in the \texttt{parameters} section of the submodule
declaration.
As a value you can use a constant (such as \texttt{42} or
\texttt{"www.foo.org"}), various parameters (most commonly, parameters
of the compound module), or write an arbitrary expression containing
the above.

It is not mandatory to mention and assign all parameters.
Unassigned parameters can get their values at runtime: either from
the configuration file (\texttt{omnetpp.ini}), or if the value
isn't there either, the simulator will prompt you to enter it
interactively. Indeed, for flexibility reasons it is often very useful
not to ``hardcode'' parameter values in the NED file,
but to leave them to \texttt{omnetpp.ini} where they can be
changed more easily.


Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} CompoundModule
    \tbf{parameters}:
        param1: numeric,
        param2: numeric,
        useParam1: bool;
    \tbf{submodules}:
        submodule1: Node
            \tbf{parameters}:
                p1 = 10,
                p2 = param1+param2,
                p3 = useParam1==true ? param1 : param2;
        //...
\tbf{endmodule}
\end{Verbatim}


The expression syntax \index{ned!expressions} is very similar to C.
Expressions may contain constants (literals) and parameters of the
compound module being defined. Parameters can be passed by value
or by reference. The latter means that the expression is evaluated
at runtime each time its value is accessed (e.g. from simple module
code), opening up interesting possibilities for the modeler.
You can also refer to parameters of the already defined submodules,
with the syntax \ttt{submodule.parametername}
(or \ttt{submodule[index].parametername}).

Expressions are described in detail in section \ref{ch-ned-lang:sec:expressions}.


\subsubsection{The \ttt{input} keyword}
\label{sec:ch-ned-lang:input}

When a parameter does not receive a value inside NED files or in
the configuration file (\ttt{omnetpp.ini}), the user will be prompted
to enter its value at the beginning of the simulation.
If you plan to make use of interactive prompting, you can specify
a prompt text and a default value.

The syntax is the following:

\begin{Verbatim}[commandchars=\\\{\}]
   parameters:
      numCPUs = \tbf{input}(10, "Number of processors?"), // default value, prompt
      processingTime = \tbf{input}(10ms), // prompt text
      cacheSize = input;
\end{Verbatim}

The third version is actually the same as leaving out the parameter
from the list of assignments, but you can use it to make it explicit
that you do not want to assign a value from the NED file.


\subsection{Defining sizes of submodule gate vectors}

\index{module!gate sizes}
\index{gate!vector!size}

The sizes of gate vectors are defined with the
\fpar[ned!keywords!gatesizes]{gatesizes} keyword.  Gate vector sizes
can be given as constants, parameters or expressions.

An example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{simple} Node
    \tbf{gates}:
        \tbf{in}: inputs[];
        \tbf{out}: outputs[];
\tbf{endsimple}

\tbf{module} CompoundModule
    \tbf{parameters}:
        numPorts: \tbf{const};
    \tbf{submodules}:
        node1: Node
            \tbf{gatesizes}:
                inputs[2], outputs[2];
        node2: Node
            \tbf{gatesizes}:
                inputs[numPorts], outputs[numPorts];
        //...
\tbf{endmodule}
\end{Verbatim}

% TBD: show in[sizeof(in)] construct as well

\ttt{gatesizes} is not mandatory.
If you omit \ttt{gatesizes} for a gate vector, it will be created with zero size.

One reason for omitting \ttt{gatesizes} is that you'll want to use
the \ttt{gate++} (``extend gate vector with a new gate'') notation later in the
\ttt{connections} section.



\subsection{Connections}

The compound module definition specifies how the gates of the compound
module and its immediate sub-modules are connected\index{connection}.

You can connect two submodules or a submodule with its enclosing
compound module. (For completeness, you can also connect two gates
of the compound module on the inside, but this is rarely needed).
This means that NED does not permit connections that span
multiple levels of hierarchy -- this restriction
enforces compound modules to be self-contained, and thus promotes
reusability. Gate directions must also be observed,
that is, you cannot connect two output gates or two input gates.

Only one-to-one connections are supported, so a particular gate may only
be used occur in one connection. One-to-many and many-to-one
connections can be achieved using simple modules that duplicate
messages or merge message flows. The rationale is that wherever
such fan-in or fan-out occurs in a model, it is usually associated
with some processing anyway that makes it necessary to use
simple modules.

Connections\index{ned!connections} are specified in the
\fpar[ned!keywords!connections]{connections:} section of a compound
module definition. It lists the connections, separated by semicolons.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} CompoundModule
    \tbf{parameters}: //...
    \tbf{gates}: //...
    \tbf{submodules}: //...
    \tbf{connections}:
        node1.output --> node2.input;
        node1.input <-- node2.output;
        //...
\tbf{endmodule}
\end{Verbatim}

The source gate can be an output gate of a submodule or an input
gate of the compound module, and the destination gate can be
an input gate of a submodule or an output gate of the compound
module. The arrow can point either left-to-right or right-to-left.

The \textit{gate++} notation allows you to extend a gate vector
with new gates, without having to declare the vector size in advance
with \ttt{gatesizes}. This feature is very convenient for connecting
nodes of a network:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{simple} Node
    \tbf{gates}:
        \tbf{in}: in[];
        \tbf{out}: out[];
\tbf{endsimple}

\tbf{module} SmallNet
    \tbf{submodules}:
        node: Node[6];
    \tbf{connections}:
        node[0].out++ --> node[1].in++;
        node[0].in++ <-- node[1].out++;

        node[1].out++ --> node[2].in++;
        node[1].in++ <-- node[2].out++;

        node[1].out++ --> node[4].in++;
        node[1].in++ <-- node[4].out++;

        node[3].out++ --> node[4].in++;
        node[3].in++ <-- node[4].out++;

        node[4].out++ --> node[5].in++;
        node[4].in++ <-- node[5].out++;
\tbf{endmodule}
\end{Verbatim}


A connection:

\begin{itemize}
  \item{may have attributes (delay, bit error rate or data rate) or
        use a named channel;}
  \item{may occur inside a for-loop (to create multiple connections);}
  \item{may be conditional.}
\end{itemize}

These connection types are described in the following sections.


\subsubsection{Single connections and channels}

\index{ned!connections}
\index{connection}

If you do not specify a channel\index{channel}, the connection will have
no propagation delay, no transmission delay and no bit errors:

\begin{verbatim}
    node1.outGate --> node2.inGate;
\end{verbatim}

You can specify a channel by its name\index{channel!name}:
\begin{verbatim}
    node1.outGate --> Fiber --> node2.inGate;
\end{verbatim}

In this case, the NED sources must contain the definition of
the channel.

One can also specify the channel parameters directly\index{channel!parameters}:
\begin{verbatim}
    node1.outGate --> error 1e-9 delay 0.001 --> node2.inGate;
\end{verbatim}

Either of the parameters can be omitted and they can be in any
order.


\subsubsection{Loop connections}


If submodule or gate vectors are used, it is possible to create
more than one connection with one statement. This is termed a \textit{multiple}
or \textit{loop connection}\index{connection!loop}.

A multiple connection is created with the \fpar[ned!keywords!for]{for}
statement:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{for} i=0..4 \tbf{do}
    node1.outGate[i] --> node2[i].inGate
\tbf{endfor};
\end{Verbatim}


The result of the above loop connection can be illustrated as
depicted in Fig. \ref{fig:ch-ned-lang:loop-connection}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.625in, height=1.297in]{figures/usmanFig7}
\caption{Loop connection}
\label{fig:ch-ned-lang:loop-connection}
\end{center}
\end{figure}


One can place several connections in the body of the
\fpar[ned!keywords!for]{for} statement, separated by semicolons.

One can create nested loops\index{ned!nested for statements}
by specifying more than one indices in the \texttt{for} statement,
with the first variable forming the outermost loop.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{for} i=0..4, j=0..4 \tbf{do}
    //...
\tbf{endfor};
\end{Verbatim}

One can also use an index in the lower and upper bound expressions
of the subsequent indices:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{for} i=0..3, j=i+1..4 \tbf{do}
    //...
\tbf{endfor};
\end{Verbatim}


\subsubsection{Conditional connections}

\index{connection!conditional}

Creation of a connection can be made conditional, using the \ttt{if}
keyword:

\index{ned!keywords!if}

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{for} i=0..n \tbf{do}
    node1.outGate[i] --> node2[i].inGate \tbf{if} i\%2==0;
\tbf{endfor};
\end{Verbatim}

The \ttt{if} condition is evaluated for each connection
(in the above example, for each \textit{i} value), and the
decision is made individually each time whether to create the
the connection or not. In the above example we connected every
second gate. Conditions may also use random variables, as
shown in the next section.


\subsubsection{The nocheck modifier}

By default, NED requires that all gates be connected. Since this
check can be inconvenient at times, it can be turned off
using the \fpar[ned!keywords!nocheck]{nocheck} modifier.

The following example generates a random subgraph of a full graph.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} RandomConnections
    \tbf{parameters}: //..
    \tbf{gates}: //..
    \tbf{submodules}: //..
    \tbf{connections} \tbf{nocheck}:
        \tbf{for} i=0..n-1, j=0..n-1 \tbf{do}
            node[i].out[j] --> node[j].in[i] \tbf{if} uniform(0,1)<0.3;
        \tbf{endfor};
\tbf{endmodule}
\end{Verbatim}

When using \fpar[ned!keywords!nocheck]{nocheck}, it is the
simple modules' responsibility not to send messages on gates
that are not connected.


\section{Networks}
\label{sec:ch-ned-lang:network}
\index{ned!network definition}

Module declarations (compound and simple module declarations)
just define module types. To actually get a simulation model that
can be run, you need to write a \textit{network definition}.

A network definition declares a simulation model as an instance
of a previously defined module type. You'll typically want to use
a compound module type here, although it is also possible to
program a model as a self-contained simple module and instantiate it
as a ``network''.

There can be several network definitions in your NED file or NED files.
The simulation program that uses those NED files will be
able to run any of them; you typically select the desired one
in the config file (\ttt{omnetpp.ini}).

The syntax of a network definition is similar to that of a submodule
declaration:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{network} wirelessLAN: WirelessLAN
    \tbf{parameters}:
        numUsers=10,
        httpTraffic=true,
        ftpTraffic=true,
        distanceFromHub=truncnormal(100,60);
\tbf{endnetwork}
\end{Verbatim}

Here, \ttt{WirelessLAN} is the name of previously defined
compound module type, which presumably contains further
compound modules of types \ttt{WirelessHost}, \ttt{WirelessHub}, etc.

Naturally, only module types without gates can
be used in network definitions.

Just as in submodules, you do not need to assign values to all
parameters. Unassigned parameters can get their values from the
config file (\ttt{omnetpp.ini}) or will be interactively prompted for.

\section{Inheritance}

Single inheritance is supported between modules, ie. you can further
specialize the above module:
FIXME TODO

\section{Packages}

To address increasingly common name collisions in NED files,
\opp 4.0 introduces a package feature for NED. The solution
is roughly modelled after Java's packages, with minor enhancements.


\subsection{Packages, imports}

A NED file may contain a package declaration:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{package} inet.protocols.transport.tcp;
\end{Verbatim}

If there is no package declaration, the file is said to be in the
\textit{default package}.

Names from other NED files can be referred to either by fully qualified
name (\ttt{"inet.protocols.network.ip.RoutingTable"}), or by short name
(\ttt{"RoutingTable"}) if the name is visible.

Visible names are:
\begin{itemize}
  \item anything from the same package;
  \item imported names.
\end{itemize}

Import directives also have a similar syntax to Java, but they
are more flexible with wildcards. All of the following are legal:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{import} inet.protocols.network.ip.RoutingTable;
\tbf{import} inet.protocols.network.ip.*;
\tbf{import} inet.protocols.network.ip.Ro*Ta*;
\tbf{import} inet.protocols.*.ip.*;
\tbf{import} inet.**.RoutingTable;
\end{Verbatim}

One asterisk "*" stands for "any character sequence not containing
period"; two asterisks mean "any character sequence which may
contain period". No other wildcards are recognized.

An import not containing wildcard MUST match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

Inner types may not be referred to outside their enclosing types.


\subsection{Directory Structure, package.ned}

Like in Java, the directory of a NED file MUST match the package declaration.
However, it is possible to omit directories at the top which don't
contain any NED files (like the "/org/projectname/" directories in Java).

There is a notion of "NED source folders". If a NED Source Folder is
named "src", then a NED file containing the package declaration
"inet.protocols.transport.tcp" must be in the following folder:

\begin{Verbatim}[commandchars=\\\{\}]
src/inet/protocols/transport/tcp/
\end{Verbatim}

If the "inet" and "protocols" directories don't contain any NED files,
they can be omitted:

\begin{Verbatim}[commandchars=\\\{\}]
src/transport/tcp
\end{Verbatim}

and the "src" directory must contain a "package.ned" file which declares
what package it corresponds to:

\begin{Verbatim}[commandchars=\\\{\}]
// file src/package.ned:
package inet.protocols;
\end{Verbatim}

All NED files under the "src" directory tree must have package
declarations consistent with that.

"package.ned" files are allowed in other folders as well (as long as
their package declarations are consistent with the NED source
directory's "package.ned"), and any file-level comment in them
will be treated as the package's documentation (similar to Java's
package.html).


\subsection{Name lookups}

\subsubsection{Base types and submodules}

Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.


\subsubsection{Parametric module types ("like" submodules)}

Lookup of the actual module type for "like" submodules differs for normal
lookups. This lookup ignores the imports in the file altogether.
Instead, it collects all modules that support the given interface
and match the given type name string (i.e. end in the same simple name,
or have the same fully qualified name). The result must be exactly
one module type.

The algorithm for parametric channel types works in the same way.


\subsubsection{Network name in the ini file}

Simple (unqualified) names are tried with the same package as the
ini file is in (provided it's in a NED directory).



\subsection{The NEDPATH environment variable}

A simulation may need NED files from several "NED source folders".
When a simulation is launched as a separate application, it will expect
to receive the list of NED source folders to scan in the NEDPATH
environment variable (similar to Java's CLASSPATH). NEDPATH should
contain the source folder names separated by a semicolon (";").
On Unix-like systems, colon (":") will also be accepted as separator.

In the future, zip files may become supported in NEDPATH as well;
then the root folder of the zip file will be treated as a NED source
folder.


%%FIXME into other doc
\subsection{OMNeT++ Projects in Eclipse}

OMNeT++ projects within Eclipse are marked with the "OMNEST/OMNeT++ Nature",
that is, those projects marked with that nature will be recognized as
OMNeT++ projects.

NED source folders can only be located within OMNeT++ projects. (That is,
NED files within non-OMNeT++ projects will be always ignored.)

Which folders in a project are NED source folders is determined by
the ".nedfolders" file in the project root directory. This is a plain
text file, which contains directory names (as relative to the
project root directory), one per line. If the ".nedfolders" file is
missing, then the project root directory will be treated as the (only)
NED source folder.


%%FIXME into other doc
\subsection{Cross-Project Dependencies}

OMNeT++ projects in Eclipse may refer to NED files in other projects.
This feature is supported by making use of the Eclipse Platform's
support for project dependencies. (In the Eclipse Platform, for any
project one can define the list other projects it depends on.)

In one project, one may only refer to NED files in the same project
or dependent projects.


\section{Inner types}
FIXME TODO

\section{Interfaces}
FIXME TODO

\section{Metadata annotations}
FIXME TODO


\section{Parameters}
\label{sec:ch-ned-lang:simple-module-param}
\index{module!parameters}


Parameters are variables that belong to a module. Simple module
parameters can be queried and used by simple module algorithms.
For example, a module called \texttt{TrafficGen} may have a parameter
called \ttt{numOfMessages} that determines how many messages it
should generate.

Parameters are identified by names.
By convention, parameter names begin with lower-case letters.

Parameters are declared by listing their names in the
\ttt{parameters:} section of a module description.
The parameter type can optionally be specified as \ttt{numeric},
\ttt{numeric const} (or simply \ttt{const}), \ttt{bool}, \ttt{string},
or \ttt{xml}. If the parameter type is omitted, \ttt{numeric} is assumed.

Example:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{simple} TrafficGen
    \tbf{parameters}:
        interarrivalTime,
        numOfMessages : \tbf{const},
        address : \tbf{string};
    \tbf{gates}: //...
\tbf{endsimple}
\end{Verbatim}

Parameters are assigned from NED (when the module is used as a building block
of a larger compound module) or from the config file \ttt{omnetpp.ini}.
\ttt{omnetpp.ini} is described in Chapter \ref{cha:run-sim}.


\subsection{Random parameters and const}
\label{sec:ch-ned-lang:const}
\index{const}
\index{module!parameters!const}

Numeric parameters can be set to return random numbers, uniformly
distributed or from various distributions. For example, setting a
parameter to \ttt{truncnormal(2,0.8)} would return a new random number
from the truncated normal distribution with mean 2.0 and standard deviation 0.8
every time the parameter is read from the simple module (from C++ code).
For example, this is useful for specifying interarrival times for generated
packets or jobs.

You may want the initial parameter value to be chosen randomly, but not
to change it afterwards. This can be achieved with declaring the parameter
to be \ttt{const}. \ttt{const} parameters will be evaluated only once
at the beginning of the simulation then set to a constant value.

It is recommended to mark every parameter with \ttt{const} unless
you really want to make use of the random numbers feature.


\subsection{XML parameters}
\index{xml}
\index{module!parameters!xml}

Sometimes modules need more complex input than simple module parameters
can describe. Then you'd put these parameters into an external config file,
and let the modules read and process the file. You'd pass the file name
to the modules in a string parameter.

These days, XML is increasingly becoming a standard format for configuration
files as well, so you might as well describe your configuration in XML.
From the 3.0 version, {\opp} contains built-in support for XML config files.

{\opp} wraps the XML parser (LibXML, Expat, etc.), reads and DTD-validates
the file (if the XML document contains a DOCTYPE), caches the file
(so that if you refer to it from several modules, it'll still be loaded
only once), lets you pick parts of the document via an XPath-subset notation,
and presents the contents to you in a DOM-like object tree.

This machinery can be accessed via the NED parameter type \ttt{xml}, and the
\ttt{xmldoc()} operator. You can point \ttt{xml}-type module parameters
to a specific XML file (or to an element inside an XML file) via the
\ttt{xmldoc()} operator. You can assign \ttt{xml} parameters both from NED
and from \ttt{omnetpp.ini}.




\section{Gates}
\label{sec:ch-ned-lang:simple-module-gates}

\index{gate}
\index{module!simple!gates}

Gates are the connection points of modules. The starting and
ending points of the connections between modules are gates. {\opp}
supports simplex (one-directional) connections, so there are
input and output gates. Messages are sent through
output gates and received through input gates.

Gates are identified by their names.
By convention, gate names begin with lower-case letters.

Gate vectors are supported: a gate vector\index{gate!vector}
contains a number of single gates.

Gates are declared by listing their names in the
\fpar[ned!keywords!gates]{gates:} section of a module description. An
empty bracket pair [] denotes a gate vector\index{gate!vector}.
Elements of the vector are numbered from zero.

Examples:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{simple} NetworkInterface
    \tbf{parameters}: //...
    \tbf{gates}:
        \tbf{in}:  fromPort, fromHigherLayer;
        \tbf{out}: toPort, toHigherLayer;
\tbf{endsimple}

\tbf{simple} RoutingUnit
    \tbf{parameters}: //...
    \tbf{gates}:
        \tbf{in}:  output[];
        \tbf{out}: input[];
\tbf{endsimple}
\end{Verbatim}

The sizes of gate vectors are given later, when the module is used as
a building block of a compound module type. Thus, every instance of
the module can have gate vectors of different sizes.

\section{Expressions}

FIXME

\subsection{Defining new functions}
\index{ned!functions}
\label{sec:ch-ned-lang:defining-functions}

To use user-defined functions\index{functions!user-defined}, one has
to code the function in C++.  The C++ function must take 0, 1, 2, 3, or 4
arguments of type double and return a double. The function must be
registered in one of the C++ files with the \fmac{Define\_Function()}
macro.

An example function (the following code must appear in one of the C++
sources):


\begin{verbatim}
#include <omnetpp.h>

double average(double a, double b)
{
  return (a+b)/2;
}

Define_Function(average, 2);
\end{verbatim}


The number 2 means that the \fname{average()} function has 2
arguments.  After this, the \fname{average()} function can be used in
NED files:


\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} Compound
    \tbf{parameter}: a,b;
    \tbf{submodules}:
        proc: Processor
            \tbf{parameters}: av = average(a,b);
\tbf{endmodule}
\end{Verbatim}


If your function takes parameters that are \ttt{int} or \ttt{long} or
some other type which is not \ttt{double}, you can create wrapper function
that takes all doubles and does the conversion. In this case you have
to register the wrapper function with the \fname{Define\_Function2()} macro
which allows a function to be registered with a name different from the
name of the function that implements it. You can do the same
if the return value differs from \ttt{double}.

\begin{verbatim}
#include <omnetpp.h>

long factorial(int k)
{
  ...
}

static double _wrap_factorial(double k)
{
  return factorial((int)k);
}

Define_Function2(factorial, _wrap_factorial, 1);
\end{verbatim}



\section{Parameterized compound modules}

\index{module!compound}

With the help of conditional parameter and gatesize blocks and
conditional connections\index{connection!conditional}, one can
create complex topologies.


\subsection{Examples}

\subsubsection{Example 1: Router}

The following example contains a router module with the number of
ports taken as parameter. The compound module is built using three
module types: Application, RoutingModule, DataLink. We assume that
their definition is in a separate NED file which we will import.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{import} "modules";

\tbf{module} Router
    \tbf{parameters}:
        rteProcessingDelay, rteBuffersize,
        numOfPorts: \tbf{const};
    \tbf{gates}:
        \tbf{in}: inputPorts[];
        \tbf{out}: outputPorts[];
    \tbf{submodules}:
        localUser: Application;
        routing: RoutingUnit
            \tbf{parameters}:
                processingDelay = rteProcessingDelay,
                buffersize = rteBuffersize;
            \tbf{gatesizes}:
                input[numOfPorts+1],
                output[numOfPorts+1];
        portIf: PPPNetworkInterface[numOfPorts]
            \tbf{parameters}:
                retryCount = 5,
                windowSize = 2;
    \tbf{connections}:
        \tbf{for} i=0..numOfPorts-1 \tbf{do}
            routing.output[i] --> portIf[i].fromHigherLayer;
            routing.input[i] <-- portIf[i].toHigherLayer;
            portIf[i].toPort --> outputPorts[i];
            portIf[i].fromPort <-- inputPorts[i];
        \tbf{endfor};
        routing.output[numOfPorts] --> localUser.input;
        routing.input[numOfPorts] <-- localUser.output;
\tbf{endmodule}
\end{Verbatim}


\subsubsection{Example 2: Chain}


For example, one can create a chain\index{chain} of modules like this:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} Chain
    \tbf{parameters}: count: \tbf{const};
    \tbf{submodules}:
        node : Node [count]
            \tbf{gatesizes}:
                in[2], out[2];
            \tbf{gatesizes} \tbf{if} index==0 || index==count-1:
                in[1], out[1];
    \tbf{connections}:
        \tbf{for} i = 0..count-2 \tbf{do}
            node[i].out[i!=0 ? 1 : 0] --> node[i+1].in[0];
            node[i].in[i!=0 ? 1 : 0] <-- node[i+1].out[0];
        \tbf{endfor};
\tbf{endmodule}
\end{Verbatim}


\subsubsection{Example 3: Binary Tree}


One can use conditional connections to build a binary tree\index{binary tree}.
The following NED code loops through all possible node pairs, and
creates the connections needed for a binary tree.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{simple} BinaryTreeNode
    \tbf{gates}:
        \tbf{in}: fromupper;
        \tbf{out}: downleft;
        \tbf{out}: downright;
\tbf{endsimple}

\tbf{module} BinaryTree
    \tbf{parameters}:
        height: \tbf{const};
    \tbf{submodules}:
        node: BinaryTreeNode [ 2^height-1 ];
    \tbf{connections} \tbf{nocheck}:
        \tbf{for} i = 0..2^height-2, j = 0..2^height-2 \tbf{do}
            node[i].downleft --> node[j].fromupper \tbf{if} j==2*i+1;
            node[i].downright --> node[j].fromupper \tbf{if} j==2*i+2;
        \tbf{endfor};
\tbf{endmodule}
\end{Verbatim}

Note that not every gate of the modules will be connected. By default,
an unconnected gate produces a run-time error message when the
simulation is started, but this error message is turned off here with
the \fpar[ned!keywords!nocheck]{nocheck} modifier.  Consequently, it
is the simple modules' responsibility not to send on a gate which is
not leading anywhere.

An alert reader might notice that there is a better alternative
to the above code. Each node except the ones at the lowest level
of the tree has to be connected to exactly two nodes,
so we can use a single loop to create the connections.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} BinaryTree2
    \tbf{parameters}:
        height: \tbf{const};
    \tbf{submodules}:
        node: BinaryTreeNode [ 2^height-1 ];
    \tbf{connections} \tbf{nocheck}:
        \tbf{for} i=0..2^(height-1)-2 \tbf{do}
            node[i].downleft --> node[2*i+1].fromupper;
            node[i].downright --> node[2*i+2].fromupper;
        \tbf{endfor};
\tbf{endmodule}
\end{Verbatim}



\subsubsection{Example 4: Random graph}

Conditional connections can also be used to generate random
topologies\index{topology!random}.  The following code generates a
random subgraph of a full graph:

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} RandomGraph
    \tbf{parameters}:
        count: \tbf{const},
        connectedness; // 0.0<x<1.0
    \tbf{submodules}:
        node: Node [count];
            \tbf{gatesizes}: \tbf{in}[count], \tbf{out}[count];
    \tbf{connections} \tbf{nocheck}:
        \tbf{for} i=0..count-1, j=0..count-1 \tbf{do}
            node[i].out[j] --> node[j].in[i]
                \tbf{if} i!=j && uniform(0,1)<connectedness;
        \tbf{endfor};
\tbf{endmodule}
\end{Verbatim}

Note the use of the \fpar[ned!keywords!nocheck]{nocheck} modifier
here too, to turn off error messages given by the network setup code
for unconnected gates.


\subsection{Design patterns for compound modules}

\index{module!compound!patterns}
\index{topology!patterns}

Several approaches can be used when you want to create complex
topologies which have a regular structure; three of them are
described below.


\subsubsection{`Subgraph of a Full Graph'}


This pattern takes a subset of the connections of a full graph.  A
condition is used to ``carve out'' the necessary interconnection from
the full graph:

\begin{Verbatim}[commandchars=\\\{\}]
for i=0..N-1, j=0..N-1 do
    node[i].out[...] --> node[j].in[...] if condition(i,j);
endfor;
\end{Verbatim}

The RandomGraph compound module (presented earlier) is an example of
this pattern, but the pattern can generate any graph where an
appropriate \textit{condition(i,j)} can be formulated. For example,
when generating a tree\index{topology!tree} structure, the condition
would return whether node \textit{j} is a child of node \textit{i} or
vica versa.

Though this pattern is very general, its usage can be prohibitive if
the \textit{N} number of nodes is high and the graph is sparse (it has
much fewer connections that $N^2$). The following
two patterns do not suffer from this drawback.


\subsubsection{`Connections of Each Node'}

The pattern loops through all nodes and creates the necessary
connections for each one. It can be generalized like this:

\begin{Verbatim}[commandchars=\\\{\}]
for i=0..Nnodes, j=0..Nconns(i)-1 do
    node[i].out[j] --> node[rightNodeIndex(i,j)].in[j];
endfor;
\end{Verbatim}

The Hypercube\index{topology!hypercube} compound module (to be
presented later) is a clear example of this approach. BinaryTree can
also be regarded as an example of this pattern where the inner j loop
is unrolled.

The applicability of this pattern depends on how easily the \textit{rightNodeIndex(i,j)}
function can be formulated.


\subsubsection{`Enumerate All Connections'}


A third pattern is to list all connections within a loop:

\begin{Verbatim}[commandchars=\\\{\}]
for i=0..Nconnections-1 do
    node[leftNodeIndex(i)].out[...] --> node[rightNodeIndex(i)].in[...];
endfor;
\end{Verbatim}

The pattern can be used if \textit{leftNodeIndex(i)} and \textit{rightNodeIndex(i)}
mapping functions can be sufficiently formulated.

The Serial module is an example of this approach where the mapping
functions are extremely simple: \textit{leftNodeIndex(i)=i} and \textit{rightNodeIndex(i)=i+1}.
The pattern can also be used to create a random subset of a full
graph with a fixed number of connections.

In the case of irregular structures where none of the above patterns
can be employed, you can resort to specifying constant submodule/gate
vector sizes and explicitly listing all connections, like you
would do it in most existing simulators.




\subsection{Topology templates}
\label{sec:ch-ned-lang:topology-templates}


\subsubsection{Overview}


Topology templates are nothing more than compound modules where one or
more submodule types are left as parameters (using the
\fpar[ned!keywords!like]{like} phrase of the NED language).  You can
write such modules which implement mesh\index{topology!mesh},
hypercube\index{topology!hypercube},
butterfly\index{topology!butterfly}, perfect
shuffle\index{topology!perfect shuffle} or other topologies, and you
can use them wherever needed in you simulations.  With topology
templates\index{topology!templates}, you can reuse
\textit{interconnection structure}.



\subsubsection{An example: hypercube}


The concept is demonstrated on a network with hypercube interconnection.
When building an N-dimension hypercube, we can exploit the fact
that each node is connected to N others which differ from it
only in one bit of the binary representations of the node indices
(see Fig. \ref{fig:ch-ned-lang:hypercube-topology}).

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[width=2.111in, height=1.285in]{figures/usmanFig8}
    \caption{Hypercube topology}
    \label{fig:ch-ned-lang:hypercube-topology}
  \end{center}
\end{figure}


The hypercube topology\index{topology!hypercube} template is the
following (it can be placed into a separate file, e.g \ttt{hypercube.ned}):


\begin{Verbatim}[commandchars=\\\{\}]
\tbf{simple} Node
    \tbf{gates}:
        \tbf{out}: out[];
        \tbf{in}: in[];
\tbf{endsimple}

\tbf{module} Hypercube
    \tbf{parameters}:
        dim, nodetype;
    \tbf{submodules}:
        node: nodetype[2{\textasciicircum}dim] \tbf{like} Node
        \tbf{gatesizes}:
            out[dim], in[dim];
    \tbf{connections}:
        \tbf{for} i=0..2^dim-1, j=0..dim-1 \tbf{do}
            node[i].out[j] --> node[i # 2^j].in[j]; // # is bitwise XOR
        \tbf{endfor};
\tbf{endmodule}
\end{Verbatim}



When you create an actual hypercube, you substitute the name
of an existing module type (e.g. \ttt{"Hypercube\_PE"}) for the nodetype
parameter. The module type implements the algorithm the user
wants to simulate and it must have the same gates that the Node
type has. The topology template code can be used through importing
the file:


\begin{Verbatim}[commandchars=\\\{\}]
\tbf{import} "hypercube.ned";

\tbf{simple} Hypercube_PE
    \tbf{gates}: \tbf{out}: out[]; \tbf{in}: in[];
\tbf{endsimple}

\tbf{network} hypercube: Hypercube
    \tbf{parameters}:
        dim = 4,
        nodetype = "Hypercube_PE";
\tbf{endnetwork}
\end{Verbatim}



If you put the nodetype parameter to the ini file, you can use the
same simulation model to test e.g. several routing algorithms in a
hypercube, each algorithm implemented with a different
simple module type -- you just have to supply
different values to nodetype, such as \ttt{"WormholeRoutingNode"},
\ttt{"DeflectionRoutingNode"}, etc.



\section{Large networks}

There are situations when using hand-written NED files to describe
network topology is inconvenient, for example when
the topology information comes from
an external source\index{topology!external source} like
a network management program.

In such case, you have two possibilities:

\begin{enumerate}
  \item{generating NED files from data files}
  \item{building the network from C++ code}
\end{enumerate}

The two solutions have different advantages and disadvantages.
The first is more useful in the model development phase, while
the second one is better for writing larger scale, more productized
simulation programs. In the next sections we examine both methods.



\subsection{Generating NED files}


Text processing programs like \fprog{awk} or \fprog{perl} are
excellent tools to read in textual data files and generate NED files
from them\index{ned!file generation}.  Perl also has extensions to
access SQL databases, so it can also be used if the network topology
is stored in a database.

The advantage is that the necessary \fprog{awk} or \fprog{perl}
program can be written in a relatively short time, and it is
inexpensive to maintain afterwards: if the structure of the data files
change, the NED-creating program can be easily modified. The
resulting NED files can either be translated by \fprog{nedtool}
into C++ and compiled in, or loaded dynamically.


\subsection{Building the network from C++ code}

Another alternative is to write C++ code which becomes part of the
simulation executable. The code would read the topology data from data
files or a database, and build the network directly, using
dynamic module creation (to be described later, in section
\ref{ch:simple-modules:dynamic-module-creation}).
The code which you need to write would be similar to the \ttt{*\_n.cc}
files output by \fprog{nedtool}.

Since writing such code is more complex than letting perl generate
NED files, this method is recommended when the simulation program
has to be somewhat more productized, for example when {\opp}
and the simulation model is embedded into a larger program, e.g.
a network design tool.


\section{XML binding for NED files}

To increase interoperability, NED files (and also message definition files)
have an XML representation. Any NED file can be converted to XML, and
any XML file which corresponds to the NED DTD can be converted to NED.
  \footnote{DTD stands for Document Type Descriptor, and it defines
  a "grammar" for XML files. More info can be found on the W3C web site,
  www.w3.org.}

XML is well suited for machine processing. For example, stylesheet
transformations (XSLT) can be used to extract information from NED files,
or the other way round, create NED files from external info present in
XML form. One practical application of XML is the \fprog{opp\_neddoc}
documentation generation tool which is described in Chapter \ref{cha:neddoc}.

The \fprog{nedtool} program (which also translates NED to C++ code)
can be used to convert between NED and XML.

Converting a NED file to XML:

\begin{verbatim}
nedtool -x wireless.ned
\end{verbatim}

It generates \ttt{wireless\_n.xml}.
Several switches control the exact content and details
of the resulting XML as well as the amount of checks
made on the input.

Converting the XML representation back to NED:

\begin{verbatim}
nedtool -n wireless.xml
\end{verbatim}

The result is \ttt{wireless\_n.ned}.

Using nedtool as NED compiler to generate C++ code:

\begin{verbatim}
nedtool wireless.ned
\end{verbatim}

The resulting code is more compact than the
one created by \fprog{nedtool}'s predecessor \fprog{nedc}.
As a result, \fprog{nedtool}-created \ttt{\_n.cc}
C++ files compile much faster.

You can generate C++ code from the XML format as well:

\begin{verbatim}
nedtool wireless.xml
\end{verbatim}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:



