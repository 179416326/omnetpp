\chapter{OPNET and {\opp}}
\label{cha:opnet-and-omnet}

\section{Comparison of OPNET and {\opp}}

OPNET$^{TM}$ (from MIL3 Inc.) is a state-of-the art commercial simulation
program for the modeling of communication systems. OPNET is designed
to enable full-detail modeling: every tool is given to implement
nonstandard protocols or behaviour.


A quote from the OPNET brochure:


\begin{itemize}
\item{\textit{OPNET presents an advanced graphical user
interface that supports multi-windowing, makes use of menus and
icons, and runs under X Windows. Supported platforms include
popular engineering workstations from SUN, DEC, HP and Silicon
Graphics. (Windows NT version also exists.)}}
\item{\textit{Graphical object-oriented editors for defining topologies
and architectures directly parallel actual systems, allowing
an intuitive mapping between a system and its model. OPNET's
hierarchical approach simplifies the specification and representation
of large and complex systems.}}
\item{\textit{The process editor provides a powerful and flexible
language to design models of protocols, resources, applications,
algorithms, queuing policies, and other processes. Specification
is performed in the Proto-C language, which combines a graphical
state-transition diagram approach with a library of more than
300 communication- and simulation-specific functions. The full
generality and power of the C language is also available.}}
\item{\textit{OPNET simulations generate user-selected performance
and behavioral data. Simulation results can be plotted as time
series graphs, scatter plots, histograms, and probability functions.
Standard statistics and confidence intervals are easily generated
and additional insight can be obtained by applying mathematical
operators to the collected data. }}
\item{\textit{OPNET provides an advanced animation capability for
visualising simulation events. Both automatic and user-customised
animations can be displayed interactively during or after a simulation.
Animations can depict messages flowing between objects, control
flow in a process, paths of mobile nodes, and dynamic values
such as queue size or resource status. }}
\item{\textit{OPNET provides open system features including: interfaces
to standard languages; the ability to take advantage of third-party
libraries; an application program interface; access to databases
and data files such as those generated by network analysers;
and PostScript and TIFF export for desktop publishing. OPNET
users are guided by a comprehensive documentation set and are
backed by outstanding technical support.}}
\end{itemize}

OPNET is very well designed and built commercial simulation software.
The author of {\opp} has worked for the Hungarian distributor
of OPNET for over three years and he has gained significant experience
with the software. He has taken part in several computer network
simulation projects for major Hungarian companies and also delivered
OPNET training. He has also written simulation models for a VSAT
system in OPNET. \\
Following is a comparison of the features that concern general-purpose
computer systems simulation (and are not specific to computer
network simulation) and that are present both in {\opp} and
OPNET.


\textbf{Model hierarchy levels}
\begin{longtable}{|p{7cm}|p{7cm}|}
  \hline
%% ROW 1
  \tabheadcol
  \textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
  {\raggedright network level (subnetwork nesting possible)\hfill} \linebreak
  {\raggedright node level (no nesting)\hfill} \linebreak
  process level (no nesting)
  &
  arbitrary levels of submodule nesting \\\hline
\end{longtable}



\textbf{Topology description method}


OPNET provides two tools for defining module topology: graphical
editors to design network and node level models, and EMA (External
Model Access), an API for building model files from C programs.
These tools correspond to {\opp}'s tools in the following way:


\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
%% ROW 1
\tabheadcol
 & \textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
\textbf{Graphical} & graphical editor within the IDE & graphical editor: GNED \\\hline
%% ROW 3
\textbf{High-level} & - & NED language\\\hline
%% ROW 4
\textbf{Low-level} & EMA & C++ output of NED compilation\\\hline
\end{longtable}



There is no high-level textual model description in OPNET (like
NED is in {\opp}). This means that one has either to use the
graphical editor or write lengthy C code using the EMA API.


The OPNET graphical model editor can only create fixed (non-parameterized)
topologies.


There's a significant difference between how EMA and {\opp}'s
NED are used. OPNET's EMA generates model files. EMA applications
are standalone programs: one writes the EMA C code, compiles
and runs it, and the EMA executable will generate a model file
that can be read into the graphical editor or loaded by simulation
programs. EMA cannot be used from within a simulation program.
In contrast, the compiled NED code of {\opp} becomes part of
the simulation program and it builds the model without having
to run external programs; this means that you can have a single
simulation executable that can be used to perform simulation
studies on networks with different topologies.


\textbf{Module parameters}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
% ROW 1
\tabheadcol
& \textbf{OPNET} & \textbf{{\opp}}\\\hline
% ROW 2
\textbf{Expressions} & no expressions are allowed: only literals or exact copy of another
parameter & arbitrary expressions using other parameters \\\hline
% ROW 3
\textbf{Parameter passing} & by value & parameters can be passed by value or by reference, and be changed during simulation\\\hline
% ROW 4
\textbf{Usage} & by process models only & by process models; also to define flexible topologies \\\hline
\end{longtable}



In OPNET, module parameter values can be passed only ''as
is''.


\textbf{Packet streams or gates\\
}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
%% ROW 1
\tabheadcol
&
\textbf{OPNET} &
\textbf{{\opp}}\\\hline
%% ROW 2
\textbf{Identification} &
Packet streams are numbered from 0; no names can be assigned. &
{\raggedright Gates are identified by names. Gate vectors are supported.\\
In the code, gates can be referenced by ID for greater speed.}\\\hline
%% ROW 3
\textbf{Directionality} &
Packet streams are uni-directional. &
Gates are uni-directional.\\\hline
\end{longtable}


\textbf{Flexible topologies}

\begin{longtable}{|p{7cm}|p{7cm}|}
\hline
%% ROW 1
\tabheadcol
\textbf{OPNET} &
\textbf{{\opp}}\\\hline
%% ROW 2
not really supported\footnote{If really necessary, it can be done through C programming (writing
EMA code) and running external program to create a separate model  file for each case.}
&
in the NED file, parameters can define submodule types, count
of submodules, gates and describe connections \\\hline
\end{longtable}





\textbf{Tracing, animation and interactive simulation}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
%% ROW 1
\tabheadcol
 & \textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
\textbf{Tracing and debugging}
&
powerful command line debugger (ODB)
&
separate window for each module's output, single-steps, run
until, inspectors, snapshot, etc. (Tkenv) \\\hline
%% ROW 3
\textbf{Animation}
&
{\raggedright mostly used in record/ playback mode;\hfill} \linebreak
animation spec. must be given in advance (via anim. probes)
&
interactive execution with message-flow animation, statistics
animation etc. (Tkenv) \\\hline
%% ROW 4
\textbf{Interactive simulation}
&
not supported
&
strongly supported via object inspectors and watches. (Tkenv) \\\hline
\end{longtable}


\textbf{Random numbers}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
%% ROW 1
\tabheadcol
& \textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
\textbf{Distributions provided}
&
many built-in distributions (through algorithms)
&
four built-in distributions, as C functions \\\hline
%% ROW 3
\textbf{Additional distributions}
&
through histograms
&
as C functions (algorithms); or through histograms \\\hline
%% ROW 4
\textbf{Random number generation}
&
one random number generator, no support for seed selection
&
{\raggedright several independent random number generators;\\
tool to support selecting good seed values} \\\hline
\end{longtable}



OPNET has many built-in distributions implemented with algorithms
(C functions). Additional distributions are supported as histograms.
There is only one common source of random numbers. OPNET has
no aid for selecting seed values that produce long non-overlapping
random number sequences.


{\opp}, only four basic distributions are provided. They are
implemented as C functions. Additional distributions can be added
by the user, and they are treated exactly in the same way as
built-in ones. Defining and using distributions in histogram
form is also supported. {\opp} provides several random number
generators, and also a tool for selecting good seed values.


\textbf{Process description method}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
%% ROW 1
\tabheadcol
& \textbf{OPNET} & \textbf{{\opp}}\\\hline
% ROW 2
\textbf{Method}
&
finite state machine (graphical spec. only)
&
both process-style (coroutine-based) and finite state machine
(textual spec. only)\\\hline
\end{longtable}



\textbf{Direct (non-scheduled) process interaction}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
%% ROW 1
\tabheadcol
& \textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
\textbf{Method} & ''forced interrupt'' & member function call of other module\\\hline
\end{longtable}



\textbf{Dynamic module creation}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
% ROW 1
\tabheadcol
& \textbf{OPNET} & \textbf{{\opp}}\\\hline
% ROW 2
\textbf{What can be created}
&
only processes within an existing module
&
{\raggedright simple\index{module!simple} modules;\\
connections;\\
compound\index{module!compound} modules with arbitrarily complex, parameterized topologies}\\\hline
\end{longtable}



\textbf{Object-oriented concepts}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
% ROW 1
\tabheadcol
& \textbf{OPNET} & \textbf{{\opp}}\\\hline
% ROW 2
\textbf{Language} & C & C++\\\hline
% ROW 3
\textbf{Objects}
&
{\raggedright C API functions operating on object-like data structures;\\
no support for inheritance\footnote{The graphical user interface of OPNET (from version 3.0) contains an ''inheritance mechanism'' for models. This is no real inheritance in the object-oriented sense because it just means that parameter values can be changed or fixed down, parameters renamed, merged etc. There is no mention about changing the behaviour of a module (that is, anything like C++'s virtual functions).}, polymorphism or the like}
&
{\raggedright full flexibility of C++: inheritance, polymorphism etc;\\
built-in object-oriented mechanisms}\\\hline
\end{longtable}


\textbf{Statistics collection and run-time analysis}

\begin{longtable}{|p{7cm}|p{7cm}|}
\hline
%% ROW 1
\tabheadcol
\textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
{\raggedright writing observations to output file; ''probes''
to select statistics to be collected;\\
only off-line analysis (analysis of output files) is supported}
&
{\raggedright writing observations to output files (roughly equivalent to
OPNET's solution);\\
run-time processing: basic measures (mean etc); distribution
estimation with histograms; quantiles ($P^{2}$ algorithm);\\
support for detecting the end of the transient period and sufficient
result accuracy}\\\hline
\end{longtable}



\textbf{Parallel execution}

\begin{longtable}{|p{7cm}|p{7cm}|}
\hline
%% ROW 1
\tabheadcol
\textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
 not supported & supported by PVM and MPI; arbitrary synchronization can be used\\\hline
\end{longtable}



\textbf{Openness}

\begin{longtable}{|p{4.5cm}|p{4.5cm}|p{4.5cm}|}
\hline
%% ROW 1
\tabheadcol
 & \textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
\textbf{Input file formats}
&
{\raggedright binary model files\footnote{Can be read and analyzed by EMA programs.};\\
textual parameter files}
&
text files \\\hline
%% ROW 3
\textbf{Output file formats}
&
binary files\footnote{Can be exported to text files from the main OPNET program.}
&
text files\\\hline
%% ROW 4
\textbf{Availability of source}
&
not available (only the source of the shipped models is available)
&
available\\\hline
%% ROW 5
\textbf{Embedding simulations into other software product}
&
not supported and also not possible (the \fname{main()} function cannot
be supplied by the user etc.)
&
{\raggedright supported.\\
Embedding application becomes a new ''user interface''
based on Envir (1); or embedding application replaces Envir (2).}\\\hline
\end{longtable}










\section{Quick reference for OPNET users}

This section is intended to help OPNET users learn {\opp} faster.

\begin{longtable}{|p{6cm}|p{8cm}|}
\hline
%% ROW 1
\tabheadcol
\textbf{OPNET} & \textbf{{\opp}}\\\hline
%% ROW 2
network, subnetwork, node & Compound modules\\\hline
%% ROW 3
module, process & An {\opp} simple\index{module!simple} module corresponds to an OPNET module with
its process.\\\hline
%% ROW 4
interrupts, invocations, states
&
{\raggedright When using \fname{handleMessage()}: interrupt = event, invocation = call
to \fname{handleMessage()}, state = FSM state or the value of the state
vars stored in the class\hfill} \linebreak
{\raggedright When using modules with \fname{activity()}, this means a little different
way of thinking from OPNET's. In {\opp}, you write a simple\index{module!simple}
module as you would write an operating system process or a thread,
thus there's no need to distinguish 'states' or speak about 'invocations'.
Within the simulation kernel, an 'invocation' corresponds to
a \ttt{transferTo(\textit{module})} call.\hfill} \linebreak
{\raggedright An {\opp} module accepts messages (and simulation time advances)
within \ttt{receive\dots (\dots )} calls; \fname{wait()} is just a \fname{scheduleAt()} followed
by a \fname{receive()}.\hfill} \linebreak
An OPNET interrupt is the event being processed. In this sense,
{\opp} messages returned by \fname{receive()} correspond to OPNET interrupts.\\\hline
%% ROW 5
endsim interrupt
&
The \fname{finish()} virtual member functions of the simple\index{module!simple} modules are
called at the end of the simulation run. You can redefine \fname{finish()}
to write statistics etc. \\\hline
%% ROW 6
\multicolumn{2}{c}{}\\\hline
%% ROW 7
\ttt{op\_ima\_obj\_attr\_get(\dots )}
&
{\raggedright \ttt{foo = par(''foo'');}\hfill} \linebreak
\ttt{foo = module-\texttt{>}par(''foo'');}\\\hline
%% ROW 8
\ttt{op\_ima\_sim\_attr\_get(\dots )}
&
{\raggedright There are no simulation attributes. You can use the parameters
of the top-level module instead:\hfill} \linebreak
\ttt{foo = simulation.systemModule()-\texttt{>}par(''foo'');}\\\hline
%% ROW 9
\multicolumn{2}{c}{}\\\hline
% ROW 10
{\raggedright \ttt{op\_prg\_odb\_print\_minor(\dots )} \hfill} \linebreak
\ttt{op\_prg\_odb\_print\_major(\dots )}
&
{\raggedright \ttt{ev << ''hello!'' << endl;}\hfill} \linebreak
\ttt{ev.printf(\dots );}\\\hline
%% ROW 11
\ttt{op\_sim\_end(\dots )}
&
\ttt{simulation.error(''Your fault! error \%d'',ec);}\\\hline
%% ROW 12
\multicolumn{2}{c}{} \\\hline
%% ROW 13
\ttt{op\_subq\_....()}
&
{\raggedright Create a queue object and then manipulate it with its member
  functions.\hfill}
\begin{verbatim}
cQueue queue;
queue.insert( msg );
if (!queue.empty())
  msg = queue.pop();
\end{verbatim}
\\\hline

%% ROW 14
{\raggedright \ttt{List}\hfill} \linebreak
\ttt{op\_prg\_list\_...()}
&
\begin{verbatim}
cLinkedList list;
list.insert( ptr );
if (!list.empty())
ptr = list.pop();
\end{verbatim}
\\\hline

%% ROW 15
\multicolumn{2}{c}{}\\\hline

%% ROW 16
{\raggedright \ttt{Topology}\hfill} \linebreak
\ttt{op\_rte\_...()}
&
The \cclass{cTopology} class offers similar functionality, and you can
expect greater speed than with OPNET's routing functions. \\\hline

%% ROW 17
\multicolumn{2}{c}{}\\\hline

%% ROW 18
\begin{verbatim}
Packet
op_pk_create(... )
op_pk_destroy( )
\end{verbatim}
&
{\raggedright Use the \cclass{cMessage} class.\hfill}
\begin{verbatim}
cMessage *msg = new cMessage;
delete msg;
\end{verbatim}
\\\hline

%% ROW 19
{\raggedright packet fields\hfill}
\begin{verbatim}
op_pk_nfd_set(... )
op_pk_nfd_get_(... )
op_pk_fd_set(... )
op_pk_fd_get(... )
\end{verbatim}
&
{\raggedright Message parameters. A parameter has both name and index.\hfill} \linebreak
\begin{verbatim}
msg->par("foo") = foo;
msg->addPar("new-foo") = foo;
int foo = msg->par("foo");

int fooindex =
  msg->parList().find("foo");
msg->par(fooindex) = foo;
\end{verbatim}
\\\hline

%% ROW 20
packet field modeled size
&
{\raggedright Message parameters do not have associated modelled bit sizes.
  Message length can be used instead.\hfill} \linebreak
\begin{verbatim}
msg->addPar("dest_addr") = dest_addr;
msg->addLength( 32 );
\end{verbatim}
\\\hline

%% ROW 21
packet formats
&
There are no explicit packet formats in {\opp}. However, you
can write function to create messages with specific fields and
length:
\begin{verbatim}
cMessage *createEthernetFrame()
{
  cMessage *msg = new cMessage;
  msg->setKind(PACKET);
  msg->addPar("source");
  msg->addPar("destination");
  msg->addPar("protocol");
  msg->setLength( 8*16 );
  return msg;
}
\end{verbatim}
\\\hline

%% ROW 22
packet encapsulation
&
{\raggedright As in OPNET, message parameters can be assigned object pointers,
thus also message pointers.\hfill}  \linebreak
However, there is also direct support encapsulation:
\begin{verbatim}
msg->encapsulate(innermsg)
innermsg = msg->encapsulatedMsg();
innermsg = msg->decapsulate();
\end{verbatim}
\\\hline

%% ROW 23
ICI
&
{\raggedright ICIs are also represented by cMessage objects, naturally with
zero length.\hfill}  \linebreak
If it is important to distinguish between packets and ICIs, you
can use the message kind field:
\begin{verbatim}
#define PACKET 0
#define ICI 1

cMessage *pk = new cMessage;
pk->setKind(PACKET);

cMessage *ici = new cMessage;
ici->setKind(ICI);
\end{verbatim}
\\\hline

%% ROW 24
ICI formats & See packet formats.\\\hline
%% ROW 25
ICI attributes & See packet fields.\\\hline
%% ROW 26
packet and ICI in the same interrupt
&
You can use encapsulation. At the sender side:
\begin{verbatim}
cMessage *ici, *pk;
ici->encapsulate(pk);
send(ici,"out-gate");
\end{verbatim}
The receiver side:
\begin{verbatim}
ici = receive();
pk = ici->decapsulate();
\end{verbatim}
\\\hline

%% ROW 27
\multicolumn{2}{c}{}\\\hline
%% ROW 28
\ttt{op\_pk\_send(\dots )}
&
\begin{verbatim}
send( msg, "out-gate");
send( msg, "gate-vector'', index);
send( msg, gate_id );
\end{verbatim}
\\\hline

%% ROW 29
\ttt{op\_pk\_send\_delayed(\dots )} & \ttt{sendDelayed(\dots )}\\\hline
%% ROW 30
\ttt{op\_pk\_deliver(\dots )} & \ttt{sendDirect(\dots )}\\\hline

%% ROW 31
\multicolumn{2}{c}{}\\\hline

%% ROW 32
\ttt{op\_pk\_schedule\_self(\dots )} & \ttt{scheduleAt( simTime()+timeout, msg );}\\\hline
%% ROW 33
\ttt{op\_ev\_cancel(\dots )} & \ttt{cancelEvent( msg );}\\\hline

%% ROW 34
\multicolumn{2}{c}{}\\\hline

%% ROW 35
\ttt{op\_dist\_load(\dots ) \linebreak
  op\_dist\_outcome(\dots )}
&
To generate random numbers from analytical distributions, use:
\begin{verbatim}
uniform(... )
intuniform(... )
exponential(... )
normal(... )
truncnormal(... )
\end{verbatim}

For custom distributions you can use the histogram classes. Histograms
can load distribution data from file.
\begin{verbatim}
cDoubleHistogram hist;
FILE *f = fopen("distribution.dat");
hist.loadFromFile( f );
fclose(f);

double rnd = hist.random();
\end{verbatim}
\\\hline

%% ROW 36
\multicolumn{2}{c}{}\\\hline

%% ROW 37
output vectors
&
The \cclass{cOutVector} class can be used.
\begin{verbatim}
cOutVector eed("End-to-end delay");

double d = msg->creationTime()
             - simTime();
eed.record( d );
\end{verbatim}
\\\hline

%% ROW 38
output scalars
&
Output scalar file exists. You can write into it with \ttt{recordScalar()}:
\begin{verbatim}
recordScalar("average delay",
             avg_delay);
\end{verbatim}
\\\hline

%% ROW 39
\multicolumn{2}{c}{}\\\hline

%% ROW 40
\ttt{op\_topo\_parent()} & \ttt{cModule *parent = parentModule();}\\\hline
%% ROW 41
\ttt{op\_topo\_child\_\dots (\dots )} & \ttt{cSubModuleIterator}\\\hline

%% ROW 42
\multicolumn{2}{c}{}\\\hline

%% ROW 43
\ttt{op\_topo\_..\_assoc\_(\dots )}
&
\begin{verbatim}
gate(i)/gate(name),
gate->toGate()/fromGate()
gate->destinationGate()/sourceGate()
gate->ownerModule()
\end{verbatim}
\\\hline

%% ROW 44
\multicolumn{2}{c}{}\\\hline

%% ROW 45
\ttt{op\_pro\_create(\dots )}
&
See dynamic module creation. Note that this is a more powerful
tool than OPNET's dynamic processes in that you can also create
compound modules. \\\hline

%% ROW 46
Prohandle
&
Module ID. Given the module pointer, you can obtain module ID
by
\begin{verbatim}
int id = mod->id();
\end{verbatim}

And you can obtain module pointer from the ID:
\begin{verbatim}
cModule *mod = simulation.module(id);
\end{verbatim}
An invalid ID is negative. \\\hline

%% ROW 47
\ttt{op\_pro\_invoke(\dots )}
&
Dynamically created modules do not need to be invoked, they
live their own life. To dispatch messages to them, you can use \ttt{sendDirect(\dots )}\\\hline

%% ROW 48
\begin{verbatim}
op_pro_destroy(... )
op_pro_destroy( self )
\end{verbatim}
&
\begin{verbatim}
deleteModule( module );
deleteModule();
\end{verbatim}
\\\hline

%% ROW 49
module memory, parent-to-child memory, argument memory to dynamic processes
&
{\raggedright Parent module can set pointers (void* data members) in the dynamically
created module object any time, thus also right after creating
it ( parent-to-child memory), right before sending a packet to it
( argument memory), and the pointer can refer to memory managed
by the parent module ( module memory).\hfill}  \linebreak
An example for argument memory. Suppose the child module class
has a public data member named argmem:
\begin{verbatim}
class ChildModule :
        public cSimpleModule {
  ...
  public
  void *argmem;
  ...
};
\end{verbatim}

The parent module code would be:
\begin{verbatim}
childmod->argmem = argument_memory_ptr;
sendDirect( msg, childmod, 0.0, "in" );
\end{verbatim}
Child module code would be:
\begin{verbatim}
msg = receive();
argument_memory_ptr = argmem;
\end{verbatim}
\\\hline

%% ROW 50
\ttt{op\_pro\_valid(\dots )}
&
Given the module id:
\begin{verbatim}
int valid = (id>=0) &&
            simulation.exist(id);
\end{verbatim}
\\\hline

%% ROW 51
\multicolumn{2}{c}{}\\\hline

%% ROW 52
Environment files
&
Configuration files. Default is \ttt{omnetpp.ini}. Multiple ini files
and ini file inclusion are also supported.\\\hline

%% ROW 53
Process Editor & Your favourite text editor. Or \textit{vi} :-).\\\hline

%% ROW 54
Network Editor, Node Editor
&
{\raggedright Any editor to write NED files.\hfill} \linebreak
GNED. Not very sophisticated yet though. \\\hline

%% ROW 55
Simulation Tool &
{\raggedright Use the \ttt{[Run 1]}, \ttt{[Run 2]} etc. sections
in \ttt{omnetpp.ini} do describe several runs with different
parameters.\hfill} \linebreak
To create loops on different variables, you can use a shell script
that creates a short ini file with the variable parameters, and
include that file in \ttt{omnetpp.ini}. \\\hline

%% ROW 56
probes, Probe Editor &
From the ini file, you can turn on/off \cclass{cOutVector} objects individually
as well as assign result collection interval to them. \\\hline

%% ROW 57
Analysis Tool &  Plove \\\hline

%% ROW 58
EMA &
{\raggedright Where you would normally use EMA, {\opp} NED files with parameterized
topology are often enough.\hfill} \linebreak
{\raggedright Otherwise, you have two choices:\hfill} \linebreak
{\raggedright a) write a program to generate NED files. Text-processing languages
like \fprog{perl} and \fprog{awk} are great tools for that.\hfill} \linebreak
b) write the network-building code in C++. You can look at the
output of nedc for some idea how to do it.\\\hline
\end{longtable}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
