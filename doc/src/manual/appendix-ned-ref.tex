\appendixchapter{NED Reference}
\label{cha:ned-ref}

\section{Syntax}

\subsection{NED File Extension}

NED files have the \texttt{.ned} file name suffix. This is mandatory, and
cannot be overridden.

\subsection{NED File Encoding}

NED files are read as 8-bit-clean ASCII. This permits NED files saved
in UTF-8, or any character set compatible with ASCII (8859-1, etc).

\begin{note}
    There is no official way to determine the encoding of a NED file. It is up
    to the user to configure the correct encoding in text editors and other
    tools that are used to edit or process NED files.
\end{note}

Keywords and other syntactic elements in NED are ASCII, and identifiers must be
ASCII as well. Comments and string literals may contain characters above
127. String literals (e.g. in parameter values) will be passed to the C++ code
as \ttt{const char *} without any conversion; it is up to the simulation model
to interpret them using the desired encoding.

Line ending may be either CR or CRLF, regardless of the platform.


\subsection{Reserved Words}

Authors have to take care that no reserved words are used as identifiers.
The reserved words of the NED language are:

\ttt{allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inout input int like
module moduleinterface network output package parameters property simple
sizeof string submodules this true types volatile xml xmldoc}


\subsection{Identifiers}

Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and underscore ``\_''. Identifiers may only begin with a
letter or underscore.

The recommended way to compose identifiers from multiple words is to
capitalize the beginning of each word (\textit{camel case}).


\subsection{Case Sensitivity}

Keywords and identifiers in the NED language are case sensitive. For example,
\ttt{TCP} and \ttt{Tcp} are two different names.


\subsection{Literals}

\subsubsection{String Literals}

String literals use double quotes. The following C-style backslash
escapes are recognized: \ttt{{\textbackslash}b}, \ttt{{\textbackslash}f}, \ttt{{\textbackslash}n}, \ttt{{\textbackslash}r},
\ttt{{\textbackslash}t}, \ttt{{\textbackslash}{\textbackslash}}, \ttt{{\textbackslash}"}, and \ttt{{\textbackslash}xhh} where \textit{h} is a
hexadecimal digit.

\subsubsection{Numeric Constants}

Numeric constants are accepted in the usual decimal, hexadecimal (\ttt{0x} prefix)
and scientific notations. Octal numbers are not accepted (numbers that start
with the \ttt{0} digit are interpreted as decimal.)

\subsubsection{Quantity Constants}

A quantity constant has the form \textit{(<numeric-constant> <unit>)+}, for
example \ttt{12.5mW} or \ttt{3h 15min 37.2s}. When multiple measurement
units are present, they have to be convertible into each other (i.e. refer
to the same physical quantity).

Section \ref{ch-ned-ref:sec:units} lists the units recognized by {\opp}.
Other units can be used as well; the only downside being that {\opp} will not be
able to perform conversions on them.


\subsection{Comments}

Comments can be placed anywhere in the NED file, with the usual C++
syntax; comments begin with a double slash `//', and continue until
the end of the line.


\subsection{Grammar}

The grammar of the NED language can be found in Appendix
\ref{cha:ned-language-grammar}.

\section{Built-in Definitions}
\label{ch-ned-ref:sec:built-in-defs}

The NED language has the following built-in definitions, all in the \ttt{ned}
package: channels \ttt{IdealChannel} \ttt{DelayChannel}, and \ttt{DatarateChannel};
module interfaces \ttt{IBidirectionalChannel}, and \ttt{IUnidirectionalChannel}.
The latter two are reserved for future use.

%%
%% Note: the following code is from src/nedxml/nedparser.cc,
%%       NEDParser::getBuiltInDeclarations()
%%
\begin{ned}
package ned;

@namespace("");

channel IdealChannel {
    @class(cIdealChannel);
}

channel DelayChannel {
    @class(cDelayChannel);
    bool disabled = false;
    double delay = 0s @unit(s);
}

channel DatarateChannel {
    @class(cDatarateChannel);
    bool disabled = false;
    double delay = 0s @unit(s);
    double datarate = 0bps @unit(bps);
    double ber = 0;
    double per = 0;
}

moduleinterface IBidirectionalChannel {
    gates:
        inout a;
        inout b;
}

moduleinterface IUnidirectionalChannel {
    gates:
        input i;
        output o;
}
\end{ned}



\section{Packages}
\label{ch-ned-ref:sec:packages}

NED supports hierarchical namespaces called \textit{packages}. The implementation
is roughly modelled after Java's packages, with minor changes.


\subsection{Package Declaration}

The package containing the declarations in a NED file is specified by the package
declaration (\fkeyword{package} keyword). A NED file may contain at
most one package declaration. If there is no package declaration, the file's
contents are in the \textit{default package}.

Component type names must be unique within their package.


\subsection{Directory Structure, package.ned}

Like in Java, the directory of a NED file must match the package
declaration. However, it is possible to omit directories at the top which do
not contain any NED files (like the typical \ttt{/org/\textit{<projectname>}}
directories in Java).

The top of a directory tree containing NED files is named a \textit{NED source
folder}. The \ttt{package.ned} file at the top level of a NED source folder plays a
special role.

If there is no toplevel \ttt{package.ned} or it contains no package declaration,
the declared package of a NED file in the folder \ttt{\textit{<srcfolder>}/x/y/z}
\textit{must} be \ttt{x.y.z}.
If there is a toplevel \ttt{package.ned} and it declares the package as
\ttt{a.b}, then any NED file in the folder \ttt{\textit{<srcfolder>}/x/y/z}
\textit{must} have the declared package \ttt{a.b.x.y.z}.

\begin{note}
    \ttt{package.ned} files are allowed in other folders as well, but they
    cannot be used to define the package they are in.
\end{note}




\section{Components}

Simple modules, compound modules, networks, channels, module interfaces
and channel interfaces are called \textit{components}.


\subsection{Simple Modules}
\label{ch-ned-ref:sec:simple-modules}

Simple module types are declared with the \fkeyword{simple} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Simple modules may have properties (\ref{ch-ned-ref:sec:properties}),
parameters (\ref{ch-ned-ref:sec:parameters})
and gates (\ref{ch-ned-ref:sec:gates}).

A simple module type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A simple module type may extend another simple module type, and
may implement one or more module interfaces (\ref{ch-ned-ref:sec:module-interfaces}).
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance},
and interface implementation rules in section \ref{ch-ned-ref:sec:implementing-an-interface}.

Every simple module type has an associated C++ class, which must be
subclassed from \cclass{cSimpleModule}. The way of associating the
NED type with the C++ class is described in section
\ref{ch-ned-ref:sec:resolving-cpp-class}.



\subsection{Compound Modules}
\label{ch-ned-ref:sec:compound-modules}

Compound module types are declared with the \fkeyword{module} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

A compound module may have properties (\ref{ch-ned-ref:sec:properties}),
parameters (\ref{ch-ned-ref:sec:parameters}),
and gates (\ref{ch-ned-ref:sec:gates}); its internal structure is defined by
its submodules (\ref{ch-ned-ref:sec:submodules}) and
connections (\ref{ch-ned-ref:sec:connections});
and it may also have inner types (\ref{ch-ned-ref:sec:inner-types})
that can be used for submodules and connections.

A compound module type may extend another compound module type, and
may implement one or more module interfaces (\ref{ch-ned-ref:sec:module-interfaces}).
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance},
and interface implementation rules in section \ref{ch-ned-ref:sec:implementing-an-interface}.



\subsection{Networks}
\label{ch-ned-ref:sec:networks}

\subsubsection{The network Keyword}

A network declared with the \fkeyword{network} keyword is equivalent to a compound
module (\fkeyword{module} keyword) with the \fprop{@isNetwork(true)} property.

\begin{note}
    A simple module can only be designated to be a network by spelling out the
    \fprop{@isNetwork} property; the \fkeyword{network} keyword cannot
    be used for that purpose.
\end{note}

\subsubsection{The @isNetwork Property}

The \fprop{@isNetwork} property is only recognized for simple modules and
compound modules. The value may be empty, true or false:

\begin{ned}
@isNetwork;
@isNetwork();
@isNetwork(true);
@isNetwork(false);
\end{ned}

The empty value corresponds to \fprop{@isNetwork(true)}.

The \fprop{@isNetwork} property is not inherited; that is, a subclass
of a module with \fprop{@isNetwork} set does not automatically become a network.
The \fprop{@isNetwork} property needs to be explicitly added to the subclass
to make it a network.

\begin{rationale}
    Subclassing may introduce changes to a module that make it unfit to be used
    as a network.
\end{rationale}



\subsection{Channels}
\label{ch-ned-ref:sec:channels}

Channel types are declared with the \fkeyword{channel} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Channel types may have properties (\ref{ch-ned-ref:sec:properties})
and parameters (\ref{ch-ned-ref:sec:parameters}).

A channel type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A channel type may extend another channel type, and
may implement one or more channel interfaces (\ref{ch-ned-ref:sec:channel-interfaces}).
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance},
and interface implementation rules in section \ref{ch-ned-ref:sec:implementing-an-interface}.

Every channel type has an associated C++ class, which must be
subclassed from \cclass{cChannel}. The way of associating the
NED type with the C++ class is described in section
\ref{ch-ned-ref:sec:resolving-cpp-class}.



\subsection{Module Interfaces}
\label{ch-ned-ref:sec:module-interfaces}

Module interface types are declared with the \fkeyword{moduleinterface} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Module interfaces may have properties (\ref{ch-ned-ref:sec:properties}),
parameters (\ref{ch-ned-ref:sec:parameters}), and
gates (\ref{ch-ned-ref:sec:gates}). However, parameters are not allowed
to have a value assigned, not even a default value.

A module interface type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A module interface type may extend one or more other module interface types.
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance}.



\subsection{Channel Interfaces}
\label{ch-ned-ref:sec:channel-interfaces}

Channel interface types are declared with the \fkeyword{channelinterface} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Channel interfaces may have properties (\ref{ch-ned-ref:sec:properties}) and
parameters (\ref{ch-ned-ref:sec:parameters}). However, parameters are not
allowed to have a value assigned, not even a default value.

A channel interface type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A channel interface type may extend one or more other channel interface types.
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance}.



\subsection{Resolving the Implementation C++ Class}
\label{ch-ned-ref:sec:resolving-cpp-class}

The procedure for determining the C++ implementation class for simple modules
and for channels are identical. It goes as follows (we are going to say
\textit{component} instead of \textit{``simple module or channel''}):

If the component extends another component and has no
\fprop{@class} property, the C++ implementation class is inherited from the base
type.

If the component contains a \fprop{@class} property, the C++ class
name will be composed of the \textit{current namespace} (see
\ref{cha:ned-ref:current-namespace}) and the value of the \fprop{@class}
property. The \fprop{@class} property should contain a single value.

\begin{note}
    The \fprop{@class} property may itself contain a namespace declaration (ie.
    may contain ``\ttt{::}'').
\end{note}

If the component contains no \fprop{@class} property and has no base
class, the C++ class name will be composed of the \textit{current namespace} and the
unqualified name of the component.

\begin{important}
    NED subclassing does not imply subclassing the C++ implementation! If you
    want to subclass a simple module or channel in NED as well as in C++, you
    explicitly need to specify the \fprop{@class} property, otherwise the
    derived simple module or channel will continue to use the C++ class from its
    super type.
\end{important}

For compound modules, the built-in default compound module C++ class will be
used, unless the module contains the \fprop{@class} property. When \fprop{@class}
is present, the resolution rules are the same as with simple modules.


\subsubsection{Current Namespace}
\label{cha:ned-ref:current-namespace}

The \textit{current namespace} is the value of the first \fprop{@namespace}
property found while searching the following order:
\begin{enumerate}
  \item the current NED file
  \item the \ttt{package.ned} file in the current package
  \item the \ttt{package.ned} file of the parent package or the first ancestor
        package searching upwards
\end{enumerate}

\begin{note}
    Note that namespaces coming from multiple \fprop{@namespace} properties
    in different scopes do not nest, but rather, the nearest one wins.
\end{note}

The \fprop{@namespace} property should contain a single value.



\subsection{Properties}
\label{ch-ned-ref:sec:properties}

Properties are a means of adding metadata annotations to NED files, component types,
parameters, gates, submodules, and connections.

\subsubsection{Identifying a Property}

Properties are identified by name. It is possible to have several properties
on the same object with the same name, as long as they have unique indices.
An index is an identifier in square brackets after the property name.

The following example shows a property without index, one with the index \ttt{foo},
and a third with the index \ttt{bar}.

\begin{ned}
@prop();
@prop[foo]();
@prop[bar]();
\end{ned}


\subsubsection{Property Value}

The value of the property is specified inside parentheses. The value consists of
\textit{key=valuelist} pairs, separated by semicolons; values are separated with commas.
Example:

\begin{ned}
@prop(key1=value11,value12,value13;key2=value21,value22)
\end{ned}

Keys must be unique.

If the key+equal sign part (\ttt{key=}) is missing, the valuelist belongs
to the \textit{default key}. Examples:

\begin{ned}
@prop(value1,value2)
@prop(value1,value2;key1=value11,value12,value13)
\end{ned}

Property values have a liberal syntax (see Appendix \ref{cha:ned-language-grammar}).
Values that do not fit the grammar (notably, those containing a comma or
a semicolon) need to be surrounded with double quotes.

When interpreting a property value, one layer of quotes is removed
automatically, that is, \ttt{foo} and \ttt{"foo"} are the same. To add a
value with quotation marks included, enclose it in an extra layer of
quotes: \ttt{"\textbackslash"foo\textbackslash""}.

Example:

\begin{ned}
@prop(marks=the ! mark, "the , mark", "the ; mark", other marks);
\end{ned}


\subsubsection{Placement}

Properties may be added to NED files, component types, parameters,
gates, submodules and connections. For the exact syntax, see
Appendix \ref{cha:ned-language-grammar}.

When a component type extends another component type(s), properties
are merged. This is described in section \ref{ch-ned-ref:sec:inheritance}.


\subsubsection{Property Declarations}

The \fkeyword{property} keyword is reserved for future use. It is
envisioned that accepted property names and property keys would need
to be pre-declared, so that the NED infrastructure can warn the user
about mistyped or unrecognized names.


\subsection{Parameters}
\label{ch-ned-ref:sec:parameters}

Parameters can be defined and assigned in the \fkeyword{parameters} section
of component types. In addition, parameters can also be assigned in the
\fkeyword{parameters} sections of submodule bodies and connection bodies,
but those places do not allow adding new parameters.

The \fkeyword{parameters} keyword is optional, and can be omitted
without change in the meaning.

A parameter is identified by a name, and has a data type. A parameter
may have value or default value, and may also have properties
(see \ref{ch-ned-ref:sec:properties}).

Accepted parameter data types are \fkeyword{double}, \fkeyword{int},
\fkeyword{string}, \fkeyword{bool}, and \fkeyword{xml}. Any
of the above types can be declared \fkeyword{volatile} as well
(\ttt{volatile int}, \ttt{volatile string}, etc.)

The presence of a data type keyword determines whether the given line defines
a new parameter or refers to an existing parameter. One can assign a value or
default value to an existing parameter, and/or modify its properties or add
new properties.

Examples:

\begin{ned}
int a;           // defines new parameter
int b @foo;      // new parameter with property
int c = default(5); // new parameter with default value
int d = 5;       // new parameter with value assigned
int e @foo = 5;  // new parameter with property and value
f = 10;          // assignment to existing (e.g.inherited) parameter
g = default(10); // overrides default value of existing parameter
h;               // legal, but does nothing
i @foo(1);       // adds a property to existing parameter
j @foo(1) = 10;  // adds a property and value to existing parameter
\end{ned}

Parameter values are NED expressions. Expressions are described in section
\ref{ch-ned-ref:sec:expressions}.

For \fkeyword{volatile} parameters, the value expression is evaluated every
time the parameter value is accessed. Non-\fkeyword{volatile} parameters
are evaluated only once.

\begin{note}
    The \fkeyword{const} keyword is reserved for use within expressions
    to define constant subexpressions, i.e. to denote a part within
    an expression that should only be evaluated once. Constant subexpressions
    are not supported yet.
\end{note}

The following properties are recognized for parameters: \fprop{@unit},
\fprop{@prompt}.


\subsubsection{The @prompt Property}

The \fprop{@prompt} property defines a prompt string for the parameter. The
prompt string is used when/if a simulation runtime user interface
interactively prompts the user for the parameter's value.

The \fprop{@prompt} property is expected to contain one string value for the
default key.


\subsubsection{The @unit Property}

A parameter may have a \fprop{@unit} property to associate it with a measurement
unit. The \fprop{@unit} property should contain one string value for the default
key. Examples:

\begin{ned}
@unit("s")
@unit(s)
@unit("second")
@unit(second)
\end{ned}

When present, values assigned to the parameter must be in the
same or in a compatible (that is, convertible) unit.
Examples:

\begin{ned}
  double a @unit(s) = 5s;  // OK
  double a @unit(s) = 5;   // error: should be 5s
  double a @unit(s) = 5kg; // error: incompatible unit
\end{ned}

@unit behavior for non-numeric parameters (string, XML) is unspecified
(may be ignored or may be an error).

The @unit property of a parameter may not be modified via inheritance.

Example:
\begin{ned}
simple A {
    double p @unit(s);
}
simple B extends A {
    p @unit(mW);  // illegal: cannot override @unit
}
\end{ned}



\subsection{Pattern Assignments}
\label{ch-ned-ref:sec:pattern-assignments}

Pattern assignments allow one to set more than one parameter using
wildcards, and to assign parameters deeper down in a submodule tree.
Pattern assignments may occur in the \fkeyword{parameters}
section of component types, submodules and connections.

The syntax of a pattern assignment is \textit{<pattern> = <value>}.

A pattern consists of two or more pattern elements, separated by dots.
The pattern element syntax is defined so that it can accomodate names of
parameters, submodules (optionally with index), gates (optionally with the
\ttt{\$i}/\ttt{\$o} suffix and/or index) and connections, and their
wildcard forms. (The default name of connection channel objects is
\fkeyword{channel}.)

Wildcard forms may use:
\begin{enumerate}
  \item Asterisks: They match zero or more alphanumeric characters,
    underscore or dollar signs but not other characters (most notably,
    it does not match dots and square brackets).
  \item Numeric ranges, \ttt{\{}\textit{<start>}..\textit{<end>}\ttt{\}}
    e.g. \ttt{\{5..120\}} or \ttt{\{..10\}}. They match numbers embedded
    in identifiers, that is, a sequence of decimal digit characters interpreted as a
    nonnegative integer that is within the specified \textit{start..end}
    range (both limits are inclusive). Both \textit{start} and \textit{end}
    are optional.
  \item Numeric index ranges,\ttt{[}\textit{<start>}..\textit{<end>}\ttt{]}.
    e.g. \ttt{[5..120]} or \ttt{[..10]}. They are intended for selecting
    submodule and gate index ranges. They match a nonnegative integer
    enclosed in square brackets that is within the specified
    \textit{start..end} range (both limits are inclusive).
    Both \textit{start} and \textit{end} are optional.
  \item Double asterisks: They match zero or more characters (including dots
    and square brackets), and can be used to match more than one parameter
    path elements.
\end{enumerate}

See the NED language grammar (Appendix \ref{cha:ned-language-grammar})
for a more formal definition of the pattern syntax.

Examples:
\begin{ned}
host1.tcp.mss = 512B;
host*.tcp.mss = 512B; // matches host, host1, host2, hostileHost, ...
host{9..11}.tcp.mss = 512B; // matches host9/host10/host11, but nothing else
host[9..11].tcp.mss = 512B; // matches host[9]/host[10]/host[11], but nothing else
**.mss = 512B; // matches foo.mss, host[1].transport.tcp[0].mss, ...
\end{ned}



\subsection{Gates}
\label{ch-ned-ref:sec:gates}

Gates can be defined in the \fkeyword{gates} section of component types.
The size of a gate vector (see below) may be specified at the place of
defining the gate, via inheritance in a derived type, and also in the
\fkeyword{gates} block of a submodule body. A submodule body does not allow
defining new gates.

A gate is identified by a name, and is characterized by a type
(\fkeyword{input}, \fkeyword{output}, \fkeyword{inout}) and optionally a
vector size. Gates may also have properties (see
\ref{ch-ned-ref:sec:properties}).

Gates may be scalar or vector. The vector size is specified with a numeric
expression inside the square brackets (\ttt{[...]}). The vector size may
also be left open by specifying an empty pair of square brackets.

A gate vector size may not be overridden in subclasses or in a submodule.

The presence of a gate type keyword determines whether the given line defines
a new gate or refers to an existing gate. One can specify the gate vector
size for an existing gate vector, and/or modify its properties, or add new
properties.

Examples:

\begin{ned}
gates:
  input a;         // defines new gate
  input b @foo;    // new gate with property
  input c[];       // new gate vector with unspecified size
  input d[8];      // new gate vector with size=8
  e[10];           // set gate size for existing (e.g.inherited) gate vector
  f @foo(bar);     // add property to existing gate
  g[10] @foo(bar); // set gate size and add property to existing gate
\end{ned}

Gate vector sizes are NED expressions. Expressions are described in section
\ref{ch-ned-ref:sec:expressions}.

See the Connections section (\ref{ch-ned-ref:sec:connections}) for more
information on gates.

\subsubsection{Recognized Gate Properties}

The following properties are recognized for gates: \fprop{@directIn}
and \fprop{@loose}. They have the same effect: When either of them is
present on a gate, the gate is not required to be connected in the
connections section of a compound module (see \ref{ch-ned-ref:sec:connections}).

\fprop{@directIn} should be used when the gate is an \fkeyword{input} gate that is
intended for being used as a target for the \ffunc{sendDirect()} method;
\fprop{@loose} should be used in any other case when the gate is not
required to be connected for some reason.

\begin{note}
    The reason \fprop{@directIn} gates are not \textit{required} to remain
    unconnected is that it is often useful to wrap such modules in a compound
    module, where the compound module also has a \fprop{@directIn} input gate
    that is internally connected to the submodule's corresponding gate.
\end{note}

Example:

\begin{ned}
gates:
    input radioIn @directIn;
\end{ned}



\subsection{Submodules}
\label{ch-ned-ref:sec:submodules}

Submodules are defined in the \fkeyword{submodules} section of the compound module.

Submodules may also be conditional.

Submodules may be scalar or vector, the vector size of the latter being
specified with a numeric expression inside the square brackets (\ttt{[...]}).

\subsubsection{Submodule Type}

The simple or compound module type (\ref{ch-ned-ref:sec:simple-modules},
\ref{ch-ned-ref:sec:compound-modules}) that will be instantiated as the
submodule may be specified in several ways:

\begin{itemize}
  \item with a concrete module type name, or
  \item by a string-valued expression that evaluates to the name of a
        module type, or
  \item the type name may come from the configuration.
\end{itemize}

In the latter two cases, the \fkeyword{like} keyword is used, and a
module interface type (\ref{ch-ned-ref:sec:module-interfaces})
needs to be specified as well, which the concrete module type must
implement in order for it to be eligible to be chosen. In the second case, the
string expression is specified in angle braces (\ttt{<...>}); in the
third case, an empty pair of angle braces is used (\ttt{<>}).
See the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
exact syntax.

\begin{note}
    When using the \ttt{<>} syntax, the actual NED type should be
    provided with the \fconfig{type-name} configuration option:
    \ttt{**.host[0..3].\-type-name=\-"MobileHost"}.
\end{note}

\subsubsection{Conditional Submodules}

Submodules may be made conditional using the \fkeyword{if} keyword. The
condition expression must evaluate to a boolean; if the result is
\ttt{false}, the submodule is not created, and trying to connect its gates
or reference its parameters will be an error.

An example:

\begin{ned}
submodules:
  tcp : TCP if withTCP { ... }
\end{ned}

\subsubsection{Parameters, Gates}

A submodule definition may or may not have a body (a curly brace
delimited block). An empty submodule body (\ttt{\{ \}}) is equivalent
to a missing one.

A submodule body may contain parameters (\ref{ch-ned-ref:sec:parameters})
and gates (\ref{ch-ned-ref:sec:module-interfaces}).

A submodule body cannot define new parameters or gates. It is only
allowed to assign existing parameters, and to set the vector
size of existing gate vectors.

It is also allowed to add or modify properties and parameter/gate properties.



\subsection{Connections}
\label{ch-ned-ref:sec:connections}

Connections are defined in the \fkeyword{connections} section of the compound module.

Normally, all gates must be connected, including submodule gates and the gates
of the compound module. When the \fkeyword{allowunconnected} modifier is present
after \fkeyword{connections}, gates will be allowed to be left unconnected.

\begin{note}
    The \fprop{@directIn} and \fprop{@loose} gate properties are alternatives to the
    \ttt{connections allow\-unconnected} syntax; see \ref{ch-ned-ref:sec:gates}.
\end{note}

\subsubsection{Connections and Connection Groups}

The connections section may contain any number of connections and
connection groups. A connection group is one or more connections
grouped with curly braces.

Both connections and connection groups may be conditional (\fkeyword{if}
keyword) or may be multiple (\fkeyword{for} keyword).

Any number of \fkeyword{for} and \fkeyword{if} clauses may be added to
a connection or connection loop; they are interpreted as if they were
nested in the given order. Loop variables of a \fkeyword{for} may be
referenced from subsequent conditions and loops as well as in module and
gate index expressions in the connections.

See the NED Grammar (\ref{cha:ned-language-grammar}) for the exact syntax.

Example connections:

\begin{ned}
a.out --> b.in;
c.out --> d.in if p>0;
e.out[i] --> f[i].in for i=0..sizeof(f)-1, if i%2==0;
\end{ned}

Example connection groups:

\begin{ned}
if p>0 {
    a.out --> b.in;
    a.in <-- b.out;
}
for i=0..sizeof(c)-1, if i%2==0 {
    c[i].out --> out[i];
    c[i].in <-- in[i];
}
for i=0..sizeof(d)-1, for j=0..sizeof(d)-1, if i!=j {
    d[i].out[j] --> d[j].in[i];
}
for i=0..sizeof(e)-1, for j=0..sizeof(e)-1 {
    e[i].out[j] --> e[j].in[i] if i!=j;
}
\end{ned}


\subsubsection{Connection Syntax}

The connection syntax uses arrows (\ttt{-{}->}, \ttt{<-{}-}) to connect
\fkeyword{input} and \fkeyword{output} gates, and double arrows
(\ttt{<-{}->}) to connect two \fkeyword{inout} gates. The latter is
also said to be a bidirectional connection.

Arrows point from the source gate (a submodule output gate or a compound
module input gate) to the destination gate (a submodule input gate or a
compound module output gate). Connections may be written either left to right
or right to left, that is, \ttt{a-{}->b} is equivalent to \ttt{b<-{}-a}.

Gates are specified as \textit{modulespec.gatespec} (to connect a submodule),
or as \textit{gatespec} (to connect the compound module). \textit{modulespec}
is either a submodule name (for scalar submodules), or a submodule name plus
an index in square brackets (for submodule vectors). For scalar gates,
\textit{gatespec} is the gate name; for gate vectors it is either the gate name
plus an index in square brackets, or \textit{gatename}\ttt{++}.

The \textit{gatename}\ttt{++} notation causes the first unconnected gate index
to be used. If all gates of the given gate vector are connected, the behavior
is different for submodules and for the enclosing compound module.
For submodules, the gate vector expands by one. For the compound module,
it is an error to use \ttt{++} on a gate vector with no unconnected gates.

\begin{rationale}
    The reason it is not supported to expand the gate vector of the compound
    module is that the module structure is built in top-down order: new gates
    would be left unconnected on the outside, as there is no way in NED to
    "go back" and connect them afterwards.
\end{rationale}

When the \ttt{++} operator is used with \ttt{\$i} or \ttt{\$o}
(e.g. \ttt{g\$i++} or \ttt{g\$o++}, see later), it will actually add
a gate pair (input+output) to maintain equal gate size for the two
directions.

The syntax to associate a channel (see \ref{ch-ned-ref:sec:channels})
with the connection is to use two arrows with a channel specification
in between (see later). The same syntax is used to add properties such as
\fprop{@display} to the connection.

%% TODO examples

%% TODO examples with a channel


\subsubsection{Inout Gates}

An inout gate is represented as a gate pair: an input gate and an output gate.
The two sub-gates may also be referenced and connected individually, by adding
the \ttt{\$i} and \ttt{\$o} suffix to the name of the inout gate.

A bidirectional connection (which uses a double arrow to connect two inout gates),
is also a shorthand for two uni-directional connections; that is,

\begin{ned}
a.g <--> b.g;
\end{ned}

is equivalent to
\begin{ned}
a.g$o --> b.g$i;
a.g$i <-- b.g$o;
\end{ned}

In inout gate vectors, gates are always in pairs, that is,
\ttt{sizeof(g\$i)==sizeof(g\$o)} always holds. It is maintained even
when \ttt{g\$i++} or \ttt{g\$o++} is used: the \ttt{++} operator will
add a gate pair, not just an input or an output gate.


\subsubsection{Specifying Channels}

A channel specification associates a channel object with the connection.
A channel object is an instance of a channel type (see \ref{ch-ned-ref:sec:channels}).

The channel type that will be instantiated as the channel object may be specified
in several ways:

\begin{itemize}
  \item with a concrete channel type name, or
  \item may be implicitly determined from the set of parameters used (see later), or
  \item by a string-valued expression that evaluates to the name of a
        channel type, or
  \item the type name may come from the configuration.
\end{itemize}

In the latter two cases, the \fkeyword{like} keyword is used, and a
channel interface type (\ref{ch-ned-ref:sec:channel-interfaces})
needs to be specified as well, which the concrete channel type needs
to implement to be eligible to be chosen. In the second case, the
string expression is specified in angle braces (\ttt{<...>}); in the
third case, an empty pair of angle braces is used (\ttt{<>}).
The syntax is similar to the submodule syntax (see \ref{ch-ned-ref:sec:submodules}).

\begin{note}
    When using the \ttt{<>} syntax, the actual NED type should be
    provided with the \fconfig{type-name} configuration option,
    where the object pattern should be the source gate plus \ttt{.channel}:
    \ttt{**.host[*].g\$o.channel.\-type-name=\-"EthernetChannel"}.
\end{note}

\begin{note}
    As bidirectional connections (those using double arrows, \ttt{<-{}->})
    are a shorthand for two uni-directional connections, bidirectional
    connections with channels will actually create \textit{two} channel
    objects, one for each direction!
\end{note}


\subsubsection{Channel Parameters and Properties}

A channel definition may or may not have a body (a curly brace
delimited block). An empty channel body (\ttt{\{ \}}) is equivalent
to a missing one.

A channel body may contain parameters (\ref{ch-ned-ref:sec:parameters}).

A channel body cannot define new parameters. It is only
allowed to assign existing parameters.

It is also allowed to add or modify properties and parameter properties.


\subsubsection{Implicit Channel Type}

When a connection uses an unnamed channel type (\ttt{-{}->
\{\ldots\} -{}->} syntax), the actual NED type to be used will depend on the
parameters set in the connection.

When no parameters are set, \ttt{ned.IdealChannel} is chosen.

When only \ttt{ned.DelayChannel} parameters are used (\ttt{delay}
and \ttt{disabled}), \ttt{ned.DelayChannel} is chosen.

When only \ttt{ned.DatarateChannel} parameters are used
(\ttt{datarate}, \ttt{delay}, \ttt{ber}, \ttt{per}, \ttt{disabled}),
the chosen channel type will be \ttt{ned.DatarateChannel}.

Unnamed channels connections cannot use any other parameters.



\subsection{Inner Types}
\label{ch-ned-ref:sec:inner-types}

Inner types are defined in the \fkeyword{types} section of the component type.

Inner types are only visible inside the enclosing component type.



\subsection{Name Uniqueness}

Identifier names within a component must be unique. That is, a submodule
or inner type cannot be named the same, or the same as a gate or
parameter of the parent module.



\subsection{Parameter Assignment Order}
\label{ch-ned-ref:sec:param-assignment-order}

A module or channel parameter may be assigned in \fkeyword{parameters}
blocks (see \ref{ch-ned-ref:sec:parameters}) at various places in NED: in
the module or channel type that defines it; in the type's subclasses; in
the submodule or connection that instantiates the type. The parameter may
also be assigned using pattern assignments (see
\ref{ch-ned-ref:sec:pattern-assignments}) in any compound module that uses
the given module or channel type directly or indirectly.

Patterns are matched against the relative path of the parameter, which is
the relative path of its submodule or connection, with a dot and the
parameter name appended. The relative path is composed of a list of
submodule names (name plus index) separated by dots; a connection is
identified by the full name of its source gate plus the name of the channel
object (which is currently always \ttt{channel}) separated by a dot.

\begin{note}
As bidirectional connections are a shorthand for two unidirectional
connections, the source gate name is qualified with \ttt{$i} or
\ttt{$o} in the relative path.
\end{note}

Note that the \fkeyword{parameters} keyword itself is optional,
and is usually not written out in submodules and connections.

This section describes the module and channel parameter assignments procedure.

The general rules are the following:

\begin{enumerate}
  \item A (non-default) parameter assignment may not be overridden later;
    that is, if there are assignments in multiple places, the assignment
    ``closest'' to the parameter declaration will be effective; others
    will be flagged as errors.
  \item A default value is only used if a non-default value is not present
    for the given parameter. A non-default value may also come from a source
    external to NED, namely the simulation configuration (\ffilename{omnetpp.ini}).
  \item Unlike non-default values, a default value \textit{may} be overridden;
    that is, if there are default value assignments in multiple places,
    the assignment ``farthest'' from the parameter declaration will win.
  \item Among pattern assignments within the same \fkeyword{parameters}
    block, the first match will win. Pattern assignments with default and
    non-default values are considered to be two disjoint sets, only one of
    which are searched at a time.
\end{enumerate}

This yields the following conceptual search order for non-default parameter
assignments:

\begin{enumerate}
  \item First, the NED type that contains the parameter declaration is checked;
  \item Then its subclasses are checked;
  \item Then the submodule or connection that instantiates the type is checked;
  \item Then the compound module that contains the submodule or connection is
    checked for matching pattern assignments;
  \item Then, assuming the compound module is part of a network, the search
    for matching pattern assignments continues up on the module tree until the root
    (the module that represents the network). At each level (compound module),
    first the specific submodule definition is checked, then the (parent) compound module.
    If a compound module is subclassed before instantiated, the base type is checked
    first.
\end{enumerate}

When no (non-default) assignment is found, the same places are searched in the
\textit{reverse order} for default value assignments. If no default value is
found, an error may be raised or the user may be interactively prompted.

To illustrate the above rules, consider the following example where we
want to assign parameter \textit{p}:

\begin{ned}
simple A { double p; }
simple A2 extends A {...}
module B { submodules: a2: A2 {...} }
module B2 extends B {...}
network C { submodules: b2: B2 {...} }
\end{ned}

Here, the search order is: \textit{A, A2, a2, B, B2, b2, C}. NED
conceptually searches the \fkeyword{parameters} blocks in that order for a
(non-default) value, and then in reverse order for a default value.

The full search order and the form of assignment expected on each level:

\begin{enumerate}
  \item \ttt{A  \{ p = ...; \}}
  \item \ttt{A2 \{ p = ...; \}}
  \item \ttt{a2 \{ p = ...; \}}
  \item \ttt{B  \{ a2.p = ...; \}}
  \item \ttt{B2 \{ a2.p = ...; \}}
  \item \ttt{b2 \{ a2.p = ...; \}}
  \item \ttt{C  \{ b2.a2.p = ...; \}}
  \item \ttt{C  \{ b2.a2.p = default(...); \}}
  \item \ttt{b2 \{ a2.p = default(...); \}}
  \item \ttt{B2 \{ a2.p = default(...); \}}
  \item \ttt{B  \{ a2.p = default(...); \}}
  \item \ttt{a2 \{ p = default(...); \}}
  \item \ttt{A2 \{ p = default(...); \}}
  \item \ttt{A  \{ p = default(...); \}}
\end{enumerate}

If only a default value is found or not even that, external configuration
has a say. The configuration may contain an assignment for \ttt{C.b2.a2.p};
it may apply the default if there is one; it may ask the user interactively
to enter a value; or if there is no default, it may raise an error
\textit{``no value for parameter''}.



\subsection{Type Name Resolution}
\label{ch-ned-ref:sec:type-name-resolution}

Names from other NED files can be referred to either by fully qualified
name (``\ttt{inet.network\-layer.ip.RoutingTable}''), or by short name
(``\ttt{RoutingTable}'') if the name is visible.

Visible names are:

\begin{itemize}
  \item inner types;
  \item anything from the same package;
  \item imported names.
\end{itemize}

\subsubsection{Imports}

Imports have a similar syntax to Java, but they are more flexible with wildcards.
All of the following are legal:

\begin{ned}
import inet.protocols.network.ip.RoutingTable;
import inet.protocols.network.ip.*;
import inet.protocols.network.ip.Ro*Ta*;
import inet.protocols.*.ip.*;
import inet.**.RoutingTable;
\end{ned}

One asterisk "*" stands for "any character sequence not containing
period"; two asterisks mean "any character sequence which may
contain period". No other wildcards are recognized.

An import not containing a wildcard MUST match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

Inner types may not be referenced outside their enclosing types.

\subsubsection{Base Types and Submodules}

Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.


\subsubsection{Parametric Module Types ("like" Submodules)}

Lookup of the actual module type for "like" submodules differs from normal
lookups. This lookup ignores the imports in the file altogether.
Instead, it collects all modules that support the given interface
and match the given type name string (i.e. end in the same simple name,
or have the same fully qualified name). The result must be exactly
one module type.

The algorithm for parametric channel types works in the same way.


\subsubsection{Network Name in the Ini File}

The network name in the ini file may be given as a fully qualified name
or as a simple (unqualified) name.

Simple (unqualified) names are tried with the same package as the
ini file is in (provided it is in a NED directory).


\subsection{Implementing an Interface}
\label{ch-ned-ref:sec:implementing-an-interface}

A module type may implement one or more module interfaces, and a channel type
may implement one or more channel interfaces, using the \fkeyword{like}
keyword.

The module or channel type is required to have \textit{at least} those
parameters and gates that the interface has.

Regarding component properties, parameter properties and gate properties
defined in the interface: the module or channel type is required to have at
least those properties, with at least the same values. It may have
additional properties, and properties may add more keys and values.

\begin{note}
  Implementing an interface does not cause the properties, parameters and
  gates to be interited by the module or channel type; they have to be added
  explicitly.
\end{note}

\begin{note}
  A module or channel type may have extra properties, parameters and gates
  in addition to those in the interface.
\end{note}



\subsection{Inheritance}
\label{ch-ned-ref:sec:inheritance}

\begin{itemize}
  \item A simple module may only extend a simple module.
  \item A compound module may only extend a compound module.
  \item A channel may only extend a channel.
  \item A module interface may only extend a module interface (or several module
        interfaces).
  \item A channel interface may only extend a channel interface (or several
        channel interfaces).
\end{itemize}

A network is a shorthand for a compound module with the \fprop{@isNetwork}
property set, so the same rules apply to it as to compound modules.

Inheritance may:
\begin{itemize}
    \item add new properties, parameters, gates, inner types, submodules,
          connections, as long as names do not conflict with inherited names
    \item modify inherited properties, and properties of inherited parameters and
          gates
    \item it may not modify inherited submodules, connections and inner types
\end{itemize}

Other inheritance rules:
\begin{itemize}
    \item  for inner types:
       new inner types can be added, but inherited ones cannot be changed
    \item  for properties:
       contents will be merged (rules like for display strings: values on
       same key and same position will overwrite old ones)
    \item for parameters:
       type cannot be redefined;
       value may be redefined in subclasses or at place of usage
    \item  for gates:
       type cannot be redefined;
       vector size may be redefined in subclasses or at place of usage
    \item  for gate/parameter properties:
       extra properties can be added;
       existing properties can be overridden/extended as for standalone properties
    \item  for submodules:
       new submodules may be added, but inherited ones cannot be modified
    \item  for connections:
       new connections may be added, but inherited ones cannot be modified
\end{itemize}

See other rules for specifics.

\subsubsection{Property Inheritance}

Generally, properties may be modified via inheritance. Inheritance may:

\begin{itemize}
    \item add new keys
    \item add/overwrite values for existing keys
    \item remove a value from an existing key (by using the special value '-')
\end{itemize}


\subsubsection{Parameter Inheritance}

Default values for parameters may be overridden in subclasses.

Parameter (non-default) assignments may also be overridden in subclasses.

\begin{rationale}
    The latter is needed for ease of use of channels and their \ttt{delay},
    \ttt{ber}, \ttt{per}, \ttt{datarate} parameters.
\end{rationale}

\subsubsection{Gate Inheritance}

Gate vector size may not be overridden in subclasses.


\subsection{Network Build Order}
\label{ch-ned-ref:sec:build-order}

When a network in instantiated for simulation, the module tree is built in
a top-down preorder fashion. This means that starting from an empty system
module, all submodules are created, their parameters and vector sizes are
assigned, and they get fully connected before proceeding to go into the
submodules to build their internals.

This implies that inside a compound module definition (including in
submodules and connections), one can refer to the compound module's
parameters and gate sizes, because they are already built at the time of
usage.

The same rules apply to compound or simple modules created dynamically during
runtime.

\section{Expressions}
\label{ch-ned-ref:sec:expressions}

NED language expressions\index{ned!expressions} have a C-like syntax, with
some variations on operator names (see \ttt{\textasciicircum}, \ttt{\#}, \ttt{\#\#}).
Expressions may refer to module parameters, loop variables (inside connection
\fkeyword{for} loops), gate vector and module vector sizes, and other attributes
of the model. Expressions can use built-in and user-defined functions as well.

\subsection{Operators}
\index{ned!expressions!operators}

The following operators are supported (in order of decreasing precedence):

\begin{longtable}{|l|l|}
\hline
\tabheadcol
\tbf{Operator}                   & \tbf{Meaning} \\\hline
%%
\ttt{-}, \ttt{!}, \ensuremath{\sim} & unary minus, negation, bitwise complement \\\hline
%%
\ttt{{\textasciicircum}}         & power-of \\\hline
%%
\ttt{*}, \ttt{/}, \ttt{\%}       & multiply, divide, integer modulo \\\hline
%%
\ttt{+}, \ttt{-}                 & add, subtract, string concatenation \\\hline
%%
\ttt{<<}, \ttt{>>}               & bitwise shift \\\hline
%%
\ttt{\&}, \ttt{|}, \ttt{\#}      & bitwise and, or, xor \\\hline
%%
\ttt{==}                         & equal \\
\ttt{!=}                         & not equal \\
\ttt{>}, \ttt{>=}                & greater than, greater than or equal to\\
\ttt{<}, \ttt{<=}                & less than, less than or equal to \\\hline
%%
\ttt{\&\&}, \ttt{||}, \ttt{\#\#} & logical operators and, or, xor \\\hline
%%
\ttt{?:}                         & the C/C++ ``inline if'' \\\hline
\end{longtable}

\subsubsection{Conversions}

Values are of type boolean, long, double, string, or xml element.
A long or double may have an associated measurement unit (\ttt{s}, \ttt{mW}, etc.)

Long and double values are implicitly converted to one another where needed.
Conversion is performed with the C++ language's built-in typecast operator.

There is no implicit conversion between bool and numeric types, so \ttt{0}
is not a synonym for \fkeyword{false}, and nonzero numbers are not a synonym
for \fkeyword{true}.

There is also no conversion between string and numeric types, so e.g. \ttt{"foo"+5}
is illegal. There are functions for converting a number to string and vice versa.

\begin{note}
Implementation note: Currently the stack-based evaluation engine
represents all numbers in \ttt{double}, i.e. it does not use \ttt{long}
on the stack. (This may change in future releases.)
Details:

\begin{itemize}
  \item Integers (integer constants, \ttt{long} parameters, etc) are
        converted to \ttt{double}.
  \item For bitwise operators, \ttt{double}s are converted to \ttt{unsigned long}
        using the C/C++ built-in conversion (type cast), the operation is performed,
        then the result is converted back to \ttt{double}.
  \item For the modulo operator (\%), operands are converted to \ttt{long}.
\end{itemize}
\end{note}


\subsubsection{Unit Handling}

Operations involving numbers with units work in the following way:

Addition, substraction, and numeric comparisons require their arguments to
have the same unit or compatible units; in the latter case a unit conversion
is performed before the operation. Incompatible units cause an error.

%%TODO example

Modulo, power-of and the bitwise operations require their arguments to be
dimensionless, otherwise the result would depend on the choice of the unit.

\begin{note}
If you need a floating-point modulo operator that handles units as well, use
the \ttt{fmod()} function.
\end{note}

%%TODO example

Multiplying two numbers with units is not supported.

%%TODO example

For division, dividing two numbers with units is only supported if the two
units are convertible (i.e. the result will be dimensionless). Dividing
a dimensionless number with a number with unit is not supported.

%%TODO example


\subsection{Referencing Parameters and Loop Variables}

Identifiers in expressions occurring \textit{anywhere} in component definitions
are interpreted as referring to parameters of the given component.

Exception: if an identifier occurs in a connection \fkeyword{for} loop and names
a previously defined loop variable, then it is understood as referring to
the loop variable.

In submodule bodies, parameters of the same submodule can be referred to
with the \fkeyword{this} qualifier: \ttt{this.destAddress}.

Expressions may also refer to parameters of submodules defined earlier
in NED file, using the \ttt{submoduleName.paramName} or the
\ttt{submoduleName[index].paramName} syntax.


\subsection{The \fkeyword{index} Operator}

The \fkeyword{index} operator is only allowed in a vector submodule's body,
and yields the index of the submodule instance.


\subsection{The \fkeyword{sizeof()} Operator}

The \fkeyword{sizeof()} operator expects one argument, and it is only accepted
in compound module definitions.

The \ttt{sizeof(identifier)} syntax occurring \textit{anywhere} in a compound
module yields the size of the named submodule or gate vector of the
compound module.

Inside submodule bodies, the size of a gate vector of the same submodule
can be referred to with the \fkeyword{this} qualifier: \ttt{sizeof(this.out)}.

To refer to the size of a submodule's gate vector defined earlier in the
NED file, use the \ttt{sizeof(submoduleName.gateVectorName)} or
\ttt{sizeof(submoduleName[index].gate\-Vector\-Name)} syntax.


\subsection{The \fkeyword{xmldoc()} Operator}

The \fkeyword{xmldoc()} operator can be used to assign XML-type parameters,
that is, point them to XML files or to specific elements inside XML files.

\fkeyword{xmldoc()} has two flavors: one accepts a file name, and the second accepts
a file name plus an XPath-like expression which selects an element
inside the XML file.

%% TODO fname mihez kepest relative

\fkeyword{xmldoc()} with two arguments accepts a path expression
to select an element within the document. The expression syntax is
similar to XPath.

If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

The expression syntax is the following:
\begin{itemize}
  \item An expression consists of \textit{path components} (or "steps")
        separated by "\ttt{/}" or "\ttt{//}".
  \item A path component can be an element tag name, "\ttt{*}", "\ttt{.}"
        or "\ttt{..}".
  \item "\ttt{/}" means child element (just as in \ttt{/usr/bin/gcc});
        "\ttt{//}" means an element any number of levels under the current element.
  \item "\ttt{.}", "\ttt{..}" and "\ttt{*}" mean the current element,
        the parent element, and an element with any tag name, respectively.
  \item Element tag names and "\ttt{*}" can have an optional predicate
        in the form "\ttt{[position]}" or "\ttt{[@attribute='value']}".
        Positions start from zero.
  \item Predicates of the form "\ttt{[@attribute=\textit{\$param}]}" are also
        accepted, where \ttt{\textit{\$param}} can be one of:
        \ttt{\$MODULE\_\-FULLPATH},
        \ttt{\$MODULE\_\-FULLNAME},
        \ttt{\$MODULE\_\-NAME},
        \ttt{\$MODULE\_\-INDEX},
        \ttt{\$MODULE\_\-ID},
        \ttt{\$PARENT\-MODULE\_\-FULLPATH},
        \ttt{\$PARENT\-MODULE\_\-FULLNAME},
        \ttt{\$PARENT\-MODULE\_\-NAME},
        \ttt{\$PARENT\-MODULE\_\-INDEX},
        \ttt{\$PARENT\-MODULE\_\-ID},
        \ttt{\$GRAND\-PARENT\-MODULE\_\-FULLPATH},
        \ttt{\$GRAND\-PARENT\-MODULE\_\-FULLNAME},
        \ttt{\$GRAND\-PARENT\-MODULE\_\-NAME},
        \ttt{\$GRAND\-PARENT\-MODULE\_\-INDEX},
        \ttt{\$GRAND\-PARENT\-MODULE\_\-ID}.
\end{itemize}

\subsection{Functions}
\index{ned!functions}

The functions available in NED are listed in Appendix
\ref{cha:ned-functions}.

\subsection{Units of Measurement}
\label{ch-ned-ref:sec:units}

The following measurements units are recognized in constants. Other units can
be used as well, but there are no conversions available for them (i.e.
\ttt{parsec} and \ttt{kiloparsec} will be treated as two completely unrelated
units.)

\begin{longtable}{|c|c|r|}
  \hline
  \tabheadcol
  \tbf{Unit} & \tbf{Name} & \tbf{Value} \\\hline
  s & second & \\\hline
  d & day & 86400s \\\hline
  h & hour & 3600s \\\hline
  min & minute & 60s \\\hline
  ms & millisecond & 1e-3s \\\hline
  us & microsecond & 1e-6s \\\hline
  ns & nanosecond & 1e-9s \\\hline
  ps & picosecond & 1e-12s \\\hline
  bps & bit/sec & \\\hline
  Kbps & kilobit/sec & 1e3bps \\\hline
  Mbps & megabit/sec & 1e6bps \\\hline
  Gbps & gigabit/sec & 1e9bps \\\hline
  Tbps & terabit/sec & 1e12bps \\\hline
  B & byte & \\\hline
  KB & kilobyte & 1024B \\\hline
  MB & megabyte & 1.04858e6B \\\hline
  GB & gigabyte & 1.07374e9B \\\hline
  TB & terabyte & 1.09951e12B \\\hline
  b & bit & \\\hline
  m & meter & \\\hline
  km & kilometer & 1e3m \\\hline
  cm & centimeter & 1e-2m \\\hline
  mm & millimeter & 1e-3m \\\hline
  W & watt & \\\hline
  mW & milliwatt & 1e-3W \\\hline
  Hz & hertz & \\\hline
  kHz & kilohertz & 1e3Hz \\\hline
  MHz & megahertz & 1e6Hz \\\hline
  GHz & gigahertz & 1e9Hz \\\hline
  g & gram & 1e-3kg \\\hline
  kg & kilogram & \\\hline
  J & joule & \\\hline
  kJ & kilojoule & 1e3J \\\hline
  MJ & megajoule & 1e6J \\\hline
  V & volt & \\\hline
  kV & kilovolt & 1e3V \\\hline
  mV & millivolt & 1e-3V \\\hline
  A & ampere & \\\hline
  mA & milliampere & 1e-3A \\\hline
  uA & microampere & 1e-6A \\\hline
\end{longtable}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:



