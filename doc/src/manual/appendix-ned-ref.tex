\appendixchapter{NED Reference}
\label{cha:ned-ref}

\section{Syntax}

\subsection{NED file extension}

NED files have the \texttt{.ned} file name suffix. This is mandatory, and
cannot be overridden.

\subsection{NED file encoding}

NED files are read as 8-bit-clean ASCII. This permits NED files saved
in UTF-8, or any character set compatible with ASCII (8859-1, etc).

\begin{note}
    There is no official way to determine the encoding of a NED file. It is up
    to the user to configure the correct encoding in text editors and other
    tools that are used to edit or process NED files.
\end{note}

Keywords and other syntactic elements in NED are ASCII, and identifiers must be
ASCII as well. Comments and string literals may contain characters above
127. String literals (e.g. in parameter values) will be passed to the C++ code
as \ttt{const char *} without any conversion; it is up to the simulation model
to interpret them using the desired encoding.

Line ending may be either CR or CRLF, regardless of platform.


\subsection{Reserved words}

Authors have to take care that no reserved words are used as identifiers.
The reserved words of the NED language are:

\ttt{allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inout input int like
module moduleinterface network output package parameters property simple
sizeof string submodules this true types volatile xml xmldoc}


\subsection{Identifiers}

Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and underscore ``\_''. Identifiers may only begin with a
letter or underscore.

The recommended way to compose identifiers from multiple words is to
capitalize the beginning of each word (\textit{camel case}).


\subsection{Case sensitivity}

Keywords and identifiers in the NED language are case sensitive. For example,
\ttt{TCP} and \ttt{Tcp} are two different names.


\subsection{Literals}

\subsubsection{String literals}

String literals use double quotes. The following C-style backslash
escapes are recognized: \ttt{{\textbackslash}b}, \ttt{{\textbackslash}f}, \ttt{{\textbackslash}n}, \ttt{{\textbackslash}r},
\ttt{{\textbackslash}t}, \ttt{{\textbackslash}{\textbackslash}}, \ttt{{\textbackslash}"}, and \ttt{{\textbackslash}xhh} where \textit{h} is a
hexadecimal digit.

\subsubsection{Numeric constants}

Numeric constants are accepted in their usual decimal or
scientific notations.

\subsubsection{Quantity constants}

A quantity constant has the form \textit{(<numeric-constant> <unit>)+}, for
example \ttt{12.5mW} or \ttt{3h 15min 37.2s}. When multiple units are present,
they have to be convertible into each other (i.e. refer to the same physical
quantity).

Section \ref{ch-ned-ref:sec:units} lists the units recognized by {\opp}.
Other units can be used as well, the only downside being that {\opp} will not be
able to perform conversions on them.


\subsection{Comments}

Comments can be placed anywhere in the NED file, with the usual C++
syntax: comments begin with a double slash `//', and last until
the end of the line.


\subsection{Grammar}

The grammar of the NED language can be found in Appendix
\ref{cha:ned-language-grammar}.

\section{Built-in definitions}
\label{ch-ned-ref:sec:built-in-defs}

The NED language has the following built-in definitions, all in the \ttt{ned}
package: channels \ttt{IdealChannel} and \ttt{DatarateChannel}, and module
interfaces \ttt{IBidirectionalChannel} and \ttt{IUnidirectionalChannel}; the
latter two are reserved for future use.

%%
%% Note: the following code is from src/nedxml/nedparser.cc,
%%       NEDParser::getBuiltInDeclarations()
%%
\begin{verbatim}
package ned;

@namespace("");

channel IdealChannel {
    @class(cIdealChannel);
}

channel DelayChannel {
    @class(cDelayChannel);
    bool disabled = false;
    double delay = 0s @unit(s);
}

channel DatarateChannel {
    @class(cDatarateChannel);
    bool disabled = false;
    double delay = 0s @unit(s);
    double datarate = 0bps @unit(bps);
    double ber = 0;
    double per = 0;
}

moduleinterface IBidirectionalChannel {
    gates:
        inout a;
        inout b;
}

moduleinterface IUnidirectionalChannel {
    gates:
        input i;
        output o;
}
\end{verbatim}



\section{Packages}
\label{ch-ned-ref:sec:packages}

NED supports hierarchical namespaces called \textit{packages}. The solution
is roughly modelled after Java's packages, with minor changes.


\subsection{Package declaration}

The package of the declarations in a NED file is determined by the package
declaration in the file (\fkeyword{package} keyword). A NED file may contain at
most one package declaration. If there is no package declaration, the file's
contents is in the \textit{default package}.

Component type names must be unique within their package.


\subsection{Directory structure, package.ned}

Like in Java, the directory of a NED file must match the package
declaration. However, it is possible to omit directories at the top which do
not contain any NED files (like the typical \ttt{/org/\textit{<projectname>}}
directories in Java).

The top of a directory tree containing NED files is named a \textit{NED source
folder}. The \ttt{package.ned} file direcly in a NED source folder plays a
special role.

If there is no toplevel \ttt{package.ned} or it contains no package declaration,
the declared package of a NED file in the folder \ttt{\textit{<srcfolder>}/x/y/z}
\textit{must} be \ttt{x.y.z}.
If there is a toplevel \ttt{package.ned} and it declares to be in package
\ttt{a.b}, then any NED file in the folder \ttt{\textit{<srcfolder>}/x/y/z}
\textit{must} have the declared package \ttt{a.b.x.y.z}.

\begin{note}
    \ttt{package.ned} files are allowed in other folders as well, but they
    are not treated specially, i.e. they cannot be used to define the package
    they are in.
\end{note}




\section{Components}

Simple modules, compound modules, networks, channels, module interfaces
and channel interfaces are called \textit{components}.


\subsection{Simple modules}

Simple module types are declared with the \fkeyword{simple} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Simple modules may have properties (\ref{ch-ned-ref:sec:properties}),
parameters (\ref{ch-ned-ref:sec:parameters})
and gates (\ref{ch-ned-ref:sec:gates}).

A simple module type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A simple module type may extend another simple module type, and
may implement one or more module interfaces (\ref{ch-ned-ref:sec:module-interfaces}).
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance}.

Every simple module type has an associated C++ class, which must be
subclassed from \cclass{cSimpleModule}. The way of associating the
NED type with the C++ class is described in section
\ref{ch-ned-ref:sec:resolving-cpp-class}.



\subsection{Compound modules}
\label{ch-ned-ref:sec:compound-modules}

Compound module types are declared with the \fkeyword{module} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Compound modules may have properties (\ref{ch-ned-ref:sec:properties}),
parameters (\ref{ch-ned-ref:sec:parameters}),
and gates (\ref{ch-ned-ref:sec:gates}); its internal structure is defined by
its submodules (\ref{ch-ned-ref:sec:submodules}) and
connections (\ref{ch-ned-ref:sec:connections});
and it may also have inner types (\ref{ch-ned-ref:sec:inner-types})
that can be used for submodules and connections.

A compound module type may extend another compound module type, and
may implement one or more module interfaces (\ref{ch-ned-ref:sec:module-interfaces}).
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance}.



\subsection{Networks}
\label{ch-ned-ref:sec:networks}

\subsubsection{The network keyword}

A network declared with the \fkeyword{network} keyword is equivalent to a compound
module (\fkeyword{module} keyword) with the \ttt{@isNetwork(true)} property.

\begin{note}
    A simple module can only be designated to be a network by spelling out the
    \ttt{@isNetwork} property; the \fkeyword{network} keyword cannot
    be used for that purpose.
\end{note}

\subsubsection{The @isNetwork property}

The \ttt{@isNetwork} property is only accepted on simple modules and
compound modules. The value may be empty, true or false:

\begin{verbatim}
@isNetwork;
@isNetwork();
@isNetwork(true);
@isNetwork(false);
\end{verbatim}

The empty value corresponds to \ttt{@isNetwork(true)}.

The \ttt{@isNetwork} property does NOT get inherited, that is, a subclass
of a module with \ttt{@isNetwork} set does not automatically become a network.
The \ttt{@isNetwork} property needs to be explicitly added to the subclass
to make it a network.

\begin{rationale}
    Subclassing may introduce changes to a module that make it unfit to be used
    as a network.
\end{rationale}



\subsection{Channels}
\label{ch-ned-ref:sec:channels}

Channel types are declared with the \fkeyword{channel} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Channel types may have properties (\ref{ch-ned-ref:sec:properties})
and parameters (\ref{ch-ned-ref:sec:parameters}).

A channel type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A channel type may extend another channel type, and
may implement one or more channel interfaces (\ref{ch-ned-ref:sec:channel-interfaces}).
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance}.

Every channel type has an associated C++ class, which must be
subclassed from \cclass{cChannel}. The way of associating the
NED type with the C++ class is described in section
\ref{ch-ned-ref:sec:resolving-cpp-class}.



\subsection{Module interfaces}
\label{ch-ned-ref:sec:module-interfaces}

Module interface types are declared with the \fkeyword{moduleinterface} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Module interfaces may have properties (\ref{ch-ned-ref:sec:properties}),
parameters (\ref{ch-ned-ref:sec:parameters}), and
gates (\ref{ch-ned-ref:sec:gates}). However, parameters are not allowed
to have a value assigned, not even a default value.

A module interface type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A module interface type may extend one or more other module interface types.
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance}.


FIXME

An interface (module interface or channel interface) may NOT contain
parameter assignment or parameter default value assignment. An interface
may NOT contain inner types. (Rationale: what use would they be?).

A module or channel type that implements ("like") an interface is
required to have at least the parameters and, for modules, the gates
defined in the interface, with the same types.

Regarding properties, parameter properties and gate properties defined
in the interface: the module or channel is required to have those properties,
with at least the same values. It may have additional properties,
and properties may add more keys and values (see property inheritance.)



\subsection{Channel interfaces}
\label{ch-ned-ref:sec:channel-interfaces}

Channel interface types are declared with the \fkeyword{channelinterface} keyword;
see the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
syntax.

Channel interfaces may have properties (\ref{ch-ned-ref:sec:properties}) and
parameters (\ref{ch-ned-ref:sec:parameters}). However, parameters are not
allowed to have a value assigned, not even a default value.

A channel interface type may not have inner types (\ref{ch-ned-ref:sec:inner-types}).

A channel interface type may extend one or more other channel interface types.
Inheritance rules are described in section \ref{ch-ned-ref:sec:inheritance}.



\subsection{Resolving the implementation C++ class}
\label{ch-ned-ref:sec:resolving-cpp-class}

The procedure for determiming the C++ implementation class for simple modules
and for channels are identical. It goes as follows (we are going to say
\textit{component} instead of \textit{``simple module or channel''}):

If the component extends another component and has no
\ttt{@class} property, the C++ implementation class is inherited from the base
type.

If the component contains has a \ttt{@class} property, the C++ class
name will be composed of the \textit{current namespace} (see
\ref{cha:ned-ref:current-namespace}) and the value of the \ttt{@class}
property. The \ttt{@class} property should contain a single value.

\begin{note}
    The \ttt{@class} property may itself contain a namespace declaration (ie.
    may contain ``\ttt{::}'').
\end{note}

If the component contains no \ttt{@class} property and has no base
class, the C++ class name will be composed of the \textit{current namespace} and the
unqualified name of the component.

\begin{note}
    NED subclassing does not imply subclassing the C++ implementation. If you
    want to subclass a simple module or channel in NED as well as in C++, you
    explicitly need to specify the \ttt{@class} property, otherwise the
    derived simple module or channel will continue to use the C++ class from its
    super type.
\end{note}

\subsubsection{Current namespace}
\label{cha:ned-ref:current-namespace}

The \textit{current namespace} is the value of the first \ttt{@namespace}
property found while searching the following order:
\begin{enumerate}
  \item the current NED file
  \item the \ttt{package.ned} file in the current package
  \item the \ttt{package.ned} file of the parent package or the first ancestor
        package searching upwards
\end{enumerate}

The \ttt{@namespace} property should contain a single value.

\begin{note}
    This was considered and discarded: \ttt{module X extends ASimple}
    instead of \ttt{simple X extends ASimple}. It was proposed because
    otherwise, if base type's implementation gets changed from simple to compound, all
    subclasses will have to be changed. Idea discarded because the confusion
    this would create is worse than the problem itself.
\end{note}



\subsection{Properties}
\label{ch-ned-ref:sec:properties}

Properties are a means of adding metadata annotations to NED files, component types,
parameters, gates, submodules, and connections.

\subsubsection{Identifying a property}

Properties are identified by name. It is possible to have several properties
on the same object with the same name, as long as they have unique indices.
An index is an identifier in square brackets after the property name.

The following example shows a property without index, one with the index \ttt{foo},
and a third with the index \ttt{bar}.

\begin{verbatim}
@statistic();
@statistic[foo]();
@statistic[bar]();
\end{verbatim}


\subsubsection{Property value}

The value of the property is specified inside parentheses. The value consists of
\textit{key-valuelist} pairs, separated by semicolons; values are separated with commas.
Example:

\begin{verbatim}
@prop(key1=value11,value12,value13;key2=value21,value22)
\end{verbatim}

Keys must be unique.

If the key+equal sign part (\ttt{key=}) is missing, the valuelist belongs
to the \textit{default key}. Examples:

\begin{verbatim}
@prop(value1,value2)
@prop(value1,value2;key1=value11,value12,value13)
\end{verbatim}

Property values have a liberal syntax (see \ref{cha:ned-language-grammar}).
Values that do not fit the grammar (notably, those containing a comma or
semicolon) need to be surrounded with double quotes.

When interpreting a property value, one layer of quotes is removed
automatically, that is, \ttt{foo} and \ttt{"foo"} are the same. To add a
value with quotation marks included, enclose it in an extra layer of
quotes: \ttt{"\textbackslash"foo\textbackslash""}.

Example:

\begin{verbatim}
@prop(marks=the ! mark, "the , mark", "the ; mark");
\end{verbatim}


\subsubsection{Placement}

TODO what can have properties, where

When a component type extends another component types, properties
are merged. This is described in section \ref{ch-ned-ref:sec:inheritance}.

\subsubsection{Property declarations}

TODO


\subsection{Parameters}
\label{ch-ned-ref:sec:parameters}

Parameters are defined or assigned in the \fkeyword{parameters} section
of the component type, submodule body or connection body.
The \fkeyword{parameters} keyword is optional, and can be omitted
without change in the meaning.

In submodules and connections, new parameters cannot be defined. One can
only assign existing parameters.

syntax

types, volatile/nonvolatile

value

\subsubsection{Evaluation}

For \fkeyword{volatile} parameters, the expression is evaluated every time the
parameter value is accessed. Non-\fkeyword{volatile} parameters are evaluated only once.

TODO const subexpression (not yet supported)

\subsubsection{Recognized parameter properties}

TODO @unit, @prompt

\subsubsection{The @unit property}

A parameter may have a \ttt{@unit} property to associate it with a physical
unit. The \ttt{@unit} property should contain one string value for the default
key. Examples:

\begin{verbatim}
@unit("s")
@unit(s)
@unit("second")
@unit(second)
\end{verbatim}

When present, values assigned to the parameter must be in the
same or in a compatible (that is, convertible) unit.
Examples:

\begin{verbatim}
  double a @unit(s) = 5s;  // OK
  double a @unit(s) = 5;   // error: should be 5s
  double a @unit(s) = 5kg; // error: incompatible unit
\end{verbatim}

@unit behavior for non-numeric parameters (string, XML) is unspecified
(may be ignored or may be an error).

The @unit property of a parameter may NOT be modified via inheritance.

Example:
\begin{verbatim}
simple A {
    double p @unit(s);
}
simple B extends A {
    p @unit(mW);  // illegal: cannot override @unit
}
\end{verbatim}



\subsection{Gates}
\label{ch-ned-ref:sec:gates}

Gates are defined in the \fkeyword{gates} section of the component type
or submodule.

In submodules, new gates cannot be defined. One can only set the size
of gate vectors defined on the component type.

TODO gate types: input, output, inout. inout consists of input+output

Gates may be scalar or vector. The vector size is specified with a
numeric expression inside the square brackets (\ttt{[...]}).
The vector size may also be left open by specifying an empty pair
of square brackets.

TODO it must be specified later (in subclasses or in submodule definition);
if not, it will be zero.


\subsubsection{Recognized gate properties}

@directIn

@loose


\subsubsection{Rules for gate vector sizes}

Gate vector sizes may NOT be overridden in subclasses.



\subsection{Submodules}
\label{ch-ned-ref:sec:submodules}

Submodules are defined in the \fkeyword{submodules} section of the compound module.

Submodules may be scalar or vector, the vector size of the latter being
specified with a numeric expression inside the square brackets (\ttt{[...]}).

The submodule's type may be specified:

\begin{itemize}
  \item with a simple or compound module type, or
  \item by a string-valued expression that evaluates to the name of a
        simple or compound module type, or
  \item may come from the configuration.
\end{itemize}

In the latter two cases, the \fkeyword{like} keyword is used, and a
module interface type (\ref{ch-ned-ref:sec:module-interfaces})
needs to be specified as well, which the concrete module type needs
to implement to be eligible to be chosen. In the second case, the
string expression is specified in angle braces (\ttt{<...>}); in the
third case, an empty pair of angle braces is used (\ttt{<>}).

See the NED Grammar (Appendix \ref{cha:ned-language-grammar}) for the
exact syntax.

A submodule definition may or may not have a body (a curly brace
delimited block). An empty submodule body (\ttt{\{ \}}) is equivalent
to a missing one.

A submodule body may contain parameters (\ref{ch-ned-ref:sec:parameters})
and gates (\ref{ch-ned-ref:sec:module-interfaces}).

A submodule body cannot define new parameters or gates. It is only
allowed to assign existing parameters, and to set the vector
size of existing gate vectors.



\subsection{Connections}
\label{ch-ned-ref:sec:connections}

Connections are defined in the \fkeyword{connections} section of the compound module.

When a connection uses an unnamed channel type (\ttt{-{}->
\{\ldots\} -{}->} syntax), the actual NED type to be used will depend on the
parameters set in the connection.

When no parameters are set, \ttt{ned.IdealChannel} is chosen.

When only \ttt{ned.DelayChannel} parameters are used (\ttt{delay}
and \ttt{disabled}), \ttt{ned.DelayChannel} is chosen.

When only \ttt{ned.DatarateChannel} parameters are used
(\ttt{datarate}, \ttt{delay}, \ttt{ber}, \ttt{per}, \ttt{disabled}),
the chosen channel type will be \ttt{ned.DatarateChannel}.

Unnamed channels connections cannot use any other parameters.

Extra params CANNOT be added in connection channel specs --
they can only be added in new channel types.



\subsection{Inner types}
\label{ch-ned-ref:sec:inner-types}

Inner types are defined in the \fkeyword{types} section of the component type.

TBD

visibility



\subsection{Name uniqueness}

Identifier names within a component must be unique. That is, submodule
or inner type cannot be named the same, or the same as a gate or
parameter of the parent module.



\subsection{Type name resolution}
\label{ch-ned-ref:sec:type-name-resolution}

Names from other NED files can be referred to either by fully qualified
name (``\ttt{inet.network\-layer.ip.RoutingTable}''), or by short name
(``\ttt{RoutingTable}'') if the name is visible.

Visible names are:

\begin{itemize}
  \item anything from the same package;
  \item imported names.
\end{itemize}

\subsubsection{Imports}

Imports have a similar syntax to Java, but they are more flexible with wildcards.
All of the following are legal:
\begin{verbatim}
import inet.protocols.network.ip.RoutingTable;
import inet.protocols.network.ip.*;
import inet.protocols.network.ip.Ro*Ta*;
import inet.protocols.*.ip.*;
import inet.**.RoutingTable;
\end{verbatim}

One asterisk "*" stands for "any character sequence not containing
period"; two asterisks mean "any character sequence which may
contain period". No other wildcards are recognized.

An import not containing wildcard MUST match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

Inner types may not be referred to outside their enclosing types.

\subsubsection{Base types and submodules}

Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.


\subsubsection{Parametric module types ("like" submodules)}

Lookup of the actual module type for "like" submodules differs for normal
lookups. This lookup ignores the imports in the file altogether.
Instead, it collects all modules that support the given interface
and match the given type name string (i.e. end in the same simple name,
or have the same fully qualified name). The result must be exactly
one module type.

The algorithm for parametric channel types works in the same way.


\subsubsection{Network name in the ini file}

Simple (unqualified) names are tried with the same package as the
ini file is in (provided it's in a NED directory).



\subsection{Inheritance}
\label{ch-ned-ref:sec:inheritance}

\begin{itemize}
  \item A simple module may only extend a simple module.
  \item A compound module may only extend a compound module.
  \item A channel may only extend a channel.
  \item A module interface may only extend a module interface (or several module
        interfaces).
  \item A channel interface may only extend a channel interface (or several
        channel interfaces).
\end{itemize}

A \fkeyword{network} is a shorthand for a compound module with the \ttt{@isNetwork}
property set, so the same rules apply to it as to compound modules.

Inheritance may:
\begin{itemize}
  \item add new properties, parameters, gates, inner types, submodules,
        connections
  \item modify inherited properties, and properties of inherited parameters and
        gates
  \item it may NOT modify inherited submodules, connections and inner types
\end{itemize}

Other inheritance rules:
\begin{itemize}
  \item  for inner types:
     can I define an inner type with the same name in subclasses? NO
  \item  for properties:
     contents will be merged (rules like for display strings: values on
     same key and same position will overwrite old ones)
  \item for parameters:
     type cannot be redefined;
     value may be redefined in subclasses or place of usage
  \item  for gates:
     type cannot be redefined;
     vector size may be redefined in subclasses or place of usage
  \item  for gate/parameter properties:
     extra properties can be added;
     existing properties can be overridden/extended like for standalone properties (?)
  \item  for submodules:
     new submodules may be added, but inherited ones cannot be modified
  \item  for connections:
     new connections may be added, but inherited ones cannot be modified
\end{itemize}

See other rules for specifics.

\subsubsection{Property inheritance}

Generally, properties may be modified via inheritance. Inheritance may:

\begin{itemize}
    \item add new keys
    \item add/overwrite values for existing keys
    \item remove a value from an existing key (by using the special value '-')
\end{itemize}


\subsubsection{Parameter inheritance}

Default values for parameters may be overridden in subclasses.

Parameter (non-default) assignments may also be overridden in subclasses.

\begin{rationale}
    The latter is needed for ease of use of channels and their \ttt{delay},
    \ttt{ber}, \ttt{per}, \ttt{datarate} parameters.
\end{rationale}

\subsubsection{Gate inheritance}

FIXME tbd



\section{Expressions}
\label{ch-ned-ref:sec:expressions}

NED language expressions\index{ned!expressions} have a C-like syntax, with
some variations on operator names (see \ttt{\textasciicircum}, \ttt{\#}, \ttt{\#\#}).
Expressions may refer to module parameters, loop variables (inside connection
\fkeyword{for} loops), gate vector and module vector sizes, and other attributes
of the model. Expressions can use built-in and user-defined functions as well.

\subsection{Operators}
\index{ned!expressions!operators}

The following operators are supported (in order of decreasing precedence):

\begin{longtable}{|l|l|}
\hline
\tabheadcol
\tbf{Operator}                   & \tbf{Meaning} \\\hline
%%
\ttt{-}, \ttt{!}, \ensuremath{\sim} & unary minus, negation, bitwise complement \\\hline
%%
\ttt{{\textasciicircum}}         & power-of \\\hline
%%
\ttt{*}, \ttt{/}, \ttt{\%}       & multiply, divide, modulus \\\hline
%%
\ttt{+}, \ttt{-}                 & add, subtract, string concatenation \\\hline
%%
\ttt{<<}, \ttt{>>}               & bitwise shift \\\hline
%%
\ttt{\&}, \ttt{|}, \ttt{\#}      & bitwise and, or, xor \\\hline
%%
\ttt{==}                         & equal \\
\ttt{!=}                         & not equal \\
\ttt{>}, \ttt{>=}                & greater, greater or equal \\
\ttt{<}, \ttt{<=}                & less, less or equal \\\hline
%%
\ttt{\&\&}, \ttt{||}, \ttt{\#\#} & logical operators and, or, xor \\\hline
%%
\ttt{?:}                         & the C/C++ ``inline if'' \\\hline
\end{longtable}

\subsubsection{Conversions}

Values are of type boolean, double, string, or xml element. A double value
may have an associated measurement unit (\ttt{s}, \ttt{mW}, etc.)

Implementation note: Currently the stack-based evaluation engine
represents all numbers in \ttt{double}, i.e. it does not use \ttt{long}
on the stack.
    \footnote{This may change in future releases.}
Details:

\begin{itemize}
  \item Integers (integer constants, \ttt{long} parameters, etc) are
        converted to \ttt{double}.
  \item For bitwise operators, \ttt{double}s are converted to \ttt{unsigned long}
        using the C/C++ builtin conversion (type cast), the operation is performed,
        then the result is converted back to \ttt{double}.
  \item For modulus (\%), the operands are converted to \ttt{long}.
\end{itemize}

There is no implicit conversion between bool and numeric types, so it is
not possible to use \ttt{0} as a synonym for \fkeyword{false}, and nonzero numbers
as synonym to \fkeyword{true}.

There is also no conversion between string and numeric types, so e.g. \ttt{"foo"+5}
is illegal. There are functions for converting a number to string and vica versa.

\subsubsection{Units}

Operations involving numbers with units work in the following way.

Addition, substraction, and numeric comparisons require their arguments to
have the same unit or compatible units; in the latter case a unit conversion
is performed before the operation. Incompatible units cause an error.

Power-of and bitwise operations require their arguments to be dimensionless.

Multiplying two numbers with units is not supported.

For division, dividing two numbers with units is only supported if the two
units are convertible (i.e. the result will be dimensionless). Dividing
a dimensionless number with a number with unit is not supported.


\subsection{Referencing parameters and loop variables}

Identifiers in expressions occurring \textit{anywhere} in component definitions
are interpreted as referring to parameters of the given component.

Exception: if an identifier occurs in a connection \fkeyword{for} loop and names
a previously defined loop variable, then it is understood as referring to
the loop variable.

In submodule bodies, parameters of the same submodule can be referred to
with the \fkeyword{this} qualifier: \ttt{this.destAddress}.

Expressions may also refer to parameters of submodules defined earlier
in NED file, using the \ttt{submoduleName.paramName} or the
\ttt{submoduleName[index].paramName} syntax.


\subsection{The \fkeyword{index} operator}

The \fkeyword{index} operator is only allowed in a vector submodule's body,
and yields the index of the submodule instance.


\subsection{The \fkeyword{sizeof()} operator}

The \fkeyword{sizeof()} operator expects one argument, and it is only accepted
in compound module definitions.

The \ttt{sizeof(identifier)} syntax occurring \textit{anywhere} in a compound
module yields the size of the named submodule or gate vector of the
compound module.

Inside submodule bodies, the size of a gate vector of the same submodule
can be referred to with the \fkeyword{this} qualifier: \ttt{sizeof(this.out)}.

To refer to the size of a submodule's gate vector defined earlier in the
NED file, use the \ttt{sizeof(submoduleName.gateVectorName)} or
\ttt{sizeof(submoduleName[index].gate\-Vector\-Name)} syntax.


\subsection{The \fkeyword{xmldoc()} operator}

The \fkeyword{xmldoc()} operator can be used to assign XML-type parameters,
that is, point them to XML files or to specific elements inside XML files.

\fkeyword{xmldoc()} has two flavours: one accepts a file name, the second accepts
a file name plus an XPath-like expression which selects an element
inside the XML file.

TODO fname mihez kepest relativ

\fkeyword{xmldoc()} with two arguments accepts a path expression
to select an element within the document. The expression syntax is
similar to XPath.

If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

The expression syntax is the following:
\begin{itemize}
  \item An expression consists of \textit{path components} (or "steps")
        separated by "\ttt{/}" or "\ttt{//}".
  \item A path component can be an element tag name, "\ttt{*}", "\ttt{.}"
        or "\ttt{..}".
  \item "\ttt{/}" means child element (just as in \ttt{/usr/bin/gcc});
        "\ttt{//}" means an element any levels under the current element.
  \item "\ttt{.}", "\ttt{..}" and "\ttt{*}" mean the current element,
        the parent element, and an element with any tag name, respectively.
  \item Element tag names and "\ttt{*}" can have an optional predicate
        in the form "\ttt{[position]}" or "\ttt{[@attribute='value']}".
        Positions start from zero.
  \item Predicate of the form "\ttt{[@attribute=\textit{\$param}]}" are also
        accepted, where \ttt{\textit{\$param}} can be one of:
        \ttt{\$MODULE\_\-FULLPATH},
        \ttt{\$MODULE\_\-FULLNAME},
        \ttt{\$MODULE\_\-NAME},
        \ttt{\$MODULE\_\-INDEX},
        \ttt{\$MODULE\_\-ID},
        \ttt{\$PARENT\-MODULE\_\-FULLPATH},
        \ttt{\$PARENT\-MODULE\_\-FULLNAME},
        \ttt{\$PARENT\-MODULE\_\-NAME},
        \ttt{\$PARENT\-MODULE\_\-INDEX},
        \ttt{\$PARENT\-MODULE\_\-ID},
        \ttt{\$GRANDPARENT\-MODULE\_\-FULLPATH},
        \ttt{\$GRANDPARENT\-MODULE\_\-FULLNAME},
        \ttt{\$GRANDPARENT\-MODULE\_\-NAME},
        \ttt{\$GRANDPARENT\-MODULE\_\-INDEX},
        \ttt{\$GRANDPARENT\-MODULE\_\-ID}.
\end{itemize}

\subsection{Functions}
\index{ned!functions}

The functions available in NED are listed in Appendix
\ref{cha:ned-functions}.

\subsection{Physical units}
\label{ch-ned-ref:sec:units}

The following physical units will be recognized in constants. Other units can
be used as well, but there will be no conversions available for them (i.e.
\ttt{parsec} and \ttt{kiloparsec} will be treated as two completely unrelated
units.)

\begin{longtable}{|c|c|r|}
  \hline
  \tabheadcol
  \tbf{Unit} & \tbf{Name} & \tbf{Value} \\\hline
  s & second & \\\hline
  d & day & 86400s \\\hline
  h & hour & 3600s \\\hline
  min & minute & 60s \\\hline
  ms & millisecond & 1e-3s \\\hline
  us & microsecond & 1e-6s \\\hline
  ns & nanosecond & 1e-9s \\\hline
  ps & picosecond & 1e-12s \\\hline
  bps & bit/sec & \\\hline
  Kbps & kilobit/sec & 1e3bps \\\hline
  Mbps & megabit/sec & 1e6bps \\\hline
  Gbps & gigabit/sec & 1e9bps \\\hline
  Tbps & terabit/sec & 1e12bps \\\hline
  B & byte & \\\hline
  KB & kilobyte & 1024B \\\hline
  MB & megabyte & 1.04858e6B \\\hline
  GB & gigabyte & 1.07374e9B \\\hline
  TB & terabyte & 1.09951e12B \\\hline
  b & bit & \\\hline
  m & meter & \\\hline
  km & kilometer & 1e3m \\\hline
  cm & centimeter & 1e-2m \\\hline
  mm & millimeter & 1e-3m \\\hline
  W & watt & \\\hline
  mW & milliwatt & 1e-3W \\\hline
  Hz & herz & \\\hline
  kHz & kiloherz & 1e3Hz \\\hline
  MHz & megaherz & 1e6Hz \\\hline
  GHz & gigaherz & 1e9Hz \\\hline
  g & gram & 1e-3kg \\\hline
  kg & kilogram & \\\hline
  J & joule & \\\hline
  kJ & kilojoule & 1e3J \\\hline
  MJ & megajoule & 1e6J \\\hline
  V & volt & \\\hline
  kV & kilovolt & 1e3V \\\hline
  mV & millivolt & 1e-3V \\\hline
  A & amper & \\\hline
  mA & milliamper & 1e-3A \\\hline
  uA & microamper & 1e-6A \\\hline
\end{longtable}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:



