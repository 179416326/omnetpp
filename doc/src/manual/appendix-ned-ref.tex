\chapter{NED Reference}
\label{cha:ned-ref}

\section{Syntax}

\subsection{NED file extension}

NED files have the \texttt{.ned} file name suffix. This is mandatory, and
cannot be overridden.

\subsection{NED file encoding}

NED files are read as 8-bit-clean ASCII. This permits NED files saved
in UTF-8, or any character set compatible with ASCII (8859-1, etc).

\begin{note}
    There is no official way to determine the encoding of a NED file. It is up
    to the user to configure the correct encoding in text editors and other
    tools that are used to edit or process NED files.
\end{note}

Keywords and other syntactic elements in NED are ASCII, and identifiers must be
ASCII as well. Comments and string literals may contain characters above
127. String literals (e.g. in parameter values) will be passed to the C++ code
as \ttt{const char *} without any conversion. 

Line ending may be either CR or CRLF, regardless of platform.


\subsection{Reserved words}

Authors have to take care that no reserved words are used for names.
The reserved words of the NED language are:

\ttt{allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inout input int like
module moduleinterface network output package parameters property simple
sizeof string submodules this true types volatile xml xmldoc}


\subsection{Identifiers}

Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and the underscore ``\_''. Identifiers may only begin with a
letter or underscore.

The recommended way to compose identifiers from multiple words is to
capitalize the beginning of each word (\textit{camel-case}).

\subsection{Case sensitivity}

Keywords and identifiers in the NED language are case sensitive. For example,
\ttt{TCP} and \ttt{Tcp} are two different names. 

\subsection{Constants}

\subsubsection{Numeric and string constants}

Numeric constants are accepted in their usual decimal or
scientific notations.

%% FIXME Only decimal notation is accepted!!! no hex, octal or binary...

\subsubsection{String constants}

String constants use double quotes.

%% FIXME no escape character sequences are accepted!!!

\subsubsection{Time constants}

FIXME

Anywhere you would put numeric constants\index{numeric constants}
(integer or real) to mean time in seconds, you can also specify the
time in units like milliseconds, minutes or hours:


\begin{Verbatim}[commandchars=\\\{\}]
    ...
    \tbf{parameters}:
        propagationDelay = 560ms, // 0.560s
        connectionTimeout = 6m 30s 500ms, // 390.5s
        recoveryIntvl = 0.5h; // 30 min
\end{Verbatim}


The following units can be used:

\begin{longtable}{|c|c|r|}
\hline
\tabheadcol
\tbf{Unit} & \tbf{Name} & \tbf{Value} \\\hline
s & second & \\\hline
d & day & 86400s \\\hline
h & hour & 3600s \\\hline
min & minute & 60s \\\hline
ms & millisecond & 1e-3s \\\hline
us & microsecond & 1e-6s \\\hline
ns & nanosecond & 1e-9s \\\hline
ps & picosecond & 1e-12s \\\hline
bps & bit/sec & \\\hline
Kbps & kilobit/sec & 1e3bps \\\hline
Mbps & megabit/sec & 1e6bps \\\hline
Gbps & gigabit/sec & 1e9bps \\\hline
Tbps & terabit/sec & 1e12bps \\\hline
B & byte & \\\hline
KB & kilobyte & 1024B \\\hline
MB & megabyte & 1.04858e6B \\\hline
GB & gigabyte & 1.07374e9B \\\hline
TB & terabyte & 1.09951e12B \\\hline
b & bit & \\\hline
m & meter & \\\hline
km & kilometer & 1e3m \\\hline
cm & centimeter & 1e-2m \\\hline
mm & millimeter & 1e-3m \\\hline
W & watt & \\\hline
mW & milliwatt & 1e-3W \\\hline
Hz & herz & \\\hline
kHz & kiloherz & 1e3Hz \\\hline
MHz & megaherz & 1e6Hz \\\hline
GHz & gigaherz & 1e9Hz \\\hline
g & gram & 1e-3kg \\\hline
kg & kilogram & \\\hline
J & joule & \\\hline
kJ & kilojoule & 1e3J \\\hline
MJ & megajoule & 1e6J \\\hline
V & volt & \\\hline
kV & kilovolt & 1e3V \\\hline
mV & millivolt & 1e-3V \\\hline
A & amper & \\\hline
mA & milliamper & 1e-3A \\\hline
uA & microamper & 1e-6A \\\hline
\end{longtable}

\subsection{Comments}

Comments can be placed anywhere in the NED file, with the usual C++
syntax: comments begin with a double slash `//', and last until
the end of the line.

\subsection{Grammar}

The grammar of the NED language can be found in Appendix FIXME.


\section{Packages}

NED supports hierarchical namespaces called \ttt{packages}. The solution is
roughly modelled after Java's packages, with minor changes.

\section{Packages, imports}

A NED file may contain a package declaration:

  package inet.protocols.transport.tcp;

If there is no package declaration, the file is said to be in the
"default package".

Names from other NED files can be referred to either by fully qualified
name ("inet.protocols.network.ip.RoutingTable"), or by short name
("RoutingTable") if the name is visible.

Visible names are:
  - anything from the same package;
  - imported names.

Import directives also have a similar syntax to Java, but they
are more flexible with wildcards. All of the following are legal:

  import  inet.protocols.network.ip.RoutingTable;
  import  inet.protocols.network.ip.*;
  import  inet.protocols.network.ip.Ro*Ta*;
  import  inet.protocols.*.ip.*;
  import  inet.**.RoutingTable;

One asterisk "*" stands for "any character sequence not containing
period"; two asterisks mean "any character sequence which may
contain period". No other wildcards are recognized.

An import not containing wildcard MUST match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

Inner types may not be referred to outside their enclosing types.


\section{Directory Structure, package.ned}

Like in Java, the directory of a NED file MUST match the package declaration.
However, it is possible to omit directories at the top which don't
contain any NED files (like the "/org/projectname/" directories in Java).

There is a notion of "NED source folders". If a NED Source Folder is
named "src", then a NED file containing the package declaration
"inet.protocols.transport.tcp" must be in the following folder:

   src/inet/protocols/transport/tcp/

If the "inet" and "protocols" directories don't contain any NED files,
they can be omitted:

   src/transport/tcp

and the "src" directory must contain a "package.ned" file which declares
what package it corresponds to:

  src/package.ned:
  package inet.protocols;

All NED files under the "src" directory tree must have package
declarations consistent with that.

"package.ned" files are allowed in other folders as well (as long as
their package declarations are consistent with the NED source
directory's "package.ned"), and any file-level comment in them
will be treated as the package's documentation (similar to Java's
package.html).


\section{Name lookups}

\subsection{Base types and submodules}

Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.


\subsection{Parametric module types ("like" submodules)}

Lookup of the actual module type for "like" submodules differs for normal
lookups. This lookup ignores the imports in the file altogether.
Instead, it collects all modules that support the given interface
and match the given type name string (i.e. end in the same simple name,
or have the same fully qualified name). The result must be exactly
one module type.

The algorithm for parametric channel types works in the same way.


\subsection{Network name in the ini file}

Simple (unqualified) names are tried with the same package as the
ini file is in (provided it's in a NED directory).


\section{The NEDPATH environment variable}

A simulation may need NED files from several "NED source folders".
When a simulation is launched as a separate application, it will expect
to receive the list of NED source folders to scan in the NEDPATH
environment variable (similar to Java's CLASSPATH). NEDPATH should
contain the source folder names separated by a semicolon (";").
On Unix-like systems, colon (":") will also be accepted as separator.

In the future, zip files may become supported in NEDPATH as well;
then the root folder of the zip file will be treated as a NED source
folder.


\section{Inheritance rules}

\begin{itemize}
  \item A simple module may only extend a simple module.
  \item A compound module may only extend a compound module.
  \item A channel may only extend a channel.
  \item A module interface may only extend a module interface (or several module
        interfaces).
  \item A channel interface may only extend a channel interface (or several
        channel interfaces).
\end{itemize}A \ttt{network} is a shorthand for a compound module with the \ttt{@isNetwork}
property set, so the same rules apply to it as to compound modules.

Inheritance may:
\begin{itemize}
\item add new properties, parameters, gates, inner types, submodules,
connections
\item modify inherited properties, and properties of inherited parameters and gates
\item it may NOT modify inherited submodules, connections and inner types
\end{itemize}

See other rules for specifics.


\subsection{Rules for interfaces}

An interface (module interface or channel interface) may NOT contain
parameter assignment or parameter default value assignment. An interface
may NOT contain inner types (rationale: what use would they be?).

A module type that implements ("like") a module interface is required
to have at least the parameters and the gates defined in the interface,
with the same types.

Regarding properties, parameter properties and gate properties defined
in the interface: the module is required to have those properties,
with at least the same values. It may have additional properties,
and properties may add more keys and values (see property inheritance.)

Similar rules apply to channel types.

\subsection{Rules for parameter assignments}

Default values for parameters may be overridden in subclasses.
Parameter (non-default) assignments may NOT be overridden in subclasses.


\subsection{Rules for gate vector sizes}

Gate vector sizes may NOT be overridden in subclasses.


\subsection{Rules for property inheritance}

Generally, properties may be modified via inheritance. Inheritance may:

\begin{itemize}
    \item add new keys
    \item add/overwrite values for existing keys
    \item remove a value from an existing key (by using the special value '-')
\end{itemize}

\section{Special properties}

\subsection{Rules for @isNetwork}

The @isNetwork property is only accepted on simple modules and
compound modules. The value may be empty, true or false:

\begin{verbatim}
  @isNetwork;
  @isNetwork();
  @isNetwork(true);
  @isNetwork(false);
\end{verbatim}

The empty value corresponds to \ttt{@isNetwork(true)}.

The @isNetwork property does NOT get inherited, that is, a subclass
of a module with @isNetwork set does NOT automatically become a network.
The @isNetwork property needs to be explicitly added to the subclass
to make it a network.

Rationale: subclassing may add gates, whereas networks cannot have gates.

\subsection{Rules for @unit()}

A parameter may have a @unit property to associate it with a physical unit.
The @unit property should contain one string value for the default key.
Examples:
  @unit("s")
  @unit(s)
  @unit("second")
  @unit(second)

When present, values assigned to the parameter must be in the
same or in a compatible (that is, convertible) unit.
Examples:
  double a @unit(s) = 5s;  // OK
  double a @unit(s) = 5;   // error: should be 5s
  double a @unit(s) = 5kg; // error: incompatible unit

@unit behavior for non-numeric parameters (string, XML) is unspecified
(may be ignored or may be an error).

The @unit property of a parameter may NOT be modified via inheritance.

Example:
\begin{verbatim} 
simple A {
    double p @unit(s);
}
simple B extends A {
    p @unit(mW);  // illegal: cannot override @unit
}
\end{verbatim}


\subsection{Rules for @class and @namespace}

@namespace property may be added to the package.ned file

@class

- @unit and expression evaluation wrt units
- rules for resolving an identifier in an expression

\section{Expressions}
\label{ch-ned-lang:sec:expressions}

In the NED language there are a number of places where
expressions\index{ned!expressions} are expected.

Expressions have a C-style syntax. They are built with the usual math
operators\index{math operators}; they can use parameters taken by
value or by reference; call C functions; contain random and input
values etc.

When an expression is used for a parameter value, it is evaluated
each time the parameter value is accessed (unless the parameter is
declared \ttt{const}, see \ref{sec:ch-ned-lang:const}). This means
that a simple module querying a non-const parameter during simulation
may get different values every time (e.g. if the value involves a
random variable, or it contains other parameters taken by reference).
Other expressions (including \ttt{const} parameter values)
are evaluated only once.

XML-type parameters can be used to conveniently access external
XML files or parts of them. XML-type parameters can be assigned
with the \ttt{xmldoc()} operator, also described in this section.


\subsection{Referencing parameters}

Expressions can use the parameters of the enclosing compound module
(the one being defined) and of submodules defined earlier in NED file.
The syntax for the latter is \ttt{submod.param} or \ttt{submod[index].param}.

There are two keywords that you can use with a parameter name:
\ttt{ancestor} and \ttt{ref}.  The first one (\ttt{ancestor} \textit{param})
means that if compound module doesn't have such a parameter,
further modules up in the module hierarchy will be searched for the parameter.
\ttt{ancestor} is considered bad practice because it violates the encapsulation
principle and can only be checked at runtime. It is provided for the
rare case when it is really needed.

\ttt{ref} \textit{param} takes the parameter by reference, meaning that
runtime changes to the parameter will propagate to all modules which
take that parameter by reference. Like \ttt{ancestor}, \ttt{ref}
should also be used very sparingly. One possible use is tuning a model
at runtime, in search for an optimum: one defines a parameter
at the highest level of the model, and lets other modules take it by reference --
then if you change the parameter value at runtime
(manually or from a simple module), it will affect the whole model.
In another setup, reference parameters may be used to propagate
status values to neighbouring modules.



\subsection{Operators}
\index{ned!expressions!operators}

The operators supported in NED are similar to C/C++ operators,
with the following differences:

\begin{itemize}
  \item{{\textasciicircum} is used for power-of (and not bitwise XOR as in C)}
  \item{\#\# is used for logical XOR (same as != between logical values), and
        \# is used for bitwise XOR}
  \item{the precedence of bitwise operators (\&, |, \#) have been raised
        to bind stronger than relational operations. This precedence is usually
        more convenient than the C/C++ one.}
\end{itemize}

All values are represented as \ttt{double}s. For the bitwise operators,
\ttt{double}s are converted to \ttt{unsigned long}
  \footnote{In case you are worried about \ttt{long} values being not accurately
  represented in \ttt{double}s, this is not the case. IEEE-754 \ttt{double}s
  have 52 bit mantissas, and integer numbers in that range are represented
  without rounding errors.}
using the C/C++ builtin conversion (type cast), the operation is performed,
then the result is converted back to \ttt{double}.
Similarly, for the logical operators \&\&, || and \#\#,
the operands are converted to \ttt{bool} using the C/C++ builtin
conversion (type cast), the operation is performed, then the result
is converted back to \ttt{double}. For modulus (\%), the operands are
converted to \ttt{long}.

Here's the complete list of operators, in order of decreasing precendence:

\begin{longtable}{|l|l|}
\hline
\tabheadcol
\tbf{Operator}                   & \tbf{Meaning} \\\hline
%%
\ttt{-}, \ttt{!}, \ensuremath{\sim} & unary minus, negation, bitwise complement \\\hline
%%
\ttt{{\textasciicircum}}         & power-of \\\hline
%%
\ttt{*}, \ttt{/}, \ttt{\%}       & multiply, divide, modulus \\\hline
%%
\ttt{+}, \ttt{-}                 & add, subtract \\\hline
%%
\ttt{<<}, \ttt{>>}               & bitwise shift \\\hline
%%
\ttt{\&}, \ttt{|}, \ttt{\#}      & bitwise and, or, xor \\\hline
%%
\ttt{==}                         & equal \\
\ttt{!=}                         & not equal \\
\ttt{>}, \ttt{>=}                & greater, greater or equal \\
\ttt{<}, \ttt{<=}                & less, less or equal \\\hline
%%
\ttt{\&\&}, \ttt{||}, \ttt{\#\#} & logical operators and, or, xor \\\hline
%%
\ttt{?:}                         & the C/C++ ``inline if'' \\\hline
\end{longtable}



\subsection{The \fname{sizeof()} and \fname{index} operators}

A useful operator is \fname{sizeof()}\index{ned!sizeof()}, which gives the
size of a vector gate\index{gate!vector}. The \fname{index}
operator\index{ned!index operator} gives the index of the current
submodule in its module vector.

The following example describes a router with several ports and one routing unit.
We assume that gate vectors \ttt{in[]} and \ttt{out[]} have the same size.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} Router
    \tbf{gates}:
        \tbf{in}: in[];
        \tbf{out}: out[];
    \tbf{submodules}:
        port: PPPInterface[\tbf{sizeof}(in)]; // one PPP for each input gate
            \tbf{parameters}: interfaceId = 1+\tbf{index}; // 1,2,3...
        routing: RoutingUnit;
            \tbf{gatesizes}:
                in[\tbf{sizeof}(in)];  // one gate pair for each port
                out[\tbf{sizeof}(in)];
    \tbf{connections}:
        \tbf{for} i = 0..\tbf{sizeof}(in)-1 \tbf{do}
            in[i] --> port[i].in;
            out[i] <-- port[i].out;
            port[i].out --> routing.in[i];
            port[i].in <-- routing.out[i];
        \tbf{endfor};
\tbf{endmodule}
\end{Verbatim}


\subsection{The \fname{xmldoc()} operator}

The \ttt{xmldoc()} operator can be used to assign XML-type parameters,
that is, point them to XML files or to specific elements inside XML files.

\ttt{xmldoc()} has two flavours: one accepts a file name, the second accepts
a file name plus an XPath-like expression which selects an element
inside the XML file. Examples:

\begin{Verbatim}[commandchars=\\\{\}]
xmlparam = \tbf{xmldoc}("someconfig.xml");
xmlparam = \tbf{xmldoc}("someconfig.xml", "/config/profile[@id='2']");
\end{Verbatim}

{\opp} supports a subset of the XPath 1.0 specification; details are
documented below.

From the C++ code you'd access the XML element like this:

\begin{verbatim}
cXMLElement *rootelement = par("xmlparam").xmlValue();
\end{verbatim}

The \cclass{cXMLElement} class provides a DOM-like access to the XML document.
You can then navigate the document tree, extract the information you need,
and store it in variables or your internal data structure.
\cclass{cXMLElement} is documented in Chapter \ref{cha:the-simulation-library}.

You can also read XML parameters from omnetpp.ini:

\begin{verbatim}
[Parameters]
**.interface[*].config = xmldoc("conf.xml")
\end{verbatim}

or

\begin{verbatim}
[Parameters]
**.interface[*].config = xmldoc("all-in-one.xml", "/config/interfaces/interface[2]")
\end{verbatim}


\subsection{XML documents and the XPath subset supported}

\ttt{xmldoc()} with two arguments accepts a path expression
to select an element within the document. The expression syntax is
similar to XPath.

If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

The expression syntax is the following:

\begin{itemize}
  \item An expression consists of \textit{path components} (or "steps")
        separated by "\ttt{/}" or "\ttt{//}".
  \item A path component can be an element tag name, "\ttt{*}", "\ttt{.}"
        or "\ttt{..}".
  \item "\ttt{/}" means child element (just as e.g. in \ttt{/usr/bin/gcc});
        "\ttt{//}" means an element any levels under the current element.
  \item "\ttt{.}", "\ttt{..}" and "\ttt{*}" mean current element,
        parent element, and an element with any tag name, respectively.
  \item Element tag names and "\ttt{*}" can have an optional predicate
        in the form "\ttt{[position]}" or "\ttt{[@attribute='value']}".
        Positions start from zero.
  \item Predicate of the form "\ttt{[@attribute=\textit{\$param}]}" are also
        accepted, where \ttt{\textit{\$param}} can be one of:
        \ttt{\$MODULE\_FULLPATH}, \ttt{\$MODULE\_FULLNAME}, \ttt{\$MODULE\_NAME},
        \ttt{\$MODULE\_INDEX}, \ttt{\$MODULE\_ID},
        \ttt{\$PARENTMODULE\_FULLPATH}, \ttt{\$PARENTMODULE\_FULLNAME},
        \ttt{\$PARENTMODULE\_NAME}, \ttt{\$PARENTMODULE\_INDEX}, \ttt{\$PARENTMODULE\_ID},
        \ttt{\$GRANDPARENTMODULE\_FULLPATH}, \ttt{\$GRANDPARENTMODULE\_FULLNAME},
        \ttt{\$GRANDPARENTMODULE\_NAME}, \ttt{\$GRANDPARENTMODULE\_INDEX},
        \ttt{\$GRANDPARENTMODULE\_ID}.{\new}
\end{itemize}

Examples:

\begin{itemize}
  \item \ttt{/foo} -- the root element which must be called \ttt{<foo>}
  \item \ttt{/foo/bar} -- first \ttt{<bar>} child of the \ttt{<foo>} root element
  \item \ttt{//bar} -- first \ttt{<bar>} anywhere (depth-first search!)
  \item \ttt{/*/bar} -- first \ttt{<bar>} child of the root element which may have any tag name
  \item \ttt{/*/*/bar} -- first \ttt{<bar>} child two levels below the root element
  \item \ttt{/*/foo[0]} -- first \ttt{<foo>} child of the root element
  \item \ttt{/*/foo[1]} -- second \ttt{<foo>} child of the root element
  \item \ttt{/*/foo[@color='green']} -- first \ttt{<foo>} child which has attribute "color" with value "green"
  \item \ttt{//bar[1]} -- a \ttt{<bar>} element anywhere which is the second \ttt{<bar>} among its siblings
  \item \ttt{//*[@color='yellow']} -- any element anywhere which has attribute "color" with value "yellow"
  \item \ttt{//*[@color='yellow']/foo/bar} -- first \ttt{<bar>} child of first \ttt{<foo>} child of a "yellow-colored" element anywhere
\end{itemize}

Path support allows you put all your XML configuration into
a single XML document, when you would otherwise end up with lots
of small XML files. For example, consider the following \ttt{sample.xml}:

\begin{verbatim}
<?xml version="1.0" encoding="UTF-8"?>
<root>
    <traffic-profile id="low">
        ...
    </traffic-profile>
    <traffic-profile id="medium">
        ...
    </traffic-profile>
    <traffic-profile id="high">
        ...
    </traffic-profile>
</root>
\end{verbatim}

In one simulation you can configure module parameters as
\ttt{xmldoc("sample.xml", "//traffic-profile[@id='low']")};
in another run as
\ttt{xmldoc("sample.xml", "//traffic-profile[@id='medium']")},
and so on.


\subsection{Functions}
\index{ned!functions}

In NED expressions, you can use the following mathematical functions:
\begin{itemize}
  \item{many of the C language's \ttt{<math.h>} library functions:
    \ttt{exp()}, \ttt{log()}, \ttt{sin()}, \ttt{cos()}, \ttt{floor()},
    \ttt{ceil()}, \ttt{etc.}}
  \item{functions that generate random variables: \ttt{uniform},
    \ttt{exponential}, \ttt{normal} and others were already
    discussed.}
\end{itemize}

It is possible to add new ones, see \ref{sec:ch-ned-lang:defining-functions}.

\subsection{Random values}

Expressions may contain random variates from different distributions.
Such parameters, unless declared as \ttt{const},
return different values each time they are evaluated.

If the parameter is declared as \ttt{const}, it is only evaluated
once at the beginning of the simulation, and subsequent queries
on the parameter will always return the same value.

Random variate functions use one of the random number generators (RNGs)
provided by \opp. By default this is generator 0, but you can specify
which one is to be used.

{\opp} has the following predefined distributions\index{distribution!predefined}:

\begin{longtable}{|p{6.5cm}|p{7.5cm}|}
\hline
\tbf{Function} & \tbf{Description}\\\hline
\multicolumn{2}{|c|}{\tbf{Continuous distributions}}\\\hline
\fname{uniform(a, b, \textit{rng=0})} & uniform distribution in the range [a,b) \\\hline
\fname{exponential(mean, \textit{rng=0})} & exponential distribution with the given mean \\\hline
\fname{normal(mean, stddev, \textit{rng=0})} & normal distribution with the given mean and standard deviation \\\hline
\fname{truncnormal(mean, stddev, \textit{rng=0})} & normal distribution truncated to nonnegative values \\\hline
\fname{gamma\_d(alpha, beta, \textit{rng=0})} & gamma distribution with parameters alpha>0, beta>0 \\\hline
\fname{beta(alpha1, alpha2, \textit{rng=0})} & beta distribution with parameters alpha1>0, alpha2>0 \\\hline
\fname{erlang\_k(k, mean, \textit{rng=0})} & Erlang distribution with k>0 phases and the given mean \\\hline
\fname{chi\_square(k, \textit{rng=0})} & chi-square distribution with k>0 degrees of freedom \\\hline
\fname{student\_t(i, \textit{rng=0})} & student-t distribution with i>0 degrees of freedom \\\hline
\fname{cauchy(a, b, \textit{rng=0})} & Cauchy distribution with parameters a,b where b>0 \\\hline
\fname{triang(a, b, c, \textit{rng=0})} & triangular distribution with parameters a<=b<=c, a!=c \\\hline
\fname{lognormal(m, s, rng=0)} & lognormal distribution with mean m and variance s>0 \\\hline
\fname{weibull(a, b, \textit{rng=0})} & Weibull distribution with parameters a>0, b>0 \\\hline
\fname{pareto\_shifted(a, b, c, \textit{rng=0})} & generalized Pareto distribution with parameters a, b and shift c \\\hline
\multicolumn{2}{|c|}{\tbf{Discrete distributions}} \\\hline
\fname{intuniform(a, b, \textit{rng=0})} & uniform integer from a..b \\\hline
\fname{bernoulli(p, \textit{rng=0})} & result of a Bernoulli trial with probability 0<=p<=1 (1 with probability p and 0 with probability (1-p)) \\\hline
\fname{binomial(n, p, \textit{rng=0})} & binomial distribution with parameters n>=0 and 0<=p<=1 \\\hline
\fname{geometric(p, \textit{rng=0})} & geometric distribution with parameter 0<=p<=1 \\\hline
\fname{negbinomial(n, p, \textit{rng=0})} & binomial distribution with parameters n>0 and 0<=p<=1\\\hline
\fname{poisson(lambda, \textit{rng=0})} & Poisson distribution with parameter lambda \\\hline

\end{longtable}

%
% FIXME insert this into the table then hypergeom() starts to work:
% fname{hypergeometric(a, b, n, \textit{rng=0})} & hypergeometric distribution with parameters a>0,b>0 and 0<=n<=a+b.\\\hline
%

If you do not specify the optional \fpar{rng} argument, the functions will
use random number generator 0.

Examples:

\begin{verbatim}
intuniform(0,10)/10  // one of: 0, 0.1, 0.2, ..., 0.9, 1
exponential(5)       // exponential with mean=5 (thus parameter=0.2)
2+truncnormal(5,3)   // normal distr with mean 7 truncated to >=2 values
\end{verbatim}

The above distributions are implemented with C functions, and you can easily
add new ones (see section \ref{sec:ch-ned-lang:defining-functions}).
Your distributions will be treated in the same way as the built-in ones.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
