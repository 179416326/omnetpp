\chapter{NED Reference}
\label{cha:ned-ref}

\section{Syntax}

\subsection{NED file extension}

NED files have the \texttt{.ned} file name suffix. This is mandatory, and
cannot be overridden.

\subsection{NED file encoding}

NED files are read as 8-bit-clean ASCII. This permits NED files saved
in UTF-8, or any character set compatible with ASCII (8859-1, etc).

\begin{note}
    There is no official way to determine the encoding of a NED file. It is up
    to the user to configure the correct encoding in text editors and other
    tools that are used to edit or process NED files.
\end{note}

Keywords and other syntactic elements in NED are ASCII, and identifiers must be
ASCII as well. Comments and string literals may contain characters above
127. String literals (e.g. in parameter values) will be passed to the C++ code
as \ttt{const char *} without any conversion.

Line ending may be either CR or CRLF, regardless of platform.


\subsection{Reserved words}

Authors have to take care that no reserved words are used as identifiers.
The reserved words of the NED language are:

\ttt{allowunconnected bool channel channelinterface connections const
default double extends false for gates if import index inout input int like
module moduleinterface network output package parameters property simple
sizeof string submodules this true types volatile xml xmldoc}


\subsection{Identifiers}

Identifiers must be composed of letters of the English alphabet (a-z, A-Z),
numbers (0-9) and underscore ``\_''. Identifiers may only begin with a
letter or underscore.

The recommended way to compose identifiers from multiple words is to
capitalize the beginning of each word (\textit{camel case}).

\subsection{Case sensitivity}

Keywords and identifiers in the NED language are case sensitive. For example,
\ttt{TCP} and \ttt{Tcp} are two different names.

\subsection{Literals}

\subsubsection{String literals}

String literals use double quotes. The following C-style backslash
escapes are recognized: \ttt{{\textbackslash}b}, \ttt{{\textbackslash}f}, \ttt{{\textbackslash}n}, \ttt{{\textbackslash}r},
\ttt{{\textbackslash}t}, \ttt{{\textbackslash}{\textbackslash}}, \ttt{{\textbackslash}"}, and \ttt{{\textbackslash}xhh} where \textit{h} is a
hexadecimal digit.

\subsubsection{Numeric constants}

Numeric constants are accepted in their usual decimal or
scientific notations.

\subsubsection{Quantity constants}

A quantity constant has the form \textit{(<numeric-constant> <unit>)+}, for
example \ttt{12.5mW} or \ttt{3h 15min 37.2s}. When multiple units are present,
they have to be convertible into each other (i.e. refer to the same physical
quantity).

Section \ref{ch-ned-ref:sec:units} lists the units recognized by \opp.
Other units can be used as well, the only downside being that \opp will not be
able to perform conversions on them.

\subsection{Comments}

Comments can be placed anywhere in the NED file, with the usual C++
syntax: comments begin with a double slash `//', and last until
the end of the line.

\subsection{Grammar}

The grammar of the NED language can be found in Appendix
\ref{cha:ned-language-grammar}.

\section{Built-in definitions}
\label{ch-ned-ref:sec:built-in-defs}

The NED language has the following built-in definitions, all in the \ttt{ned}
package: channels \ttt{IdealChannel} and \ttt{DatarateChannel}, and module
interfaces \ttt{IBidirectionalChannel} and \ttt{IUnidirectionalChannel}; the
latter two are reserved for future use.

%%
%% Note: the following code is from src/nedxml/nedparser.cc,
%%       NEDParser::getBuiltInDeclarations()
%%
\begin{verbatim}
package ned;

@namespace("");

channel IdealChannel {
    @class(cIdealChannel);
}

channel DelayChannel {
    @class(cDelayChannel);
    bool disabled = false;
    double delay = 0s @unit(s);
}

channel DatarateChannel {
    @class(cDatarateChannel);
    bool disabled = false;
    double delay = 0s @unit(s);
    double datarate = 0bps @unit(bps);
    double ber = 0;
    double per = 0;
}

moduleinterface IBidirectionalChannel {
    gates:
        inout a;
        inout b;
}

moduleinterface IUnidirectionalChannel {
    gates:
        input i;
        output o;
}
\end{verbatim}



\section{Packages}

NED supports hierarchical namespaces called \textit{packages}. The solution
is roughly modelled after Java's packages, with minor changes.
\subsection{Package declaration}

The package of the declarations in a NED file is determined by the package
declaration in the file (\ttt{package} keyword). A NED file may contain at
most one package declaration. If there is no package declaration, the file's
contents is in the \textit{default package}.

\subsection{Directory structure, package.ned}

Like in Java, the directory of a NED file must match the package
declaration. However, it is possible to omit directories at the top which do
not contain any NED files (like the typical \ttt{/org/\textit{<projectname>}}
directories in Java).

The top of a directory tree containing NED files is named a \textit{NED source
folder}. The \ttt{package.ned} file direcly in a NED source folder plays a
special role.

If there is no toplevel \ttt{package.ned} or it contains no package declaration,
the declared package of a NED file in the folder \ttt{\textit{<srcfolder>}/x/y/z}
\textit{must} be \ttt{x.y.z}.
If there is a toplevel \ttt{package.ned} and it declares to be in package
\ttt{a.b}, then any NED file in the folder \ttt{\textit{<srcfolder>}/x/y/z}
\textit{must} have the declared package \ttt{a.b.x.y.z}.

\begin{note}
    \ttt{package.ned} files are allowed in other folders as well, but they
    are not treated specially, i.e. they cannot be used to define the package
    they are in.
\end{note}

\section{Name uniqueness}

All component type names must be unique.
%%FIXME clarify

Identifier names within a component must be unique. That is, submodule
or inner type cannot be named the same, or the same as a gate or
parameter of the parent module.



\section{Type name resolution}

Names from other NED files can be referred to either by fully qualified
name ("inet.protocols.network.ip.RoutingTable"), or by short name
("RoutingTable") if the name is visible.

Visible names are:
\begin{itemize}
  \item anything from the same package;
  \item imported names.
\end{itemize}

\subsection{Imports}

Imports have a similar syntax to Java, but they are more flexible with wildcards.
All of the following are legal:
\begin{verbatim}
import inet.protocols.network.ip.RoutingTable;
import inet.protocols.network.ip.*;
import inet.protocols.network.ip.Ro*Ta*;
import inet.protocols.*.ip.*;
import inet.**.RoutingTable;
\end{verbatim}

One asterisk "*" stands for "any character sequence not containing
period"; two asterisks mean "any character sequence which may
contain period". No other wildcards are recognized.

An import not containing wildcard MUST match an existing NED type.
However, it is legal for an import that does contain wildcards
not to match any NED type (although that might generate a warning.)

Inner types may not be referred to outside their enclosing types.

\subsection{Base types and submodules}

Fully qualified names and simple names are accepted. Simple names
are looked up among the inner types of the enclosing type (compound
module), then using imports, then in the same package.


\subsection{Parametric module types ("like" submodules)}

Lookup of the actual module type for "like" submodules differs for normal
lookups. This lookup ignores the imports in the file altogether.
Instead, it collects all modules that support the given interface
and match the given type name string (i.e. end in the same simple name,
or have the same fully qualified name). The result must be exactly
one module type.

The algorithm for parametric channel types works in the same way.


\subsection{Network name in the ini file}

Simple (unqualified) names are tried with the same package as the
ini file is in (provided it's in a NED directory).


\section{Inheritance}

\begin{itemize}
  \item A simple module may only extend a simple module.
  \item A compound module may only extend a compound module.
  \item A channel may only extend a channel.
  \item A module interface may only extend a module interface (or several module
        interfaces).
  \item A channel interface may only extend a channel interface (or several
        channel interfaces).
\end{itemize}

A \ttt{network} is a shorthand for a compound module with the \ttt{@isNetwork}
property set, so the same rules apply to it as to compound modules.

Inheritance may:
\begin{itemize}
  \item add new properties, parameters, gates, inner types, submodules,
        connections
  \item modify inherited properties, and properties of inherited parameters and
        gates
  \item it may NOT modify inherited submodules, connections and inner types
\end{itemize}

XXX
- parameter once assigned in base class or type MUST be allowed to be
  set to a different value in subclass/place of usage!!!

XXX
- rules of inheritance:
    o for inner types:
       - can I define an inner type with the same name in subclasses? NO
    o for properties:
       - contents will be merged (rules like for display strings: values on
         same key and same position will overwrite old ones)
    o for parameters:
       - type cannot be redefined
       - value may be redefined in subclasses or place of usage
    o for gates:
       - type cannot be redefined
       - vector size may be redefined in subclasses or place of usage
    o for gate/parameter properties:
       - extra properties can be added
       - existing properties can be overridden/extended like for standalone properties (?)
    o for submodules:
       - new submodules may be added, but inherited ones cannot be modified
    o for connections:
       - new connections may be added, but inherited ones cannot be modified

See other rules for specifics.

\section{Simple modules}

XXX

\section{Channels}

XXX

\section[C++ class for simple modules/channels]{Determining the implementation
C++ class for simple modules and channels}

The procedure for determiming the C++ implementation class for simple modules
and for channels are identical. It goes as follows (we are going to say
\textit{component} instead of \textit{``simple module or channel''}):

If the component extends another component and has no
\ttt{@class} property, the C++ implementation class is inherited from the base
type.

If the component contains has a \ttt{@class} property, the C++ class
name will be composed of the \textit{current namespace} (see
\ref{cha:ned-ref:current-namespace}) and the value of the \ttt{@class}
property. The \ttt{@class} property should contain a single value.

\begin{note}
    The \ttt{@class} property may itself contain a namespace declaration (ie.
    may contain ``\ttt{::}'').
\end{note}

If the component contains no \ttt{@class} property and has no base
class, the C++ class name will be composed of the \textit{current namespace} and the
unqualified name of the component.

\begin{note}
    NED subclassing does not imply subclassing the C++ implementation. If you
    want to subclass a simple module or channel in NED as well as in C++, you
    explicitly need to specify the \ttt{@class} property, otherwise the
    derived simple module or channel will continue to use the C++ class from its
    super type.
\end{note}

\subsection{Current namespace}
\label{cha:ned-ref:current-namespace}

The \textit{current namespace} is the value of the first \ttt{@namespace}
property found while searching the following order:
\begin{enumerate}
  \item the current NED file
  \item the \ttt{package.ned} file in the current package
  \item the \ttt{package.ned} file of the parent package or the first ancestor
        package searching upwards
\end{enumerate}

The \ttt{@namespace} property should contain a single value.

\begin{note}
    This was considered and discarded: \ttt{module X extends ASimple}
    instead of \ttt{simple X extends ASimple}. It was proposed because
    otherwise, if base type's implementation gets changed from simple to compound, all
    subclasses will have to be changed. Idea discarded because the confusion
    this would create is worse than the problem itself.
\end{note}


\section{Interfaces}

An interface (module interface or channel interface) may NOT contain
parameter assignment or parameter default value assignment. An interface
may NOT contain inner types. (Rationale: what use would they be?).

A module or channel type that implements ("like") an interface is
required to have at least the parameters and, for modules, the gates
defined in the interface, with the same types.

Regarding properties, parameter properties and gate properties defined
in the interface: the module or channel is required to have those properties,
with at least the same values. It may have additional properties,
and properties may add more keys and values (see property inheritance.)


\section{Compound modules}

Extra params CANNOT be added in submodules and connection channelspecs --
they can only be added in new types.

\subsection{Submodules}

\subsection{Connections}

When a connection uses an unnamed channel type (\ttt{-->
\{\ldots\} -->} syntax), the actual NED type to be used will depend on the
parameters set in the connection.

When no parameters are set, \ttt{ned.IdealChannel} is chosen. 

When only \ttt{ned.DelayChannel} parameters are used (\ttt{delay} 
and \ttt{disabled}), \ttt{ned.DelayChannel} is chosen. 

When only \ttt{ned.DatarateChannel} parameters are used
(\ttt{datarate}, \ttt{delay}, \ttt{ber}, \ttt{per}, \ttt{disabled}),
the chosen channel type will be \ttt{ned.DatarateChannel}.

Unnamed channels connections cannot use any other parameters.  

\section{Networks}

\subsection{The network keyword}

A network declared with the \ttt{network} keyword is equivalent to a compound
module (\ttt{module} keyword) with the \ttt{@isNetwork(true)} property.

\subsection{The @isNetwork property}

The \ttt{@isNetwork} property is only accepted on simple modules and
compound modules. The value may be empty, true or false:

\begin{verbatim}
@isNetwork;
@isNetwork();
@isNetwork(true);
@isNetwork(false);
\end{verbatim}

The empty value corresponds to \ttt{@isNetwork(true)}.

The \ttt{@isNetwork} property does NOT get inherited, that is, a subclass
of a module with \ttt{@isNetwork} set does NOT automatically become a network.
The \ttt{@isNetwork} property needs to be explicitly added to the subclass
to make it a network.

\begin{rationale}
	Subclassing may introduce changes to a module that make it unfit to be used
	as a network.
\end{rationale}



\section{Properties}

\subsection{Property inheritance}

Generally, properties may be modified via inheritance. Inheritance may:

\begin{itemize}
    \item add new keys
    \item add/overwrite values for existing keys
    \item remove a value from an existing key (by using the special value '-')
\end{itemize}



\section{Parameters}

\subsection{Parameter inheritance}

Default values for parameters may be overridden in subclasses.

Parameter (non-default) assignments may also be overridden in subclasses.

\begin{rationale}
    The latter is needed for ease of use of channels and their \ttt{delay},
    \ttt{error}, \ttt{datarate} parameters.
\end{rationale}

\subsection{The @unit property}

A parameter may have a \ttt{@unit} property to associate it with a physical
unit. The \ttt{@unit} property should contain one string value for the default
key. Examples:

\begin{verbatim}
@unit("s")
@unit(s)
@unit("second")
@unit(second)
\end{verbatim}

When present, values assigned to the parameter must be in the
same or in a compatible (that is, convertible) unit.
Examples:

\begin{verbatim}
  double a @unit(s) = 5s;  // OK
  double a @unit(s) = 5;   // error: should be 5s
  double a @unit(s) = 5kg; // error: incompatible unit
\end{verbatim}

@unit behavior for non-numeric parameters (string, XML) is unspecified
(may be ignored or may be an error).

The @unit property of a parameter may NOT be modified via inheritance.

Example:
\begin{verbatim}
simple A {
    double p @unit(s);
}
simple B extends A {
    p @unit(mW);  // illegal: cannot override @unit
}
\end{verbatim}



\section{Gates}

\subsection{Rules for gate vector sizes}

Gate vector sizes may NOT be overridden in subclasses.



\section{Expressions}
\label{ch-ned-ref:sec:expressions}

FIXME TODO:
- @unit and expression evaluation wrt units
- rules for resolving an identifier in an expression

In the NED language there are a number of places where
expressions\index{ned!expressions} are expected.

Expressions have a C-style syntax. They are built with the usual math
operators\index{math operators}; they can use parameters taken by
value or by reference; call C functions; contain random and input
values etc.

When an expression is used for a parameter value, it is evaluated
each time the parameter value is accessed (unless the parameter is
declared \ttt{const}, see \ref{sec:ch-ned-lang:const}). This means
that a simple module querying a non-const parameter during simulation
may get different values every time (e.g. if the value involves a
random variable, or it contains other parameters taken by reference).
Other expressions (including \ttt{const} parameter values)
are evaluated only once.

XML-type parameters can be used to conveniently access external
XML files or parts of them. XML-type parameters can be assigned
with the \ttt{xmldoc()} operator, also described in this section.


\subsection{Referencing parameters}

Expressions can use the parameters of the enclosing compound module
(the one being defined) and of submodules defined earlier in NED file.
The syntax for the latter is \ttt{submod.param} or \ttt{submod[index].param}.

There are two keywords that you can use with a parameter name:
\ttt{ancestor} and \ttt{ref}.  The first one (\ttt{ancestor} \textit{param})
means that if compound module doesn't have such a parameter,
further modules up in the module hierarchy will be searched for the parameter.
\ttt{ancestor} is considered bad practice because it violates the encapsulation
principle and can only be checked at runtime. It is provided for the
rare case when it is really needed.

\ttt{ref} \textit{param} takes the parameter by reference, meaning that
runtime changes to the parameter will propagate to all modules which
take that parameter by reference. Like \ttt{ancestor}, \ttt{ref}
should also be used very sparingly. One possible use is tuning a model
at runtime, in search for an optimum: one defines a parameter
at the highest level of the model, and lets other modules take it by reference --
then if you change the parameter value at runtime
(manually or from a simple module), it will affect the whole model.
In another setup, reference parameters may be used to propagate
status values to neighbouring modules.



\subsection{Operators}
\index{ned!expressions!operators}

The operators supported in NED are similar to C/C++ operators,
with the following differences:

\begin{itemize}
  \item{{\textasciicircum} is used for power-of (and not bitwise XOR as in C)}
  \item{\#\# is used for logical XOR (same as != between logical values), and
        \# is used for bitwise XOR}
  \item{the precedence of bitwise operators (\&, |, \#) have been raised
        to bind stronger than relational operations. This precedence is usually
        more convenient than the C/C++ one.}
\end{itemize}

All values are represented as \ttt{double}s. For the bitwise operators,
\ttt{double}s are converted to \ttt{unsigned long}
  \footnote{In case you are worried about \ttt{long} values being not accurately
  represented in \ttt{double}s, this is not the case. IEEE-754 \ttt{double}s
  have 52 bit mantissas, and integer numbers in that range are represented
  without rounding errors.}
using the C/C++ builtin conversion (type cast), the operation is performed,
then the result is converted back to \ttt{double}.
Similarly, for the logical operators \&\&, || and \#\#,
the operands are converted to \ttt{bool} using the C/C++ builtin
conversion (type cast), the operation is performed, then the result
is converted back to \ttt{double}. For modulus (\%), the operands are
converted to \ttt{long}.

Here's the complete list of operators, in order of decreasing precendence:

\begin{longtable}{|l|l|}
\hline
\tabheadcol
\tbf{Operator}                   & \tbf{Meaning} \\\hline
%%
\ttt{-}, \ttt{!}, \ensuremath{\sim} & unary minus, negation, bitwise complement \\\hline
%%
\ttt{{\textasciicircum}}         & power-of \\\hline
%%
\ttt{*}, \ttt{/}, \ttt{\%}       & multiply, divide, modulus \\\hline
%%
\ttt{+}, \ttt{-}                 & add, subtract \\\hline
%%
\ttt{<<}, \ttt{>>}               & bitwise shift \\\hline
%%
\ttt{\&}, \ttt{|}, \ttt{\#}      & bitwise and, or, xor \\\hline
%%
\ttt{==}                         & equal \\
\ttt{!=}                         & not equal \\
\ttt{>}, \ttt{>=}                & greater, greater or equal \\
\ttt{<}, \ttt{<=}                & less, less or equal \\\hline
%%
\ttt{\&\&}, \ttt{||}, \ttt{\#\#} & logical operators and, or, xor \\\hline
%%
\ttt{?:}                         & the C/C++ ``inline if'' \\\hline
\end{longtable}
\subsection{The \fname{sizeof()} and \fname{index} operators}

A useful operator is \fname{sizeof()}\index{ned!sizeof()}, which gives the
size of a vector gate\index{gate!vector}. The \fname{index}
operator\index{ned!index operator} gives the index of the current
submodule in its module vector.

FIXME TBD:
- sizeof() resolution:
    IN SUBMODULE SCOPE:
        sizeof(foo): must refer to a parent module gate vector, or
                     sibling submodule vector (there cannot be ambiguity
                     here, because of the name uniqueness rule above)
                     NOTE: IT CANNOT REFER TO LOCAL GATE VECTOR !!!
        sizeof(this.foo): refers to local gate vector
        sizeof(foo.bar): refers to gatevector of sibling submodule
    IN CONNECTION SCOPE:
        same as above, only sizeof(this.foo) does not make sense
    IN [PARENT] MODULE SCOPE:
        sizeof(foo), sizeof(this.foo): refers to that module's gatevector
        sizeof(foo.bar): makes no sense (thus illegal)

- "index" operator: it always returns the same (sub)module's index in whose "parameters"
   block it is defined. It is NOT POSSIBLE to obtain the parent module's index.


\subsection{The \fname{xmldoc()} operator}

The \ttt{xmldoc()} operator can be used to assign XML-type parameters,
that is, point them to XML files or to specific elements inside XML files.

\ttt{xmldoc()} has two flavours: one accepts a file name, the second accepts
a file name plus an XPath-like expression which selects an element
inside the XML file. Examples:

\begin{Verbatim}[commandchars=\\\{\}]
xmlparam = \tbf{xmldoc}("someconfig.xml");
xmlparam = \tbf{xmldoc}("someconfig.xml", "/config/profile[@id='2']");
\end{Verbatim}

{\opp} supports a subset of the XPath 1.0 specification; details are
documented below.

From the C++ code you'd access the XML element like this:

\begin{verbatim}
cXMLElement *rootelement = par("xmlparam").xmlValue();
\end{verbatim}

The \cclass{cXMLElement} class provides a DOM-like access to the XML document.
You can then navigate the document tree, extract the information you need,
and store it in variables or your internal data structure.
\cclass{cXMLElement} is documented in Chapter \ref{cha:the-simulation-library}.

You can also read XML parameters from omnetpp.ini:

\begin{verbatim}
[Parameters]
**.interface[*].config = xmldoc("conf.xml")
\end{verbatim}

or

\begin{verbatim}
[Parameters]
**.interface[*].config = xmldoc("all-in-one.xml", "/config/interfaces/interface[2]")
\end{verbatim}


\subsection{XML documents and the XPath subset supported}

\ttt{xmldoc()} with two arguments accepts a path expression
to select an element within the document. The expression syntax is
similar to XPath.

If the expression matches several elements, the first element
(in preorder depth-first traversal) will be selected. (This is
unlike XPath, which selects all matching nodes.)

The expression syntax is the following:
\begin{itemize}
  \item An expression consists of \textit{path components} (or "steps")
        separated by "\ttt{/}" or "\ttt{//}".
  \item A path component can be an element tag name, "\ttt{*}", "\ttt{.}"
        or "\ttt{..}".
  \item "\ttt{/}" means child element (just as in \ttt{/usr/bin/gcc});
        "\ttt{//}" means an element any levels under the current element.
  \item "\ttt{.}", "\ttt{..}" and "\ttt{*}" mean the current element,
        the parent element, and an element with any tag name, respectively.
  \item Element tag names and "\ttt{*}" can have an optional predicate
        in the form "\ttt{[position]}" or "\ttt{[@attribute='value']}".
        Positions start from zero.
  \item Predicate of the form "\ttt{[@attribute=\textit{\$param}]}" are also
        accepted, where \ttt{\textit{\$param}} can be one of:
        \ttt{\$MODULE\_\-FULLPATH},
        \ttt{\$MODULE\_\-FULLNAME},
        \ttt{\$MODULE\_\-NAME},
        \ttt{\$MODULE\_\-INDEX},
        \ttt{\$MODULE\_\-ID},
        \ttt{\$PARENT\-MODULE\_\-FULLPATH},
        \ttt{\$PARENT\-MODULE\_\-FULLNAME},
        \ttt{\$PARENT\-MODULE\_\-NAME},
        \ttt{\$PARENT\-MODULE\_\-INDEX},
        \ttt{\$PARENT\-MODULE\_\-ID},
        \ttt{\$GRANDPARENT\-MODULE\_\-FULLPATH},
        \ttt{\$GRANDPARENT\-MODULE\_\-FULLNAME},
        \ttt{\$GRANDPARENT\-MODULE\_\-NAME},
        \ttt{\$GRANDPARENT\-MODULE\_\-INDEX},
        \ttt{\$GRANDPARENT\-MODULE\_\-ID}.
\end{itemize}

\subsection{Functions}
\index{ned!functions}

The functions available in NED are listed in Appendix
\ref{cha:ned-functions}.

\subsection{Physical units}
\label{ch-ned-ref:sec:units}

The following physical units will be recorgnized in constants. Other units can
be used as well, the only downside being that \opp will not be able to
perform conversions on them.

\begin{longtable}{|c|c|r|}
  \hline
  \tabheadcol
  \tbf{Unit} & \tbf{Name} & \tbf{Value} \\\hline
  s & second & \\\hline
  d & day & 86400s \\\hline
  h & hour & 3600s \\\hline
  min & minute & 60s \\\hline
  ms & millisecond & 1e-3s \\\hline
  us & microsecond & 1e-6s \\\hline
  ns & nanosecond & 1e-9s \\\hline
  ps & picosecond & 1e-12s \\\hline
  bps & bit/sec & \\\hline
  Kbps & kilobit/sec & 1e3bps \\\hline
  Mbps & megabit/sec & 1e6bps \\\hline
  Gbps & gigabit/sec & 1e9bps \\\hline
  Tbps & terabit/sec & 1e12bps \\\hline
  B & byte & \\\hline
  KB & kilobyte & 1024B \\\hline
  MB & megabyte & 1.04858e6B \\\hline
  GB & gigabyte & 1.07374e9B \\\hline
  TB & terabyte & 1.09951e12B \\\hline
  b & bit & \\\hline
  m & meter & \\\hline
  km & kilometer & 1e3m \\\hline
  cm & centimeter & 1e-2m \\\hline
  mm & millimeter & 1e-3m \\\hline
  W & watt & \\\hline
  mW & milliwatt & 1e-3W \\\hline
  Hz & herz & \\\hline
  kHz & kiloherz & 1e3Hz \\\hline
  MHz & megaherz & 1e6Hz \\\hline
  GHz & gigaherz & 1e9Hz \\\hline
  g & gram & 1e-3kg \\\hline
  kg & kilogram & \\\hline
  J & joule & \\\hline
  kJ & kilojoule & 1e3J \\\hline
  MJ & megajoule & 1e6J \\\hline
  V & volt & \\\hline
  kV & kilovolt & 1e3V \\\hline
  mV & millivolt & 1e-3V \\\hline
  A & amper & \\\hline
  mA & milliamper & 1e-3A \\\hline
  uA & microamper & 1e-6A \\\hline
\end{longtable}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:



