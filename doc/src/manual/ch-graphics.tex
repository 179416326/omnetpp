\chapter{Network Graphics And Animation}
\label{cha:graphics}

\section{Display strings}
\label{sec:ch-graphics:display-strings}

\subsection{Display string syntax}

Display strings\index{display strings} specify the arrangement and
appearance of modules in graphical user interfaces (currently only
Tkenv): they control how the objects (compound modules, their
submodules and connections) are displayed. Display strings occur in
NED description's \fpar[ned!keywords!display]{display:}
phrases.

The display string format is a semicolon-separated list of tags.
Each tag consists of a key (usually one letter), an equal sign
and a comma-separated list of parameters, like:

\begin{verbatim}
  "p=100,100;b=60,10,rect;o=blue,black,2"
\end{verbatim}

Parameters may be omitted also at the end and also inside the
parameter list, like:

\begin{verbatim}
  "p=100,100;b=,,rect;o=blue,black"
\end{verbatim}

Module/submodule parameters can be included with the \ttt{\$name} notation:

\begin{verbatim}
  "p=$xpos,$ypos;b=rect,60,10;o=$fillcolor,black,2"
\end{verbatim}

Objects that may have display strings are:
\begin{itemize}
  \item \textit{submodules} -- display string may contain position, arrangement
        (for module vectors), icon, icon color, auxiliary icon, status text,
        communication range (as circle or filled circle), etc.
  \item \textit{connections} -- display string can specify positioning, arrow color,
        arrow thickness
  \item \textit{compound modules} -- display string can specify background color,
        border color, border thickness
\end{itemize}

The following NED sample shows where to place display strings in the code.

\begin{Verbatim}[commandchars=\\\{\}]
\tbf{module} ClientServer
    \tbf{submodules}:
        pc: Host;
            \tbf{display}: "p=66,55;i=comp"; // position and icon
        server: Server;
            \tbf{display}: "p=135,73;i=server1";
    \tbf{connections}:
        pc.out --> server.in
            \tbf{display} "m=m,61,40,41,28"; // note missing ":"
        server.out --> pc.in
            \tbf{display} "m=m,15,57,35,69";
    \tbf{display}: "o=#ffffff"; // affects background
\tbf{endmodule}
\end{Verbatim}


\subsection{Submodule display strings}


The following table lists the tags used in submodule display strings:

\index{display strings!tags}

\begin{longtable}{|p{6cm}|p{8cm}|}
\hline
% ROW 1
\tabheadcol
\tbf{Tag} & \tbf{Meaning} \\\hline
% ROW 2
\tbf{p=}\textit{xpos},\textit{ypos}
&
{\raggedright Place submodule at (\textit{xpos},\textit{ypos}) pixel position,
with the origin being the top-left corner of the enclosing module.

Defaults: an appropriate automatic layout is where submodules do not overlap.

If applied to a submodule vector, \textit{ring} or \textit{row} layout is
selected automatically.}\\\hline
% ROW 3
\tbf{p=}\textit{xpos},\textit{ypos},\tbf{row},\textit{deltax} &
{\raggedright Used for module vectors. Arranges submodules in a row starting
at (\textit{xpos},\textit{ypos}), keeping \textit{deltax} distances.

Defaults: \textit{deltax} is chosen so that submodules do not overlap.

\tbf{row} may be abbreviated as \tbf{r}.}\\\hline
% ROW 4
\tbf{p=}\textit{xpos},\textit{ypos},\tbf{column},\textit{deltay}
&
{\raggedright Used for module vectors. Arranges submodules in a column starting
at (\textit{xpos},\textit{ypos}), keeping \textit{deltay} distances.

Defaults: \textit{deltay} is chosen so that submodules do not overlap.

\tbf{column} may be abbreviated as \tbf{col} or \tbf{c}.}\\\hline
% ROW 5
\tbf{p=}\textit{xpos},\textit{ypos},\tbf{matrix},
\textit{itemsperrow},\textit{deltax},\textit{deltay}
&
{\raggedright Used for module vectors. Arranges submodules in a matrix starting
at (\textit{xpos},\textit{ypos}), at most \textit{itemsperrow} submodules in
a row, keeping \textit{deltax} and \textit{deltay} distances.

Defaults: \textit{itemsperrow}=5, \textit{deltax,deltay} are chosen so that
submodules do not overlap.

\tbf{matrix} may be abbreviated as \tbf{m}.}\\\hline
% ROW 6
\tbf{p=}\textit{xpos},\textit{ypos},\tbf{ring},\textit{width,height}
&
{\raggedright Used for module vectors. Arranges submodules in an ellipse,
with the top-left corner of the ellipse's bounding box at (\textit{xpos},\textit{ypos}),
with the \textit{width} and \textit{height}.

Defaults: \textit{width,height} are chosen so that submodules do not overlap.

\tbf{ring} may be abbreviated as \tbf{ri}.}\\\hline
% ROW 7
\tbf{p=}\textit{xpos},\textit{ypos},\tbf{exact},\textit{deltax},\textit{deltay}
&
{\raggedright Used for module vectors. Each submodule is placed at
\textit{(xpos+deltax}, \textit{ypos+deltay)}.
This is useful if \textit{deltax} and \textit{deltay} are parameters
 (e.g.:\textit{''p=100,100,exact,\$x,\$y''})
which take different values for each module in the vector.

Defaults: \textit{none}

\tbf{exact} may be abbreviated as \tbf{e} or \tbf{x}.}\\\hline
% ROW 8
\tbf{b=}\textit{width},\textit{height},\tbf{rect}
&
{\raggedright Rectangle with the given \textit{height} and \textit{width}.

Defaults: \textit{width}=40, \textit{height}=24}\\\hline
% ROW 9
\tbf{b=}\textit{width},\textit{height},\tbf{oval}
&
{\raggedright Ellipse with the given \textit{height} and \textit{width}.

Defaults: \textit{width}=40, \textit{height}=24}\\\hline
% ROW 10
\tbf{o=}\textit{fillcolor},\textit{outlinecolor},\textit{borderwidth}
&
{\raggedright Specifies options for the rectangle or oval.
For color notation, see section \ref{sec:ch-graphics:colors}.

Defaults: \textit{fillcolor}=\#8080ff (a lightblue), \textit{outlinecolor}=black,
\textit{borderwidth}=2}\\\hline
% ROW 11
\tbf{i=}\textit{iconname},\textit{color},\textit{percentage}
&
{\raggedright Use the named icon. It can be colorized, and percentage
specifies the amount of colorization.

Defaults: \textit{iconname}: no default -- if no icon name is present, \textit{box} is used;
\textit{color}: no coloring; \textit{percentage}: 30\%}\\\hline
%%
\tbf{is=}\textit{size}
&
{\raggedright Specifies the size of the icon. \textit{size} can be one of
\ttt{l}, \ttt{vl}, \ttt{s} and \ttt{vs} (for large, very large, small, very small).
If this option is present, size cannot be included in the icon name (\ttt{"i="} tag)
with the \ttt{"i=\textit{<iconname>}\_\textit{<size>}"} notation.}\\\hline
%%
\tbf{i2=}\textit{iconname},\textit{color},\textit{percentage}
&
{\raggedright Displays a small "modifier" icon at the top right corner of the primary icon.
Suggested icons are \ttt{status/busy}, \ttt{status/down}, \ttt{status/up},
\ttt{status/asleep}, etc.

The arguments are analoguous with those of \ttt{"i="}.}\\\hline
%%
\tbf{r=}\textit{radius},\textit{fillcolor},\textit{color},\textit{width}
&
{\raggedright Draws a circle (or a filled circle) around the submodule with
the given radius. It can be used to visualize transmission range of
wireless nodes.

Defaults: \textit{radius}=100, \textit{fillcolor}=none, \textit{color}=black,
\textit{width}=1 (unfilled black circle)}\\\hline
%%
\tbf{q=}\textit{queue-object-name}
&
{\raggedright Displays the queue length next to submodule icon.
It expects a \cclass{cQueue} object's name (as set by the \fname{setName()}
method, see section \ref{sec:sim-lib:name}). Tkenv will do a depth-first
search to find the object, and it will find the queue object within submodules
as well.}\\\hline
%%
\tbf{t=}\textit{text},\textit{pos},\textit{color}
&
{\raggedright Displays a short text by the icon. The text is meant to convey status information
(\textit{"up"}, \textit{"down"}, \textit{"5Kb in buffer"}) or statistics
(\textit{"4 pks received"}). \textit{pos} can be \ttt{"l"}, \ttt{"r"} or \ttt{"t"}
for left, right and top.

Defaults: \textit{radius}=100, \textit{pos}="t", \textit{color}=blue}\\\hline

\end{longtable}

Examples:

\begin{verbatim}
  "p=100,60;i=workstation"
  "p=100,60;b=30,30,rect;o=4"
\end{verbatim}



\subsection{Background display strings}

The tags that can be used in enclosing module display strings are:


\begin{longtable}{|p{6cm}|p{8cm}|}
\hline
% ROW 1
\tabheadcol
\tbf{Tag} & \tbf{Meaning}\\
\hline
% ROW 2
\tbf{p=}\textit{xpos},\textit{ypos} & Place enclosing module at
(\textit{xpos},\textit{ypos}) pixel position, with (0,0) being
the top-left corner of the window.\\\hline
% ROW 3
\tbf{b=}\textit{width},\textit{height},\tbf{rect}
&
{\raggedright Display enclosing module as a rectangle with the given \textit{height}
and \textit{width}.

Defaults: \textit{width,} \textit{height} are chosen automatically}\\\hline
% ROW 4
\tbf{b=}\textit{width},\textit{height},\tbf{oval}
&
{\raggedright Display enclosing module as an ellipse with the given \textit{height}
and \textit{width}.

Defaults: \textit{width,} \textit{height} are chosen automatically}\\\hline
% ROW 5
\tbf{o=}\textit{fillcolor},\textit{outlinecolor},\textit{borderwidth}
&
{\raggedright Specifies options for the rectangle or oval.
For color notation, see section \ref{sec:ch-graphics:colors}.

Defaults: \textit{fillcolor}=\#8080ff (a lightblue), \textit{outlinecolor}=black,
\textit{borderwidth}=2}\\\hline
\end{longtable}


\subsection{Connection display strings}

Tags that can be used in connection display strings:

\begin{longtable}{|p{6cm}|p{8cm}|}
\hline
% ROW 1
\tabheadcol
\tbf{Tag} & \tbf{Meaning}\\\hline
% ROW 2
\tbf{m=auto} \linebreak
\tbf{m=north} \linebreak
\tbf{m=west} \linebreak
\tbf{m=east} \linebreak
\tbf{m=south}
&
Drawing mode. Specifies the exact placement of the connection
arrow. The arguments can be abbreviated as a,e,w,n,s.\\\hline
% ROW 3
{\raggedright \tbf{m=manual},\textit{srcpx},\textit{srcpy},\textit{destpx},\textit{destpy}}
&
{\raggedright The manual mode takes four parameters that explicitly specify
anchoring of the ends of the arrow: \textit{srcpx}, \textit{srcpy},
\textit{destpx}, \textit{destpy}.
Each value is a percentage of the width/height of the source/destination
module's enclosing rectangle, with the upper-left corner being
the origin. Thus,
\begin{verbatim}
m=m,50,50,50,50
\end{verbatim}
would connect the centers of the two module rectangles.}\\\hline
% ROW 4
\tbf{o=}\textit{color},\textit{width} &
Specifies the appearance of the arrow.
For color notation, see section \ref{sec:ch-graphics:colors}.

Defaults: \textit{color}=black, \textit{width}=2\\\hline
\end{longtable}


Examples:
\begin{verbatim}
  "m=a;o=blue,3"
\end{verbatim}


\subsection{Message display strings}

Message objects do not store a display string by default, but you can redefine
the \cclass{cMessage}'s \fname{displayString()} method and make it return
one.

\begin{verbatim}
const char *CustomPacket::displayString() const
{
    return "i=msg/packet_vs";
}
\end{verbatim}

This display string affects how messages are shown during animation.
By default, they are displayed as a small filled circle, in one of
8 basic colors (the color is determined as \textit{message kind modulo 8}),
and with the message class and/or name displayed under it
The latter is configurable in the Tkenv Options dialog, and message kind
dependent coloring can also be turned off there.

The following tags can be used in message display strings:

\begin{longtable}{|p{6cm}|p{8cm}|}
\hline
% ROW 1
\tabheadcol
\tbf{Tag} & \tbf{Meaning} \\\hline
% ROW 2
\tbf{b=}\textit{width},\textit{height},\tbf{oval}
&
{\raggedright Ellipse with the given \textit{height} and \textit{width}.

Defaults: \textit{width}=10, \textit{height}=10}\\\hline
% ROW 3
\tbf{b=}\textit{width},\textit{height},\tbf{rect}
&
{\raggedright Rectangle with the given \textit{height} and \textit{width}.

Defaults: \textit{width}=10, \textit{height}=10}\\\hline
% ROW 4
\tbf{o=}\textit{fillcolor},\textit{outlinecolor},\textit{borderwidth}
&
{\raggedright Specifies options for the rectangle or oval.
For color notation, see section \ref{sec:ch-graphics:colors}.

Defaults: \textit{fillcolor}=red, \textit{outlinecolor}=black,
\textit{borderwidth}=1}\\\hline
% ROW 5
\tbf{i=}\textit{iconname},\textit{color},\textit{percentage}
&
{\raggedright Use the named icon. It can be colorized, and percentage
specifies the amount of colorization. If color name is \ttt{"kind"},
a message kind dependent colors is used (like default behaviour).

Defaults: \textit{iconname}: no default -- if no icon name is present, a small
red solid circle will be used;
\textit{color}: no coloring; \textit{percentage}: 30\%}\\\hline

\end{longtable}

Examples:

\begin{verbatim}
   "i=penguin"
\end{verbatim}

\begin{verbatim}
   "b=15,15,rect;o=white,kind,5"
\end{verbatim}


%FIXME more examples

%FIXME displayString().setTagArg(), bubble() etc here!

\section{Colors}
\label{sec:ch-graphics:colors}

\subsection{Color names}

Any valid Tk color specification is accepted: English color names
(blue, lightgray, wheat) or \textit{\#rgb}, \textit{\#rrggbb} format
(where \textit{r},\textit{g},\textit{b} are hex digits).

It is also possible to specify colors in HSB (hue-saturation-brightness) as
\textit{@hhssbb} (with \textit{h}, \textit{s}, \textit{b} being hex digits).
HSB makes it easier to scale colors e.g. from white to bright red.

A hypen (\textit{"-"}) specified as color means transparent.


\subsection{Icon colorization}

The \ttt{"i="} display string tag allows for colorization of icons.
It accepts a target color and a percentage as the degree of colorization.
Percentage has no effect if the target color is missing.
Brightness of icon is also affected -- to keep the original brightness,
specify a color with about 50% brightness (e.g. #808080 mid-grey,
#008000 mid-green).

Examples:

\begin{itemize}
  \item \ttt{"i=device/server,gold"} creates a gold server icon
  \item \ttt{"i=place/globe,#808080,100"} makes the icon grayscale
  \item \ttt{"i=block/queue,white,100"} yields a "burnt-in" black-and-white icon
\end{itemize}

Colorization works with both submodule and message icons.


\section{The icons}
\label{sec:ch-graphics:icon-library}

\subsection{The bitmap path}

In the current {\opp} version, module icons are GIF files. The icons shipped
with {\opp} are in the \ttt{bitmaps/} subdirectory. Both the GNED editor
and Tkenv need the exact location of this directory to load the icons.

Icons are loaded from all directories in the \textit{bitmap path},
a semicolon-separated list of directories.
The default bitmap path is compiled into GNED and Tkenv with the value
\ttt{"\textit{omnetpp-dir}/bitmaps;./bitmaps"} -- which will work fine
as long as you don't move the directory, and you'll also be able to
load more icons from the \ttt{bitmaps/} subdirectory of the current
directory. As people usually run simulation models from the model's
directory, this practically means that custom icons placed in the
\ttt{bitmaps/} subdirectory of the model's directory are automatically
loaded.

The compiled-in bitmap path can be overridden with the \ttt{OMNETPP\_BITMAP\_PATH}
environment variable. The way of setting environment variables is system
specific: in Unix, if you're using the bash shell, adding a line

\begin{verbatim}
export OMNETPP_BITMAP_PATH="/home/you/bitmaps;./bitmaps"
\end{verbatim}

to \ttt{~/.bashrc} or \ttt{~/.bash_profile} will do; on Windows, environment variables
can be set via the \textit{My Computer --> Properties} dialog.

You can also add to the bitmap path from \ttt{omnetpp.ini}, with
the \ttt{bitmap-path} setting:

\begin{verbatim}
[Tkenv]
bitmap-path = "/home/you/model-framework/bitmaps;/home/you/extra-bitmaps"
\end{verbatim}

The value should be quoted, otherwise the first semicolon separator will be
interpreted as comment sign, which will result in the rest of the
directories being ignored.


\subsection{Categorized icons}

Since {\opp} 3.0, icons are organized into several categories, represented
by folders. These categories include:

\begin{itemize}
  \item block/ - icons for subcomponents (queues, protocols, etc).
  \item device/ - network devices: servers, hosts, routers, etc.
  \item abstract/ - symbolic icons for various devices
  \item place/ - subnet, building, town, city; map symbols
  \item msg/ - icons that can be used for messages
\end{itemize}

Old (pre-3.0) icons are in the \ttt{old/} folder.

Tkenv and GNED now load icons from subdirectories of all directories
of the bitmap path, and these icons can be referenced from display strings
by naming the subdirectory (subdirectories) as well:
\ttt{"subdir/icon"}, \ttt{"subdir/subdir2/icon"}, etc.

For compatibility, if the display string contains a icon without
a category (i.e. subdirectory) name, {\opp} tries it as "old/icon" as well.

If you create new or custom icons, you can put

\subsection{Icon size}

Icons come in various sizes: normal, large, small, very small. Sizes are
encoded into the icon name's suffix: \ttt{\_l}, \ttt{\_s}, \ttt{\_vs}.
In display strings, one can either use the suffix (\ttt{"i=device/router_l"}),
or the \ttt{"is}" (\textit{icon size}) display string tag ("i=device/router;is=l").


\section{GNED -- Graphical NED Editor}

\index{ned!graphical interface}

The GNED editor allows you to design compound modules graphically.
GNED works directly with NED files -- it doesn't have any internal file
format. You can load any of your existing NED files, edit the compound
modules in it graphically and then save the file back. Other components
in the NED file (simple modules, channels, networks etc.) will
survive the operation. GNED puts all graphics-related data into
display strings.

GNED works by parsing your NED file into an internal data structure,
and regenerating the NED text when you save the file. One consequence
of this is that indentation will be ``canonized''.
Comments in the original NED are preserved -- the parser associates
them with the NED elements they belong to, so comments won't
be messed up even if you edit the graphical representation extensively
by removing/adding submodules, gates, parameters, connections, etc.

GNED is a fully two-way visual tool. While editing the graphics,
you can always switch to NED source view, edit in there and switch
back to graphics. Your changes in the NED source will be immediately
backparsed to graphics; in fact, the graphics will be totally
reconstructed from the NED source and the display strings in
it.


\subsection{Keyboard and mouse bindings}

\index{gned!mouse bindings}

In graphics view, there are two editing modes: draw and select/mode.
The mouse bindings are the following:


\begin{longtable}{|p{7cm}|p{7cm}|}
\hline
% ROW 1
\tabheadcol
\tbf{Mouse} & \tbf{Effect}\\\hline
\multicolumn{2}{|c|}{\tbf{In \textit{draw} mode:}} \\
\hline
% ROW 3
Drag out a rectangle in empty area: &  create new submodule \\\hline
% ROW 4
Drag from one submodule to another: &  create new connection \\\hline
% ROW 5
Click in empty area: & switch to select/move mode \\\hline
\multicolumn{2}{|c|}{\tbf{In \textit{select/move} mode:}} \\\hline
% ROW 7
Click submodule/connection: & select it\\\hline
% ROW 8
Ctrl-click submodule/conn.: & add to selection \\\hline
% ROW 9
Click in empty area: & clear selection\\\hline
% ROW 10
Drag a selected object: & move selected objects \\\hline
% ROW 11
Drag submodule or connection: & move it \\\hline
% ROW 12
Drag either end of connection: & move that end \\\hline
% ROW 13
Drag corner of (sub)module: & resize module\\\hline
% ROW 14
Drag starting in empty area: & select enclosed submodules/connections \\\hline
% ROW 15
\textit{Del} key & delete selected objects \\\hline
\multicolumn{2}{|c|}{\tbf{Both editing modes:}} \\\hline
% ROW 17
Right-click on module/submodule/con\-nec\-tion: & popup menu \\\hline
% ROW 18
Double-click on submodule: & go into submodule \\\hline
% ROW 19
Click name label & edit name \\\hline
% ROW 20
Drag\&drop module type from the tree view to the canvas &
create a submodule of that type \\\hline
\end{longtable}



\section{Changing the network graphics at run-time}

%FIXME update
\subsection{Setting display strings}

Sometimes it is useful to change the appearance or position of
some components in the network graphics, such as the color of the
modules\index{module!color}, color/width of connection arrows,
position of a submodule, etc.

The appearance of nodes and connections is determined by the display
strings\index{display strings}. Display strings (e.g. \ttt{"p=100,10;i=pc"})
are initially taken from the NED description.
You can change the display string of a module or connection arrow
at run-time by calling methods named \fname{setDisplayString()}.
The \cclass{cDisplayString} class (discussed in the following sections)
might be useful for manipulating the display string.

Setting the module's appearance when it is displayed as a component
within a compound module:

\begin{verbatim}
setDisplayString("p=100,100;b=60,30,rect;o=red,black,3", true);
\end{verbatim}

Setting appearance of a compound module when it is displayed as a
bounding box for its submodules:

\begin{verbatim}
parentModule()->setBackgroundDisplayString("p=100.....", true);
\end{verbatim}

The display string of a connection arrow\index{arrow display string}
is stored in its source gate, so you'll need to write something
like this:

\begin{verbatim}
gate("out")->setDisplayString("o=yellow,3");
\end{verbatim}

The \fname{setDisplayString()} methods additionally take a bool
argument called \fvar{immediate}. It specifies whether the display
string change should take effect immediately, or only after processing
the current event (the default is \textit{immediate=true}). If several
display string changes are going to be done within one event, then
\textit{immediate=false} is useful because it reduces the number of
necessary redraws. \textit{Immediate=false} also uses less stack.  But
its drawback is that a \fname{setDisplayString()} followed by a
\fname{send()} would actually be displayed in reverse order (message
animation first), because message animations are performed immediately
(actually within the \fname{send()} call).


\subsection{The cDisplayString class}

The \cclass{cDisplayString} utility class lets you parse and
manipulate display strings.

As far as \cclass{cDisplayString} is concerned, a display string
(e.g. \ttt{"p=100,125;i=cloud"}) is a string that consist of several
\textit{tags} separated by semicolons, and each tag has a \textit{name}
and after an equal sign, zero or more \textit{arguments} separated by commas.

The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags,
removing tags or replacing arguments. The internal storage method allows
very fast operation; it will generally be faster than direct string manipulation.
The class doesn't try to interpret the display string in any way, nor does
it know the meaning of the different tags; it merely parses the string
as data elements separated by semicolons, equal signs and commas.

An example:

\begin{Verbatim}
cDisplayString dispstr("a=1,2;p=alpha,,3");
dispstr.insertTag("x");
dispstr.setTagArg("x",0,"joe");
dispstr.setTagArg("x",2,"jim");
dispstr.setTagArg("p",0,"beta");
ev << dispstr.getString();  // result: "x=joe,,jim;a=1,2;p=beta,,3"
\end{Verbatim}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
