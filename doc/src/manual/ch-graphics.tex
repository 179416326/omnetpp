\chapter{Network Graphics And Animation}
\label{cha:graphics}

\section{Display strings}
\label{sec:ch-graphics:display-strings}

\subsection{Display string syntax}

Display strings\index{display strings} specify the arrangement and
appearance of modules in graphical user interfaces (currently only
Tkenv): they control how the objects (compound modules, their
submodules and connections) are displayed. Display strings occur in
NED description's \fpar[ned!keywords!display]{@display}
property.

The display string format is a semicolon-separated list of tags.
Each tag consists of a key (usually one letter), an equal sign
and a comma-separated list of parameters, like:

Example:
\begin{verbatim}
  "p=100,100;b=60,10,rect;o=blue,black,2"
\end{verbatim}

Parameters may be omitted also at the end and also inside the
parameter list, like:

Example:
\begin{verbatim}
  "p=100,100;b=,,rect,blue"
\end{verbatim}

Module/submodule parameters can be included with the \ttt{\$name} notation:

Example:
\begin{verbatim}
  "p=$xpos,$ypos;b=60,10,rect,$fillcolor,black,2"
\end{verbatim}

Display string tags can be inherited from the base NED type if you have a derived
NED type. Submodules are also inheriting their display tags from their type. If
you have several submodules with the same type and want to assign the same icon
to each one you no longer have to specify the icon in each submodule (this was the
case with {\opp} 3.x). Just specify the icon in the type of the submodule and each
submodule with that type will inherit it. You may still override any display tag
value in the submodule's display string. If you don't want to inherit a value
from your base type, but also don't want to specify one (i.e. want to have the
default value) use the dash (-) character at that position in the tag. This will
prevent the inheritance.

Objects that may have display strings are:
\begin{itemize}
  \item \textit{compound modules, networks} -- display string can specify background color,
        border color, border thickness, background image, scaling etc.
  \item \textit{submodules} -- display string may contain position, arrangement
        (for module vectors), icon, icon color, auxiliary icon, status text,
        communication range (as circle or filled circle), etc.
  \item \textit{connections} -- display string can specify positioning, arrow color,
        arrow thickness
  \item \textit{channles, connections} -- display string can specify color,
        linestyle, line width, text and tooltip
  \item \textit{messages} -- display string can specify icon, icon color, etc.
\end{itemize}

The following NED sample shows where to place display strings in the code:

Example:
\begin{verbatim}
simple Queue
{
    parameters:
        @display("i=block/queue");  // icon for any submodules using this type
    gates:
        input in[];
        output out;
}

network SimpleQueue
{
    parameters:
        @display("i=block/network2;bgi=bgimage"); // module display string
    submodules:
        sink: Sink {
            @display("p=273,101");  // submodule params
        }
        queue: Queue {
            @display("p=165.0,79.0"); // icon is inherited from the Queue type
        }
        source: Source {
            @display("p=50.0,79.0;i=-"); // icon won't be inherited from Source
        }
    connections:
        // display string for a connection
        source.out --> { @display("ls=red,3"); } --> queue.in++;
        queue.out --> sink.in++;
}

\end{verbatim}


\subsection{Simple module display strings}

The simple module display string supports the following tags:
\begin{itemize}
  \item{\ttt{b} -- shapes, colors}
  \item{\ttt{i} -- icon}
  \item{\ttt{is} -- icon size}
\end{itemize}
These tags are used mainly to describe the default appearence of
a submodule of this type. To see detailed descripton of 
these tags check Appendix \ref{cha:display-string-tags} about 
display string tags.

\subsection{Compound module and network display strings}

In addition to the tags supported by a simple module there are tags
describing how a compound module looks like if opened in Tkenv. These
tags mainly deal with the module background.

\begin{itemize}
  \item{\ttt{b} -- shapes, colors}
  \item{\ttt{i} -- icon}
  \item{\ttt{is} -- icon size}
  \item{\ttt{bgi} -- background image}
  \item{\ttt{bgtt} -- tooltip above the background}
  \item{\ttt{bgg} -- background grid}
  \item{\ttt{bgl} -- control child layouting}
  \item{\ttt{bgb} -- background size, color, border}
  \item{\ttt{bgs} -- scaling of background coordinates}
  \item{\ttt{bgp} -- background coordinate offset}
\end{itemize}

Example:
\begin{verbatim}
network SimpleQueue
{
    parameters:
        @display("i=block/network2;bgi=bgimage"); // module display string
\end{verbatim}

To see detailed descripton of these tags check 
Appendix \ref{cha:display-string-tags} about display string tags.

\subsection{Submodule display strings}

Submodules inherit their appearance from their type. There are
additional tags that are supported additionally to the ones supported
for simple modules. These tags let you add instance specific changes
like range indicator, satus icons, position etc.
The submodule display string supports the following tags:
\begin{itemize}
  \item{\ttt{b} -- shapes, colors}
  \item{\ttt{i} -- icon}
  \item{\ttt{is} -- icon size}
  \item{\ttt{i2} -- alternate (status) icon}
  \item{\ttt{p} -- positioning and layouting}
  \item{\ttt{r} -- range indicator}
  \item{\ttt{q} -- queue information text}
  \item{\ttt{t} -- text}
  \item{\ttt{tt} -- tooltip}
\end{itemize}

Example:
\begin{verbatim}
submodules:
    source: Source {
        @display("p=50,79;i=-;r=90"); // icon won't be inherited from Source
    }
\end{verbatim}

To see detailed descripton of these tags check
Appendix \ref{cha:display-string-tags} about display string tags.

\subsection{Channel and connection display strings}

Channels and connections may also have display strings. Display property
defined for a channel is inherited by a connection similary how a submodule
inherits the display property from its type.

Channels and connections support the following tags:
\begin{itemize}
  \item{\ttt{ls} -- line shape, and colors}
  \item{\ttt{t} -- text}
  \item{\ttt{tt} -- tooltip}
\end{itemize}

Example:
\begin{verbatim}
source.out --> { @display("ls=red,3"); } --> queue.in++;
\end{verbatim}

To see detailed descripton of these tags check
Appendix \ref{cha:display-string-tags} about display string tags.

\subsection{Message display strings}

Message objects do not store a display string by default, but you can redefine
the \cclass{cMessage}'s \fname{getDisplayString()} method and make it return
one.

Example:
\begin{verbatim}
const char *CustomPacket::getDisplayString() const
{
    return "i=msg/packet;is=vs";
}
\end{verbatim}

Or better: If you add the field \fname{displayString} to your message 
definition (.msg file) the message compiler will automatically generate 
the \fname{set/getDisplayString} methods for you:

\begin{verbatim}
message Job
{
    string displayString = "i=msg/package_s,kind";
...
\end{verbatim}

This display string affects how messages are shown during animation.
By default, they are displayed as a small filled circle, in one of
8 basic colors (the color is determined as \textit{message kind modulo 8}),
and with the message class and/or name displayed under it
The latter is configurable in the Tkenv Options dialog, and message kind
dependent coloring can also be turned off there.

The following tags can be used in message display strings:
\begin{itemize}
  \item{\ttt{b} -- shapes, colors}
  \item{\ttt{i} -- icon}
  \item{\ttt{is} -- icon size}
\end{itemize}

\begin{note}
   You may use the word \ttt{kind} as a special color. This virtual color depends on 
   the \ttt{messageKind} field in the message.
\end{note}

Examples:
\begin{verbatim}
   "i=msd/box,red;is=s"
\end{verbatim}

\begin{verbatim}
   "b=15,15,rect,white,kind,5"
\end{verbatim}

%FIXME more examples, WITH EXPLANATIONS


\section{Colors}
\label{sec:ch-graphics:colors}

\subsection{Color names}

Any valid Tk color specification is accepted: English color names
(blue, lightgray, wheat) or \textit{\#rgb}, \textit{\#rrggbb} format
(where \textit{r},\textit{g},\textit{b} are hex digits).

It is also possible to specify colors in HSB (hue-saturation-brightness) as
\textit{@hhssbb} (with \textit{h}, \textit{s}, \textit{b} being hex digits).
HSB makes it easier to scale colors e.g. from white to bright red.

You can produce a transparent background by specifying a hyphen (\textit{"-"})
as background color.


\subsection{Icon colorization}

The \ttt{"i="} display string tag allows for colorization of icons.
It accepts a target color and a percentage as the degree of colorization.
Percentage has no effect if the target color is missing.
Brightness of icon is also affected -- to keep the original brightness,
specify a color with about 50\% brightness (e.g. \#808080 mid-grey,
\#008000 mid-green).

Examples:

\begin{itemize}
  \item \ttt{"i=device/server,gold"} creates a gold server icon
  \item \ttt{"i=misc/globe,\#808080,100"} makes the icon grayscale
  \item \ttt{"i=block/queue,white,100"} yields a "burnt-in" black-and-white icon
\end{itemize}

Colorization works with both submodule and message icons.


\section{The icons}
\label{sec:ch-graphics:icon-library}

\subsection{The image path}

In the current {\opp} version, module icons are PNG or GIF files. The icons shipped
with {\opp} are in the \ttt{images/} subdirectory. Both the graphical NED editor
and Tkenv need the exact location of this directory to load the icons.

Icons are loaded from all directories in the \textit{image path},
a semicolon-separated list of directories.
The default image path is compiled into Tkenv with the value
\ttt{"\textit{omnetpp-dir}/images;./images;./bitmaps"} -- which will work fine
as long as you don't move the directory, and you'll also be able to
load more icons from the \ttt{images/} subdirectory of the current
directory. As people usually run simulation models from the model's
directory, this practically means that custom icons placed in the
\ttt{images/} subdirectory of the model's directory are automatically
loaded.

The compiled-in image path can be overridden with the \ttt{OMNETPP\_IMAGE\_PATH}
environment variable. The way of setting environment variables is system
specific: in Unix, if you're using the bash shell, adding a line

\begin{verbatim}
export OMNETPP_IMAGE_PATH="/home/you/images;./images"
\end{verbatim}

to \ttt{~/.bashrc} or \ttt{~/.bash\_profile} will do; on Windows, environment variables
can be set via the \textit{My Computer --> Properties} dialog.

You can also add to the image path from \ttt{omnetpp.ini}, with
the \ttt{image-path} setting:

\begin{verbatim}
[General]
tkenv-image-path = "/home/you/model-framework/images;/home/you/extra-images"
\end{verbatim}

The value should be quoted, otherwise the first semicolon separator will be
interpreted as comment sign, which will result in the rest of the
directories being ignored.


\subsection{Categorized icons}

Since {\opp} 3.0, icons are organized into several categories, represented
by folders. These categories include:

\begin{itemize}
  \item block/ - icons for subcomponents (queues, protocols, etc).
  \item device/ - network devices: servers, hosts, routers, etc.
  \item abstract/ - symbolic icons for various devices
  \item misc/ - node, subnet, cloud, building, town, city, etc.
  \item msg/ - icons that can be used for messages
\end{itemize}

Old (pre-3.0) icons are in the \ttt{old/} folder.

Tkenv and the IDE now load icons from subdirectories of all directories
of the image path, and these icons can be referenced from display strings
by naming the subdirectory (subdirectories) as well:
\ttt{"subdir/icon"}, \ttt{"subdir/subdir2/icon"}, etc.

For compatibility, if the display string contains a icon without
a category (i.e. subdirectory) name, {\opp} tries it as "old/icon" as well.

%FIXME If you create new or custom icons...

\subsection{Icon size}

Icons come in various sizes: normal, large, small, very small. Sizes are
encoded into the icon name's suffix: \ttt{\_vl}, \ttt{\_l}, \ttt{\_s}, \ttt{\_vs}.
In display strings, one can either use the suffix (\ttt{"i=device/router\_l"}),
or the \ttt{"is}" (\textit{icon size}) display string tag ("i=device/router;is=l"),
but not both at the same time (we recommend using the \ttt{is} tag whenever possible).


\section{Layouting}
\label{sec:ch-graphics:layouting}

{\opp} implements an automatic layouting feature, using
a variation of the SpringEmbedder algorithm. Modules which have
not been assigned explicit positions via the \ttt{"p="} tag will be
automatically placed by the algorithm.

SpringEmbedder is a graph layouting algorithm based on a physical model.
Graph nodes (modules) repent each other like electric charges
of the same sign, and connections are sort of springs which try
to contract and pull the nodes they're attached to. There is also friction
built in, in order to prevent oscillation of the nodes. The layouting algorithm
simulates this physical system until it reaches equilibrium
(or times out). The physical rules above have been slightly tweaked
to get better results.

The algorithm doesn't move any module which has fixed coordinates.
Predefined row, matrix, ring or other arrangements (defined
via the 3rd and further args of the \ttt{"p="} tag) will be preserved --
you can think about them as if those modules were attached
to a wooden framework so that they can only move as one unit.

Caveats:

\begin{itemize}
  \item If the full graph is too big after layouting, it is scaled
    back so that it fits on the screen, \textit{unless it contains
    any fixed-position module}. (For obvious reasons: if there's a module
    with manually specified position, we don't want to move that one).
    To prevent rescaling, you can specify a sufficiently large bounding
    box in the background display string, e.g. \ttt{"b=2000,3000"}.
  \item Size is ignored by the present layouter, so longish modules
    (such as an Ethernet segment) may produce funny results.
  \item The algorithm is prone to produce erratic results, especially
    when the number of submodules is small, or when using predefined
    (matrix, row, ring, etc) layouts. The "Re-layout" toobar button
    can then be very useful. Larger networks usually produce
    satisfactory results.
  \item The algorithm is starting from random positions. 
     To get the best results you may experiment with
    different seeds by specifying them using the \ttt{bgl=\textit{seed}}
    display string tag. 
\end{itemize}

\section{Enhancing animation}

\subsection{Changing display strings at runtime}

Often it is useful to manipulate the display string at runtime.
Changing colors, icon, or text may convey status change, and
changing a module's position is useful when simulating mobile
networks.

Display strings are stored in \cclass{cDisplayString} objects inside
channels, modules and gates. \cclass{cDisplayString} also lets you manipulate the string.

To get a pointer to the \cclass{cDisplayString} object, you can call
the components's \fname{getDisplayString()} method:

\begin{verbatim}
// Setting a module's position, icon and status icon:
cDisplayString *dispStr = getDisplayString();
dispStr->parse("p=40,20;i=device/cellphone;i2=status/disconnect");
\end{verbatim}

\begin{note}
The connection display string is stored in the output gate of the connection.
\end{note}

\begin{verbatim}
//Settig an outgoing connection's color to red:
cDisplayString *gateDispStr = gate("out")->getDisplayString();
dispStr->parse("ls=red");
\end{verbatim}

\begin{note}
In {\opp} 3.x to manipulate the appearence of a compound module you had to use
the \fname{backgroundDisplayString()} method. This is no longer supported in 
{\opp} 4.0. Use the \fname{getDisplayString()} method instead along with the background
specific tags (i.e. \ttt{bg*} tags).
\end{note}

\begin{verbatim}
// Setting module background and grid with background display string tags:
cDisplayString *parentDispStr = getParentModule()->getDisplayString();
parentDispStr->parse("bgi=maps/europe;bgg=100,2");
\end{verbatim}

\begin{note}
Modules are inheriting the display string from their type (for submodules) or
from their ancestors if you have a derived simple or compound module. If you
do not want to inherit a tag argument you should specify a single dash (-) 
as the argument's value. Tkenv will use the default value for this argument.
\end{note}

As far as \cclass{cDisplayString} is concerned, a display string
(e.g. \ttt{"p=100,125;i=cloud"}) is a string that consist of several
\textit{tags} separated by semicolons, and each tag has a \textit{name}
and after an equal sign, zero or more \textit{arguments} separated by commas.

The class facilitates tasks such as finding out what tags a display string
has, adding new tags, adding arguments to existing tags,
removing tags or replacing arguments. The internal storage method allows
very fast operation; it will generally be faster than direct string manipulation.
The class doesn't try to interpret the display string in any way, nor does
it know the meaning of the different tags; it merely parses the string
as data elements separated by semicolons, equal signs and commas.

An example:

\begin{verbatim}
dispStr->parse("a=1,2;p=alpha,,3");
dispStr->insertTag("x");
dispStr->setTagArg("x",0,"joe");
dispStr->setTagArg("x",2,"jim");
dispStr->setTagArg("p",0,"beta");
ev << dispStr->str();  // result: "x=joe,,jim;a=1,2;p=beta,,3"
\end{verbatim}

\subsection{Bubbles}

Modules can let the user know about important events (such as a node
going down or coming up) by displaying a bubble with a short message
("Going down", "Coming up", etc.) This is done by the \fname{bubble()} method
of \cclass{cComponent}. The method takes the string to be displayed
as a \ttt{const char *} pointer.

An example:
\begin{verbatim}
bubble("Going down!");
\end{verbatim}

If the module contains a lot of code that modifies the display string or
displays bubbles, it is recommended to make these calls conditional
on \ttt{ev.isGUI()}. The \ttt{ev.isGUI()} call returns \textit{false}
when the simulation is run under Cmdenv, so one can make the code skip
potentially expensive display string manipulation.

Better:
\begin{verbatim}
if (ev.isGUI())
    bubble("Going down!");
\end{verbatim}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
