\chapter{Introduction}
\label{cha:introduction}


\section{What is {\opp}?}

{\opp} is an object-oriented modular discrete event network simulator.
The simulator can be used for:

\begin{itemize}
  \item{traffic modeling of telecommunication networks}
  \item{protocol modeling}
  \item{modeling queueing networks}
  \item{modeling multiprocessors and other distributed hardware systems}
  \item{validating hardware architectures}
  \item{evaluating performance aspects of complex software systems}
  \item{\dots modeling any other system where the discrete event approach is
    suitable.}
\end{itemize}


An {\opp} model consists of hierarchically nested modules. The
depth of module nesting is not limited, which allows the user
to reflect the logical structure of the actual system in the
model structure. Modules communicate through message passing. Messages
can contain arbitrarily complex data structures. Modules can
send messages either directly to their destination or along a
predefined path, through gates and connections.


Modules can have their own parameters. Parameters can be used to customize
module behaviour and to parameterize the model's topology.

Modules at the lowest level of the module hierarchy encapsulate
behaviour. These modules are termed simple modules, and they are
programmed in C++ using the simulation library.

{\opp} simulations can feature varying user interfaces for
different purposes: debugging, demonstration and batch execution.
Advanced user interfaces make the inside of the model visible
to the user, allow control over simulation execution
and to intervene by changing variables/objects inside the model.
This is very useful in the development/debugging phase
of the simulation project. User interfaces also facilitate demonstration
of how a model works.

The simulator as well as user interfaces and tools are portable:
they are known to work on Windows and on several Unix flavours,
using various C++ compilers.

{\opp} also supports parallel distributed simulation. {\opp} can
use several mechanisms for communication between partitions of
a parallel distributed simulation, for example MPI or named pipes.
The parallel simulation algorithm can easily be extended or new
ones plugged in. Models do not need any special instrumentation
to be run in parallel -- it is just a matter of configuration.
{\opp} can even be used for classroom presentation of parallel
simulation algorithms, because simulations can be run in parallel
even under the GUI which provides detailed feedback on what's going on.




% \section{Where does {\opp} stand in the world of simulation tools?}
%
% There are numerous network simulation tools on the market today,
% both commercial and non-commercial. In this section I will try
% to give an overview by picking some of the most important or
% most representative ones in both categories and comparing them
% to {\opp}: PARSEC, SMURPH, NS, Ptolemy, NetSim++, C++SIM, CLASS
% as non-commercial, and OPNET, COMNET III as commercial tools.
% (The {\opp} Home Page contains a list of Web sites with collections
% of references to network simulation tools where the reader can
% get a more complete list.) In the commercial category, OPNET
% is widely held to be the state of the art in network simulation.
% {\opp} is targeted at roughly the same segment of network simulation
% as OPNET.
%
% Seven issues are examined to get an overview about the network
% simulation tools:
%
%
% \textbf{Detail Level}. \textit{Does the simulation tool have the necessary
% power to express details in the model?} In other words, can the
% user implement arbitrary new building blocks like in {\opp}
% or he is confined to the predefined blocks implemented by the
% supplier? Some tools like COMNET III are not programmable by
% the user to this extent therefore they cannot be compared to
% {\opp}. Specialized network simulation tools like NS (for IP)
% and CLASS (for ATM) also rather fall into this category.
%
%
% \textbf{Available Models.} \textit{What protocol models are readily available
% for the simulation tool?} As of end 2004, there are three large
% protocol modelling frameworks available for {\opp}:
% the Mobility Framework for modelling mobile, wireless and ad-hoc networks;
% the INET Framework with TCP, IP, MPLS and other Internet-related protocols;
% and IPv6Suite which provides detailed models for IPv6, Mobile IPv6, 802.11
% and other protocols. Several other simulation models (such as AntNet routing)
% have also been published -- the list is ever growing, and model frameworks
% are constantly maturing and converging.
%
%
% \textbf{Defining Network Topology}. \textit{How does the simulation
% tool support defining the network topology?} Is it possible to
% create some form of hierarchy (nesting) or only ``flat'' topologies
% are supported? Network simulation tools naturally share the property
% that a model (network) consists of ``nodes'' (blocks, entities,
% modules, etc.) connected by ``links'' (channels, connections, etc.).
% Many commercial simulators have graphical editors to define the
% network; however, this is only a good solution if there is an
% alternative form of topology description (e.g. text file) which allows
% one to generate the topology by program. OPNET follows a unique way:
% the network topology is stored in a proprietary binary file format
% which can be generated (and read) by the graphical editor and C
% programs linked against a special library. On the other hand, most
% non-commercial simulation tools do not provide explicit support for
% topology description: one must program a ``driver entity'' which will
% boot the model by creating the necessary nodes and interconnecting
% them (PARSEC, SMURPH, NS). Finally, a large part of the tools that do
% support explicit topology description supports only flat topologies
% (CLASS). {\opp} probably uses the most flexible method: it has a
% human-readable textual topology description format (the NED language)
% which is easy to create with any text-processing tool (\fprog{perl},
% \fprog{awk}, etc.), and the same format is used by the graphical
% editor. It is also possible to create a ``driver entity'' to build a
% network at run-time by program. {\opp} also supports submodule
% nesting.
%
%
% \textbf{Programming Model.} \textit{What is the programming model supported
% by the simulation environment?} Network simulators typically use
% either thread/coroutine-based programming (such as \fname{activity()}
% in {\opp}), or FSMs built upon a \fname{handleMessage()}-like function.
% For example, OPNET, SMURPH and NetSim++ use FSMs (with underlying
% handleMessage()), PARSEC and C++SIM use threads. {\opp} supports
% both programming models; the author does not know of another
% simulation tool that does so.
%
%
% \textbf{Debugging and Tracing Support.} \textit{What debugging or tracing
% facilities does the simulation tool offer?} Simulation programs
% are infamous for long debugging periods. C++-based simulation
% tools rarely offer much more than \fname{printf()}-style debugging; often
% the simulation kernel is also capable of dumping selected debug
% information on the standard output. Animation is also often supported,
% either off-line (record\&playback) or in some client-server architecture,
% where the simulation program is the ``server'' and
% it can be viewed using the ``client''. Off-line animation
% naturally lacks interactivity and is therefore little use in
% debugging. The client-server solution typically has limited power
% because the simulation and the viewer run as independent operating
% system processes, and the viewer has limited access to the simulation
% program's internals and/or it does not have enough control over
% the course of simulation execution. OPNET has a very good support
% for command-line debugging and provides both off-line and client-server
% style animation. NetSim++ and Ptolemy use the client-server method
% of animation. {\opp} goes a different way by linking the GUI
% library with the debugging/tracing capability into the simulation
% executable. This architecture enables the GUI to be very powerful:
% every user-created object is visible (and modifiable) in the
% GUI via inspector windows and the user has tight control over
% the execution. To the author's best knowledge, the tracing feature
% {\opp} provides is unique among the C++-based simulation tools.
%
%
% \textbf{Performance.} \textit{What performance can be expected from the
% simulation?} Simulation programs typically run for several hours.
% Probably the most important factor is the programming language;
% almost all network simulation tools are C/C++-based. Performance
% is a particularly interesting issue with {\opp} since the GUI
% debugging/tracing support involves some extra overhead in the
% simulation library. However, in a reported case, an {\opp} simulation
% was only 1.3 slower than its counterpart implemented in plain
% C (i.e. one containing very little administration overhead),
% which is a very good showing. A similar result was reported in
% a performance comparison with a PARSEC simulation.
%
%
% \textbf{Source Availability.} \textit{Is the simulation library available
% in source?} This is a trivial question but it immediately becomes
% important if one wants to examine or teach the internal workings
% of a simulation kernel, or one runs into trouble because some
% function in the simulation library has a bug and/or it is not
% documented well enough. In general it can be said that non-commercial
% tools (like {\opp}) are open-source and commercial ones are
% not. This is also true for OPNET: the source for simulation kernel
% is not available (although the ready-made protocol models come
% with sources).
%
%
% In conclusion, it can be said that {\opp} has enough features
% to make it a good alternative to most network simulation tools,
% and it has a strong potential to become one of the most widely
% used network simulation packages in academic and research environments.
%

\section{Organization of this manual}

The manual is organized the following way:

\begin{itemize}
  \item{The chapters \ref{cha:introduction} and \ref{cha:overview}
    contain introductory material}
  \item{The second group of chapters,
    \ref{cha:the-ned-language},
    \ref{cha:simple-modules} and
    \ref{cha:the-simulation-library}
    are the programming guide. They present the NED language\index{ned!language},
    the simulation concepts and their implementation in {\opp}, explain
    how to write simple\index{module!simple} modules and describe the class library.}
  \item{The chapters
    \ref{cha:graphics} and
    \ref{cha:neddoc}
    elaborate the topic further, by explaining how one can customize
    the network graphics and how to write NED source code comments
    from which documentation can be generated.}
  \item{The following chapters,
    \ref{cha:building-simulation-programs},
    \ref{cha:run-sim} and
    \ref{cha:analyzing-simulation-results} deal with practical issues
    like building and running simulations and analyzing results, and
    present the tools {\opp} provides to support these tasks.}
  \item{Chapter \ref{cha:parallel-execution} is devoted to the support
    of distributed execution.}
  \item{Finally, Chapter \ref{cha:opp-design} explains the
    architecture and the internals of {\opp}. This chapter will be
    useful to those who want to extend the capabilities of the
    simulator or want to embed it into a larger application.}
%  \item{The first two Appendices, \ref{cha:opnet-and-omnet} and
%    \ref{cha:parsec-and-omnet}, contain a comparison of {\opp} and
%    two other important and well-known simulation tools, OPNET and
%    PARSEC.}
  \item{Appendix \ref{cha:ned-language-grammar} provides a reference
    of the NED language\index{ned!language}.}
\end{itemize}




% \section{History}
%
% \tbf{The early days: 1992-1997}
%
% {\opp} has its distant roots in OMNeT, a simulator written
% in Object Pascal by dr. Gy\"{o}rgy Pongor.
% The development of {\opp} started as a semester's programming
% assignment at the Technical University of Budapest (BME) in 1992.
% The assignment (``creation of an object-oriented discrete event
% simulation system in C++'') was handed out by Prof. Dr Gy\"{o}rgy
% Pongor, and two students signed up: \'{A}kos Kun and Andr\'{a}s Varga.
% The basis for the design was Mr. Pongor's existing simulation
% software written in Pascal, named OMNeT.
%
% We started developing the code in Borland C++ 3.1. The idea
% of multiple runtime environments, a significant addition to the
% original OMNeT design, was there from the very beginning.
% We used Turbo Vision (Borland's then successful character-based
% GUI) for the first `graphical' user interface.
%
% In 1992, we submitted a paper about {\opp} to the
% student's annual university conference
% (named ``TDK'') and won first prize in the ``Software'' section.
% Later we also won 1st prize in the national ``TDK''. Then the
% idea came to port {\opp} to Unix (first for AIX on an RS/6000
% with only 16MB RAM, later Linux), until all development was done
% in Linux and BC3.1 could no longer be supported.
%
% Well, here's a brief list of events since then -- maybe one time
% I'll make up my mind to enhance them to a whole story\dots
%
% 1994: XEnv (a GUI in pure MOTIF, superceded by Tkenv by now)
% was written as diploma work
%
% 1994: used OPNET for several simulation projects. OPNET features
% (and flaws) gave lots of ideas how to continue with {\opp}.
%
% 1995: initial version of nedc was written by a group of exchange
% students from Delft
%
% 1996: initial version of PVM support was programmed by Zoltan
% Vass as diploma work
%
% 1997: started working on Tkenv
%
% 1997 Dec: added GNED
%
% \tbf{Regular open-source releases: 1997-2003}
%
% Until 1997, some people occasionally contributed to {\opp}.
% Since 1997, all development is done entirely by Andras;
% independent of the University since 1998. (He leaves
% the University in 1998, and is no longer affiliated with it
% since then.)
%
% 1997 Sept: web site set up (www.hit.bme.hu/phd/vargaa/omnetpp), first public release
%
% 1997 Feb-1998 Sept: simulation projects for a small company in
% Hungary. We used a version of {\opp}.
%
% 1998 March: added Plove
%
% 1998 June: animation implemented in Tkenv
%
% 1998 Sept-1999 May: work at MeTechnology (later Brokat) in Leipzig
%
% 2000 Jan: MSVC porting
%
% 2000 Sept: contributed model repository set up
%
% 2000: IPSuite created in Karlsruhe
%
% 2001 May: {\opp} 2.1 release
%
% 2001 June: the CVS gets hosted in Karlsruhe
%
% 2002 May: {\opp} 2.2 release
%
% 2003 Jan: Omnest Global Inc. was founded
%
% 2003 Feb-Oct: Andras's stay at CTIE, Monash University, Melbourne, Australia
% with Ahmet Sekercioglu's group; development of {\opp}'s parallel simulation
% framework, doing parallel simulation experiments
%
% 2003 June: first public release of IPv6Suite (CTIE, Monash University)
%
% 2003 July: launch of www.omnetpp.org
%
% 2003 July: release of RSVP/TE models at UTS Sydney
%
% 2003 Aug: Andras takes over IPSuite maintenance
%
% 2003 Sept: Ethernet model made available
%
% 2003 Nov: {\opp} 2.3p1 release
%
% 2004 July: Mobility Framework first official release (TKN, TU Berlin)
%
% 2004 Oct: IPSuite renamed to INET Framework
%
% \dots
%


\section{Credits}

{\opp} has been developed by Andr\'{a}s Varga (andras@omnetpp.org, andras.varga@omnest.com).

In the early stage of the project, several people have contributed
to {\opp}. Although most contributed code is no longer part of
the {\opp}, nevertheless I'd like to acknowledge the work of the
following people. First of all, I'd like thank Dr Gy\"{o}rgy Pongor
(pongor@hit.bme.hu), my advisor at the Technical University of Budapest
who initiated the {\opp} as a student project.

My fellow student \'{A}kos Kun started to program the first NED parser
in 1992-93, but it was abandoned after a few months.
The first version of nedc was finally developed in summer 1995,
by three exchange students from TU Delft: Jan Heijmans, Alex Paalvast
and Robert van der Leij. nedc was first called JAR after their initials
until it got renamed to nedc. nedc was further developed and refactored
several times until it finally retired and got replaced by nedtool in {\opp} 3.0.
The second group of Delft exchange students (Maurits Andr\'{e},
George van Montfort, Gerard van de Weerd) arrived in fall 1995.
They performed some testing of the simulation library, and
wrote some example simulations, for example the original version
of Token Ring, and simulation of the NIM game which survived until {\opp} 3.0.
These student exchanges were organized by Dr. Leon Rothkranz
at TU Delft, and Gy\"{o}rgy Pongor at TU Budapest.

The diploma thesis of Zolt\'{a}n Vass (spring 1996) was to prepare
{\opp} for parallel execution over PVM to {\opp}. This code has been
replaced with the new Parallel Simulation Architecture in {\opp} 3.0.
G\'{a}bor Lencse (lencse@hit.bme.hu) was also interested in parallel
simulation, namely a method called Statistical Synchronization (SSM).
He implemented the FDDI model (practically unchanged until now), and added
some extensions into NED for SSM. These extensions have been removed
since then ({\opp} 3.0 does parallel execution on different principles).

The $P^{2}$ algorithm and the original implementation of the k-split algorithm
was programmed in fall 1996 by Babak Fakhamzadeh from TU Delft.
k-split was later reimplemented by Andr\'{a}s.

Several bugfixes and valuable suggestions for improvements came
from the user community of {\opp}. It would be impossible to
mention everyone here, and the list is constantly growing --
instead, the README and ChangeLog files contain acknowledgements.

Between summer 2001 and fall 2004, the {\opp} CVS was hosted
at the University of Karlsruhe. Credit for setting
up and maintaining the CVS server goes to Ulrich Kaage.
Ulrich can also be credited with converting the User Manual from
Microsoft Word format to LaTeX, which was a huge undertaking
and great help.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
