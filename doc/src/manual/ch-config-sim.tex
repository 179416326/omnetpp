\chapter{Configuring Simulations}
\label{cha:config-sim}

\section{Configuring simulations}

Configuration and input data for the simulation are in
a configuration file usually called \ffilename{omnetpp.ini}.

The following sections explain \ffilename{omnetpp.ini}.

\section{The configuration file: omnetpp.ini}

\subsection{An example}

For a start, let us see a simple \ffilename{omnetpp.ini} file which
can be used to run the Fifo example simulation.

\begin{inifile}
[General]
network = FifoNet
sim-time-limit = 100h
cpu-time-limit = 300s
#debug-on-errors = true
#record-eventlog = true

[Config Fifo1]
description = "low job arrival rate"
**.gen.sendIaTime = exponential(0.2s)
**.gen.msgLength = 100b
**.fifo.bitsPerSec = 1000bps

[Config Fifo2]
description = "high job arrival rate"
**.gen.sendIaTime = exponential(0.01s)
**.gen.msgLength = 10b
**.fifo.bitsPerSec = 1000bps
\end{inifile}

The file is grouped into \textit{sections} named \ttt{[General]}, \ttt{[Config Fifo1]}
and \ttt{[Config Fifo2]}, each one containing several \textit{entries}.

Lines that start with ``\#'' are comments.


\subsection{File syntax}

The ini file is a text file consisting of entries grouped into different sections.
The order of the sections doesn't matter.

Lines that start with "\#" are comments, and will be ignored during processing.

Long lines can be broken up using the backslash notation: if the last character
of a line is "\textbackslash", it will be merged with the next line.

There is no limit on the file size or the maximum line length.

Example:

\begin{inifile}
[General]
# this is a comment
**.foo = "this is a single value \
for the foo parameter"
\end{inifile}

\subsection{File inclusion}

{\opp} supports including an ini file in another\index{ini file!file inclusion},
via the \ttt{include} keyword. This feature allows you to partition large ini
files into logical units, fixed and varying part etc.

An example:

\begin{inifile}
# omnetpp.ini
...
include parameters.ini
include per-run-pars.ini
...
\end{inifile}

You can also include files from other directories. If the included ini file
further includes others, their path names will be understood as relative
to the location of the file which contains the reference,
rather than relative to the current working directory of the simulation.

This rule also applies to other file names occurring in ini files
(such as the \ttt{load-libs=}, \ttt{output-vector-file=}, \ttt{output-scalar-file=}
etc. options, and \ttt{xmldoc()} module parameter values.)


\section{Sections}
\label{sec:ch-config-sim:general-section}


\subsection{The [General] section}

The most commonly used options of the \texttt{[General]} section are the
following.

\begin{itemize}
  \item{The \fpar{network} option selects the model to be set up and run.}
  \item{The length of the simulation can be set with the
    \fpar{sim-time-limit} and the \fpar{cpu-time-limit} options (the
    usual time units such as ms, s, m, h, etc. can be used).}
\end{itemize}

Note that the NED files loaded by the simulation may contain several
networks, and any of them may be specified in the \ttt{network=}
option.


\subsection{Named configurations}

Named configurations are sections of the form \ttt{[Config <configname>]}, where
\textit{<configname>} is by convention a camel-case string that starts with a capital letter:
\ttt{Config1}, \ttt{WirelessPing}, \ttt{OverloadedFifo}, etc. For example,
\ffilename{omnetpp.ini} for an Aloha simulation might have the following skeleton:

\begin{inifile}
[General]
...
[Config PureAloha]
...
[Config SlottedAloha1]
...
[Config SlottedAloha2]
...
\end{inifile}

Some configuration keys (such as user interface selection) are only
accepted in the \ttt{[General]} section, but most of them can go into Config
sections as well.

When you run a simulation, you need to select one of the configurations
to be activated. In Cmdenv, this is done with the \ttt{-c} command-line option:

\begin{commandline}
$ aloha -c PureAloha
\end{commandline}

The simulation will then use the contents of the \ttt{[Config PureAloha]}
section to set up the simulation. (Tkenv, of course, lets you select
the configuration from a dialog.)


\subsection{Section inheritance}

Actually, when you activate the PureAloha configuration, the contents of
the \ttt{[General]} section will also be taken into account: if some
configuration key or parameter value is not found in \ttt{[Config PureAloha]},
then the search will continue in the \ttt{[General]} section. In
other words, lookups in \ttt{[Config PureAloha]} will fall back to \ttt{[General]}.
The \ttt{[General]} section itself is optional; when it is absent, it is
treated like an empty \ttt{[General]} section.

All named configurations fall back to \ttt{[General]} by default. However, for
each configuration it is possible to specify a fall-back section
explicitly, using the \ttt{extends=} key. Consider the following ini file
skeleton:

\begin{inifile}
[General]
...
[Config SlottedAlohaBase]
...
[Config SlottedAloha1]
extends = SlottedAlohaBase
...
[Config SlottedAloha2]
extends = SlottedAlohaBase
...
[Config SlottedAloha2a]
extends = SlottedAloha2
...
[Config SlottedAloha2b]
extends = SlottedAloha2
...
\end{inifile}


If you activate the \ttt{SlottedAloha2b} configuration, lookups will consider
sections in the following order (this is also called the
\textit{section fallback chain}): \ttt{SlottedAloha2b},
\ttt{SlottedAloha2}, \ttt{SlottedAlohaBase}, \ttt{General}.

The effect is the same as if the contents of the sections
SlottedAloha2b, SlottedAloha2, SlottedAlohaBase and General were copied
together into one section, one after another, \ttt{[Config SlottedAloha2b]}
being at the top, and \ttt{[General]} at the bottom. Lookups always start at
the top, and stop at the first matching entry.

The concept is similar to inheritance in object-oriented languages,
and benefits are similar too: you can factor out the common parts of
several configurations into a "base"
configuration, and the other way round, you can reuse existing
configurations (as opposed to copying them) by using them as a base. In
practice you will often have "abstract"
configurations too (in the C++/Java sense), which assign only a subset
of parameters and leave the others open, to be assigned in derived
configurations.

If you are experimenting a lot with different parameter settings of a
simulation model, these techniques will make it a lot easier to manage
ini files.

\section{Assigning module parameters}
\label{sec:ch-config-sim:parameter-settings}

Simulations get input via module parameters, which can be assigned a
value in NED files or in \ffilename{omnetpp.ini} -- in this order. Since parameters
assigned in NED files cannot be overridden in omnetpp.ini, one can
think about them as being ``hardcoded''. In contrast, it is easier
and more flexible to maintain module parameter settings in omnetpp.ini.

In omnetpp.ini, module parameters are referred to by their full paths
or hierarchical names. This name consists of the dot-separated list of
the module names (from the top-level module down to the module containing
the parameter), plus the parameter name
(see section \ref{sec:sim-lib:fullname-and-fullpath}).

An example \ffilename{omnetpp.ini} which sets the \ttt{numHosts} parameter of
the toplevel module and the \ttt{transactionsPerSecond} parameter of the
\ttt{server} module:

\begin{inifile}
[General]
net.numHosts = 15
net.server.transactionsPerSecond = 100
\end{inifile}


\subsection{Using wildcard patterns}
\label{sec:ch-config-sim:wildcards}

Models can have a large number of parameters to be configured, and it would
be tedious to set them one-by-one in \ffilename{omnetpp.ini}. {\opp} supports
\textit{wildcards patterns} which allow for setting several model parameters
at once.

The pattern syntax is a variation on the usual \textit{glob}-style
patterns. The most apparent differences to the \textit{glob} rules are the
distinction between \ttt{*} and \ttt{**}, and that character ranges should
be written with curly braces instead of square brackets (that is,
\textit{any-letter} is expressed as \ttt{\{a-zA-Z\}} and not as
\ttt{[a-zA-Z]}, because square brackets are reserved for the notation of
module vector indices).

Pattern syntax:

\begin{itemize}
  \item \ttt{?} : matches any character except dot (.)
  \item \ttt{*} : matches zero or more characters except dot (.)
  \item \ttt{**} : matches zero or more character (any character)
  \item \ttt{\{a-f\}} : \textit{set}: matches a character in the range a-f
  \item \ttt{\{{\textasciicircum}a-f\}}: \textit{negated set}: matches a character
    NOT in the range a-f
  \item \ttt{\{38..150\}} : \textit{numeric range}: any number (i.e. sequence of digits)
    in the range 38..150  (e.g. \ttt{99})
  \item \ttt{[38..150]} : \textit{index range}: any number in square brackets in the
    range 38..150 (e.g. \ttt{[99]})
  \item backslash ({\textbackslash}) : takes away the special meaning of the
    subsequent character
\end{itemize}

\subsubsection{Precedence}

If you use wildcards, the order of entries is important: if a parameter
name matches several wildcards-patterns, the \textit{first} matching occurrence
is used. This means that you need to list specific settings first, and
more general ones later. Catch-all settings should come last.

An example ini file:

\begin{inifile}
[General]
*.host[0].waitTime = 5ms   # specifics come first
*.host[3].waitTime = 6ms
*.host[*].waitTime = 10ms  # catch-all comes last
\end{inifile}


\subsubsection{Asterisk vs double asterisk}

The \ttt{*} wildcard is for matching a single module or parameter name in the
path name, while \ttt{**} can be used to match several components in the path.
For example, \ttt{**.queue*.bufSize} matches the \ttt{bufSize} parameter of any module
whose name begins with \ttt{queue} in the model, while \ttt{*.queue*.bufSize}
or \ttt{net.queue*.bufSize} selects only queues immediately on network level.
Also note that \ttt{**.queue**.bufSize} would match \ttt{net.queue1.foo.bar.bufSize}
as well!

\subsubsection{Sets, negated sets}

Sets and negated sets can contain several character ranges and also
enumeration of characters. For example, \ttt{\{\_a-zA-Z0-9\}} matches any letter
or digit, plus the underscore; \ttt{\{xyzc-f\}} matches any of the characters
x, y, z, c, d, e, f.
To include '-' in the set, put it at a position where it cannot be
interpreted as character range, for example: \ttt{\{a-z-\}} or \ttt{\{-a-z\}}.
If you want to include '\}' in the set, it must be the first
character: \ttt{\{\}a-z\}}, or as a negated set: \ttt{\{{\textasciicircum}\}a-z\}}.
A backslash is always taken as a literal backslash (and not as an escape character)
within set definitions.


\subsubsection{Numeric ranges and index ranges}

Only nonnegative integers can be matched.  The start or the end of the range
(or both) can be omitted: \ttt{\{10..\}}, \ttt{\{..99\}} or \ttt{\{..\}}
are valid numeric ranges (the last one matches any number).
The specification must use exactly two dots.
Caveat: \ttt{*\{17..19\}} will match \ttt{a17}, \ttt{117} and \ttt{963217} as well,
because the \ttt{*} can also match digits!

An example for numeric ranges:

\begin{inifile}
[General]
*.*.queue[3..5].bufSize = 10
*.*.queue[12..].bufSize = 18
*.*.queue[*].bufSize = 6  # this will only affect queues 0,1,2 and 6..11
\end{inifile}


\subsection{Using the default values}

It is also possible to utilize the default values specified in the NED files.
The \textit{<parameter-fullpath>}\ttt{=default} setting assigns
the default value to a parameter if it has one.

The \textit{<parameter-fullpath>}\ttt{=ask} setting will try to get the parameter
value interactively from the user.

If a parameter was not set but has a default value, that value will be
assigned. This is like having a \ttt{**=default} line at the
bottom of the \ttt{[General]} section.

If a parameter was not set and has no default value, that will either
cause an error or will be interactively prompted for, depending
on the particular user interface.

\begin{note}
In Cmdenv you must explicitly enable the interactive mode with the
\ttt{-{}-cmdenv-interactive=true} option otherwise you will get an error
when running the simulation.
\end{note}

More precisely, parameter resolution takes place as follows:

\begin{enumerate}
\item If the parameter is assigned in NED, it cannot be overridden in the
    configuration. The value is applied and the process finishes.
\item If the first match is a value line (matches
    \textit{<parameter-fullpath>}\ttt{=}\textit{<value>}), the value is
    applied and the process finishes.
\item If the first match is a \textit{<parameter-fullpath>}\ttt{=default} line,
    the default value is applied and the process finishes.
\item If the first match is a \textit{<parameter-fullpath>}\ttt{=ask} line,
    the parameter will be asked from the user interactively (UI dependent).
\item If there was no match and the parameter has a default value, it is applied
    and the process finishes.
\item Otherwise the parameter is declared unassigned, and handled accordingly
    by the user interface. It may be reported as an error, or may be
    asked from the user interactively.
\end{enumerate}


\section{Parameter studies}

\subsection{Basic use}


It is quite common in simulation studies that the simulation model is
run several times with different parameter settings, and the results
are analyzed in relation to the input parameters. {\opp} 3.x had no
direct support for batch runs, and users had to resort to writing shell
(or Python, Ruby, etc.) scripts that iterated over the required
parameter space, and generated a (partial) ini file and run the
simulation program in each iteration.

{\opp} 4.0 largely automates this process, and eliminates the need for
writing batch execution scripts. It is the ini file where the user can
specify iterations over various parameter settings.
Here's an example:

\begin{inifile}
[Config AlohaStudy]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential(${0.2, 0.4, 0.6}s)
\end{inifile}


This parameter study expands to 8*3 = 24 simulation runs, where the number of
hosts iterates over the numbers 1, 2, 5, 10, 20, 30, 40, 50, and for
each host count three simulation runs will be done, with the generation
interval being exponential(0.2), exponential(0.4), and
exponential(0.6).

How does it get run? First of all, Cmdenv with the '-x' option will tell you how many
simulation runs a given section expands to. (You'll of course use Cmdenv for batch runs,
not Tkenv.)

\begin{commandline}
$ aloha -u Cmdenv -x AlohaStudy

`\opp` Discrete Event Simulation
...
Config: AlohaStudy
Number of runs: 24
\end{commandline}


If you add the '-g' option, the program will also print out the
values of the iteration variables for each run. (Use '-G' for even more info)
Note that the parameter study actually maps to nested
loops, with the last "\$\{..\}" becoming
the innermost loop. The iteration variables are just named \ttt{\$0} and \ttt{\$1}
-- we'll see that it is possible to give
meaningful names to them. Please ignore the
\ttt{\$repetition=0} part in the printout
for now.


\begin{commandline}
$ aloha -u Cmdenv -x AlohaStudy -g
`\opp` Discrete Event Simulation
...
Config: AlohaStudy
Number of runs: 24
Run 0: $0=1, $1=0.2, $repetition=0
Run 1: $0=1, $1=0.4, $repetition=0
Run 2: $0=1, $1=0.6, $repetition=0
Run 3: $0=2, $1=0.2, $repetition=0
Run 4: $0=2, $1=0.4, $repetition=0
Run 5: $0=2, $1=0.6, $repetition=0
Run 6: $0=5, $1=0.2, $repetition=0
Run 7: $0=5, $1=0.4, $repetition=0
...
Run 19: $0=40, $1=0.4, $repetition=0
Run 20: $0=40, $1=0.6, $repetition=0
Run 21: $0=50, $1=0.2, $repetition=0
Run 22: $0=50, $1=0.4, $repetition=0
Run 23: $0=50, $1=0.6, $repetition=0
\end{commandline}


Any of these runs can be executed by passing the '-r
<runnumber>' option to Cmdenv.
So, the task is now to run the simulation program 24 times, with
'-r' running from 0 through 23:

\begin{commandline}
$ aloha -u Cmdenv -c AlohaStudy -r 0
$ aloha -u Cmdenv -c AlohaStudy -r 1
$ aloha -u Cmdenv -c AlohaStudy -r 2
...
$ aloha -u Cmdenv -c AlohaStudy -r 23
\end{commandline}


This batch can be executed either from the {\opp} IDE (where you are
prompted to pick an executable and an ini file, choose the configuration
from a list, and just click Run), or using a little command-line
batch execution tool (\fprog{opp\_runall}) supplied with {\opp}.

Actually, it is also possible to get Cmdenv execute all runs in one go,
by simply omitting the '-r' option.


\begin{commandline}
$ aloha -u Cmdenv -c AlohaStudy

`\opp` Discrete Event Simulation
Preparing for running configuration AlohaStudy, run #0...
...
Preparing for running configuration AlohaStudy, run #1...
...
...
Preparing for running configuration AlohaStudy, run #23...
\end{commandline}


However, this approach is not recommended, because it is more
susceptible to C++ programming errors in the model. (For example, if
any of the runs crashes, the whole batch is terminated -- which may
not be what the user wants).

Let us get back to the ini file. We had:

\begin{inifile}
[Config AlohaStudy]
*.numHosts = ${1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${0.2, 0.4, 0.6}s )
\end{inifile}


The \ttt{\$\{...\}} syntax specifies an iteration. It is sort of a macro: at
each run, the whole \ttt{\$\{...\}} string gets textually replaced with the
current iteration value. The values to iterate over do not need to be
numbers (unless you want to use the \textit{"a..b"} or
\textit{"a..b step c"} syntax), and the
substitution takes place even inside string constants. So, the
following examples are all valid (note that textual substitution is
used):

\begin{Verbatim}[commandchars=\\\{\}]
*.param = 1 + \$\{1e-6, 1/3, sin(0.5)\}
    ==> *.param = 1 + 1e-6
        *.param = 1 + 1/3
        *.param = 1 + sin(0.5)
*.greeting = "We will simulate \$\{1,2,5\} host(s)."
    ==> *.greeting = "We will simulate 1 host(s)."
        *.greeting = "We will simulate 2 host(s)."
        *.greeting = "We will simulate 5 host(s)."
\end{Verbatim}

To write a literal \ttt{\$\{..\}} inside a string constant, quote
the left brace with a backslash: \ttt{\${\textbackslash}\{..\}}.


\subsection{Named iteration variables}

You can assign names to iteration variables, which has the advantage
that you'll see meaningful names instead of \ttt{\$0} and
\ttt{\$1} in the Cmdenv output, and also lets you refer to the variables at
more than one place in the ini file. The syntax is
\ttt{\$\{<varname>=<iteration>\}}, and variables can be referred to simply as
\ttt{\$\{<varname>\}}:

\begin{inifile}
[Config Aloha]
*.numHosts = ${N=1, 2, 5, 10..50 step 10}
**.host[*].generationInterval = exponential( ${mean=0.2, 0.4, 0.6}s )
**.greeting = "There are ${N} hosts"
\end{inifile}

The scope of the variable name is the section that defines it, plus
sections based on that section (via \ttt{extends=}).

There are also a number of predefined variables: \ttt{\$\{configname\}} and
\ttt{\$\{runnumber\}} with the obvious meanings; \ttt{\$\{network\}} is the name of
the network that is simulated; \ttt{\$\{processid\}} and \ttt{\$\{datetime\}}
expand to the OS process id of the simulation and the time it was
started; and there are some more: \ttt{\$\{runid\},} \ttt{\$\{iterationvars\}} and
\ttt{\$\{repetition\}.}

\ttt{\$\{runid\}} holds the Run ID. When a simulation is run, it gets assigned
a Run ID, which uniquely identifies that instance of running the
simulation: if you run the same thing again, it will get a different
Run ID. Run ID is a concatenation of several variables like
\ttt{\$\{configname\},} \ttt{\$\{runnumber\},} \ttt{\$\{datetime\}} and \ttt{\$\{processid\}.}
This yields an identifier that is unique
"enough" for all practical purposes, yet it
is meaningful for humans. The Run ID is recorded into result files
written during the simulation, and can be used to match vectors and
scalars written by the same simulation run.

In cases when not all combinations of the iteration variables make sense
or need to be simulated, it is possible to specify an additional
constraint expression. This expression is interpreted as a conditional
(an "if" statement) within the innermost
loop, and it must evaluate to \ttt{true} for
the variable combination to generate a run. The expression should be
given with the \ttt{constraint=} configuration key. An example:

\begin{inifile}
*.numNodes = ${n=10..100 step 10}
**.numNeighbors = ${m=2..10 step 2}
constraint = $m <= sqrt($n)
\end{inifile}

The expression syntax supports most C language operators (including
boolean, conditional and binary shift operations) and most
\textit{<math.h>} functions; data types are boolean,
double and string. The expression must evaluate to a boolean.

\begin{note}
    It is not supported to refer to other iteration variables
    in the definition of an iteration variable (i.e. you cannot write
    things like \ttt{\$\{j=\$i..10\}}), although it might get implemented in
    future {\opp} releases.
\end{note}

\subsection{Repeating runs with different seeds}

It is directly supported to perform several runs with the same
parameters but different random number seeds. There are two
configuration keys related to this: \ttt{repeat=} and \ttt{seed-set=}. The first
one simple specifies how many times a run needs to be repeated. For
example,

\begin{inifile}
repeat = 10
\end{inifile}

causes every combination of iteration variables to be repeated 10 times,
and the \ttt{\$\{repetition\}} predefined variable holds the loop counter.
Indeed, \ttt{repeat=10} is equivalent to adding \ttt{\$\{repetition=0..9\}}
to the ini file. The \ttt{\$\{repetition\}} loop always becomes the innermost loop.

The \ttt{seed-set=} configuration key affects seed selection. Every
simulation uses one or more random number generators (as configured by
the \ttt{num-rngs=} key), for which the simulation kernel can automatically
generate seeds. The first simulation run may use one set of seeds (seed
set 0), the second run may use a second set (seed set 1), and so on.
Each set contains as many seeds as there are RNGs configured. All
automatic seeds generate random number sequences that are far apart in
the RNG's cycle, so they will never overlap during
simulations.

\begin{note}
Mersenne Twister, the default RNG of {\opp} has a cycle length of
$2^{19937}$, which is more than enough for any conceivable purpose.
\end{note}

The \ttt{seed-set=} key tells the simulation kernel which seed set to use.
It can be set to a concrete number (such as \ttt{seed-set=0}), but it
usually does not make sense as it would cause every simulation to run
with exactly the same seeds. It is more practical to set it to either
\ttt{\$\{runnumber\}} or to \ttt{\$\{repetition\}}. The default setting is
\ttt{\$\{runnumber\}}:

\begin{inifile}
seed-set = ${runnumber}   # this is the default
\end{inifile}

This makes every simulation run to execute with a unique seed set. The
second option is:

\begin{inifile}
seed-set = ${repetition}
\end{inifile}

where all \ttt{\$repetition=0} runs will use the same seeds (seed set 0), all
\ttt{\$repetition=1} runs use another seed set, \ttt{\$repetition=2} a third seed
set, etc.

To perform runs with manually selected seed sets, you can just define an
iteration for the \ttt{seed-set=} key:

\begin{inifile}
seed-set = ${5,6,8..11}
\end{inifile}

In this case, the \ttt{repeat=} key should be left out, as \ttt{seed-set=}
already defines an iteration and there's no need for an extra loop.

It is of course also possible to manually specify individual seeds for
simulations. This is rarely necessary, but we can use it here to
demonstrate another feature, parallel iterators:

\begin{inifile}
repeat = 4
seed-1-mt = ${53542, 45732, 47853, 33434 ! repetition}
seed-2-mt = ${75335, 35463, 24674, 56673 ! repetition}
seed-3-mt = ${34542, 67563, 96433, 23567 ! repetition}
\end{inifile}

The meaning of the above is this: in the first repetition, the first
column of seeds is chosen, for the second repetition, the second
column, etc. The "!" syntax chooses the
\textit{kth} value from the iteration, where \textit{k} is the position
(iteration count) of the iteration variable after the
"!". Thus, the above example is equivalent
to the following:

\begin{inifile}
# no repeat= line!
seed-1-mt = ${seed1 = 53542, 45732, 47853, 33434}
seed-2-mt = ${        75335, 35463, 24674, 56673 ! seed1}
seed-3-mt = ${        34542, 67563, 96433, 23567 ! seed1}
\end{inifile}

That is, the iterators of \ttt{seed-2-mt} and \ttt{seed-3-mt} are advanced
in lockstep with the \ttt{seed1} iteration.



\subsection{Experiment-Measurement-Replication}

We have introduced three concepts that are useful for organizing
simulation results generated by batch executions or several batches of
executions.

During a simulation study, a person prepares several
\textit{experiments}. The purpose of an experiment is to find out the
answer to questions like \textit{"how does the number of
nodes affect response times in the network?"} For an
experiment, several \textit{measurements} are performed on the
simulation model, and each measurement runs the simulation model with a
different parameter settings. To eliminate the bias introduced by the
particular random number stream used for the simulation, several
\textit{replications} of every measurement are run with different
random number seeds, and the results are averaged.

{\opp} result analysis tools can take advantage of the \textit{experiment},
\textit{measurement} and \textit{replication} labels recorded into result
files, and display simulation runs and recorded results accordingly on
the user interface.

These labels can be explicitly specified in the ini file using the
\ttt{experiment=}, \ttt{measurement=} and \ttt{replication=} config keys.
If they are missing, the default is the following:

\begin{inifile}
experiment = "${configname}"
measurement = "${iterationvars}"
replication = "#${repetition},seed-set=<seedset>"
\end{inifile}

That is, the default experiment label is the configuration name; the
measurement label is concatenated from the iteration variables; and the
replication label contains the repeat loop variable and seed-set.
Thus, for our first example the \textit{experiment-measurement-replication}
tree would look like this:

\begin{Verbatim}[commandchars=\\\{\}]
"PureAloha"\textrm{\textit{--experiment}}
  \$N=1,\$mean=0.2\textrm{\textit{ -- measurement}}
    \#0, seed-set=0\textrm{\textit{ -- replication}}
    \#1, seed-set=1
    \#2, seed-set=2
    \#3, seed-set=3
    \#4, seed-set=4
  \$N=1,\$mean=0.4
    \#0, seed-set=5
    \#1, seed-set=6
    ...
    \#4, seed-set=9
  \$N=1,\$mean=0.6
    \#0, seed-set=10
    \#1, seed-set=11
    ...
    \#4, seed-set=14
  \$N=2,\$mean=0.2
    ...
  \$N=2,\$mean=0.4
    ...
    ...
\end{Verbatim}

The \textit{experiment-measurement-replication} labels should be enough to
reproduce the same simulation results, given of course that the ini
files and the model (NED files and C++ code) haven't changed.

Every instance of running the simulation gets a unique run ID. We can
illustrate this by listing the corresponding run IDs under each
repetition in the tree. For example:

\begin{Verbatim}[commandchars=\\\{\}]
"PureAloha"
  \$N=1,\$mean=0.2
    \#0, seed-set=0
      \textit{PureAloha-0-20070704-11:38:21-3241}
      \textit{PureAloha-0-20070704-11:53:47-3884}
      \textit{PureAloha-0-20070704-16:50:44-4612}
    \#1, seed-set=1
      \textit{PureAloha-1-20070704-16:50:55-4613}
    \#2, seed-set=2
      \textit{PureAloha-2-20070704-11:55:23-3892}
      \textit{PureAloha-2-20070704-16:51:17-4615}
      ...
\end{Verbatim}

The tree shows that ("PureAloha", "\$N=1,\$mean=0.2", "\#0, seed-set=0")
was run three times. The results produced
by these three executions should be identical, unless, for example,
some parameter was modified in the ini file, or a bug got fixed in the
C++ code.

We believe that the default way of generating
\textit{experiment-measurement-replication} labels is useful and
sufficient for the majority of simulation studies. However, you can
customize it if needed. For example, here is a way to join two
configurations into one experiment:

\begin{inifile}
[Config PureAloha_Part1]
experiment = "PureAloha"
...
[Config PureAloha_Part2]
experiment = "PureAloha"
...
\end{inifile}

Measurement and replication labels can be customized in a similar way,
making use of named iteration variables, \ttt{\$\{repetition\}},
\ttt{\$\{runnumber\}} and other predefined variables. One possible benefit is
to customize the generated measurement and replication labels. For
example:

\begin{inifile}
[Config PureAloha_Part1]
measurement = "${N} hosts, exponential(${mean}) packet generation interval"
\end{inifile}

One should be careful with the above technique though, because if some
iteration variables are left out of the measurement labels, runs with
all values of those variables will be grouped together to the same
replications.


\section{Configuring the random number generators}
\label{sec:ch-config-sim:rng-config}

The random number architecture of {\opp} was already outlined
in section \ref{cha:sim-lib:generating-random-numbers}. Here
we'll cover the configuration of RNGs in \ffilename{omnetpp.ini}.

\subsection{Number of RNGs}

The \ttt{num-rngs=} configuration option sets the number of
random number generator instances (i.e. random number streams)
available for the simulation model (see \ref{cha:sim-lib:generating-random-numbers}).
Referencing an RNG number greater or equal to this number
(from a simple module or NED file) will cause a runtime error.


\subsection{RNG choice}

The \ttt{rng-class=} configuration option sets the random number
generator class to be used. It defaults to \ttt{"cMersenneTwister"},
the Mersenne Twister RNG. Other available classes are \ttt{"cLCG32"}
(the "legacy" RNG of {\opp} 2.3 and earlier versions, with a cycle length
of $2^{31}-2$), and \ttt{"cAkaroaRNG"} (Akaroa's random number generator,
see section \ref{sec:ch-run-sim:akaroa}).

\subsection{RNG mapping}

The RNG numbers used in simple modules may be arbitrarily mapped to the
actual random number streams (actual RNG instances) from \ffilename{omnetpp.ini}.
The mapping allows for great flexibility in RNG usage and random number
streams configuration -- even for simulation models which were not
written with RNG awareness.

RNG mapping may be specified in \ffilename{omnetpp.ini}. The syntax of
configuration entries is the following.

\begin{inifile}
[General]
<modulepath>.rng-N = M  # where N,M are numeric, M < num-rngs
\end{inifile}

This maps module-local RNG N to physical RNG M. The following
example maps all  \ttt{gen} module's default (N=0) RNG to physical RNG 1,
and all  \ttt{noisychannel} module's default (N=0) RNG to physical RNG 2.

\begin{inifile}
[General]
num-rngs = 3
**.gen[*].rng-0 = 1
**.noisychannel[*].rng-0 = 2
\end{inifile}

This mapping allows variance reduction techniques to be applied to
{\opp} models, without any model change or recompilation.


\subsection{Automatic seed selection}

Automatic seed selection gets used for an RNG if you don't explicitly
specify seeds in omnetpp.ini. Automatic and manual seed selection can
co-exist: for a particular simulation, some RNGs can be configured
manually, and some automatically.

The automatic seed selection mechanism uses two inputs: the \textit{run number}
 and the \textit{RNG number}. For the same run number and RNG number,
{\opp} always selects the same seed value for any simulation model.
If the run number or the RNG number is different, {\opp} does its best
to choose different seeds which are also sufficiently apart in the RNG's sequence
so that the generated sequences don't overlap.

The run number can be specified either in in omnetpp.ini (e.g. via the
\ttt{cmdenv-runs-to-execute=} entry) or on the command line:

\begin{commandline}
./mysim -r 1
./mysim -r 2
./mysim -r 3
\end{commandline}

For the \ttt{cMersenneTwister} random number generator, selecting seeds
so that the generated sequences don't overlap is easy,
due to the extremely long sequence of the RNG.
The RNG is initialized from the 32-bit seed value $seed = runNumber*numRngs + rngNumber$.
(This implies that simulation runs participating in the study should have
the same number of RNGs set).
    \footnote{While (to our knowledge) no one has proven that the seeds 0,1,2,...
    are well apart in the sequence, this is probably true, due to the extremely
    long sequence of MT. The author would however be interested in papers
    published about seed selection for MT.}

For the \ttt{cLCG32} random number generator, the situation is more difficult,
because the range of this RNG is rather short ($2^{31}-1$, about 2 billion).
For this RNG, {\opp} uses a table of 256 pre-generated seeds, equally spaced
in the RNG's sequence. Index into the table is calculated with the
$runNumber*numRngs + rngNumber$ formula. Care should be taken that
one doesn't exceed 256 with the index, or it will wrap and the
same seeds will be used again. It is best not to use the \ttt{cLCG32}
at all -- \ttt{cMersenneTwister} is superior in every respect.


\subsection{Manual seed configuration}

In some cases you may want manually configure seed values.
Reasons for doing that may be that you want to use variance reduction
techniques, or you may want to use the same seeds for several simulation
runs.

To manually set seeds for the Mersenne Twister RNG, use the \ttt{seed-}\textit{k}\ttt{-mt}
option, where \textit{k} is the RNG index. An example:

\begin{inifile}
[General]
num-rngs = 3
seed-0-mt = 12
seed-1-mt = 9
seed-2-mt = 7
\end{inifile}

\label{sec:ch-config-sim:seedtool}

For the now obsolete cLCG32 RNG, the name of the corresponding option is
\ttt{seed-}\textit{k}\ttt{-lcg32}, and {\opp} provides a standalone program
called \fprog{opp\_lcg32\_seedtool} to generate good seed values that
are sufficiently apart in the RNG's sequence.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

