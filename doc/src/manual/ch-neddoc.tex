\chapter{Documenting NED and Messages}
\label{cha:neddoc}

\section{Overview}

Like Javadoc and Doxygen... opp\_neddoc


\section{Writing the documentation}


\subsection{Documentation comments}

Documentation is embedded in comments. Javadoc and Doxygen use special
comments (those beginning with \texttt{/**}, \texttt{//} or similar marker)
to distinguish them from ``normal'' comments in the source files.
In {\opp}, the NED and message syntax is very compact and practically all
comments one would write in them are for documentation purposes,
so there's no need for special comment marker -- all comments will be
regarded as documentation comments. That is, all \texttt{//} comments
that are appropriately placed will be included in the documentation.

Example:

\begin{verbatim}
//
// An ad-hoc traffic generator to test the Ethernet models.
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
\end{verbatim}

You can also place comments above parameters and gates. This is useful
if they need long explanations. Example:

\begin{verbatim}
//
// Deletes packets and optionally keeps statistics.
//
simple Sink
    parameters:
        // You can turn statistics generation on and off. This is
        // a very long comment because it has to be described what
        // statistics are collected (or not).
        statistics: bool;
    gates:
        in: in;
endsimple
\end{verbatim}

If you want a comment line \textit{not} to appear in the documentation,
begin it with \texttt{//\#}. Those lines will be ignored by the
documentation generation, and can be used to comment out
unused NED code or to make ``private'' comments like \texttt{FIXME} or
\texttt{TBD}.

\begin{verbatim}
//
// An ad-hoc traffic generator to test the Ethernet models.
//# FIXME above description needs to be refined
//
simple Gen
    parameters:
        destAddress: string,  // destination MAC address
        protocolId: numeric,  // value for SSAP/DSAP in Ethernet frame
        //# burstiness: numeric;  -- not yet supported
        waitMean: numeric;    // mean for exponential interarrival times
    gates:
        out: out;             // to Ethernet LLC
endsimple
\end{verbatim}


\subsection{Text layout and formatting}

If you write longer descriptions, you'll need text formatting capabilities.
Text formatting works like in Javadoc or Doxygen -- you can break up the
text into paragraphs and create bulleted/numbered lists without
special commands, and use HTML for more fancy formatting.

Paragraphs are separated by empty lines, like in Latex. Lines beginning with `\ttt{-}'
will be turned into bulleted lists, and lines beginning with
`\ttt{-\#}' into numbered lists.

Example:

\begin{verbatim}
// Ethernet MAC layer. MAC performs transmission and reception of frames.
//
// Processing of frames received from higher layers:
// - sends out frame to the network
// - no encapsulation of frames -- this is done by higher layers.
// - can send PAUSE message if requested by higher layers (PAUSE protocol,
//   used in switches). PAUSE is not implemented yet.
//
// Supported frame types:
// -# IEEE 802.3
// -# Ethernet-II
//
\end{verbatim}

\subsection{Additional text formatting using HTML}

Common HTML tags are understood as formatting commands.
The most useful of these tags are: \ttt{<i>..</i>} (italic),
\ttt{<b>..</b>} (bold), \ttt{<tt>..</tt>} (typewriter font),
\ttt{<sub>..</sub>} (subscript), \ttt{<sup>..</sup>} (superscript),
\ttt{<br>} (line break), \ttt{<h3>} (heading),
\ttt{<pre>..</pre>} (preformatted text) and \ttt{<a href=..>..</a>} (link),
as well as a few other tags used for table creation (see below).
For example, \texttt{<i>Hello</i>} will be rendered as ``\textit{Hello}''
(using an italic font).

The complete list of HTML tags interpreted by \ttt{opp\_neddoc} are:
\texttt{<a>}, \texttt{<b>}, \texttt{<body>}, \texttt{<br>}, \texttt{<center>},
\texttt{<caption>}, \texttt{<code>}, \texttt{<dd>}, \texttt{<dfn>}, \texttt{<dl>},
\texttt{<dt>}, \texttt{<em>}, \texttt{<form>}, \texttt{<font>}, \texttt{<hr>},
\texttt{<h1>}, \texttt{<h2>}, \texttt{<h3>}, \texttt{<i>}, \texttt{<input>}, \texttt{<img>},
\texttt{<li>}, \texttt{<meta>}, \texttt{<multicol>}, \texttt{<ol>}, \texttt{<p>}, \texttt{<small>},
\texttt{<span>}, \texttt{<strong>},
\texttt{<sub>}, \texttt{<sup>}, \texttt{<table>}, \texttt{<td>}, \texttt{<th>}, \texttt{<tr>},
\texttt{<tt>}, \texttt{<kbd>}, \texttt{<ul>}, \texttt{<var>}.

Any tags not in the above list will not be interpreted as formatting commands
but will be printed verbatim -- for example, \texttt{<what>bar</what>}
will be rendered literally as ``<what>bar</what>'' (unlike HTML where
unknown tags are simply ignored, i.e. HTML would display ``bar'').

If you insert links to external pages (web sites), its useful to add
the \ttt{target="\_blank"} attribute to ensure pages come up in a new
browser window and not just in the current frame which looks awkward.
(Alternatively, you can use the \ttt{target="\_top"} attribute
which replaces all frames in the current browser).

Examples:

\begin{verbatim}
//
// For more info on Ethernet and other LAN standards, see the
// <a href="http://www.ieee802.org/" target="_blank">IEEE 802
// Committee's site</a>.
//
\end{verbatim}

You can also use the \ttt{<a href=..>} tag to create links within the page:

\begin{verbatim}
//
// See the <a href="#resources">resources</a> in this page.
// ...
// <a name="resources"><b>Resources</b></a>
// ...
//
\end{verbatim}

You can use the \texttt{<pre>..</pre>} HTML tag to insert souce code examples
into the documentation. Line breaks and indentation will be preserved,
but HTML tags continue to be interpreted (or you can turn them off
with \texttt{<nohtml>}, see later).

Example:

\begin{verbatim}
// <pre>
// // my preferred way of indentation in C/C++ is this:
// <b>for</b> (<b>int</b> i=0; i<10; i++)
// {
//     printf(<i>"%d\n"</i>, i);
// }
// </pre>
\end{verbatim}

will be rendered as

\begin{Verbatim}[commandchars=\\\{\}]
// my preferred way of indentation in C/C++ is this:
\textbf{for} (\textbf{int} i=0; i<10; i++)
\{
    printf(\textit{"%d{\textbackslash}n"}, i);
\}
\end{Verbatim}

HTML is also the way to create tables. The example below

\begin{verbatim}
//
// <table border="1">
//   <tr>  <th>#</th> <th>number</th> </tr>
//   <tr>  <td>1</td> <td>one</td>    </tr>
//   <tr>  <td>2</td> <td>two</td>    </tr>
//   <tr>  <td>3</td> <td>three</td>  </tr>
// </table>
//
\end{verbatim}

will be rendered approximately as:

\begin{longtable}{|l|l|}
\hline
\tabheadcol
\tbf{\#} & \tbf{number} \\\hline
1 & one \\\hline
2 & two \\\hline
3 & three \\\hline
\end{longtable}


\subsection{Turning off HTML}

You may temporarily turn off interpreting \ttt{<i>}, \ttt{<b>}, etc.
as HTML formatting commands. This is useful if you have to put literal
\ttt{<i>}, \ttt{<b>} text in the documentation. To turn off interpreting
HTML, surround the text with \ttt{<nohtml>}...\ttt{</nohtml>} tags.
For example,

\begin{verbatim}
// Use the <nohtml><i></nohtml> tag (like <tt><nohtml><i>this</i></nohtml><tt>)
// to write in <i>italic</i>.
\end{verbatim}

will be rendered as ``Use the <i> tag (like \texttt{<i>this</i>}) to write
in \textit{italic}.''



\subsection{Where to put comments}

You have to put the comments where nedtool will find them.
This is a) above the documented item, or b) after the
documented item, on the same line.

If you put it above, make sure there's no blank line left
between the comment and the documented item. Blank lines
detach the comment from the documented item.

Example:
\begin{verbatim}
// This is wrong! Because of the blank line, this comment is not
// associated with the following simple module!

simple Gen
    parameters:
    ...
endsimple
\end{verbatim}

Do not try to comment groups of parameters together. The result
will be awkward.


\subsection{Customizing the title page}

The title page is the one that appears in the main frame after 
opening the documentation in the browser. By default it contains
a boilerplate text with the generic title \textit{``OMNeT++ Model Documentation''}.
You probably want to customize that, and at least change the title
to the name of the documented simulation model.
 
You can supply your own version of the title page adding a \ttt{@titlepage}
directive to a file-level comment (a comment that appears at the top of
a NED file, but is separated from the first \ttt{import}, \ttt{channel}, 
\ttt{module}, etc. definition by at least one blank line).
In theory you can place your title page definition into 
any NED or MSG file, but it is probably a good idea to create
a separate \ttt{index.ned} file for it.   

The lines you write after the \ttt{@titlepage} line up to the next 
\ttt{@page} line (see later) or the end of the comment will be used 
as the title page.
You probably want to begin with a title because the documentation
tool doesn't add one (it lets you have full control over the
page contents). You can use the \ttt{<h1>..</h1>} HTML tag 
to define a title. 

Example:

\begin{verbatim}
//
// @titlepage
// <h1>Ethernet Model Documentation</h1>
//
// This documents the Ethernet model created by David Wu and refined by Andras
// Varga at CTIE, Monash University, Melbourne, Australia.
//
\end{verbatim}


\subsection{Adding extra pages}

You can add new pages to the documentation in a similar way as customizing
the title page. The directive to be used is \ttt{@page}, and it can 
appear in any file-level comment (see above).

The syntax of the \ttt{@page} directive is the following:

\begin{verbatim}
// @page filename.html, Title of the Page
\end{verbatim}
  
Please choose a file name that doesn't collide with the files generated
by the documentation tool (such as \ttt{index.html}). 
The page title you supply will appear on the top of the page as well as
in the page index.

The lines after the \ttt{@page} line up to the next \ttt{@page} line
or the end of the comment will be used as the page body.
You don't need to add a title because the documentation tool
automatically adds one.

Example:
\begin{verbatim}
//
// @page structure.html, Directory Structure
//
// The model core model files and the examples have been placed 
// into different directories. The <tt>examples/</tt> directory...
//
//
// @page examples.html, Examples
// ...
//
\end{verbatim}

You can create links to the generated pages in the normal HTML way,
using the \ttt{<a href="...">...</a>} tag. All HTML files are 
placed in a single directory, so you don't have to worry about 
specifying directories.

Example:
\begin{verbatim}
//
// @titlepage
// ...
// The structure of the model is described <a href="structure.html">here</a>.
//
\end{verbatim}

\section{Generating HTML}

\ttt{opp\_neddoc} generates HTML documentation from NED and MSG files.
It accepts the following options:

-a: all files


\subsection{Multiple projects}

The generated \ttt{tags.xml} can be used to generate other documentation
that refers to pages in this documentation via HTML links.


\section{How does opp\_neddoc work?}

\ttt{*.ned} and \ttt{*.msg} files are collected (e.g. via the \ttt{find}
command if you used the \ttt{-a} option on Unix) and processed
with \ttt{nedtool}. \ttt{nedtool} parses them and outputs the resulting syntax
tree in XML -- a single large XML file wich contains all files.

The \ttt{*.ned} files are processed with the \ttt{-c} (export-diagrams-and-exit)
option of \ttt{gned}. This causes \ttt{gned} to export diagrams for the
compound modules in Postscript. Postscript files are then converted
to GIFs using \ttt{convert} (part of the ImageMagick package).
\ttt{gned} also exports an \ttt{images.xml} file which describes which
image was generated from which compound module, and also contains
additional info (coordinates of submodule rectangles and icons in the image)
for creating clickable image maps.

The XML file containing parsed NED and message files is then processed
with an XSLT stylesheet to generate HTML. XSLT is a very powerful way
of converting an XML document into another XML (or HTML, or text) document.
Additionally, the stylesheet reads \ttt{images.xml} and uses its contents
to make the compound module images clickable.
The stylesheet also outputs a \ttt{tags.xml} file which describes what is documented
in which .html file, so that external documentation can link to this one.

As a final step, the comments in the generated HTML file are processed
with a perl script. The perl script also performs syntax hightlighting
of the source listings in the HTML, and puts hyperlinks on module,
channel, message, etc. names. (It uses the info in the \ttt{tags.xml} file
for the latter task.) This last step, comment formatting and source code
coloring whould have been very difficult to achieve from XSLT, which
(at least in its 1.0 version of the standard) completely lacks powerful
string manipulation functions. (Not even simple find/replace
is supported in strings, let alone regular expressions. Perhaps the
2.0 version of XSLT will improve on this.)

The whole process is controlled by the \ttt{opp\_neddoc} shell script
(or on Windows, the \ttt{opp\_neddoc.cmd} batch file.)





