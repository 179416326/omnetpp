\chapter{Plug-in Extensions}
\label{cha:plugin-exts}

\section{Overview}

{\opp} is an open system, and several details of its operation
can be customized via plug-ins. To create a plug-in, you generally
need to write a C++ class that implements a certain interface
(i.e. subclasses from a C++ abstract class), and register it in {\opp}.
The plug-in class can be activated for a particular simulation
with a corresponding configuration option.

The following plug-in interfaces are supported:

\begin{itemize}
   \item{\cclass{cRNG}. Interface for random number generators.}
   \item{\cclass{cScheduler}. The scheduler class. This plug-in interface
     allows for implementing real-time, hardware-in-the-loop, distributed
     and distributed parallel simulation.}
   \item{\cclass{cConfiguration}. Configuration provider plug-in.
     This plug-in interface lets you replace \ttt{omnetpp.ini}
     with some other implementation, for example a database.}
   \item{\cclass{cOutputScalarManager}. It handles recording the scalar output data.
     The default output scalar manager is \cclass{cFileOutputScalarManager},
     defined in the Envir library.}
   \item{\cclass{cOutputVectorManager}. It handles recording the output
     from \cclass{cOutVector} objects. The default output vector manager is
     \cclass{cIndexedFileOutputVectorManager}, defined in the Envir library.}
   \item{\cclass{cSnapshotManager}. It provides an output stream to which
     snapshots are written (see section \ref{sec:ch-sim-lib:snapshots}).
     The default snapshot manager is \cclass{cFileSnapshotManager},
     defined in the Envir library.}
\end{itemize}

The classes (\cclass{cRNG}, \cclass{cScheduler}, etc.) are documented in
the API Reference.

To actually implement and select a plug-in for use:

\begin{enumerate}
   \item Subclass the given interface class (e.g. for a custom RNG, \cclass{cRNG})
     to create your own version.
   \item Register the class by putting the \fmac{Register\_Class(MyRNGClass)}
     line into the C++ source.
   \item Compile and link your interface class into the {\opp} simulation
     executable. IMPORTANT: make sure the executable actually contains
     the code of your class! Over-optimizing linkers (esp. on Unix)
     tend to leave out code to which there seem to be no external reference.
   \item Add an entry to \ttt{omnetpp.ini} to tell Envir use your class
     instead of the default one. For RNGs, this setting is \ttt{rng-class}
     in the \ttt{[General]} section.
\end{enumerate}


\section{Plug-in descriptions}


\subsection{Defining a new random number generator}
\label{sec:plugin-exts:rng}

% TODO

The new class can be activated with the \fpar{rng-class}
configuration option.


\subsection{Defining a new scheduler}
\label{sec:plugin-exts:scheduler}

The scheduler plug-in interface allows for implementing real-time,
hardware-in-the-loop, distributed and distributed parallel simulation.
%FIXME cScheduler usage

The new class can be activated with the \fpar{scheduler-class}
configuration option.


\subsection{Defining a new configuration provider}
\label{sec:plugin-exts:configuration}

The configuration provider provider plug-in lets you replace \ttt{omnetpp.ini}
with some other implementation, for example a database.

The new class can be activated with the \fpar{configuration-class}
configuration option.

%FIXME boot-time config! etc

For the configuration plug-in, the startup sequence is the following
(see \ttt{cEnvir::setup()} in the source code):

\begin{enumerate}
  \item First, \ttt{omnetpp.ini} (or the ini file(s) specified via the "-f"
     command-line option) are read.
  \item Shared libraries in \ttt{[General]/load-libs} are loaded.
     (Also the ones specified with the "-l" command-line option.)
  \item \ttt{[General]/configuration-class} is examined, and if it is present,
     a configuration object of the given class is instantiated.
     The configuration object may read further entries from the
     ini file (e.g. database connect parameters, or XML file name).
  \item The original \ttt{omnetpp.ini} \cclass{cInifile} configuration
     object is deleted. No other settings are taken from it.
  \item \ttt{[General]/load-libs} from the new configuration object is
     processed.
  \item Then everything goes on as normally, using the new configuration
     object.
\end{enumerate}


\subsection{Defining a new output scalar manager}
\label{sec:plugin-exts:outputscalarmanager}

cOutputScalarManager handles recording the scalar output data.
The default output scalar manager is \cclass{cFileOutputScalarManager},
defined in the Envir library.

The new class can be activated with the \fpar{outputscalarmanager-class}
configuration option.


\subsection{Defining a new output vector manager}
\label{sec:plugin-exts:outputvectormanager}

cOutputVectorManager handles recording the output from \cclass{cOutVector} objects.
The default output vector manager is \cclass{cIndexedFileOutputVectorManager},
defined in the Envir library.

The new class can be activated with the \fpar{outputvectormanager-class}
configuration option.


\subsection{Defining a new snapshot manager}
\label{sec:plugin-exts:snapshotmanager}

cSnapshotManager provides an output stream to which snapshots are written
(see section \ref{sec:ch-sim-lib:snapshots}). The default snapshot manager
is \cclass{cFileSnapshotManager}, defined in the Envir library.

The new class can be activated with the \fpar{snapshotmanager-class}
configuration option.


\section{Reading the configuration and defining new configuration options}
\label{sec:plugin-exts:accessing-config}

config options need to be registered

%rename Entry to Option!!!!
Register\_GlobalConfigEntry(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register\_PerRunConfigEntry(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register\_GlobalConfigEntryU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register\_PerRunConfigEntryU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register\_PerObjectConfigEntry(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register\_PerObjectConfigEntryU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)




The configuration is available to plug-in classes via the \fname{getConfig()}
method of \cclass{cEnvir}, which returns a pointer to the configuration
object (\cclass{cConfiguration}). This enables plug-in classes to have
their own config entries.

An example which reads the \ttt{parsim-debug} boolean entry from the
\ttt{[General]} section, with \ttt{true} as default:

fallbackValue is returned if the value is not specified in the configuration:
and there is no default value.

const char *getAsCustom(cConfigOption *entry, const char *fallbackValue=NULL);
bool getAsBool(cConfigOption *entry, bool fallbackValue=false);
long getAsInt(cConfigOption *entry, long fallbackValue=0);
double getAsDouble(cConfigOption *entry, double fallbackValue=0);
std::string getAsString(cConfigOption *entry, const char *fallbackValue="");
std::string getAsFilename(cConfigOption *entry);
std::vector<std::string> getAsFilenames(cConfigOption *entry);
std::string getAsPath(cConfigOption *entry);


\begin{verbatim}
bool debug = ev.getConfig()->getAsBool(CFGID_PARSIM_DEBUG);
\end{verbatim}


\section{Implementing a new user interface}
\label{sec:plugin-exts:userinterface}

It is possible to extend {\opp} with a new user interface. The new
user interface will have fully equal rights to Cmdenv and Tkenv, that is,
it can be activated by starting the simulation executable with the
\ttt{-u} \textit{<name>} command-line or the \ttt{user-interface}
configuration option, it can be made the default user interface,
it can define new command-line options and configuration options,
and so on.

User interfaces must implement (i.e. subclass from) \cclass{cEnvir},
and must be registered to {\opp} with the \fmac{Register\_OmnetApp()} macro.
In practice, you'll almost always want to subclass \cclass{EnvirBase}
instead of \cclass{cEnvir}, because \cclass{EnvirBase} already
implements lots of functionality that otherwise you'd have to.

\begin{note}
If you want something completely different from what \cclass{EnvirBase}
provides, such as when embedding the simulation kernel into another
application, then you should be reading section \ref{sec:ch-opp-design:embedding},
not this one.
\end{note}

An example user interface:

\begin{verbatim}
#include "envirbase.h"

class FooEnv : public EnvirBase
{
    ...
};

Register_OmnetApp("FooEnv", FooEnv, 30, "an experimental user interface");
\end{verbatim}

The \fname{envirbase.h} header comes from the \ttt{src/envir} directory,
so it is necessary to add it to the include path (\ttt{-I}).

The arguments to \fmac{Register\_OmnetApp()} include the user interface name
(for use with the \ttt{-u} and \ttt{user-interface=} options),
the C++ class that implements it, a weight for default user interface selection
(if \ttt{-u} is missing, the user interface with the largest weight will get
activated), and a description string (for help and other purposes).

The C++ class should implement all methods left pure virtual in
\cclass{EnvirBase}, and possibly others if you want to customize
their behaviour. One method that you'll surely want to reimplement is
\ttt{run()} -- this is where your user interface runs. When this method
exits, the simulation program exits.

\begin{note}
A good starting point for implementing your own user interface is
Cmdenv -- just copy and modify its source code to quickly get going.
\end{note}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

