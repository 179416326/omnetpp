\chapter{Plug-in Extensions}
\label{cha:plugin-exts}

\section{Overview}

{\opp} is an open system, and several details of its operation
can be customized via plug-ins. To create a plug-in, you generally
need to write a C++ class that implements a certain interface
(i.e. subclasses from a C++ abstract class), and register it in {\opp}.
The plug-in class can be activated for a particular simulation
with a corresponding configuration option.

The following plug-in interfaces are supported:

\begin{itemize}
   \item{\cclass{cRNG}. Interface for random number generators.}
   \item{\cclass{cScheduler}. The scheduler class. This plug-in interface
     allows for implementing real-time, hardware-in-the-loop, distributed
     and distributed parallel simulation.}
   \item{\cclass{cConfiguration}. Configuration provider plug-in.
     This plug-in interface lets you replace \ttt{omnetpp.ini}
     with some other implementation, for example a database.}
   \item{\cclass{cOutputScalarManager}. It handles recording the scalar output data.
     The default output scalar manager is \cclass{cFileOutputScalarManager},
     defined in the Envir library.}
   \item{\cclass{cOutputVectorManager}. It handles recording the output
     from \cclass{cOutVector} objects. The default output vector manager is
     \cclass{cIndexedFileOutputVectorManager}, defined in the Envir library.}
   \item{\cclass{cSnapshotManager}. It provides an output stream to which
     snapshots are written (see section \ref{sec:ch-sim-lib:snapshots}).
     The default snapshot manager is \cclass{cFileSnapshotManager},
     defined in the Envir library.}
\end{itemize}

The classes (\cclass{cRNG}, \cclass{cScheduler}, etc.) are documented in
the API Reference.

To actually implement and select a plug-in for use:

\begin{enumerate}
   \item Subclass the given interface class (e.g. for a custom RNG, \cclass{cRNG})
     to create your own version.
   \item Register the class by putting the \fmac{Register\_Class(MyRNGClass)}
     line into the C++ source.
   \item Compile and link your interface class into the {\opp} simulation
     executable. IMPORTANT: make sure the executable actually contains
     the code of your class! Over-optimizing linkers (esp. on Unix)
     tend to leave out code to which there seem to be no external reference.
   \item Add an entry to \ttt{omnetpp.ini} to tell Envir use your class
     instead of the default one. For RNGs, this setting is \ttt{rng-class}
     in the \ttt{[General]} section.
\end{enumerate}


\section{Plug-in descriptions}


\subsection{Defining a new random number generator}
\label{sec:plugin-exts:rng}

% TODO

The new class can be activated with the \fpar{rng-class}
configuration option.


\subsection{Defining a new scheduler}
\label{sec:plugin-exts:scheduler}

The scheduler plug-in interface allows for implementing real-time,
hardware-in-the-loop, distributed and distributed parallel simulation.
%FIXME cScheduler usage

The new class can be activated with the \fpar{scheduler-class}
configuration option.


\subsection{Defining a new configuration provider}
\label{sec:plugin-exts:configuration}

The configuration provider plug-in lets you replace ini files
with some other storage implementation, for example a database.

The new class can be activated with the \fpar{configuration-class}
configuration option, and it must implement the \cclass{cConfiguration}
interface.

The \cclass{cConfiguration} interface abstracts the inifile-based
data model a little. It assumes that the configuration data
consists of several \textit{named configurations}. Before every
simulation run, one of the \textit{named configurations} get
activated, and from then on, all queries into the configuration
operate on the \textit{active named configuration} only.

It practice, you'll probably want to subclass from the
\cclass{SectionBasedConfiguration} class (in \ttt{src/envir})
instead, because it already implements a lot of functionality
that otherwise you would have to.

\cclass{SectionBasedConfiguration} does not assume ini files or
any other particular storage format; instead, it accepts
an object that implements the \cclass{cConfigurationReader}
interface to provides the data in raw form to it.
The default implementation of \cclass{cConfigurationReader} is
\cclass{InifileReader}.

From the configuration plug-in's point of view, the startup sequence
looks like the following (see \ttt{src/sim/bootenv.cc} in the source code):

\begin{enumerate}
  \item First, ini files specified on the command-line are read into a
     \textit{boot-time configuration object}. The boot-time configuration
     is always a \cclass{SectionBasedConfiguration} with
     \cclass{InifileReader}.
  \item Shared libraries get loaded (see the \ttt{-l} command-line option,
     and the \ttt{load-libs} configuration option). This allows
     configuration classes to come from shared libraries.
  \item The \ttt{configuration-class} configuration option is examined.
     If it is present, a configuration object of the given class
     is instantiated, and replaces the boot-time configuration.
     The new configuration object is initialized from the boot-time
     configuration, so that it can read parameters (e.g. database
     connection parameters, XML file name, etc) from it.
     Then the boot-time configuration object is deallocated.
  \item The \ttt{load-libs} option from the new configuration object is
     processed.
  \item Then everything goes on as normally, using the new configuration
     object.
\end{enumerate}

\begin{verbatim}
class DatabaseConfiguration : SectionBasedConfiguration
{
FIXME TODO!!
};
\end{verbatim}


\subsection{Defining a new output scalar manager}
\label{sec:plugin-exts:outputscalarmanager}

cOutputScalarManager handles recording the scalar output data.
The default output scalar manager is \cclass{cFileOutputScalarManager},
defined in the Envir library.

The new class can be activated with the \fpar{outputscalarmanager-class}
configuration option.


\subsection{Defining a new output vector manager}
\label{sec:plugin-exts:outputvectormanager}

cOutputVectorManager handles recording the output from \cclass{cOutVector} objects.
The default output vector manager is \cclass{cIndexedFileOutputVectorManager},
defined in the Envir library.

The new class can be activated with the \fpar{outputvectormanager-class}
configuration option.


\subsection{Defining a new snapshot manager}
\label{sec:plugin-exts:snapshotmanager}

cSnapshotManager provides an output stream to which snapshots are written
(see section \ref{sec:ch-sim-lib:snapshots}). The default snapshot manager
is \cclass{cFileSnapshotManager}, defined in the Envir library.

The new class can be activated with the \fpar{snapshotmanager-class}
configuration option.


\section{Accessing the configuration}
\label{sec:plugin-exts:accessing-config}

config is the ini file plus --ccc=vvv options

\subsection{Defining new configuration options}

New configuration options need to be declared with one of the appropriate
registration macros. These macros are:

\begin{verbatim}
Register_GlobalConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_GlobalConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
\end{verbatim}

Config options come in three flavours, as indicated by the macro names:

\begin{itemize}
  \item \textit{Global} options affect all configurations (i.e. they are
      only accepted in the \ttt{[General]} section but not in
      \ttt{[Config <name>]} sections)
  \item \textit{Per-Run} options can be specified in any section
      (i.e. both in \ttt{[General]} and in \ttt{[Config <name>]} sections)
  \item \textit{Per-Object} options ...
\end{itemize}

The macro arguments are as follows:
\begin{itemize}
  \item \textit{ID} is a C++ identifier that will let you refer to
        the configuration option in \textit{cConfiguration} member functions.
        (It is actually pointer to a \cclass{cConfigOption} object that
        the macro creates.)
  \item \textit{NAME} is the name of the option (a string).
  \item \textit{TYPE} is the data type of the option; it must be one of:
        \ttt{CFG\_BOOL}, \ttt{CFG\_INT}, \ttt{CFG\_DOUBLE}, \ttt{CFG\_STRING},
        \ttt{CFG\_FILENAME}, \ttt{CFG\_FILENAMES}, \ttt{CFG\_PATH}, \ttt{CFG\_CUSTOM}.
        The most significant difference between filesystem-related types
        (filename, filenames, path) and plain string is that relative
        filenames and paths get automatically converted to absolute
        when the configuration is read, with the base directory being the
        location of the ini file where the configuration entry was read from.
  \item \textit{UNIT} is a string that names the measurement unit in which
        the option's value is to be interpreted; it implies type \ttt{CFG\_DOUBLE}.
  \item \textit{DEFAULTVALUE} is the default value in textual form (string);
        this should be \ttt{NULL} if the option has no default value.
  \item \textit{DESCRIPTION} is an arbitrarily long string that describes
        the purpose and and operation of the option. It will be used in
        help texts etc.
\end{itemize}

For example, the \ttt{debug-on-errors} macro is declared in the following way:

\begin{verbatim}
Register_GlobalConfigOption(CFGID_DEBUG_ON_ERRORS,
                            "debug-on-errors", CFG_BOOL, "false",
                            "When enabled, runtime errors will etc etc...");
\end{verbatim}

\begin{note}
Registration is necessary because from the 4.0 version, {\opp} validates
the configuration on startup, in order to be able to report invalid or
mistyped option names and other errors.
\end{note}


\subsection{Reading values from the configuration}

The configuration is accessible via the \fname{getConfig()} method of \cclass{cEnvir}.
It returns a pointer to the configuration object (\cclass{cConfiguration}):

\begin{verbatim}
cConfiguration *config = ev.getConfig();
\end{verbatim}

\cclass{cConfiguration} provides several methods for querying the configuration.

no sections: flattened view etc.

\begin{verbatim}
const char *getAsCustom(cConfigOption *entry, const char *fallbackValue=NULL);
bool getAsBool(cConfigOption *entry, bool fallbackValue=false);
long getAsInt(cConfigOption *entry, long fallbackValue=0);
double getAsDouble(cConfigOption *entry, double fallbackValue=0);
std::string getAsString(cConfigOption *entry, const char *fallbackValue="");
std::string getAsFilename(cConfigOption *entry);
std::vector<std::string> getAsFilenames(cConfigOption *entry);
std::string getAsPath(cConfigOption *entry);
\end{verbatim}

\textit{fallbackValue} is returned if the value is not specified in the configuration,
and there is no default value.

\begin{verbatim}
bool debug = ev.getConfig()->getAsBool(CFGID_PARSIM_DEBUG);
\end{verbatim}


\section{Implementing a new user interface}
\label{sec:plugin-exts:userinterface}

It is possible to extend {\opp} with a new user interface. The new
user interface will have fully equal rights to Cmdenv and Tkenv, that is,
it can be activated by starting the simulation executable with the
\ttt{-u} \textit{<name>} command-line or the \ttt{user-interface}
configuration option, it can be made the default user interface,
it can define new command-line options and configuration options,
and so on.

User interfaces must implement (i.e. subclass from) \cclass{cEnvir},
and must be registered to {\opp} with the \fmac{Register\_OmnetApp()} macro.
In practice, you'll almost always want to subclass \cclass{EnvirBase}
instead of \cclass{cEnvir}, because \cclass{EnvirBase} already
implements lots of functionality that otherwise you'd have to.

\begin{note}
If you want something completely different from what \cclass{EnvirBase}
provides, such as when embedding the simulation kernel into another
application, then you should be reading section \ref{sec:ch-opp-design:embedding},
not this one.
\end{note}

An example user interface:

\begin{verbatim}
#include "envirbase.h"

class FooEnv : public EnvirBase
{
    ...
};

Register_OmnetApp("FooEnv", FooEnv, 30, "an experimental user interface");
\end{verbatim}

The \fname{envirbase.h} header comes from the \ttt{src/envir} directory,
so it is necessary to add it to the include path (\ttt{-I}).

The arguments to \fmac{Register\_OmnetApp()} include the user interface name
(for use with the \ttt{-u} and \ttt{user-interface=} options),
the C++ class that implements it, a weight for default user interface selection
(if \ttt{-u} is missing, the user interface with the largest weight will get
activated), and a description string (for help and other purposes).

The C++ class should implement all methods left pure virtual in
\cclass{EnvirBase}, and possibly others if you want to customize
their behaviour. One method that you'll surely want to reimplement is
\ttt{run()} -- this is where your user interface runs. When this method
exits, the simulation program exits.

\begin{note}
A good starting point for implementing your own user interface is
Cmdenv -- just copy and modify its source code to quickly get going.
\end{note}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

