\chapter{Plug-in Extensions}
\label{cha:plugin-exts}

\section{Overview}

{\opp} is an open system, and several details of its operation
can be customized via plug-ins. To create a plug-in, you generally
need to write a C++ class that implements a certain interface
(i.e. subclasses from a C++ abstract class), and register it in {\opp}.
The plug-in class can be activated for a particular simulation
with a corresponding configuration option.

The following plug-in interfaces are supported:

\begin{itemize}
   \item{\cclass{cRNG}. Interface for random number generators.}
   \item{\cclass{cScheduler}. The scheduler class. This plug-in interface
     allows for implementing real-time, hardware-in-the-loop, distributed
     and distributed parallel simulation.}
   \item{\cclass{cConfigurationEx}. Configuration provider plug-in.
     This plug-in interface lets you replace \ffilename{omnetpp.ini}
     with some other implementation, for example a database.}
   \item{\cclass{cIOutputScalarManager}. It handles recording the scalar output data.
     The default output scalar manager is \cclass{cFileOutputScalarManager},
     defined in the Envir library.}
   \item{\cclass{cIOutputVectorManager}. It handles recording the output
     from \cclass{cOutVector} objects. The default output vector manager is
     \cclass{cIndexedFileOutputVectorManager}, defined in the Envir library.}
   \item{\cclass{cISnapshotManager}. It provides an output stream to which
     snapshots are written (see section \ref{sec:ch-sim-lib:snapshots}).
     The default snapshot manager is \cclass{cFileSnapshotManager},
     defined in the Envir library.}
\end{itemize}

\label{sec:ch-plugin-exts:customization}

The classes (\cclass{cRNG}, \cclass{cScheduler}, etc.) are documented in
the API Reference.

To actually implement and select a plug-in for use:

\begin{enumerate}
   \item Subclass the given interface class (e.g. for a custom RNG, \cclass{cRNG})
     to create your own version.
   \item Register the class by putting the \fmac{Register\_Class(MyRNGClass)}
     line into the C++ source.
   \item Compile and link your interface class into the {\opp} simulation
     executable. IMPORTANT: make sure the executable actually contains
     the code of your class! Over-optimizing linkers (esp. on Unix)
     tend to leave out code to which there seem to be no external reference.
   \item Add an entry to \ffilename{omnetpp.ini} to tell Envir use your class
     instead of the default class. For RNGs, this setting is \ttt{rng-class}
     in the \ttt{[General]} section.
\end{enumerate}


\section{Plug-in Descriptions}


\subsection{Defining a New Random Number Generator}
\label{sec:plugin-exts:rng}

% TODO
The new RNG C++ class must implement the \cclass{cRNG} interface,
and can be activated with the \fconfig{rng-class} configuration option.


\subsection{Defining a New Scheduler}
\label{sec:plugin-exts:scheduler}

The scheduler plug-in interface allows for implementing real-time,
hardware-in-the-loop, distributed and distributed parallel simulation.
%FIXME cScheduler usage

The scheduler C++ class must implement the \cclass{cScheduler} interface,
and can be activated with the \fconfig{scheduler-class} configuration option.

To see examples of scheduler classes, check the \cclass{cRealTimeScheduler}
class in the simulation kernel, and \ttt{cSocketRTScheduler} which is part
of the \textit{Sockets} sample simulation.


\subsection{Defining a New Configuration Provider}
\label{sec:plugin-exts:configuration}

\subsubsection{Overview}

The configuration provider plug-in lets you replace ini files
with some other storage implementation, for example a database.
The configuration provider C++ class must implement the
\cclass{cConfigurationEx} interface, and can be activated with
the \fconfig{configuration-class} configuration option.

The \cclass{cConfigurationEx} interface abstracts the inifile-based
data model to some degree. It assumes that the configuration data
consists of several \textit{named configurations}. Before every
simulation run, one of the \textit{named configurations} is
activated, and from then on, all queries into the configuration
operate on the \textit{active named configuration} only.

It practice, you will probably use the \cclass{SectionBasedConfiguration}
class (in \ttt{src/envir}) or subclass from it, because it already
implements a lot of functionality that you would otherwise have to.

\cclass{SectionBasedConfiguration} does not assume ini files or
any other particular storage format; instead, it accepts
an object that implements the \cclass{cConfigurationReader}
interface to provide the data in raw form to it.
The default implementation of \cclass{cConfigurationReader} is
\cclass{InifileReader}.

\subsubsection{The Startup Sequence}

From the configuration plug-in's point of view, the startup sequence
looks like the following (see \ttt{src/envir/startup.cc} in the source code):

\begin{enumerate}
  \item First, ini files specified on the command-line are read into a
     \textit{boot-time configuration object}. The boot-time configuration
     is always a \cclass{SectionBasedConfiguration} with
     \cclass{InifileReader}.
  \item Shared libraries are loaded (see the \ttt{-l} command-line option,
     and the \ttt{load-libs} configuration option). This allows
     configuration classes to come from shared libraries.
  \item The \ttt{configuration-class} configuration option is examined.
     If it is present, a configuration object of the given class
     is instantiated, and replaces the boot-time configuration.
     The new configuration object is initialized from the boot-time
     configuration, so that it can read parameters (e.g. database
     connection parameters, XML file name, etc) from it.
     Then the boot-time configuration object is deallocated.
  \item The \ttt{load-libs} option from the new configuration object is
     processed.
  \item Then everything goes on as normally, using the new configuration
     object.
\end{enumerate}

\subsubsection{Providing a Custom Configuration Class}

To replace the configuration object with your custom implementation,
you would write the class:

\begin{cpp}
#include "cconfiguration.h"

class CustomConfiguration : public cConfigurationEx
{
   ...
};

Register_Class(CustomConfiguration);
\end{cpp}

and then activate it in the boot-time configuration:

\begin{inifile}
[General]
configuration-class = CustomConfiguration
\end{inifile}


\subsubsection{Providing a Custom Reader for SectionBasedConfiguration}

As said already, writing a configuration class from scratch can
be a lot of work, and it may be more practical to reuse
\cclass{SectionBasedConfiguration} with a different configuration
reader class. This can be done with \ttt{sectionbasedconfig-configreader-class}
config option, interpreted by \cclass{SectionBasedConfiguration}.
Specify the following in your boot-time ini file:

\begin{inifile}
[General]
configuration-class = SectionBasedConfiguration
sectionbasedconfig-configreader-class = <my new reader class>
\end{inifile}

The configuration reader class should look like this:

\begin{cpp}
#include "cconfigreader.h"

class DatabaseConfigurationReader : public cConfigurationReader
{
   ...
};

Register_Class(DatabaseConfigurationReader);
\end{cpp}


\subsection{Defining a New Output Scalar Manager}
\label{sec:plugin-exts:outputscalarmanager}

\cclass{cIOutputScalarManager} handles recording the scalar output data.
The default output scalar manager is \cclass{cFileOutputScalarManager},
defined in the Envir library.

The new class can be activated with the \fconfig{outputscalarmanager-class}
configuration option.


\subsection{Defining a New Output Vector Manager}
\label{sec:plugin-exts:outputvectormanager}

\cclass{cIOutputVectorManager} handles recording the output from \cclass{cOutVector} objects.
The default output vector manager is \cclass{cIndexedFileOutputVectorManager},
defined in the Envir library.

The new class can be activated with the \fconfig{outputvectormanager-class}
configuration option.


\subsection{Defining a New Snapshot Manager}
\label{sec:plugin-exts:snapshotmanager}

\cclass{cISnapshotManager} provides an output stream to which snapshots are written
(see section \ref{sec:ch-sim-lib:snapshots}). The default snapshot manager
is \cclass{cFileSnapshotManager}, defined in the Envir library.

The new class can be activated with the \fconfig{snapshotmanager-class}
configuration option.


\section{Accessing the Configuration}
\label{sec:plugin-exts:accessing-config}

\subsection{Defining New Configuration Options}

New configuration options need to be declared with one of the appropriate
registration macros. These macros are:

\begin{cpp}
Register_GlobalConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_GlobalConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerRunConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOption(ID, NAME, TYPE, DEFAULTVALUE, DESCRIPTION)
Register_PerObjectConfigOptionU(ID, NAME, UNIT, DEFAULTVALUE, DESCRIPTION)
\end{cpp}

Config options come in three flavors, as indicated by the macro names:

\begin{itemize}
  \item \textit{Global} options affect all configurations (i.e. they are
      only accepted in the \ttt{[General]} section but not in
      \ttt{[Config <name>]} sections)
  \item \textit{Per-Run} options can be specified in any section
      (i.e. both in \ttt{[General]} and in \ttt{[Config <name>]} sections).
      They are specific to a particular section. Their names always contain
      a hyphen (-) character.
  \item \textit{Per-Object} options can be specified in any section
      (i.e. both in \ttt{[General]} and in \ttt{[Config <name>]} sections).
      They are specific to an object or group of objects and their name must
      not contain a hypen (-) character.
\end{itemize}

The macro arguments are as follows:
\begin{itemize}
  \item \textit{ID} is a C++ identifier that will let you refer to
        the configuration option in \textit{cConfiguration} member functions.
        (It is actually pointer to a \cclass{cConfigOption} object that
        the macro creates.)
  \item \textit{NAME} is the name of the option (a string).
  \item \textit{TYPE} is the data type of the option; it must be one of:
        \ttt{CFG\_BOOL}, \ttt{CFG\_INT}, \ttt{CFG\_DOUBLE}, \ttt{CFG\_STRING},
        \ttt{CFG\_FILENAME}, \ttt{CFG\_FILENAMES}, \ttt{CFG\_PATH}, \ttt{CFG\_CUSTOM}.
        The most significant difference between filesystem-related types
        (filename, filenames, path) and plain strings is that relative
        filenames and paths are automatically converted to absolute
        when the configuration is read, with the base directory being the
        location of the ini file where the configuration entry was read from.
  \item \textit{UNIT} is a string that names the measurement unit in which
        the option's value is to be interpreted; it implies type \ttt{CFG\_DOUBLE}.
  \item \textit{DEFAULTVALUE} is the default value in textual form (string);
        this should be \ttt{nullptr} if the option has no default value.
  \item \textit{DESCRIPTION} is an arbitrarily long string that describes
        the purpose and and operation of the option. It will be used in
        help texts etc.
\end{itemize}

For example, the \ttt{debug-on-errors} option is declared in the following way:

\begin{cpp}
Register_GlobalConfigOption(CFGID_DEBUG_ON_ERRORS,
                            "debug-on-errors", CFG_BOOL, "false",
                            "When enabled, runtime errors will etc etc...");
\end{cpp}

\begin{note}
Registration is necessary because from the 4.0 version, {\opp} validates
the configuration on startup, in order to be able to report invalid or
mistyped option names and other errors.
\end{note}


\subsection{Reading Values from the Configuration}

The configuration is accessible via the \ffunc{getConfig()} method of \cclass{cEnvir}.
It returns a pointer to the configuration object (\cclass{cConfiguration}):

\begin{cpp}
cConfiguration *config = ev.getConfig();
\end{cpp}

\cclass{cConfiguration} provides several methods for querying the configuration.

\begin{note}
The configuration object provides a flattened view of the ini file. Sections
inheriting from each other are merged for you. Configuration options provided
on the command line in the form \ttt{--option=value} are added first to the object.
This ensures that the command line options take precedence over the values specified
in the INI file.
\end{note}

\begin{cpp}
const char *getAsCustom(cConfigOption *entry, const char *fallbackValue=nullptr);
bool getAsBool(cConfigOption *entry, bool fallbackValue=false);
long getAsInt(cConfigOption *entry, long fallbackValue=0);
double getAsDouble(cConfigOption *entry, double fallbackValue=0);
std::string getAsString(cConfigOption *entry, const char *fallbackValue="");
std::string getAsFilename(cConfigOption *entry);
std::vector<std::string> getAsFilenames(cConfigOption *entry);
std::string getAsPath(cConfigOption *entry);
\end{cpp}

\textit{fallbackValue} is returned if the value is not specified in the configuration,
and there is no default value.

\begin{cpp}
bool debug = ev.getConfig()->getAsBool(CFGID_PARSIM_DEBUG);
\end{cpp}


\section{Implementing a New User Interface}
\label{sec:plugin-exts:userinterface}

It is possible to extend {\opp} with a new user interface. The new
user interface will have fully equal rights to Cmdenv and Tkenv; that is,
it can be activated by starting the simulation executable with the
\ttt{-u} \textit{<name>} command-line or the \ttt{user-interface}
configuration option, it can be made the default user interface,
it can define new command-line options and configuration options,
and so on.

User interfaces must implement (i.e. subclass from) \cclass{cRunnableEnvir},
and must be registered to {\opp} with the \fmac{Register\_OmnetApp()} macro.
In practice, you will almost always want to subclass \cclass{EnvirBase}
instead of \cclass{cRunnableEnvir}, because \cclass{EnvirBase} already
implements lots of functionality that otherwise you'd have to.

\begin{note}
If you want something completely different from what \cclass{EnvirBase}
provides, such as embedding the simulation kernel into another
application, then you should be reading section \ref{sec:ch-embedding:embedding},
not this one.
\end{note}

An example user interface:

\begin{cpp}
#include "envirbase.h"

class FooEnv : public EnvirBase
{
    ...
};

Register_OmnetApp("FooEnv", FooEnv, 30, "an experimental user interface");
\end{cpp}

The \ffilename{envirbase.h} header comes from the \ttt{src/envir} directory,
so it is necessary to add it to the include path (\ttt{-I}).

The arguments to \fmac{Register\_OmnetApp()} include the user interface name
(for use with the \ttt{-u} and \fconfig{user-interface} options),
the C++ class that implements it, a weight for default user interface selection
(if \ttt{-u} is missing, the user interface with the largest weight will be
activated), and a description string (for help and other purposes).

The C++ class should implement all methods left pure virtual in
\cclass{EnvirBase}, and possibly others if you want to customize
their behavior. One method that you will surely want to reimplement is
\ttt{run()} -- this is where your user interface runs. When this method
exits, the simulation program exits.

\begin{note}
A good starting point for implementing your own user interface is
Cmdenv -- just copy and modify its source code to quickly get going.
\end{note}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

