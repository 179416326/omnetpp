\chapter{Building Simulation Programs}
\label{cha:building-simulation-programs}

\section{Overview}

As it was already mentioned, an {\opp} model physically consists of
the following parts:

\begin{itemize}
  \item{NED language\index{ned!files} topology description(s). These
      are files with the \ttt{.ned} extension.}
  \item{Message definitions\index{message definitions}, in files
      with \ttt{.msg} extension.}
  \item{Simple modules implementations and other C++ code, in \ttt{.cc}
        files (or \ttt{.cpp}, on Windows)}
\end{itemize}


To build an executable simulation program,
you first need to translate the MSG files\index{msg!files}
into C++, using the message compiler (\ttt{opp\_msgc}).
After this step, the process is the same as building any C/C++
program from source: all C++ sources need to be compiled into object files
(\ttt{.o} files (using gcc on Mac, Linux) or mingw on Windows)
\ifcommercial or \ttt{.obj} (using MSVC on Windows)) \fi
and all object files need to be linked with the necessary libraries to get
an executable or shared library.

\begin{note}
Compiling NED files directly to C++ code is no longer supported in
{\opp} 4.0. NED files are always dynamically loaded.
\end{note}

File names for libraries differ for Unix/Linux and for Windows,
and also different for static and shared libraries.
Let us suppose you have a library called Tkenv.
If you are compiling with gcc or mingw, the file name for the static library
would be something like \ttt{libopptkenv[d].a},
and the shared library would be called \ttt{libopptkenv[d].so}.
(libopptkenvd.so would be used for the debug version while libopptkenv.so
is for the release build.)

\begin{note}
\ifcommercial With MSVC, the corresponding filenames will be \ttt{opptkenv.lib} and \ttt{opptkenv.dll}.\fi
On Windows, shared libraries have the \ttt{.dll} extension instead of \ttt{.so}
On Mac OS X, shared libraries have the \ttt{.dylib} extension instead of \ttt{.so}.
\end{note}

In {\opp} 4.0 we recommend to use shared libraries whenever it is possible.
You'll need to link with the following libraries:

\begin{itemize}
  \item{The simulation kernel and class library\index{simulation!kernel},
    called \textit{oppsim} (file \ttt{liboppsim.[so|dll|dylib]} etc).}
  \item{User interfaces. The common part of all user interfaces is
    the \textit{oppenvir} library (file \texttt{liboppenvir.[so|dll|dylib]}, etc),
    and the specific user interfaces are \textit{opptkenv} and \textit{oppcmdenv}
    (\ttt{libopptkenv.[so|dll|dylib]}, \ttt{liboppcmdenv.[so|dll|dylib]}, etc).
    You have to link with \textit{oppenvir}, plus \textit{opptkenv} or
    \textit{oppcmdenv} or both.}
\end{itemize}

Luckily, you do not have to worry about the above details, because
automatic tools like \ttt{opp\_makemake} will take care of the hard
part for you.

The following figure gives an overview of the process of building
and running simulation programs.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics{figures/build-workflow}
    \caption{Building and running simulation}
  \end{center}
\end{figure}


This section discusses how to use the simulation system on the
following platforms:
\begin{itemize}
  \item{Unix (Linux/Mac OS X) with gcc}
  \item{Windows with the included MinGW compiler}
  \ifcommercial\item{Windows with Microsoft Visual C++}\fi
\end{itemize}


\section{Using gcc}

The following section applies to using {\opp} on Linux, Solaris, Mac OS X, FreeBSD and
other Unix derivatives, and also to MinGW on Windows.

\begin{note}
The \ttt{doc/} directory of your {\opp} installation contains
\ttt{Readme.}\textit{<platform>} files that provide more detailed platform specific instructions.
\end{note}


\subsection{The opp\_makemake Tool}

The \fprog{opp\_makemake} tool can automatically generate a
\texttt{Makefile} for your simulation program, based on the source files
in the current directory or directory tree.
\fprog{opp\_makemake} has several options; \ttt{opp\_makemake -h}
displays help.

The most important options are:

\begin{itemize}
    \item{\ttt{-f, -{}-force} : Force overwriting existing Makefile}
    \item{\ttt{-o filename} : Name of simulation executable or library to be built.}
    \item{\ttt{-O directory, -{}-out directory} : Specifies the name of the output directory tree
                          for out-of-directory build}
    \item{\ttt{-{}-deep} : Generates a "deep" Makefile. A deep Makefile will
                          cover the whole source tree under the make directory,
                          not just files in that directory.}
    \item{\ttt{-r, -{}-recurse} : Causes make to recursively descend into all subdirectories;
                          subdirectories are expected to contain
                          makefiles themselves.}
    \item{\ttt{-X directory, -Xdirectory, -{}-except directory} :
                          With \ttt{-r} and \ttt{-{}-deep} option: ignore the given directory.}
    \item{\ttt{-dsubdir, -d subdir, -{}-subdir subdir} :
                          Causes make to recursively descend into the given
                          directory.}
    \item{\ttt{-n, -{}-nolink} :  Produce object files but do not create executable or
                          library.}
    \item{\ttt{-s, -{}-make-so} : Build shared library (.so, .dll or .dylib).}
    \item{\ttt{-a, -{}-make-lib} : Create static library (.a or .lib).}
    \item{\ttt{-Idir} :         Additional NED and C++ include directory.}
    \item{\ttt{-Ldir} :         Add a directory to the library path.}
    \item{\ttt{-llibrary} :     Additional library to link against.}
\end{itemize}


\subsection{Basic Use}

Once you have the source files (\ttt{*.ned}, \ttt{*.msg}, \ttt{*.cc},
\ttt{*.h}) in a directory, change there and type:

\begin{commandline}
$ opp_makemake
\end{commandline}

This will create a file named \ttt{Makefile}\index{Makefile}. If you
type \fprog{make}, your simulation program should build.


If you already had a \ttt{Makefile} in that directory, \fprog{opp\_makemake}
will refuse to overwrite it. You can force overwriting the old \ttt{Makefile}
with the -f option:

\begin{commandline}
$ opp_makemake -f
\end{commandline}

The name of the output file\index{output!file} will be derived from
the name of the project directory (see later). You can override it
with the \ttt{-o} option:

\begin{commandline}
$ opp_makemake -f -o aloha
\end{commandline}

In addition to the default target that builds the simulation executable,
the \ttt{Makefile} also contains the following targets:

\begin{longtable}{|l|p{8cm}|}
\hline
\tabheadcol
\tbf{Target} & \tbf{Action}\\\hline
all & The default target is to build the simulation executable\\\hline
depend & Adds (or refreshes) dependencies in the \ttt{Makefile}\\\hline
clean &  Deletes all files that were produced by the make process\\\hline
\end{longtable}


\subsection{Debug and Release Builds}

\fprog{opp\_makemake} generates a makefile that can create both release and debug builds.
By default it creates debug version, but it is easy to override this behaviour.
Just define the \ttt{MODE} variable on the \fprog{make} command line.

\begin{commandline}
$ make MODE=release
\end{commandline}

If you want to create release builds by default you should use the \ttt{-{}-mode} \textit{mode}
option for \fprog{opp\_makemake} when generating your makefiles.
\begin{commandline}
$ opp_makemake --mode release ...
\end{commandline}


\subsection{Using External C/C++ Libraries}

If you are using external libraries you should specify the include path for the header files
with the \ttt{-I} \textit{includedir} option. You should specify this option if you are using
anything outside from the source directory tree (except the system and {\opp} headers which are
always included automatically)

To define an external library to be linked with, use \ttt{-Ldir} to specify
the directory of the external library and \ttt{-llibrary} to specify the name of the
external dependency.


\subsection{Building Directory Trees}

It is possible to build a whole source directory tree with a single makefile.
A source tree will generate a single output file (executable or library).
A source directory tree will always have a \ttt{Makefile} in its root,
and source files may be placed anywhere in the tree.

To turns on this option, use the \ttt{opp\_makemake -{}-deep} option.
\ttt{opp\_makemake} will collect all \ttt{.cc} and \ttt{.msg} files from
the whole subdirectory tree, and generate a makefile that covers all.
If you need to exclude a specific directory, use the \ttt{-X exclude/dir/path}
option. (Multiple \ttt{-X} options are accepted.)

An example:

\begin{commandline}
$ opp_makemake -f --deep -X experimental -X obsolete
\end{commandline}


\subsection{Automatic Include Dirs}

If your source tree contains several subdirectories (maybe several levels
deep), it can be annoying that you should specify relative paths for your
header files in your \ttt{.cc} files or you should specify the include path
explicitly by the \ttt{-I includepath} option. \ttt{opp\_makemake} has a
command line option, which adds all directories in the current source tree
to the compiler command line. This option is turned on by default.

\begin{note}
You may turn off this mechanism with the \ttt{-{}-no-deep-includes} option.
\end{note}

The only requirement is that your \ttt{\#include} statements must unambigously
specify the name of the header file. (i.e. if you have two \ttt{common.h}
files, one in subdir1 and the other in subdir2 specify \ttt{\#include
"subdir1/common.h"} instead of \ttt{\#include "common.h"}. If you want to
include a directory which is outside of your source directory tree you
always must specify it with the \ttt{-I external/include/dir} option.


\subsection{Dependency Handling}

Dependency information is used by the makefile to minimize the time required to
compile and link your project. If your makefile contains up-to date dependency info
-- only files changed since you last compiled your project will be re-compiled or linked.


\fprog{opp\_makemake} automatically adds dependencies to the makefile\index{Makefile!dependencies}.
You can regenerate the dependencies by typing \fprog[make]{make depend} any time.
The warnings during the dependency generation process can be safely ignored.


You may generate and add dependencies to the \ttt{makefile} manually using the \fprog{opp\_makedep}
tool. Use \fprog{opp\_makedep -{}-help} to display the supported command line options.

\begin{note}
The dependency generator does not handle conditional macros and includes. Conditionally included header
files are always added to the file's dependency list.
\end{note}


\subsection{Out-of-Directory Build}

The build system creates object and executable files in a separate directory, called
\textit{output directory}. The structure of the output folder will be the same as your
sourcefolder structure except that it will be placed in the \ttt{out/configname} directory.
The \ttt{configname} part will mirror your compiler toolchain and build mode settings.
(i.e. The result of a debug build with gcc will be placed in \ttt{out/gcc-debug})


The location of the generated output file is determined by the -O option.
(The default value is 'out', relative to the project root directory):


\begin{commandline}
$ opp_makemake -O ../tmp/obj
\end{commandline}


\begin{note}
The project directory is the first ancestor of the current directory which
contains a \ttt{.project} file).
\end{note}


\begin{note}
Source files (i.e. those created by the \fprog{opp\_msgc} compiler) will be generated in the
source folder rather than in the output folder.
\end{note}


\subsection{Building Shared and Static Libraries}

By default the makefile will create an executable file, but it is also
possible to build shared or static libraries. Shared libraries
are usually a better choice.

Use \ttt{-{}-make-so} to create shared libraries, and \ttt{-{}-make-lib}
to build static libraries. The \ttt{-{}-nolink} option completely avoids
the linking step, which is useful for top-level makefiles that only invoke
other makefiles, or if you want to do the linking manually.

\ifcommercial
\begin{note}
The Microsoft Visual C++ compiler handles shared library (DLL) linking (-s)
differently and requires additional steps to compile and link correctly.
You must choose a \ttt{<symbol>} for your project and annotate each class
and dll-public declaration with \ttt{<symbol>\_API}. If you generate your makefiles
with the \ttt{-p <symbol>} option, \ttt{<symbol>\_EXPORT} macro will be passed to
the compiler causing <symbol>\_API to be defined as \_\_declspec(dllexport) in
your sources. This step allows to correctly generate DLL exports in windows.
\end{note}
\fi


\subsection{Recursive Builds}


The \ttt{-{}-recurse} option enables recursive make: when you build the simulation, make
will descend into the subdirectories and runs make in them too.
By default, \ttt{-{}-recurse} decends into all subdirectories; the -X directory option
can be used to make it ignore certain subdirectories. This option is especially useful
for top level makefiles.


The \ttt{-{}-recurse} option automatically discovers subdirectories, but this
is sometimes inconvenient. Your source directory tree may contain
parts which need their own hand written \ttt{Makefile}. This can happen if
you include source files from an other non {\opp} project.With the \ttt{-d dir}
or \ttt{-{}-subdir dir} option, you can explicitly specify which directories to
recurse into, and also, the directories need not be direct children of the
current directory.


The recursive make options (\ttt{-{}-recurse}, \ttt{-d}, \ttt{-{}-subdir})
imply \ttt{-X}, that is, the directories recursed into will be
automatically excluded from deep makefiles.


You can control the order of traversal by adding dependencies into
the \ttt{makefrag} file (see \ref{sec:makefrag})

\begin{note}
With \ttt{-d}, it is also possible to create infinite recursions.
\fprog{opp\_makemake} cannot detect them, it is your responsibility that
cycles do not occur.
\end{note}


Motivation for recursive builds:
\begin{itemize}
 \item{toplevel makefile}
 \item{integrating sources that have their own makefile}
\end{itemize}


\subsection{Customizing the Makefile}
\label{sec:makefrag}

It is possible to add rules or otherwise customize the generated makefile
by providing a \ttt{makefrag} file. When you run \fprog{opp\_makemake}, it
will automatically insert \ttt{makefrag} into the resulting \ttt{Makefile}.
With the \ttt{-i} option, you can also name other files to be included into the
\ttt{Makefile}.

\ttt{makefrag} will be inserted after the definitions but before the first
rule, so it is possible to override existing definitions and add new
ones, and also to override the default target.

\ttt{makefrag} can be useful if some of your source files are generated
from other files (for example, you use generated NED files), or you need
additional targets in your makefile or just simply wants to override the
default target in the makefile.


\subsection{Projects with Multiple Source Trees}

In the case of a large project, your source files may be spread across
several directories and your project may generate more than one executable
file (i.e. several shared libraries, examples etc.).

Once you have created your makefiles with \ttt{opp\_makemake} in
every source directory tree, you will need a toplevel makefile.
The toplevel makefile usually calls only the makefiles
recursively in the source directory trees.


\subsection{A Multi-Directory Example}

For a complex example of using \fprog{opp\_makemake}, we will check how to create
the makefiles for the mobility-framework. First take a look at the
project's directory structure and find the directories that should be used as
source trees:

\begin{verbatim}
mobility-framework
    bitmaps
    contrib <-- source tree (build libmfcontrib.so from this dir)
    core <-- source tree (build libmfcore.so from this dir)
    docs
    network
    template
    testSuite <-- source tree (build testSuite executable from this dir)
\end{verbatim}

Additionally there are dependencies between these output files: \ttt{mfcontrib}
requires \ttt{mfcore} and \ttt{testSuite} requires \ttt{mfcontrib} (and indirectly
\ttt{mfcore} of course).

First create the makefile for the core directory (build a shared lib from all .cc files
found in the core subtree and name it 'mfcore'):

\begin{commandline}
$ cd core && opp_makemake -f --deep --make-so -o mfcore -O out
\end{commandline}

The contrib directory is depending on \ttt{mfcore} so we use the -L and -l options
to specify the library we should link with. Note that we must also add
the include directories manually from the core source tree, because autodiscovery works only
in the same source tree:

\begin{commandline}
$ cd contrib && opp_makemake -f --deep --make-so -o mfcontrib -O out \\
  -I../core/basicModules -I../core/utils -L../out/$(CONFIGNAME)/core -lmfcore
\end{commandline}

The testSuite will be created as an executable file which depends on both
\ttt{mfcontrib} and \ttt{mfcore}.

\begin{commandline}
$ cd testSuite && opp_makemake -f --deep -o testSuite -O out
    -I../core/utils -I../core/basicModules -I../contrib/utils \\
    -I../contrib/applLayer -L../out/$(CONFIGNAME)/contrib -lmfcontrib
\end{commandline}

Now the last step is to create a top-level makefile in the root of the project that
calls the previously created makefiles in the correct order. We will use the
\ttt{-{}-nolink} option, exclude every subdirectory from the build (-X.) and explicitly call
the above makefiles (-d dirname).

\begin{commandline}
$ opp_makemake -f --nolink -O out -d testSuite -d core -d contrib -X.
\end{commandline}

Finally we have to specify the dependencies between the above directories. Add the lines below
to the \ttt{makefrag} file in the project directory root.

\begin{filelisting}
contrib_dir: core_dir
testSuite_dir: contrib_dir
\end{filelisting}

\ifcommercial
\section{Using Windows and Microsoft Visual C++}

There are only slight differences to the way Microsoft Visual C++
is handled. The main differences are:
\begin{itemize}
  \item{You should use \ttt{opp\_nmakemake} instead of \ttt{opp\_makemake}}
  \item{The generated makefile will be called \ttt{Makefile.vc} by default.}
  \item{Use \ttt{makefrag.vc} instead of \ttt{makefrag}.}
  \item{\ttt{nmake} is used instead of \ttt{make}.}
  \item{The build process is started by \ttt{nmake -f Makefile.vc} instead of \ttt{make}.}
\end{itemize}

Required compiler settings: turn on exception handling and RTTI, and
set stack size to as low as 64K.
\fi

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
