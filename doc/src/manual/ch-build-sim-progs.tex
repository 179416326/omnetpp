\chapter{Building Simulation Programs}
\label{cha:building-simulation-programs}

\section{Overview}

As has already been mentioned, an {\opp} model consists of
the following parts:

\begin{itemize}
  \item{NED language\index{ned!files} topology description(s). These
      are files with the \ttt{.ned} extension.}
  \item{Message definitions\index{message definitions}, in files
      with \ttt{.msg} extension.}
  \item{Simple module implementations and other C++ code, in \ttt{.cc}
        files.}
\end{itemize}


To build an executable simulation program,
you first need to translate the MSG files\index{msg!files}
into C++, using the message compiler (\ttt{opp\_msgc}).
After this step, the process is the same as building any C/C++
program from source: all C++ sources need to be compiled into object files
(\ttt{.o} files (using gcc or clang)
\ifcommercial or \ttt{.obj} (using MSVC on Windows)) \fi
and all object files need to be linked with the necessary libraries to get
an executable or shared library.

File names for libraries differ depending on the platform, whether it is
a static or shared library, and whether it is a debug or release version.
Let us suppose you have a library called \ttt{common}:
\begin{itemize}
  \item{The \ttt{opp} prefix is always prepended to all library names to avoid name clashes with other programs.}
  \item{For all platforms, where the gcc (or mingw) compiler is used the static library filename has a ".a" extension
         and the \ttt{lib} prefix is prepended to the name (e.g. \ttt{liboppfoo[d].a}).}
  \item{For all platforms, the debug version filename has a "d" inserted
            at the end of the library name  (e.g. \ttt{liboppcommond.ext}).}
  \item{For the Unix/Linux platform, the shared library filename has a ".so"
         extension (e.g. \ttt{liboppcommon[d].so}).}
  \item{For the Mac OS X platform, the shared library filename has a ".dylib"
         extension (e.g. \ttt{liboppcommon[d].dylib}).}
  \item{For the Windows platform, the shared library filename has a ".dll"
         extension (e.g. \ttt{liboppfoo[d].dll}).}
  \ifcommercial
     \item{With Microsoft Visual C++, the \ttt{lib} prefix is not prepended to the name
     and the static library filename has a ".lib" extension. (e.g. \ttt{oppcommon.lib} and \ttt{oppcommon.dll}).}
  \fi
\end{itemize}

We recommend that you use shared libraries whenever it is possible.
You will need to link with the following libraries:

\begin{itemize}
  \item{The simulation kernel and class library\index{simulation!kernel},
    called \textit{oppsim} (file \ttt{liboppsim.[so|dll|dylib]} etc).}
  \item{User interfaces. The common part of all user interfaces is
    the \textit{oppenvir} library (file \texttt{liboppenvir.[so|dll|dylib]}, etc),
    and the specific user interfaces are \textit{opptkenv}, \textit{oppqtenv}
    and \textit{oppcmdenv} (\ttt{libopptkenv.[so|dll|dylib]},
    \ttt{liboppqtenv.[so|dll|dylib]}, \ttt{liboppcmdenv.[so|dll|dylib]}, etc).
    You have to link with \textit{oppenvir}, plus one or more of \textit{opptkenv},
    \textit{oppqtenv} or \textit{oppcmdenv} .}
  \item{Additionally, \ttt{liboppmain.[a|lib]} needs to be linked in if you are
    building a standalone executable file.}
\end{itemize}

Luckily, you do not have to worry about the above details, because
automatic tools like \ttt{opp\_makemake} will take care of the hard
part for you.

The following figure gives an overview of the process of building
and running simulation programs.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics{figures/build-workflow}
    \caption{Building and running simulation}
  \end{center}
\end{figure}

\section{Using gcc or clang}

The following section applies to using {\opp} on Linux, Solaris, Mac OS X, FreeBSD and
other Unix derivatives, and also to MinGW on Windows.

\begin{note}
The \ttt{doc/InstallGuide.pdf} file in your {\opp} installation
provides more detailed platform specific instructions.
\end{note}


\subsection{The opp\_makemake Tool}

The \fprog{opp\_makemake} tool can automatically generate a
\texttt{Makefile} for your simulation program, based on the source files
in the current directory or directory tree.
\fprog{opp\_makemake} has several options; \ttt{opp\_makemake -h}
displays help.

The most important options are:

\begin{itemize}
    \item{\ttt{-f, -{}-force} : Force overwriting existing Makefile}
    \item{\ttt{-o filename} : Name of simulation executable or library to be built.}
    \item{\ttt{-O directory, -{}-out directory} : Specifies the name of the output directory tree
                          for out-of-directory build}
    \item{\ttt{-{}-deep} : Generates a "deep" Makefile. A deep Makefile will
                          cover the whole source tree under the make directory,
                          not just files in that directory.}
    \item{\ttt{-r, -{}-recurse} : Causes make to recursively descend into all subdirectories;
                          subdirectories are expected to contain
                          makefiles themselves.}
    \item{\ttt{-X directory, -Xdirectory, -{}-except directory} :
                          With \ttt{-r} and \ttt{-{}-deep} option: ignore the given directory.}
    \item{\ttt{-dsubdir, -d subdir, -{}-subdir subdir} :
                          Causes make to switch to the given directory and invoke
                          a Makefile in that directory.}
    \item{\ttt{-n, -{}-nolink} :  Produce object files but do not create executable or
                          library.}
    \item{\ttt{-s, -{}-make-so} : Build shared library (.so, .dll or .dylib).}
    \item{\ttt{-a, -{}-make-lib} : Create static library (.a or .lib).}
    \item{\ttt{-Idir} :         Additional NED and C++ include directory.}
    \item{\ttt{-Ldir} :         Add a directory to the library path.}
    \item{\ttt{-llibrary} :     Additional library to link against.}
\end{itemize}


\subsection{Basic Use}

Once you have the source files (\ttt{*.ned}, \ttt{*.msg}, \ttt{*.cc},
\ttt{*.h}) in a directory, change the working directory to there and type:

\begin{commandline}
$ opp_makemake
\end{commandline}

This will create a file named \ttt{Makefile}\index{Makefile}. If you
type \fprog{make}, your simulation program should build.


If you already had a \ttt{Makefile} in that directory, \fprog{opp\_makemake}
will refuse to overwrite it. You can force overwriting the old \ttt{Makefile}
with the -f option:

\begin{commandline}
$ opp_makemake -f
\end{commandline}

The name of the output file\index{output!file} will be derived from
the name of the project directory (see later). You can override it
with the \ttt{-o} option:

\begin{commandline}
$ opp_makemake -f -o aloha
\end{commandline}

In addition to the default target that builds the simulation executable,
the \ttt{Makefile} also contains the following targets:

\begin{longtable}{|l|p{8cm}|}
\hline
\tabheadcol
\tbf{Target} & \tbf{Action}\\\hline
all & The default target is to build the simulation executable\\\hline
depend & Adds (or refreshes) dependencies in the \ttt{Makefile}\\\hline
clean &  Deletes all files that were produced by the make process\\\hline
\end{longtable}


\subsection{Debug and Release Builds}

\fprog{opp\_makemake} generates a makefile that can create both release and debug builds.
By default it creates debug version, but it is easy to override this behavior.
Just define the \ttt{MODE} variable on the \fprog{make} command line.

\begin{commandline}
$ make MODE=release
\end{commandline}

If you want to create release builds by default you should use the \ttt{-{}-mode} \textit{mode}
option for \fprog{opp\_makemake} when generating your makefiles.
\begin{commandline}
$ opp_makemake --mode release ...
\end{commandline}

\subsection{Debugging the Makefile}

\fprog{opp\_makemake} generates a makefile that prints only minimal information
during the build process (only the name of the compiled file.) If you want to
see the full compiler commands executed by the makefile, specify \ttt{V=1} as
a command line parameter for the \fprog{make} command.

\begin{commandline}
$ make V=1
\end{commandline}


\subsection{Using External C/C++ Libraries}

If you are using external libraries you should specify the include path for the header files
with the \ttt{-I} \textit{includedir} option. You should specify this option if you are using
anything outside of the source directory tree (except the system and {\opp} headers which are
always included automatically)

To define an external library to be linked with, use \ttt{-Ldir} to specify
the directory of the external library and \ttt{-llibrary} to specify the name of the
external dependency.


\subsection{Building Directory Trees}

It is possible to build a whole source directory tree with a single makefile.
A source tree will generate a single output file (executable or library).
A source directory tree will always have a \ttt{Makefile} in its root,
and source files may be placed anywhere in the tree.

To turn on this option, use the \ttt{opp\_makemake -{}-deep} option.
\ttt{opp\_makemake} will collect all \ttt{.cc} and \ttt{.msg} files from
the whole subdirectory tree, and generate a makefile that covers all.
If you need to exclude a specific directory, use the \ttt{-X exclude/dir/path}
option. (Multiple \ttt{-X} options are accepted.)

An example:

\begin{commandline}
$ opp_makemake -f --deep -X experimental -X obsolete
\end{commandline}


\subsection{Automatic Include Dirs}

If your source tree contains several subdirectories (maybe several levels
deep), it can be annoying to have to specify relative paths for your
header files in your \ttt{.cc} files or you should specify the include path
explicitly by the \ttt{-I includepath} option. \ttt{opp\_makemake} has a
command line option, which adds all directories in the current source tree
to the compiler command line. This option is turned on by default.

\begin{note}
You may turn off this mechanism with the \ttt{-{}-no-deep-includes} option.
\end{note}

The only requirement is that your \ttt{\#include} statements must unambigously
specify the name of the header file. (i.e. if you have two \ttt{common.h}
files, one in subdir1 and the other in subdir2 specify \ttt{\#include
"subdir1/common.h"} instead of \ttt{\#include "common.h"}. If you want to
include a directory which is outside of your source directory tree you
always must specify it with the \ttt{-I external/include/dir} option.

\begin{note}
With bigger projects or with projects that are intended to be used by other
3rd party projects, we recommend not to use this feature. You can never be sure
what include file names the dependent project will use and this can lead to
unexpected errors in the build process.
\end{note}


\subsection{Dependency Handling}

Dependency information is used by the makefile to minimize the time required to
compile and link your project. If your makefile contains up-to date dependency info
-- only files changed since you last compiled your project will be re-compiled or linked.


\fprog{opp\_makemake} automatically adds dependencies to the makefile\index{Makefile!dependencies}.
You can regenerate the dependencies by typing \fprog[make]{make depend} any time.
The warnings during the dependency generation process can be safely ignored.


You may generate and add dependencies to the \ttt{makefile} manually using the \fprog{opp\_makedep}
tool. Use \fprog{opp\_makedep -{}-help} to display the supported command line options.

\begin{note}
The dependency generator does not handle conditional macros and includes. Conditionally included header
files are always added to the file's dependency list.
\end{note}


\subsection{Out-of-Directory Build}

The build system creates object and executable files in a separate directory, called the
\textit{output directory}. The structure of the output directory will be the same as your
source directory structure except that it will be placed in the \ttt{out/configname} directory.
The \ttt{configname} part will mirror your compiler toolchain and build mode settings.
(i.e. The result of a debug build with gcc will be placed in \ttt{out/gcc-debug})


The location of the generated output file is determined by the -O option.
(The default value is 'out', relative to the project root directory):


\begin{commandline}
$ opp_makemake -O ../tmp/obj
\end{commandline}


\begin{note}
The project directory is the first ancestor of the current directory which
contains a \ttt{.project} file).
\end{note}


\begin{note}
Source files (i.e. those created by the \fprog{opp\_msgc} compiler) will be generated in the
source folder rather than in the output folder.
\end{note}


\subsection{Building Shared and Static Libraries}

By default the makefile will create an executable file, but it is also
possible to build shared or static libraries. Shared libraries
are usually a better choice.

Use \ttt{-{}-make-so} to create shared libraries, and \ttt{-{}-make-lib}
to build static libraries. The \ttt{-{}-nolink} option completely avoids
the linking step, which is useful for top-level makefiles that only invoke
other makefiles, or if you want to do the linking manually.

\ifcommercial
\begin{note}
The Microsoft Visual C++ compiler handles shared library (DLL) linking (-s)
differently and requires additional steps to compile and link correctly.
You must choose a \ttt{<symbol>} for your project and annotate each class
and dll-public declaration with \ttt{<symbol>\_API}. If you generate your makefiles
with the \ttt{-p <symbol>} option, \ttt{<symbol>\_EXPORT} macro will be passed to
the compiler causing <symbol>\_API to be defined as \_\_declspec(dllexport) in
your sources. This step allows Visual C++ to correctly generate DLL exports in Windows.
\end{note}
\fi


\subsection{Recursive Builds}


The \ttt{-{}-recurse} option enables recursive make; when you build the simulation, make
descends into the subdirectories and runs make in them too.
By default, \ttt{-{}-recurse} decends into all subdirectories; the -X directory option
can be used to make it ignore certain subdirectories. This option is especially useful
for top level makefiles.


The \ttt{-{}-recurse} option automatically discovers subdirectories, but this
is sometimes inconvenient. Your source directory tree may contain
parts which need their own hand written \ttt{Makefile}. This can happen if
you include source files from an other non {\opp} project. With the \ttt{-d dir}
or \ttt{-{}-subdir dir} option, you can explicitly specify which directories to
recurse into, and also, the directories need not be direct children of the
current directory.


The recursive make options (\ttt{-{}-recurse}, \ttt{-d}, \ttt{-{}-subdir})
imply \ttt{-X}, that is, the directories recursed into will be
automatically excluded from deep makefiles.


You can control the order of traversal by adding dependencies into
the \ttt{makefrag} file (see \ref{sec:makefrag})

\begin{note}
With \ttt{-d}, it is also possible to create infinite recursions.
\fprog{opp\_makemake} cannot detect them, it is your responsibility that
cycles do not occur.
\end{note}


Motivation for recursive builds:
\begin{itemize}
 \item{toplevel makefile}
 \item{integrating sources that have their own makefile}
\end{itemize}


\subsection{Customizing the Makefile}
\label{sec:makefrag}

It is possible to add rules or otherwise customize the generated makefile
by providing a \ttt{makefrag} file. When you run \fprog{opp\_makemake}, it
will automatically insert the content of the \ttt{makefrag} file into the
resulting \ttt{Makefile}. With the \ttt{-i} option, you can also name other
files to be included into the \ttt{Makefile}.

\ttt{makefrag} will be inserted after the definitions but before the first
rule, so it is possible to override existing definitions and add new
ones, and also to override the default target.

\ttt{makefrag} can be useful if some of your source files are generated
from other files (for example, you use generated NED files), or you need
additional targets in your makefile or just simply want to override the
default target in the makefile.

\begin{note}
If you change the content of the \ttt{makefrag} file, you must recreate the
makefile using the \ttt{opp\_makemake} command.
\end{note}

\subsection{Projects with Multiple Source Trees}

In the case of a large project, your source files may be spread across
several directories and your project may generate more than one executable
file (i.e. several shared libraries, examples etc.).

Once you have created your makefiles with \ttt{opp\_makemake} in
every source directory tree, you will need a toplevel makefile.
The toplevel makefile usually calls only the makefiles
recursively in the source directory trees.


\subsection{A Multi-Directory Example}

For a complex example of using \fprog{opp\_makemake}, we will show how to create
the makefiles for the Mobility Framework. First, take a look at the
project's directory structure and find the directories that should be used as
source trees:

\begin{verbatim}
project
    bitmaps
    contrib <-- source tree (build libmfcontrib.so from this dir)
    core <-- source tree (build libmfcore.so from this dir)
    docs
    network
    template
    testSuite <-- source tree (build testSuite executable from this dir)
\end{verbatim}

Additionally, there are dependencies between these output files: \ttt{mfcontrib}
requires \ttt{mfcore} and \ttt{testSuite} requires \ttt{mfcontrib} (and indirectly
\ttt{mfcore}).

First, we create the makefile for the core directory. The makefile will build
a shared lib from all .cc files in the \ttt{core} subtree, and will name it \ttt{mfcore}):

\begin{commandline}
$ cd core && opp_makemake -f --deep --make-so -o mfcore -O out
\end{commandline}

The \ttt{contrib} directory depends on \ttt{mfcore} so we use the \ttt{-L} and \ttt{-l} options
to specify the library we should link with. Note that we must also add
the include directories manually from the \ttt{core} source tree, because autodiscovery works only
in the same source tree:

\begin{commandline}
$ cd contrib && opp_makemake -f --deep --make-so -o mfcontrib -O out \\
  -I../core/basicModules -I../core/utils -L../out/$(CONFIGNAME)/core -lmfcore
\end{commandline}

The \ttt{testSuite} will be created as an executable file which depends on both
\ttt{mfcontrib} and \ttt{mfcore}.

\begin{commandline}
$ cd testSuite && opp_makemake -f --deep -o testSuite -O out
    -I../core/utils -I../core/basicModules -I../contrib/utils \\
    -I../contrib/applLayer -L../out/$(CONFIGNAME)/contrib -lmfcontrib
\end{commandline}

Now let us specify the dependencies between the above directories.
Add the lines below to the \ttt{makefrag} file in the project directory root.

\begin{filelisting}
contrib_dir: core_dir
testSuite_dir: contrib_dir
\end{filelisting}

Now the last step is to create a top-level makefile in the root of the project that
calls the previously created makefiles in the correct order. We will use the
\ttt{-{}-nolink} option, exclude every subdirectory from the build (\ttt{-X.}), and explicitly call
the above makefiles using \ttt{-d dirname}. \ttt{opp\_makemake} will automatically include
the above created \ttt{makefrag} file.

\begin{commandline}
$ opp_makemake -f --nolink -O out -d testSuite -d core -d contrib -X.
\end{commandline}


\ifcommercial
\section{Using Windows and Microsoft Visual C++}

There are only slight differences to the way Microsoft Visual C++
is handled. The main differences are:
\begin{itemize}
  \item{You should use \ttt{opp\_nmakemake} instead of \ttt{opp\_makemake}}
  \item{The generated makefile will be called \ttt{Makefile.vc} by default.}
  \item{Use \ttt{makefrag.vc} instead of \ttt{makefrag}.}
  \item{\ttt{nmake} is used instead of \ttt{make}.}
  \item{The build process is started by \ttt{nmake -f Makefile.vc} instead of \ttt{make}.}
\end{itemize}

Required compiler settings: turn on exception handling and RTTI, and
set stack size to as low as 64K.
\fi

\section{Using Project Features}

Long compile times are often an inconvenience when working with large
{\opp}-based model frameworks. Project features lets you
reduce build times by excluding or disabling parts of the model framework that
you do not use for your simulation study. The word feature refers
to a piece of the project codebase that can be turned off as a whole.

Additional benefits of project features include a less cluttered model palette
in the NED editor, being able to exclude code that does not compile on your system,
and enforcing cleaner separation of unrelated parts in the model framework.

\begin{note}
  A similar effect could also achieved via breaking up the model framework
  into several smaller projects, but that would cause other kinds of inconveniences for
  model developers and users alike.
\end{note}

\subsection{What is a Project Feature}

Features can be defined per project. As already mentioned, a feature is a piece of the
project codebase that can be turned off as a whole, that is, excluded from the C++ sources
(and thus from the build) and also from NED. Feature definitions are typically written
and distributed by the author of the project; end users are only presented with the
option of enabling/disabling those features. A feature definition contains:

\begin{itemize}
  \item{Feature name; for example "UDP" or "Mobility examples".}
  \item{Feature description; This is a few sentences of text describing what the feature
    is or does; for example "Implementation of the UDP protocol".}
  \item{Labels; This is a list of labels or keywords that facilitate grouping or finding features.}
  \item{Initially enabled. This is a boolean flag that determines the initial enablement
    of the feature.}
\item{Required features; Some features may be built on top of others; for example, a HMIPv6
    protocol implementation relies on MIPv6, which in turn relies on IPv6. Thus, HMIPv6 can
    only be enabled if MIPv6 and IPv6 are enabled as well.}
\item{NED packages; This is a list of NED package names that identify the code that implements
    the feature. When you disable the feature, NED types defined in those packages and their
    subpackages will be excluded; also, C++ code in the folders that correspond to the packages
    (i.e. in the same folders as excluded NED files) will also be excluded.}
\item{Extra C++ source folders; If the feature contains C++ code that lives outside NED source
    folders (nontypical), those folders are listed here.}
\item{Compile options, for example \ttt{-DWITH\_IPv6}. When the feature is enabled, the compiler
    options listed here are added to the compiler command line of all C++ files in the project.
    A typical use of this field is defining symbols (\ttt{WITH\_xxx}) that allows you to write conditional code
    that only compiles when a given feature is enabled. Currently only the \ttt{-D} option
    (define symbol) is supported here.}
\item{Linker options. When the feature is enabled, the linker options listed here are added
    to the linker command line. A typical use of this field is linking with additional
    libraries that the feature's code requires, for example libavcodec.
    Currently only the \ttt{-l} option (\ttt{link with library}) is supported here.}
\end{itemize}

\subsection{The \ttt{.oppfeatures} File}
Project features are defined in the \ttt{.oppfeatures} file in your project's
root directory. This is an XML file, and it has to be written by hand
(there is no specialized editor for it).

The root element is \ttt{<features>}, and it may have several \ttt{<feature>}
child elements, each defining a project feature. The fields of a feature
are represented with XML attributes; attribute names are \ttt{id, name,
description, initiallyEnabled, requires, labels, nedPackages,
extraSourceFolders, compileFlags} and \ttt{linkerFlags}. Items within attributes
that represent lists (\ttt{requires}, \ttt{labels}, etc.) are separated by spaces.

Here is an example feature from the INET Framework:
\begin{filelisting}
<feature
  id="TCP_common"
  name="TCP Common"
  description = "The common part of TCP implementations"
  initiallyEnabled = "true"
  requires = "IPv4"
  labels = "Transport"
  nedPackages = "inet.transport.tcp_common
                 inet.applications.tcpapp
                 inet.util.headerserializers.tcp"
  extraSourceFolders = ""
  compileFlags = "-DWITH\_TCP_COMMON"
  linkerFlags = ""
  />
\end{filelisting}

\subsection{How to Introduce a Project Feature}

If you plan to introduce a project feature in your project, here's what you'll need
to do:

\begin{itemize}
    \item{Isolate the code that implements the feature into a separate source directory
      (or several directories). This is because only whole folders can be
      declared as part of a feature, individual source files cannot.}

      \item{Check the remainder of the project. If you find source lines that reference
        code from the new feature, use conditional compilation (\ttt{\#ifdef WITH\_YOURFEATURE})
        to make sure that code compiles (and either works sensibly or throws an error)
        when the new feature is disabled. (Your feature should define the \ttt{WITH\_YOURFEATURE}
        symbol, i.e. \ttt{-DWITH\_YOURFEATURE} will need to be added to the feature compile flags.)}

    \item{Add the feature description into the \ttt{.oppfeatures} file of your project.}

    \item{Test. A rudimentary test is to verify that your project compiles at all, both
      with the new feature enabled and disabled. For such build tests, the
      'Export build tester makefile' function (at the bottom of the 'Project Features'
      property page) can be quite useful: it creates a makefile that builds the
      project in typical feature combinations. (It does not test 2\textsuperscript{N} combinations because
      that's usually prohibitive, only about 2*N+2.)}
\end{itemize}

\subsection{The opp\_featuretool}

The {\opp} IDE allows you to easily enable or disable a feature in the project. The
state of the feature is stored in the \ttt{.oppfeaturestate} file in the project's root
folder. The \ttt{opp\_featuretool} allows you to manipulate or query the state of any
of the project's features.


List all features in the project:
\begin{commandline}
$ opp_featuretool list
\end{commandline}

List all enabled features in the project:
\begin{commandline}
$ opp_featuretool list -e
\end{commandline}

Enable all features:
\begin{commandline}
$ opp_featuretool enable all
\end{commandline}

Disable a specific feature:
\begin{commandline}
$ opp_featuretool disable MyFeature
\end{commandline}

Print all the command line options that should be used with \ttt{opp\_makemake}
to create a makefile that builds the project with the currently enabled features:
\begin{commandline}
$ opp_featuretool makemakeargs
\end{commandline}

Using it directly with the \ttt{opp\_makemake} command (note the back ticks):
\begin{verbatim}
$ opp_makemake --deep `opp_featuretool makemakeargs`
\end{verbatim}

The above command allows you to build the same executable from both the IDE and
the command line.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:
