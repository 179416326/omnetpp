\chapter{Message Definitions}
\label{cha:message-definitions}

\section{Introduction}

In practice, you will need to add various fields to \cclass{cMessage} to
make it useful. For example, if you are modelling packets in communication
networks, you need to have a way to store protocol header fields in message
objects. Since the simulation library is written in C++, the natural way
of extending \cclass{cMessage} is via subclassing it.
However, because for each field you need to write at least
three things (a private data member, a getter and a setter method),
and the resulting class has to integrate with the simulation framework,
writing the necessary C++ code can be a tedious and time-consuming task.

{\opp} offers a more convenient way called \textit{message definitions}.
Message definitions provide a very compact syntax to describe
message contents. C++ code is automatically generated from message
definitions, saving you a lot of typing.

A common source of complaint about code generators in general is
lack of flexibility: if you have a different idea how the generated
code should look, there is little you can do about it.
In {\opp}, however, you can
customize the generated class to any extent you like.
Even if you decide to heavily customize the generated class,
message definitions still save you a great deal of manual work.

The subclassing approach for adding message parameters was originally
suggested by Nimrod Mesika.


\subsection{The First Message Class}

Let us begin with a simple example. Suppose that you need message objects to
carry source and destination addresses as well as a hop count. You could write
a \ttt{mypacket.msg} file with the following contents:

%% FIXME TODO show the "packet" keyword too!

\begin{msg}
message MyPacket
{
     int srcAddress;
     int destAddress;
     int hops = 32;
};
\end{msg}

The task of the \textit{message subclassing compiler} is to generate C++ classes
you can use from your models as well as ``reflection'' classes that allow
Tkenv to inspect these data structures.

If you process \ttt{mypacket.msg} with the message subclassing compiler, it will
create the following files for you: \ttt{mypacket\_m.h} and \ttt{mypacket\_m.cc}.
\ttt{mypacket\_m.h} contains the declaration of the \ttt{MyPacket} C++ class, and
it should be included with your C++ sources where you need to handle
\ttt{MyPacket} objects.

The generated \ttt{mypacket\_m.h} will contain the following class declaration:

\begin{cpp}
class MyPacket : public cMessage {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
\end{cpp}

So in your C++ file, you could use the \ttt{MyPacket} class like this:

\begin{cpp}
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt->setSrcAddress( localAddr );
...
\end{cpp}

The \ttt{mypacket\_m.cc} file contains implementation of the generated \ttt{MyPacket}
class, as well as ``reflection'' code that allows you to inspect these data
structures in the Tkenv GUI. The \ttt{mypacket\_m.cc} file should be compiled and
linked into your simulation. (If you use the \fprog{opp\_makemake} tool
to generate your makefiles, the latter will be automatically taken care of.)


\subsection{What Is Message Subclassing \textit{Not?}}

There can be some confusion about the purpose and
concept of message definitions, so it might be a good idea
to deal with that right here.

It is \textit{\textbf{not:}}

\begin{itemize}
  \item{\textit{... an attempt to reproduce the functionality of C++ with another
     syntax.} Do not look for complex C++ types, templates, conditional compilation, etc.
     Also, it defines \textit{data} only (or rather: an interface to access
     data) -- not any kind of active behaviour.}
  \item{\textit{... a generic class generator.} This is meant for defining message
     contents, and data structure you put in messages.
     Defining methods is not supported on purpose.
     Also, while you can probably (ab)use the syntax to
     generate classes and structs used internally in simple modules,
     this is probably not a good idea.}
\end{itemize}

The goal is to define the \textit{interface} (getter/setter methods) of messages
rather than their implementations in C++. A simple and straightforward
implementation of fields is provided -- if you'd like a different internal
representation for some field, you can have it by customizing the class.

There are questions you might ask:

\begin{itemize}
  \item{\textit{Why doesn't it support \ttt{std::vector} and other STL classes?}
     Well, it does. Message definitions focus on the interface
     (getter/setter methods) of the classes, optionally leaving the implementation
     to you -- so you can implement fields (dynamic array fields)
     using \ttt{std::vector}.
     (This aligns with the idea behind STL -- it was designed to be
     \textit{nuts and bolts} for C++ programs).}
  \item{\textit{Why does it support C++ data types and not octets,
     bytes, bits, etc..?}
     That would restrict the scope of message definitions to networking,
     and {\opp} wants to support other application areas as well.
     Furthermore, the set of necessary concepts to be supported is
     probably not bounded, there would always be new data types to
     be adopted.}
  \item{\textit{Why no embedded classes?} Good question. As it does not
     conflict with the above principles, it might be added someday.}
\end{itemize}



The following sections describe the message syntax and features in detail.


\section{Declaring Enums}

An enum (declared with the \fkeyword{enum} keyword) generates a normal C++
enum, plus creates an object which stores text representations of the
constants. The latter makes it possible to display symbolic names in Tkenv.
An example:

\begin{msg}
enum ProtocolTypes
{
   IP = 1;
   TCP = 2;
};
\end{msg}

Enum values need to be unique.


% It is possible to ``extend'' an enum with new values.
%
% begin{msg}
% // add new values to ProtocolTypes
% enum MoreProtocolTypes extends ProtocolTypes
% {
%   CLNP = 3;
%   TP4 = 4;
% };
% end{msg}

\section{Message Declarations}

\subsection{Basic Use}

You can describe messages with the following syntax:

\begin{msg}
message FooPacket
{
    int sourceAddress;
    int destAddress;
    bool hasPayload;
};
\end{msg}

Processing this description with the message compiler will produce
a C++ header file with a generated class, \ttt{FooPacket}.
\ttt{FooPacket} will be a subclass of \cclass{cMessage}.

For each field in the above description, the generated class will have
a protected data member, a getter and a setter method. The names of the
methods will begin with \ttt{get} and \ttt{set}, followed by the field name
with its first letter converted to uppercase.\footnote{
  To generate getter methods without the \ttt{get} verb, add the
  \ttt{@omitGetVerb(true)} property to the message. It is not recommended
  to use \ttt{@omitGetVerb(true)} though, because it goes against the
  accepted naming convention in {\opp} and models.}
Thus, \ttt{FooPacket} will contain the following methods:

\begin{cpp}
virtual int getSourceAddress() const;
virtual void setSourceAddress(int sourceAddress);

virtual int getDestAddress() const;
virtual void setDestAddress(int destAddress);

virtual bool getHasPayload() const;
virtual void setHasPayload(bool hasPayload);
\end{cpp}

Note that the methods are all declared \fkeyword{virtual} to give you the possibility
of overriding them in subclasses.

Two constructors will be generated: one that optionally accepts object name and
(for \cclass{cMessage} subclasses) message kind, and a copy constructor:

\begin{cpp}
FooPacket(const char *name=NULL, int kind=0);
FooPacket(const FooPacket& other);
\end{cpp}

Appropriate assignment operator (\ffunc{operator=()}) and \ffunc{dup()} methods will
also be generated.

Data types for fields are not limited to \fkeyword{int} and
\fkeyword{bool}. You can use the following primitive types (i.e. primitive
types as defined in the C++ language):

\begin{itemize}
   \item \fkeyword{bool}
   \item \fkeyword{char}, \fkeyword{unsigned char}
   \item \fkeyword{short}, \fkeyword{unsigned short}
   \item \fkeyword{int}, \fkeyword{unsigned int}
   \item \fkeyword{long}, \fkeyword{unsigned long}
   \item \fkeyword{double}
\end{itemize}

Field values are initialized to zero.


\subsection{Initial Values}

You can initialize field values with the following syntax:

\begin{msg}
message FooPacket
{
    int sourceAddress = 0;
    int destAddress = 0;
    bool hasPayload = false;
};
\end{msg}

Initialization code will be placed in the constructor of the generated class.


\subsection{Enum Declarations}

You can declare that an \fkeyword{int} (or other integral type) field
takes values from an enum. The message compiler can then generate code
that allows Tkenv display the symbolic value of the field.

Example:

\begin{msg}
message FooPacket
{
    int payloadType enum(PayloadTypes);
};
\end{msg}

The enum has to be declared separately in the message file.


\subsection{Fixed-Size Arrays}

You can specify fixed size arrays:

\begin{msg}
message FooPacket
{
    long route[4];
};
\end{msg}

The generated getter and setter methods will have an extra \ttt{k} argument,
the array index:

\begin{cpp}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
\end{cpp}

If you call the methods with an index that is out of bounds, an exception
will be thrown.


\subsection{Dynamic Arrays}

If the array size is not known in advance, you can declare the field
to be a dynamic array:

\begin{msg}
message FooPacket
{
    long route[];
};
\end{msg}

In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

\begin{cpp}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
\end{cpp}

The \ffunc{set...ArraySize()} method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

The default array size is zero. This means that you need to call the
\ffunc{set...ArraySize()} before you can start filling array elements.


\subsection{String Members}

You can declare string-valued fields with the following syntax:

\begin{msg}
message FooPacket
{
    string hostName;
};
\end{msg}

The generated getter and setter methods will return and accept \ttt{const char*}
pointers:

\begin{cpp}
virtual const char *getHostName() const;
virtual void setHostName(const char *hostName);
\end{cpp}

The generated object will have its own copy of the string.

Note that a string member is different from a character array,
which is treated as an array of any other type. For example,

\begin{msg}
message FooPacket
{
    char chars[10];
};
\end{msg}

will generate the following methods:

\begin{cpp}
virtual char getChars(unsigned k);
virtual void setChars(unsigned k, char a);
\end{cpp}


\section{Inheritance, Composition}

So far we have discussed how to add fields of primitive types
(\fkeyword{int}, \fkeyword{double}, \fkeyword{char}, ...) to
\cclass{cMessage}. This might be sufficient for simple models, but if you
have more complex models, you will probably need to:

\begin{itemize}
  \item set up a hierarchy of message (packet) classes, that is,
    not only subclass from \cclass{cMessage} but also from your
    own message classes;
  \item use not only primitive types as fields, but also structs,
    classes or typedefs. Sometimes you'll want to use a C++ type
    present in an already existing header file, another time you will
    want a struct or class to be generated by the message
    compiler so that you can benefit from Tkenv inspectors.
\end{itemize}

The following section describes how to do this.


\subsection{Inheritance Among Message Classes}

By default, messages are subclassed from \cclass{cMessage}. However, you can
explicitly specify the base class using the \fkeyword{extends} keyword:

\begin{msg}
message FooPacket extends FooBase
{
    ...
};
\end{msg}

For the example above, the generated C++ code will look like:

\begin{cpp}
class FooPacket : public FooBase { ... };
\end{cpp}

Inheritance also works for structs and classes (see next sections
for details).



\subsection{Defining Classes}

Until now we have used the \fkeyword{message} keyword to define classes, which
implies that the base class is \cclass{cMessage}, either directly or indirectly.

But as part of complex messages, you will need structs and other classes
(rooted or not rooted in \cclass{cObject}) as building blocks.
Classes can be created with the \fkeyword{class} keyword;
structs we'll cover in the next section.

The syntax for defining classes is almost the same as defining messages,
only the \fkeyword{class} keyword is used instead of \fkeyword{message}.

Slightly different code is generated for classes that are rooted in
\cclass{cObject} than for those which are not.
If there is no \ttt{extends}, the generated class will not be
derived from \cclass{cObject}, thus it will not have \ffunc{getName()},
\ffunc{getClassName()}, etc. methods.
To create a class with those methods, you have to explicitly write
\ttt{extends cObject} or \ttt{extends cOwnedObject}.

\begin{msg}
class MyClass extends cOwnedObject
{
    ...
};
\end{msg}



\subsection{Defining Plain C Structs}

You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods''.
(Actually, in the C++ a struct can have methods,
and in general it can do anything a class can.)

The syntax is similar to that of defining messages:

\begin{msg}
struct MyStruct
{
    char array[10];
    short version;
};
\end{msg}

However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. For the definition above, the
following code is generated:

\begin{cpp}
// generated C++
struct MyStruct
{
    char array[10];
    short version;
};
\end{cpp}

A struct can have primitive types or other structs as fields, but it cannot
have string or class fields.

Inheritance is supported for structs:

\begin{msg}
struct Base
{
    ...
};

struct MyStruct extends Base
{
    ...
};
\end{msg}

But because a struct has no member functions, there are limitations:

\begin{itemize}
   \item dynamic arrays are not supported (no place for the array allocation code)
   \item ``generation gap'' or abstract fields (see later) cannot be used,
      because they would build upon virtual functions.
\end{itemize}


\subsection{Using Structs and Classes as Fields}

In addition to primitive types, you can also use another struct or object
as a field. For example, if you have a struct named \ttt{IPAddress},
you can write the following:

\begin{msg}
message FooPacket
{
    IPAddress src;
};
\end{msg}

The \ttt{IPAddress} structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via \ttt{cplusplus \{\{...\}\}} and its type announced
(see Announcing C++ types).

The generated class will contain an \ttt{IPAddress} data member
(that is, \textbf{not} a pointer to an \ttt{IPAddress}).
The following getter and setter methods will be generated:

\begin{cpp}
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
\end{cpp}


\subsection{Pointers}

Pointers are not supported yet.



\section{Using Existing C++ Types}


\subsection{Announcing C++ Types}

If you want to use one of your own types (a class, struct or typedef,
declared in a C++ header) in a message definition, you have to
announce those types to the message compiler. You also have to make sure
that your header file gets included into the generated \ttt{\_m.h} file
so that the C++ compiler can compile it.

Suppose you have an \ttt{IPAddress} structure, defined in an \ttt{ipaddress.h}
file:

\begin{cpp}
// ipaddress.h
struct IPAddress {
    int byte0, byte1, byte2, byte3;
};
\end{cpp}

To be able to use \ttt{IPAddress} in a message definition, the message
file (say \ttt{foopacket.msg}) should contain the following lines:

\begin{msg}
cplusplus {{
#include "ipaddress.h"
}};

struct IPAddress;
\end{msg}

The effect of the first three lines is simply that the \ttt{\#include}
statement will be copied into the generated \ttt{foopacket\_m.h}
file to let the C++ compiler know about the \ttt{IPAddress} class.
The message compiler itself will not try to make sense of the
text in the body of the \ttt{cplusplus \{\{ ... \}\}} directive.

The next line, \ttt{struct IPAddress}, tells the message compiler that
\ttt{IPAddress} is a C++ struct. This information will (among others)
affect the generated code.

Classes can be announced using the \fkeyword{class} keyword:

\begin{msg}
class cSubQueue;
\end{msg}

The above syntax assumes that the class is derived from \cclass{cOwnedObject}
either directly or indirectly. If it is not, the \fkeyword{noncobject}
keyword should be used:

\begin{msg}
class noncobject IPAddress;
\end{msg}

The distinction between classes derived and not derived from \cclass{cOwnedObject}
is important because the generated code differs at places.
The generated code is set up so that if you incidentally
forget the \fkeyword{noncobject} keyword (and thereby mislead the
message compiler into thinking that your class is rooted in
\cclass{cObject} when in fact it is not), you will get a C++ compiler
error in the generated header file.


\section{Customizing the Generated Class}
\label{sec:ch-messages:customizing-generated-class}


\subsection{The Generation Gap Pattern}

Sometimes you need the generated code to do something
more or do something differently than the version generated
by the message compiler.
For example, when setting an integer field named \ttt{payloadLength},
you might also need to adjust the packet length. That is,
the following default (generated) version of the
\ttt{setPayloadLength()} method is not suitable:

\begin{cpp}
void FooPacket::setPayloadLength(int payloadLength)
{
    this->payloadLength = payloadLength;
}
\end{cpp}

Instead, it should look something like this:

\begin{cpp}
void FooPacket::setPayloadLength(int payloadLength)
{
    int diff = payloadLength - this->payloadLength;
    this->payloadLength = payloadLength;
    setBitLength(length() + diff);
}
\end{cpp}

According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the \textit{Generation Gap} design pattern.
It is enabled with the \fprop{@customize} property set on the
message:

\begin{msg}
message FooPacket
{
   @customize(true);
   int payloadLength;
};
\end{msg}

If you process the above code with the message compiler,
the generated code will contain a \ttt{FooPacket\_Base} class
instead of \ttt{FooPacket}. Then you would subclass
\ttt{FooPacket\_Base} to produce \ttt{FooPacket},
while doing your customizations by redefining the necessary methods.

\begin{cpp}
class FooPacket_Base : public cMessage
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
\end{cpp}

There is a minimum amount of code you have to write
for \ttt{FooPacket}, because not everything can be
pre-generated as part of \ttt{FooPacket\_Base}, e.g.
constructors cannot be inherited. This minimum
code is the following (you will find it the generated C++ header
too, as a comment):

\begin{cpp}
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual FooPacket *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
\end{cpp}

Note that it is important that you redefine \ffunc{dup()} and
provide an assignment operator (\ffunc{operator=()}).

So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

\begin{cpp}
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy constructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setBitLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
\end{cpp}



\subsection{Abstract Fields}

The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

For example, this is the situation when you want to store a bitfield
in a single \fkeyword{int} or \fkeyword{short}, and yet you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

You can declare any field to be abstract with the following syntax:

\begin{msg}
message FooPacket
{
   @customize(true);
   abstract bool urgentBit;
};
\end{msg}

For an \fkeyword{abstract} field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

\begin{cpp}
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
\end{cpp}


Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.



\section{Using STL in Message Classes}


%%FIXME ADD THIS SOLUTION:
%%cplusplus {{
%%#include <vector>
%%typedef std::vector<int> IntVector;
%%}}
%%
%%class noncobject IntVector;
%%
%%message X {
%%  fields:
%%    IntVector v;
%%};


You may want to use STL \ttt{vector} or \ttt{stack} classes in your message classes.
This is possible using abstract fields. After all, \ttt{vector} and \ttt{stack}
are representations of a \textit{sequence} -- same abstraction as dynamic-size vectors.
That is, you can declare the field as \ttt{abstract T fld[]}, and provide
an underlying implementation using \ttt{vector<T>}. You can also add methods
to the message class that invoke \ttt{push\_back()}, \ttt{push()}, \ttt{pop()}, etc.
on the underlying STL object.

See the following message declaration:

\begin{msg}
struct Item
{
    int a;
    double b;
}

message STLMessage
{
   @customize(true);
   abstract Item foo[]; // will use vector<Item>
   abstract Item bar[]; // will use stack<Item>
}
\end{msg}

If you compile the above, in the generated code you will only find a couple of
abstract methods for \ttt{foo} and \ttt{bar}, no data members or anything concrete.
You can implement everything as you like. You can write the following C++ file
then to implement \ttt{foo} and \ttt{bar} with \ttt{std::vector} and \ttt{std::stack}:

\begin{cpp}
#include <vector>
#include <stack>
#include "stlmessage_m.h"


class STLMessage : public STLMessage_Base
{
  protected:
    std::vector<Item> foo;
    std::stack<Item> bar;

  public:
    STLMessage(const char *name=NULL, int kind=0) : STLMessage_Base(name,kind) {}
    STLMessage(const STLMessage& other) : STLMessage_Base(other.getName())
        { operator=(other); }
    STLMessage& operator=(const STLMessage& other) {
        if (&other==this) return *this;
        STLMessage_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual STLMessage *dup() {return new STLMessage(*this);}

    // foo methods
    virtual void setFooArraySize(unsigned int size) {}
    virtual unsigned int getFooArraySize() const {return foo.size();}
    virtual Item& getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, const Item& afoo) {foo[k]=afoo;}
    virtual void addToFoo(const Item& afoo) {foo.push_back(afoo);}

    // bar methods
    virtual void setBarArraySize(unsigned int size) {}
    virtual unsigned int getBarArraySize() const {return bar.size();}
    virtual Item& getBar(unsigned int k) {throw cRuntimeException("sorry");}
    virtual void setBar(unsigned int k, const Item& bar)
        { throw cRuntimeException("sorry"); }
    virtual void barPush(const Item& abar) {bar.push(abar);}
    virtual void barPop() {bar.pop();}
    virtual Item& barTop() {return bar.top();}
};

Register_Class(STLMessage);
\end{cpp}

Some additional notes:

\begin{enumerate}
  \item{\ttt{setFooArraySize()}, \ttt{setBarArraySize()} are redundant.}
  \item{\ttt{getBar(int k)} cannot be implemented in a straightforward way
     (\ttt{std::stack} does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.}
  \item{\ttt{setBar(int k, const Item\&)} could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.}
\end{enumerate}

You may regret that the STL \ttt{vector}/\ttt{stack} are not directly exposed.
Well you could expose them (by adding a \ttt{vector<Item>\& getFoo() \{return foo;\}}
method to the class) but this is probably not a good idea.
STL itself was purposefully designed with a low-level approach, to provide
``nuts and bolts'' for C++ programming, and STL is better used in other classes
for internal representation of data.



\section{Summary}

This section attempts to summarize the possibilities that message definitions present.

You can generate:

\begin{itemize}
  \item  classes rooted in \cclass{cObject}
  \item  messages (default base class is \cclass{cMessage})
  \item  classes not rooted in \cclass{cObject}
  \item  plain C structs
\end{itemize}

The following data types are supported for fields:

\begin{itemize}
  \item  primitive types: \ttt{bool}, \ttt{char}, \ttt{short},
    \ttt{int}, \ttt{long}, \ttt{unsigned short}, \ttt{unsigned int},
    \ttt{unsigned long}, \ttt{double}
  \item  \ttt{string}, a dynamically allocated string, presented as \ttt{const char *}
  \item  fixed-size arrays of the above types
  \item  structs, classes (both rooted and not rooted in \cclass{cObject}),
    declared with the message syntax or externally in C++ code
  \item  variable-sized arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
\end{itemize}

Further features:

\begin{itemize}
  \item  fields initialize to zero (except struct members)
  \item  field initializers can be specified (except struct members)
  \item  assigning \ttt{enum}s to variables of integral types.
  \item  inheritance
  \item  customizing the generated class via subclassing (\textit{Generation Gap} pattern)
  \item  abstract fields (for nonstandard storage and calculated fields)
\end{itemize}

Generated code (all generated methods are \ttt{virtual}, although
this is not written out in the following table):

\begin{longtable}{|p{4cm}|p{10cm}|}
\hline
\tabheadcol

\tbf{Field declaration}
    &
\tbf{Generated code}
\\\hline

primitive types
\begin{verbatim}
double field;
\end{verbatim}
     &
\begin{verbatim}
double getField();
void setField(double d);
\end{verbatim}
\\\hline

string type
\begin{verbatim}
string field;
\end{verbatim}
     &
\begin{verbatim}
const char *getField();
void setField(const char *);
\end{verbatim}
\\\hline

fixed-size arrays
\begin{verbatim}
double field[4];
\end{verbatim}
     &
\begin{verbatim}
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
\end{verbatim}

\\\hline

dynamic arrays
\begin{verbatim}
double field[];
\end{verbatim}
     &
\begin{verbatim}
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
\end{verbatim}
\\\hline

customized class
\begin{verbatim}
class Foo {
  @customize(true);
\end{verbatim}
     &
\begin{verbatim}
class Foo_Base { ... };
\end{verbatim}
and you have to write:
\begin{verbatim}
class Foo : public Foo_Base {
   ...
};
\end{verbatim}
\\\hline

abstract fields
\begin{verbatim}
abstract double field;
\end{verbatim}
     &
\begin{verbatim}
double getField() = 0;
void setField(double d) = 0;
\end{verbatim}
\\\hline

\end{longtable}



\subsection{Example Simulations}

Several of the example simulations contain message definitions, for example
Tictoc, Dyna, Routing and Hypercube. For example, in Dyna you will find this:

\begin{itemize}
 \item \ttt{dynapacket.msg} defines \ttt{DynaPacket} and \ttt{DynaDataPacket};
 \item \ttt{dynapacket\_m.h} and \ttt{dynapacket\_m.cc} are produced
   by the message subclassing compiler from it, and they contain
   the generated \ttt{DynaPacket} and \ttt{DynaDataPacket}
   C++ classes (plus code for Tkenv inspectors);
 \item other model files (\ttt{client.cc}, \ttt{server.cc}, ...)
   use the generated message classes
\end{itemize}



\section{What Else Is There in the Generated Code?}

In addition to the message class and its implementation,
the message compiler also generates reflection code which makes it
possible to inspect message contents in Tkenv.
To illustrate why this is necessary, suppose you manually subclass
\cclass{cMessage} to get a new message class. You could write the following:
  \footnote{Note that the code is only for illustration.
  In real code, \ttt{freq} and \ttt{power} should be private members,
  and getter/setter methods should exist to access them.
  Also, the above class definition misses several member functions
  (constructor, assignment operator, etc.) that should be written.}

\begin{cpp}
class RadioMsg : public cMessage
{
  public:
    int freq;
    double power;
    ...
};
\end{cpp}

Now it is possible to use \ttt{RadioMsg} in your simple modules:

\begin{cpp}
RadioMsg *msg = new RadioMsg();
msg->freq = 1;
msg->power = 10.0;
...
\end{cpp}

%% FIXME remove this section?

You will notice one drawback of this solution when you try to use
Tkenv for debugging. While \cclass{cMsgPar}-based message parameters can be viewed in
message inspector windows, fields added via subclassing do not appear
there. The reason is that Tkenv, being just another C++ library in your
simulation program, doesn't know about your C++ instance variables.
The problem cannot be solved entirely within Tkenv, because C++ does not
support ``reflection'' (extracting class information at runtime)
like for example Java does.

There is a solution however: one can supply Tkenv with missing ``reflection''
information about the new class. Reflection info might take the form of
a separate C++ class whose methods return information about the
\ttt{RadioMsg} fields. This descriptor class might look like this:

\begin{cpp}
class RadioMsgDescriptor : public Descriptor
{
  public:
    virtual int getFieldCount() {return 2;}

    virtual const char *getFieldName(int k) {
        const char *fieldname[] = {"freq", "power";}
        if (k<0 || k>=2) return NULL;
        return fieldname[k];
    }

    virtual double getFieldAsDouble(RadioMsg *msg, int k) {
        if (k==0) return msg->freq;
        if (k==1) return msg->power;
        return 0.0; // not found
    }
    //...
};
\end{cpp}

Then you have to inform Tkenv that a \ttt{RadioMsgDescriptor} exists and that it
should be used whenever Tkenv finds messages of type \ttt{RadioMsg} (as it is
currently implemented, whenever the object's \ffunc{getClassName()} method returns
\ttt{"RadioMsg"}). So when you inspect a \ttt{RadioMsg} in your simulation, Tkenv
can use \ttt{RadioMsgDescriptor} to extract and display the values of
the \ttt{freq} and \ttt{power} variables.

The actual implementation is somewhat more complicated than this, but not
much.

