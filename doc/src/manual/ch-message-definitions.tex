\chapter{Message Definitions}
\label{cha:message-definitions}

\section{Introduction}

In practice, you will need to add various fields to \cclass{cMessage} or
\cclass{cPacket} to make them useful. For example, if you are modelling
packets in communication networks, you need to have a way to store protocol
header fields in packets. Since the simulation library is written in C++,
the natural way of extending \cclass{cMessage}/\cclass{cPacket} is via
subclassing them. However, because for each field you need to write at
least three things (a private data member, a getter and a setter method),
and the resulting class has to integrate with the simulation framework,
writing the necessary C++ code can be a tedious and time-consuming task.

{\opp} offers a more convenient way called \textit{message definitions}.
Message definitions offer you a compact syntax to describe message
contents, and the corresponding C++ code is automatically generated from
the definitions. A common complaint about code generators in general is
lack of flexibility: if you have a different idea how the generated code
should look, there is little you can do about it. {\opp}, however, allows
you to extensively customize the generated class. Even if you need to
heavily customize the generated class, message definitions still save you a
great deal of manual work.


\subsection{The First Message Class}

Let us begin with a simple example. Suppose that you need a packet class that
carries source and destination addresses as well as a hop count. You may then
write a \ttt{mypacket.msg} file with the following contents:

\begin{msg}
packet MyPacket
{
     int srcAddress;
     int destAddress;
     int remainingHops = 32;
};
\end{msg}

It is the task of the \textit{message compiler} is to generate C++ classes
you can use from your models. The message compiler is normally invoked
automatically for your \ttt{.msg} files during build.

When the message compiler processes \ttt{mypacket.msg}, it creates the
following files: \ttt{mypacket\_m.h} and \ttt{mypacket\_m.cc}. The
generated \ttt{mypacket\_m.h} will contain the following class declaration:

\begin{cpp}
class MyPacket : public cPacket {
    ...
    virtual int getSrcAddress() const;
    virtual void setSrcAddress(int srcAddress);
    ...
};
\end{cpp}

In your C++ files, you can use the \ttt{MyPacket} class by including the
generated header file:

\begin{cpp}
#include "mypacket_m.h"

...
MyPacket *pkt = new MyPacket("pkt");
pkt->setSrcAddress(localAddr);
...
\end{cpp}

The \ttt{mypacket\_m.cc} file will contain implementation of the generated \ttt{MyPacket}
class as well as ``reflection'' code that allows you to inspect these data
structures in the Tkenv GUI. The \ttt{mypacket\_m.cc} file should be compiled and
linked into your simulation; this is normally taken care of automatically.

The following sections describe the message syntax and features in detail.



\section{Messages and Packets}

\subsection{Defining Messages and Packets}

Message and packet contents can be defined in a syntax resembling C structs.
The keyword can be \fkeyword{message} or \fkeyword{packet}; they cause
cause the generated C++ class to be derived from \cclass{cMessage} and
\cclass{cPacket}, respectively. (Further keywords, \fkeyword{class} and
\fkeyword{struct}, will be covered later.)

An example packet definition:

\begin{msg}
packet FooPacket
{
    int sourceAddress;
    int destAddress;
    bool hasPayload;
};
\end{msg}

Saving the above code into a \ttt{foopacket.msg} file and processing it
with the message compiler will produce the files \ttt{foopacket\_m.h}
and \ttt{foopacket\_m.cc}. The header file will contain the declaration of
the generated C++ class.

The generated class will have a constructor that optionally accepts object
name and message kind, and also a copy constructor. An assignment operator
(\ffunc{operator=()}) and cloning method (\ffunc{dup()}) will also be
generated.

\begin{cpp}
class FooPacket : public cPacket
{
  public:
    FooPacket(const char *name=NULL, int kind=0);
    FooPacket(const FooPacket& other);
    FooPacket& operator=(const FooPacket& other);
    virtual FooPacket *dup() const;
    ...
\end{cpp}

For each field in the above description, the generated class will have a
protected data member, and a public getter and setter method. The names of
the methods will begin with \ttt{get} and \ttt{set}, followed by the field
name with its first letter converted to uppercase. Thus, \ttt{FooPacket}
will contain the following methods:

\begin{cpp}
    virtual int getSourceAddress() const;
    virtual void setSourceAddress(int sourceAddress);
    virtual int getDestAddress() const;
    virtual void setDestAddress(int destAddress);
    virtual bool getHasPayload() const;
    virtual void setHasPayload(bool hasPayload);
\end{cpp}

Note that the methods are all declared \fkeyword{virtual} to give you the possibility
of overriding them in subclasses.

String fields can also be declared:

\begin{msg}
packet HttpRequestMessage
{
    string method; // "GET", "POST", etc.
    string resource;
};
\end{msg}

The generated getter and setter methods will return and accept \ttt{const char*}
pointers:

\begin{cpp}
virtual const char *getMethod() const;
virtual void setMethod(const char *method);
virtual const char *getResource() const;
virtual void setResource(const char *resource);
\end{cpp}

The generated object will have its own copy of the string, so it not only stores
the \ttt{const char*} pointer.


\subsection{Field Data Types}

Data types for fields are not limited to \fkeyword{int} and
\fkeyword{bool}. You can use several C/C++ and other data types:

\begin{itemize}
   \item logical: \fkeyword{bool}
   \item integral types: \fkeyword{char}, \fkeyword{short}, \fkeyword{int},
      \fkeyword{long}; and their unsigned versions \fkeyword{unsigned char},
      \fkeyword{unsigned short}, \fkeyword{unsigned int}, \fkeyword{unsigned long}
   \item floating-point types: \fkeyword{float}, \fkeyword{double}
   \item C99-style fixed-size integral types: \fkeyword{int8\_t}, \fkeyword{int16\_t},
      \fkeyword{int32\_t}, \fkeyword{int64\_t}; and their unsigned versions
      \fkeyword{uint8\_t}, \fkeyword{uint16\_t}, \fkeyword{uint32\_t}, \fkeyword{uint64\_t};
      \footnote{These type names are accepted without the \ttt{\_t} suffix as well,
      but you are responsible to ensure that the generated code compiles, i.e. the
      shortened type names must be defined in a header file you include.}
   \item {\opp} simulation time: \fkeyword{simtime\_t}
   \item \fkeyword{string}. Getters and setters use the \ttt{const char*} data type;
      \ttt{NULL} is not allowed. The object will store a copy of the string,
      not just the pointer.
   \item structs and classes, defined in message files or elsewhere
\end{itemize}

Numeric fields are initialized to zero, and string fields to empty string.


\subsection{Initial Values}

You can initialize field values with the following syntax:

\begin{msg}
packet FooPacket
{
    int sourceAddress = 0;
    int destAddress = 0;
    bool hasPayload = false;
};
\end{msg}

Initialization code will be placed in the constructor of the generated class.


\subsection{Enums}

You can declare that an \fkeyword{int} (or other integral type) field
takes values from an enum. The message compiler can then generate code
that allows Tkenv display the symbolic value of the field.

Example:

\begin{msg}
packet FooPacket
{
    int payloadType @enum(PayloadType);
};
\end{msg}

The enum itself has to be declared separately. An enum is declared with
the \fkeyword{enum} keyword, using the following syntax:

\begin{msg}
enum PayloadType
{
   NONE = 0;
   UDP = 1;
   TCP = 2;
   SCTP = 3;
};
\end{msg}

Enum values need to be unique.

The message compiler translates an enum into a normal C++ enum, plus
creates an object which stores text representations of the constants. The
latter makes it possible to display symbolic names in Tkenv.

If the enum to be associated with a field comes from a different message file,
then the enum must be announced and its generated header file be included.
An example:

\begin{msg}
cplusplus {{
#include "PayloadType_m.h"
}}

enum PayloadType;

packet FooPacket
{
    int payloadType @enum(PayloadType);
};
\end{msg}



\subsection{Fixed-Size Arrays}

You can specify fixed size arrays:

\begin{msg}
packet SourceRoutedPacket
{
    int route[4];
};
\end{msg}

The generated getter and setter methods will have an extra \ttt{k} argument,
the array index:

\begin{cpp}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
\end{cpp}

If you call the methods with an index that is out of bounds, an exception
will be thrown.


\subsection{Variable-Size Arrays}

If the array size is not known in advance, you can declare the field
to have a variable size:

\begin{msg}
packet SourceRoutedPacket
{
    int route[];
};
\end{msg}

In this case, the generated class will have two extra methods in addition
to the getter and setter methods: one for setting the array size, and another
one for returning the current array size.

\begin{cpp}
virtual long getRoute(unsigned k) const;
virtual void setRoute(unsigned k, long route);
virtual unsigned getRouteArraySize() const;
virtual void setRouteArraySize(unsigned n);
\end{cpp}

The \ffunc{set...ArraySize()} method internally allocates a new array. Existing
values in the array will be preserved (copied over to the new array.)

The default array size is zero. This means that you need to call
\ffunc{set...ArraySize()} with a nonzero argument before you can
start filling array elements.


\subsection{Using Structs and Classes as Fields}

In addition to primitive types, you can also use another struct or object
as a field. For example, if you have a struct named \ttt{IPAddress},
you can write the following:

\begin{msg}
packet FooPacket
{
    IPAddress src;
};
\end{msg}

The \ttt{IPAddress} structure must be known in advance to the message compiler;
that is, it must either be a struct or class defined earlier in the message
description file, or it must be a C++ type with its header file
included via \ttt{cplusplus \{\{...\}\}} and its type announced
(see Announcing C++ types).

The generated class will contain an \ttt{IPAddress} data member
(that is, \textbf{not} a pointer to an \ttt{IPAddress}).
The following getter and setter methods will be generated:

\begin{cpp}
virtual const IPAddress& getSrc() const;
virtual void setSrc(const IPAddress& src);
\end{cpp}


\subsection{Pointer Fields}
\label{sec:ch-msg-defs:pointers-fields}

Pointer fields where the setters and the destructor would delete the
previous value are not supported yet. However, there are workarounds, as
described below.

You can create a typedef for the pointer and use the typedef name as field
type. Then you'll get a plain pointer field where neither the setter nor
the destructor deletes the old value (which is a likely memory leak).

Example (section \ref{sec:ch-msg-defs:using-cpp-types} will explain the
details):

\begin{msg}
cplusplus {{ typedef Foo *FooPtr; }} // C++ typedef
class noncobject FooPtr; // announcement for the message compiler

packet Bar
{
    FooPtr fooPtr;  // leaky pointer field
};
\end{msg}

Then you can customize the class via C++ inheritance and reimplement
the setter methods in C++, inserting the missing \ttt{delete} statements.
Customization via C++ inheritance will be described in section
\ref{sec:ch-msg-defs:customizing-via-inheritance}.


\subsection{Inheritance}

By default, messages are subclassed from \cclass{cMessage} or
\cclass{cPacket}. However, you can explicitly specify the base class
using the \fkeyword{extends} keyword:

\begin{msg}
packet Ieee80211DataFrame extends Ieee80211Frame
{
    ...
};
\end{msg}

For the example above, the generated C++ code will look like:

\begin{cpp}
class Ieee80211DataFrame : public Ieee80211Frame { ... };
\end{cpp}

Inheritance also works for structs and classes (see next sections
for details).

Only single inheritance is supported.



\section{Classes}
\label{sec:ch-msg-defs:defining-classes}

Until now we have only seen message and packet descriptions, which generate
classes derived from \cclass{cMessage} or \cclass{cPacket}. However, it is
also useful to be able to generate classes and structs, for building blocks
for messages, as control info objects (see \cclass{cMessage}'s
\ffunc{setControlInfo()} and for other purposes. This section covers
classes; structs will be described in the next section.

The syntax for defining classes is almost the same as defining messages,
only the \fkeyword{class} keyword is used instead of \fkeyword{message} /
\fkeyword{packet}. The base class can be specified with the \fkeyword{extends}
keyword, and defaults to \cclass{cObject}.

\begin{note}
\cclass{cObject} has no data members. It only defines virtual methods so
the only overhead would be the vtable, but the generated class already has
a vtable because of generated methods are also virtual. In other words,
\cclass{cObject} adds zero overhead to the generated class, and there is no
reason not to always use it as base class.
\end{note}

Examples:

\begin{msg}
class TCPCommand  // same as "extends cObject"
{
    ...
};

class TCPOpenCommand extends TCPCommand
{
    ...
};
\end{msg}

The generated code:

\begin{cpp}
// generated C++
class TCPCommand : public cObject
{
    ...
};

class TCPOpenCommand : public TCPCommand
{
    ...
};
\end{cpp}


\section{Structs}
\label{sec:ch-msg-defs:defining-structs}

You can define C-style structs to be used as fields in message classes,
``C-style'' meaning ``containing only data and no methods'' (in contrast to
C++ where a struct is just a class with a different default member
visibility.)

The syntax is similar to that of defining messages:

\begin{msg}
struct Place
{
    int type;
    string description;
    double coords[3];
};
\end{msg}

However, the generated code is different. The generated struct has
no getter or setter methods, instead the fields are represented
by public data members. The following code is generated from
the above definition:

\begin{cpp}
// generated C++
struct Place
{
    int type;
    opp_string description; // minimal string class that wraps a const char*
    double coords[3];
};
\end{cpp}

Note that \fkeyword{string} fields are generated with the \ttt{opp\_string}
C++ type, which is a minimalistic string class that wraps \ttt{const char*}
and takes care of allocation/deallocation. It was chosen instead of
\ttt{std::string} because of its significantly smaller memory footprint
(the sizeof of \ttt{opp\_string} is the same as that of a \ttt{const char*}
pointer).

Inheritance is supported for structs:

\begin{msg}
struct Base
{
    ...
};

struct Extended extends Base
{
    ...
};
\end{msg}

However, because a struct has no member functions, there are limitations:

\begin{itemize}
   \item variable-size arrays are not supported;
   \item customization via inheritance and \fkeyword{abstract} fields
      (see later in \ref{sec:ch-msg-defs:customizing-via-inheritance})
      cannot be used;
   \item cannot have classes subclassed from \cclass{cOwnedObject} as fields,
      because structs cannot be owners.
\end{itemize}



\section{Literal C++ Blocks}
\label{sec:ch-msg-defs:cplusplus-blocks}

It is possible to have C++ code placed directly into the generated code,
more precisely, into the generated header file. This is done with the
\fkeyword{cplusplus} keyword and a double curly braces. As we'll see in
later sections, \fkeyword{cplusplus} blocks are customarily used to insert
\ttt{\#include} directives, typedefs, \ttt{\#define} macros and other
elements into the generated header.

Example:

\begin{msg}
cplusplus {{
#include <vector>
#include "foo.h"
#define FOO_VERSION 4
typedef std::vector<int> IntVector;
}}
\end{msg}

The message compiler does not try to make sense of the text in the body of
the \ttt{cplusplus} block, it just simply copies it into the generated
header file.


\section{Using C++ Types}
\label{sec:ch-msg-defs:using-cpp-types}

The message compile only knows about the types defined within the same msg
file, and the built-in types. To be able to use other types, for example
for fields or as base class, you need to do two things:

\begin{enumerate}
   \item Let the message compiler know about the type by announcing it; and
   \item Make sure its C++ declaration will be available at compile time
\end{enumerate}

The next two sections describe how to do each.


\subsection{Announcing Types to the Message Compiler}
\label{sec:ch-msg-defs:announcing-types}

If you want to use a C++ type (a class, struct or typedef) not
declared with the message syntax in the same file, you have to
announce those types to the message compiler.

Type annoucements have a similar syntax to those in C++:

\begin{msg}
struct Point;
class PrioQueue;  // implies it is derived from cOwnedObject! see below
message TimeoutMessage;
packet TCPSegment;
\end{msg}

However, with the \fkeyword{class} keyword, the message compiler needs to
know the whether the class is derived (directly or indirectly) from
\cclass{cOwnedObject}, \cclass{cNamedObject}, \cclass{cObject} or none of
the above, because it affects code generation. The ancestor class can be
declared with the \fkeyword{extends} keyword, like this:

\begin{msg}
class IPAddress extends void;  // does not extend any "interesting" class
class ModulePtr extends void;  // ditto
class IntVector extends void;  // ditto
class IPCtlInfo extends cObject;
class FooOption extends cNamedObject;
class PrioQueue extends cOwnedObject;
class IPAddrExt extends IPAddress;  // also OK: IPAddress has been announced
\end{msg}

An alternative to \ttt{extends void} is the \fkeyword{noncobject} modifier:

\begin{msg}
class noncobject IPAddress; // same as "extends void"
\end{msg}

By default, that is, when \fkeyword{extends} is missing, it is assumed
that the class is derived from \cclass{cOwnedObject}. Thus, the following
two announcements are equivalent:

\begin{msg}
class PrioQueue;
class PrioQueue extends cOwnedObject;
\end{msg}

\begin{note}
Notice that this default is inconsistent with the default base class for
generating classes, which is \cclass{cObject} (see
\ref{sec:ch-msg-defs:defining-classes}). The reason why type announcements
assume \cclass{cOwnedObject} is that it is safer: a mistake will surface in
the form of a compile error and will not remain hidden until it causes some
obscure runtime error.
\end{note}


\subsection{Making the C++ Declarations Available}

In addition to announcing types to the message compiler, you also have make
sure their C++ declarations will be available at compile time so that the
generated code will actually compile. This can be achieved with
\fkeyword{cplusplus} blocks that let you inject includes, typedefs,
class/struct declarations, etc. into the generated header file:

\begin{msg}
cplusplus {{
#include "IPAddress.h"
typedef std::vector<int> IntVector;
}}
\end{msg}

You need a \fkeyword{cplusplus} block even if the desired types are defined
in a (different) message file, to include the generated header file.
It is currently not supported to import types from other message files directly.
Example:

\begin{msg}
cplusplus {{
#include "TCPSegment_m.h"  // make types defined in TCPSegment.msg available
                           // for the C++ compiler
}}
\end{msg}


\subsection{Putting it Together}

Suppose you have header files and message files that define various types:

\begin{cpp}
// IPAddress.h
class IPAddress {
   ...
};
\end{cpp}

\begin{cpp}
// Location.h
struct Location {
    double lon;
    double lat;
};
\end{cpp}

\begin{msg}
// AppPacket.msg
packet AppPacket {
   ...
}
\end{msg}

To be able to use the above types in a message definition (and two more,
an \ttt{IntVector} and a module pointer), the message file should contain
the following lines:

\begin{msg}
cplusplus {{
#include <vector>
#include "IPAddress.h"
#include "Location.h"
#include "AppPacket_m.h"
typedef std::vector<int> IntVector;
typedef cModule *ModulePtr;
}};

class noncobject IPAddress;
struct Location;
packet AppPacket;
class noncobject IntVector;
class noncobject ModulePtr;

packet AppPacketExt extends AppPacket {
    IPAddress destAddress;
    Location senderLocation;
    IntVector data;
    ModulePtr originatingModule;
}
\end{msg}



\section{Customizing the Generated Class}
\label{sec:messages:customizing-generated-class}


\subsection{Customizing Method Names}

The names and some other properties of generated methods can be influenced
with metadata annotations (properties).

The names of the getter and setter methods can be changed with the
\fprop{@getter} and \fprop{@setter} properties. For variable-size array
fields, the names of array size getter and setter methods can be changed
with \fprop{@sizeGetter} and \fprop{@sizeSetter}.

In addition, the data type for the array size (by default \ttt{unsigned
int}) can be changed with \fprop{@sizetype} property.

Consider the following example:

\begin{msg}
packet IPPacket {
    int ttl @getter(getTTL) @setter(setTTL);
    Option options[] @sizeGetter(getNumOptions)
                     @sizeSetter(setNumOptions)
                     @sizetype(short);
}
\end{msg}

The generated class would have the following methods (note the differences
from the default names \ttt{getTtl()}, \ttt{setTtl()}, \ttt{getOptions()},
\ttt{setOptions()}, \ttt{getOptionsArraySize()}, \ttt{getOptionsArraySize()};
also note that indices and array sizes are now \ttt{short}):

\begin{cpp}
virtual int getTTL() const;
virtual void setTTL(int ttl);
virtual const Option& getOption(short k) const;
virtual void setOption(short k, const Option& option);
virtual short getNumOptions() const;
virtual void setNumOptions(short n);
\end{cpp}

In some older simulation models you may also see the use of the
\fprop{@omitGetVerb} class property. This property tells the message
compiler to generate getter methods without the ``get'' prefix, e.g. for a
\ttt{sourceAddress} field it would generate a \ttt{sourceAddress()} method
instead of the default \ttt{getSourceAddress()}. It is not recommended to
use \ttt{@omitGetVerb} in new models, because it is inconsistent with the
accepted naming convention.

%% TODO \fprop{nopack}  (also a field property)


\subsection{Customizing the Class Via Inheritance}

Sometimes you need the generated code to do something
more or do something differently than the version generated
by the message compiler.
For example, when setting an integer field named \ttt{payloadLength},
you might also need to adjust the packet length. That is,
the following default (generated) version of the
\ttt{setPayloadLength()} method is not suitable:

\begin{cpp}
void FooPacket::setPayloadLength(int payloadLength)
{
    this->payloadLength = payloadLength;
}
\end{cpp}

Instead, it should look something like this:

\begin{cpp}
void FooPacket::setPayloadLength(int payloadLength)
{
    int delta = payloadLength - this->payloadLength;
    this->payloadLength = payloadLength;
    setByteLength(getByteLength() + delta);
}
\end{cpp}

According to common belief, the largest drawback of generated code
is that it is difficult or impossible to fulfill such wishes.
Hand-editing of the generated files is worthless, because
they will be overwritten and changes will be lost
in the code generation cycle.

However, object oriented programming offers a solution.
A generated class can simply be customized by subclassing
from it and redefining whichever methods need to be
different from their generated versions. This practice
is known as the \textit{Generation Gap} design pattern.
It is enabled with the \fprop{@customize} property set on the
message:

\begin{msg}
packet FooPacket
{
   @customize(true);
   int payloadLength;
};
\end{msg}

If you process the above code with the message compiler,
the generated code will contain a \ttt{FooPacket\_Base} class
instead of \ttt{FooPacket}. Then you would subclass
\ttt{FooPacket\_Base} to produce \ttt{FooPacket},
while doing your customizations by redefining the necessary methods.

\begin{cpp}
class FooPacket_Base : public cPacket
{
  protected:
    int src;
    // make constructors protected to avoid instantiation
    FooPacket_Base(const char *name=NULL);
    FooPacket_Base(const FooPacket_Base& other);
  public:
    ...
    virtual int getSrc() const;
    virtual void setSrc(int src);
};
\end{cpp}

There is a minimum amount of code you have to write
for \ttt{FooPacket}, because not everything can be
pre-generated as part of \ttt{FooPacket\_Base}, e.g.
constructors cannot be inherited. This minimum
code is the following (you will find it the generated C++ header
too, as a comment):

\begin{cpp}
class FooPacket : public FooPacket_Base
{
  public:
    FooPacket(const char *name=NULL) : FooPacket_Base(name) {}
    FooPacket(const FooPacket& other) : FooPacket_Base(other) {}
    FooPacket& operator=(const FooPacket& other)
        {FooPacket_Base::operator=(other); return *this;}
    virtual FooPacket *dup() {return new FooPacket(*this);}
};

Register_Class(FooPacket);
\end{cpp}

Note that it is important that you redefine \ffunc{dup()} and
provide an assignment operator (\ffunc{operator=()}).

So, returning to our original example about payload length
affecting packet length, the code you'd write is the following:

\begin{cpp}
class FooPacket : public FooPacket_Base
{
    // here come the mandatory methods: constructor,
    // copy constructor, operator=(), dup()
    // ...

    virtual void setPayloadLength(int newlength);
}

void FooPacket::setPayloadLength(int newlength)
{
    // adjust message length
    setBitLength(length()-getPayloadLength()+newlength);

    // set the new length
    FooPacket_Base::setPayloadLength(newlength);
}
\end{cpp}



\subsection{Abstract Fields}

The purpose of abstract fields is to let you to override
the way the value is stored inside the class,
and still benefit from inspectability in Tkenv.

For example, this is the situation when you want to store a bitfield
in a single \fkeyword{int} or \fkeyword{short}, and yet you want
to present bits as individual packet fields.
It is also useful for implementing computed fields.

You can declare any field to be abstract with the following syntax:

\begin{msg}
packet FooPacket
{
   @customize(true);
   abstract bool urgentBit;
};
\end{msg}

For an \fkeyword{abstract} field, the message compiler generates
no data member, and generated getter/setter methods will be pure
virtual:

\begin{cpp}
virtual bool getUrgentBit() const = 0;
virtual void setUrgentBit(bool urgentBit) = 0;
\end{cpp}


Usually you'll want to use abstract fields together with
the Generation Gap pattern, so that you can immediately
redefine the abstract (pure virtual) methods and
supply your implementation.



\section{Using STL in Message Classes}


%%FIXME ADD THIS SOLUTION:
%%cplusplus {{
%%#include <vector>
%%typedef std::vector<int> IntVector;
%%}}
%%
%%class noncobject IntVector;
%%
%%message X {
%%  fields:
%%    IntVector v;
%%};


You may want to use STL \ttt{vector} or \ttt{stack} classes in your message classes.
This is possible using abstract fields. After all, \ttt{vector} and \ttt{stack}
are representations of a \textit{sequence} -- same abstraction as variable-size vectors.
That is, you can declare the field as \ttt{abstract T fld[]}, and provide
an underlying implementation using \ttt{vector<T>}. You can also add methods
to the message class that invoke \ttt{push\_back()}, \ttt{push()}, \ttt{pop()}, etc.
on the underlying STL object.

See the following message declaration:

\begin{msg}
struct Item
{
    int a;
    double b;
}

message STLMessage
{
   @customize(true);
   abstract Item foo[]; // will use vector<Item>
   abstract Item bar[]; // will use stack<Item>
}
\end{msg}

If you compile the above, in the generated code you will only find a couple of
abstract methods for \ttt{foo} and \ttt{bar}, no data members or anything concrete.
You can implement everything as you like. You can write the following C++ file
then to implement \ttt{foo} and \ttt{bar} with \ttt{std::vector} and \ttt{std::stack}:

\begin{cpp}
#include <vector>
#include <stack>
#include "stlmessage_m.h"


class STLMessage : public STLMessage_Base
{
  protected:
    std::vector<Item> foo;
    std::stack<Item> bar;

  public:
    STLMessage(const char *name=NULL, int kind=0) : STLMessage_Base(name,kind) {}
    STLMessage(const STLMessage& other) : STLMessage_Base(other.getName())
        { operator=(other); }
    STLMessage& operator=(const STLMessage& other) {
        if (&other==this) return *this;
        STLMessage_Base::operator=(other);
        foo = other.foo;
        bar = other.bar;
        return *this;
    }
    virtual STLMessage *dup() {return new STLMessage(*this);}

    // foo methods
    virtual void setFooArraySize(unsigned int size) {}
    virtual unsigned int getFooArraySize() const {return foo.size();}
    virtual Item& getFoo(unsigned int k) {return foo[k];}
    virtual void setFoo(unsigned int k, const Item& afoo) {foo[k]=afoo;}
    virtual void addToFoo(const Item& afoo) {foo.push_back(afoo);}

    // bar methods
    virtual void setBarArraySize(unsigned int size) {}
    virtual unsigned int getBarArraySize() const {return bar.size();}
    virtual Item& getBar(unsigned int k) {throw cRuntimeException("sorry");}
    virtual void setBar(unsigned int k, const Item& bar)
        { throw cRuntimeException("sorry"); }
    virtual void barPush(const Item& abar) {bar.push(abar);}
    virtual void barPop() {bar.pop();}
    virtual Item& barTop() {return bar.top();}
};

Register_Class(STLMessage);
\end{cpp}

Some additional notes:

\begin{enumerate}
  \item{\ttt{setFooArraySize()}, \ttt{setBarArraySize()} are redundant.}
  \item{\ttt{getBar(int k)} cannot be implemented in a straightforward way
     (\ttt{std::stack} does not support accessing elements by index).
     It could still be implemented in a less efficient way using STL iterators,
     and efficiency does not seem to be major problem because only Tkenv
     is going to invoke this function.}
  \item{\ttt{setBar(int k, const Item\&)} could not be implemented, but this
     is not particularly a problem. The exception will materialize in a
     Tkenv error dialog when you try to change the field value.}
\end{enumerate}

You may regret that the STL \ttt{vector}/\ttt{stack} are not directly exposed.
Well, you could expose them (by adding a \ttt{vector<Item>\& getFoo() \{return foo;\}}
method to the class) but this is probably not a good idea.
STL itself was purposefully designed with a low-level approach, to provide
``nuts and bolts'' for C++ programming, and STL is better used in other classes
for internal representation of data.



\section{Descriptor Classes}

For each generated class and struct, the message compiler generates an
associated descriptor class. The descriptor class carries ``reflection''
information about the new class, and makes it possible to inspect message
contents in Tkenv.

The descriptor class encapsulates virtually all information that the
original message definition contains, and exposes it via member functions.
It has methods for enumerating fields (\ffunc{getFieldCount()},
\ffunc{getFieldName()}, \ffunc{getFieldTypeString()}, etc.), for getting
and setting a field's value in an instance of the class
(\ffunc{getFieldAsString()}, \ffunc{setFieldAsString()}), for exploring the
class hierarchy (\ffunc{getBaseClassDescriptor()}, etc.), for accessing
class and field properties, and for similar tasks. When you inspect a
message or packet in the simulation, Tkenv can uses the associated
descriptor class to extract and display the field values.

The \fprop{@descriptor} class property can be used to control the generation
of the descriptor class. \ttt{@descriptor(readonly)} instructs the message
compiler not to generate field setters for the descriptor, and
\ttt{@descriptor(false)} instructs it not to generate a dscription class
for the class at all.

It is also possible to the (or abuse) the message compiler for generating a
descriptor class for an existing class. (This can be useful for making your
class inspectable in Tkenv.) To do that, write a message definition for
your existing class (for example, if it has \ttt{int getFoo()} and
\ttt{setFoo(int)} methods, add an \ttt{int foo} field to the message
definition), and mark it with \ttt{@existingClass(true)}. This will the
message compiler that it should not generate the actual class it already
exists), only the descriptor class.



\section{Summary}

This section summarizes the possibilities offered by message definitions.

Base functionality:

\begin{itemize}
  \item  generation of classes and plain C structs from concise descriptions
  \item  default base classes:
    \cclass{cPacket} (with the \fkeyword{packet} keyword),
    \cclass{cMessage} (with the \fkeyword{message} keyword), or
    \cclass{cObject} (with the \fkeyword{class} keyword)
\end{itemize}

The following data types are supported for fields:

\begin{itemize}
  \item  primitive types:
    \ttt{bool}, \ttt{char}, \ttt{short}, \ttt{int}, \ttt{long};
    \ttt{unsigned char}, \ttt{unsigned short}, \ttt{unsigned int}, \ttt{unsigned long};
    \ttt{int8\_t}, \ttt{int16\_t}, \ttt{int32\_t}, \ttt{int64\_t};
    \ttt{uint8\_t}, \ttt{uint16\_t}, \ttt{uint32\_t}, \ttt{uint64\_t};
    \ttt{float}, \ttt{double}; \ttt{simtime\_t}
  \item  \ttt{string}, a dynamically allocated string, presented as \ttt{const char *}
  \item  structs and classes, declared with the message syntax or in C++ code
  \item  fixed-size arrays of the above types
  \item  variable-size arrays of the above types (stored as a dynamically
    allocated array plus an integer for the array size)
\end{itemize}

Further features:

\begin{itemize}
  \item  fields initialize to zero (except for struct/class fields)
  \item  field initializers can be specified (except for struct/class fields)
  \item  associating fields of integral types with enums
  \item  inheritance
  \item  namespaces
  \item  customization of generated method names
  \item  customization of the generated class via subclassing (\textit{Generation Gap} pattern)
  \item  abstract fields (for nonstandard storage and calculated fields)
  \item  generation of descriptor objects that encapsulate reflection information
\end{itemize}

Generated code (all generated methods are \ttt{virtual}, although
this is not written out in the following table):

\begin{longtable}{|p{4cm}|p{10cm}|}
\hline
\tabheadcol

\tbf{Field declaration}
    &
\tbf{Generated code}
\\\hline

primitive types
\begin{verbatim}
double field;
\end{verbatim}
     &
\begin{verbatim}
double getField();
void setField(double d);
\end{verbatim}
\\\hline

string type
\begin{verbatim}
string field;
\end{verbatim}
     &
\begin{verbatim}
const char *getField();
void setField(const char *);
\end{verbatim}
\\\hline

fixed-size arrays
\begin{verbatim}
double field[4];
\end{verbatim}
     &
\begin{verbatim}
double getField(unsigned k);
void setField(unsigned k, double d);
unsigned getFieldArraySize();
\end{verbatim}

\\\hline

variable-size arrays
\begin{verbatim}
double field[];
\end{verbatim}
     &
\begin{verbatim}
void setFieldArraySize(unsigned n);
unsigned getFieldArraySize();
double getField(unsigned k);
void setField(unsigned k, double d);
\end{verbatim}
\\\hline

customized class
\begin{verbatim}
class Foo {
  @customize(true);
\end{verbatim}
     &
\begin{verbatim}
class Foo_Base { ... };
\end{verbatim}
and you have to write:
\begin{verbatim}
class Foo : public Foo_Base {
   ...
};
\end{verbatim}
\\\hline

abstract fields
\begin{verbatim}
abstract double field;
\end{verbatim}
     &
\begin{verbatim}
double getField() = 0;
void setField(double d) = 0;
\end{verbatim}
\\\hline

\end{longtable}



